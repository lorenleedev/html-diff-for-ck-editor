var zb = Object.defineProperty;
var Hb = (i, e, t) => e in i ? zb(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t;
var Pn = (i, e, t) => Hb(i, typeof e != "symbol" ? e + "" : e, t);
function Ub(i, e) {
  for (var t = 0; t < e.length; t++) {
    const n = e[t];
    if (typeof n != "string" && !Array.isArray(n)) {
      for (const s in n)
        if (s !== "default" && !(s in i)) {
          const o = Object.getOwnPropertyDescriptor(n, s);
          o && Object.defineProperty(i, s, o.get ? o : {
            enumerable: !0,
            get: () => n[s]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(i, Symbol.toStringTag, { value: "Module" }));
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let jr;
try {
  jr = { window, document };
} catch (i) {
  /* istanbul ignore next -- @preserve */
  jr = { window: {}, document: {} };
}
const E = jr;
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function $b() {
  try {
    return navigator.userAgent.toLowerCase();
  } catch (i) {
    return "";
  }
}
const Jt = $b(), M = {
  isMac: sf(Jt),
  isWindows: Wb(Jt),
  isGecko: qb(Jt),
  isSafari: Gb(Jt),
  isiOS: jb(Jt),
  isAndroid: Kb(Jt),
  isBlink: Zb(Jt),
  get isMediaForcedColors() {
    return Xb();
  },
  get isMotionReduced() {
    return Qb();
  },
  features: {
    isRegExpUnicodePropertySupported: Jb()
  }
};
function sf(i) {
  return i.indexOf("macintosh") > -1;
}
function Wb(i) {
  return i.indexOf("windows") > -1;
}
function qb(i) {
  return !!i.match(/gecko\/\d+/);
}
function Gb(i) {
  return i.indexOf(" applewebkit/") > -1 && i.indexOf("chrome") === -1;
}
function jb(i) {
  return !!i.match(/iphone|ipad/i) || sf(i) && navigator.maxTouchPoints > 0;
}
function Kb(i) {
  return i.indexOf("android") > -1;
}
function Zb(i) {
  return i.indexOf("chrome/") > -1 && i.indexOf("edge/") < 0;
}
function Jb() {
  let i = !1;
  try {
    i = "ć".search(new RegExp("[\\p{L}]", "u")) === 0;
  } catch (e) {
  }
  return i;
}
function Xb() {
  return E.window.matchMedia ? E.window.matchMedia("(forced-colors: active)").matches : !1;
}
function Qb() {
  return E.window.matchMedia ? E.window.matchMedia("(prefers-reduced-motion)").matches : !1;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function of(i, e, t, n) {
  t = t || function(l, c) {
    return l === c;
  };
  const s = Array.isArray(i) ? i : Array.prototype.slice.call(i), o = Array.isArray(e) ? e : Array.prototype.slice.call(e), r = Yb(s, o, t);
  return n ? tw(r, o.length) : ew(o, r);
}
function Yb(i, e, t) {
  const n = ec(i, e, t);
  if (n === -1)
    return { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 };
  const s = tc(i, n), o = tc(e, n), r = ec(s, o, t), a = i.length - r, l = e.length - r;
  return { firstIndex: n, lastIndexOld: a, lastIndexNew: l };
}
function ec(i, e, t) {
  for (let n = 0; n < Math.max(i.length, e.length); n++)
    if (i[n] === void 0 || e[n] === void 0 || !t(i[n], e[n]))
      return n;
  return -1;
}
function tc(i, e) {
  return i.slice(e).reverse();
}
function ew(i, e) {
  const t = [], { firstIndex: n, lastIndexOld: s, lastIndexNew: o } = e;
  return o - n > 0 && t.push({
    index: n,
    type: "insert",
    values: i.slice(n, o)
  }), s - n > 0 && t.push({
    index: n + (o - n),
    type: "delete",
    howMany: s - n
  }), t;
}
function tw(i, e) {
  const { firstIndex: t, lastIndexOld: n, lastIndexNew: s } = i;
  if (t === -1)
    return Array(e).fill("equal");
  let o = [];
  return t > 0 && (o = o.concat(Array(t).fill("equal"))), s - t > 0 && (o = o.concat(Array(s - t).fill("insert"))), n - t > 0 && (o = o.concat(Array(n - t).fill("delete"))), s < e && (o = o.concat(Array(e - s).fill("equal"))), o;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Bi(i, e, t) {
  t = t || function(p, w) {
    return p === w;
  };
  const n = i.length, s = e.length;
  if (n > 200 || s > 200 || n + s > 300)
    return Bi.fastDiff(i, e, t, !0);
  let o, r;
  if (s < n) {
    const p = i;
    i = e, e = p, o = "delete", r = "insert";
  } else
    o = "insert", r = "delete";
  const a = i.length, l = e.length, c = l - a, u = {}, d = {};
  function h(p) {
    const w = (d[p - 1] !== void 0 ? d[p - 1] : -1) + 1, v = d[p + 1] !== void 0 ? d[p + 1] : -1, C = w > v ? -1 : 1;
    u[p + C] && (u[p] = u[p + C].slice(0)), u[p] || (u[p] = []), u[p].push(w > v ? o : r);
    let L = Math.max(w, v), F = L - p;
    for (; F < a && L < l && t(i[F], e[L]); )
      F++, L++, u[p].push("equal");
    return L;
  }
  let f = 0, m;
  do {
    for (m = -f; m < c; m++)
      d[m] = h(m);
    for (m = c + f; m > c; m--)
      d[m] = h(m);
    d[c] = h(c), f++;
  } while (d[c] !== l);
  return u[c].slice(1);
}
Bi.fastDiff = of;
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function nc() {
  return function i() {
    i.called = !0;
  };
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class St {
  /**
   * @param source The emitter.
   * @param name The event name.
   */
  constructor(e, t) {
    this.source = e, this.name = t, this.path = [], this.stop = nc(), this.off = nc();
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Te = new Array(256).fill("").map((i, e) => ("0" + e.toString(16)).slice(-2));
function je() {
  const i = Math.random() * 4294967296 >>> 0, e = Math.random() * 4294967296 >>> 0, t = Math.random() * 4294967296 >>> 0, n = Math.random() * 4294967296 >>> 0;
  return "e" + Te[i >> 0 & 255] + Te[i >> 8 & 255] + Te[i >> 16 & 255] + Te[i >> 24 & 255] + Te[e >> 0 & 255] + Te[e >> 8 & 255] + Te[e >> 16 & 255] + Te[e >> 24 & 255] + Te[t >> 0 & 255] + Te[t >> 8 & 255] + Te[t >> 16 & 255] + Te[t >> 24 & 255] + Te[n >> 0 & 255] + Te[n >> 8 & 255] + Te[n >> 16 & 255] + Te[n >> 24 & 255];
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Ht = {
  get(i = "normal") {
    return typeof i != "number" ? this[i] || this.normal : i;
  },
  highest: 1e5,
  high: 1e3,
  normal: 0,
  low: -1e3,
  lowest: -1e5
};
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function rf(i, e) {
  const t = Ht.get(e.priority);
  for (let n = 0; n < i.length; n++)
    if (Ht.get(i[n].priority) < t) {
      i.splice(n, 0, e);
      return;
    }
  i.push(e);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const nw = "https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html";
class g extends Error {
  /**
   * Creates an instance of the CKEditorError class.
   *
   * @param errorName The error id in an `error-name` format. A link to this error documentation page will be added
   * to the thrown error's `message`.
   * @param context A context of the error by which the {@link module:watchdog/watchdog~Watchdog watchdog}
   * is able to determine which editor crashed. It should be an editor instance or a property connected to it. It can be also
   * a `null` value if the editor should not be restarted in case of the error (e.g. during the editor initialization).
   * The error context should be checked using the `areConnectedThroughProperties( editor, context )` utility
   * to check if the object works as the context.
   * @param data Additional data describing the error. A stringified version of this object
   * will be appended to the error message, so the data are quickly visible in the console. The original
   * data object will also be later available under the {@link #data} property.
   */
  constructor(e, t, n) {
    super(iw(e, n)), this.name = "CKEditorError", this.context = t, this.data = n;
  }
  /**
   * Checks if the error is of the `CKEditorError` type.
   */
  is(e) {
    return e === "CKEditorError";
  }
  /**
   * A utility that ensures that the thrown error is a {@link module:utils/ckeditorerror~CKEditorError} one.
   * It is useful when combined with the {@link module:watchdog/watchdog~Watchdog} feature, which can restart the editor in case
   * of a {@link module:utils/ckeditorerror~CKEditorError} error.
   *
   * @param err The error to rethrow.
   * @param context An object connected through properties with the editor instance. This context will be used
   * by the watchdog to verify which editor should be restarted.
   */
  static rethrowUnexpectedError(e, t) {
    if (e.is && e.is("CKEditorError"))
      throw e;
    const n = new g(e.message, t);
    throw n.stack = e.stack, n;
  }
}
function D(i, e) {
  console.warn(...sw(i, e));
}
function af(i) {
  return `
Read more: ${nw}#error-${i}`;
}
function iw(i, e) {
  const t = /* @__PURE__ */ new WeakSet(), s = e ? ` ${JSON.stringify(e, (r, a) => {
    if (typeof a == "object" && a !== null) {
      if (t.has(a))
        return `[object ${a.constructor.name}]`;
      t.add(a);
    }
    return a;
  })}` : "", o = af(i);
  return i + s + o;
}
function sw(i, e) {
  const t = af(i);
  return e ? [i, e, t] : [i, t];
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const ow = "41.4.2", rw = new Date(2024, 4, 17);
/* istanbul ignore next -- @preserve */
if (globalThis.CKEDITOR_VERSION)
  throw new g("ckeditor-duplicated-modules", null);
globalThis.CKEDITOR_VERSION = ow;
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Dn = Symbol("listeningTo"), Kr = Symbol("emitterId"), _t = Symbol("delegations"), lf = G(Object);
function G(i) {
  if (!i)
    return lf;
  class e extends i {
    on(n, s, o) {
      this.listenTo(this, n, s, o);
    }
    once(n, s, o) {
      let r = !1;
      const a = (l, ...c) => {
        r || (r = !0, l.off(), s.call(this, l, ...c));
      };
      this.listenTo(this, n, a, o);
    }
    off(n, s) {
      this.stopListening(this, n, s);
    }
    listenTo(n, s, o, r = {}) {
      let a, l;
      this[Dn] || (this[Dn] = {});
      const c = this[Dn];
      fr(n) || cf(n);
      const u = fr(n);
      (a = c[u]) || (a = c[u] = {
        emitter: n,
        callbacks: {}
      }), (l = a.callbacks[s]) || (l = a.callbacks[s] = []), l.push(o), uw(this, n, s, o, r);
    }
    stopListening(n, s, o) {
      const r = this[Dn];
      let a = n && fr(n);
      const l = r && a ? r[a] : void 0, c = l && s ? l.callbacks[s] : void 0;
      if (!(!r || n && !l || s && !c))
        if (o)
          mr(this, n, s, o), c.indexOf(o) !== -1 && (c.length === 1 ? delete l.callbacks[s] : mr(this, n, s, o));
        else if (c) {
          for (; o = c.pop(); )
            mr(this, n, s, o);
          delete l.callbacks[s];
        } else if (l) {
          for (s in l.callbacks)
            this.stopListening(n, s);
          delete r[a];
        } else {
          for (a in r)
            this.stopListening(r[a].emitter);
          delete this[Dn];
        }
    }
    fire(n, ...s) {
      try {
        const o = n instanceof St ? n : new St(this, n), r = o.name;
        let a = df(this, r);
        if (o.path.push(this), a) {
          const c = [o, ...s];
          a = Array.from(a);
          for (let u = 0; u < a.length && (a[u].callback.apply(this, c), o.off.called && (delete o.off.called, this._removeEventListener(r, a[u].callback)), !o.stop.called); u++)
            ;
        }
        const l = this[_t];
        if (l) {
          const c = l.get(r), u = l.get("*");
          c && ic(c, o, s), u && ic(u, o, s);
        }
        return o.return;
      } catch (o) {
        /* istanbul ignore next -- @preserve */
        g.rethrowUnexpectedError(o, this);
      }
    }
    delegate(...n) {
      return {
        to: (s, o) => {
          this[_t] || (this[_t] = /* @__PURE__ */ new Map()), n.forEach((r) => {
            const a = this[_t].get(r);
            a ? a.set(s, o) : this[_t].set(r, /* @__PURE__ */ new Map([[s, o]]));
          });
        }
      };
    }
    stopDelegating(n, s) {
      if (this[_t])
        if (!n)
          this[_t].clear();
        else if (!s)
          this[_t].delete(n);
        else {
          const o = this[_t].get(n);
          o && o.delete(s);
        }
    }
    _addEventListener(n, s, o) {
      cw(this, n);
      const r = Zr(this, n), a = Ht.get(o.priority), l = {
        callback: s,
        priority: a
      };
      for (const c of r)
        rf(c, l);
    }
    _removeEventListener(n, s) {
      const o = Zr(this, n);
      for (const r of o)
        for (let a = 0; a < r.length; a++)
          r[a].callback == s && (r.splice(a, 1), a--);
    }
  }
  return e;
}
[
  "on",
  "once",
  "off",
  "listenTo",
  "stopListening",
  "fire",
  "delegate",
  "stopDelegating",
  "_addEventListener",
  "_removeEventListener"
].forEach((i) => {
  G[i] = lf.prototype[i];
});
function aw(i, e) {
  const t = i[Dn];
  return t && t[e] ? t[e].emitter : null;
}
function cf(i, e) {
  i[Kr] || (i[Kr] = e || je());
}
function fr(i) {
  return i[Kr];
}
function uf(i) {
  return i._events || Object.defineProperty(i, "_events", {
    value: {}
  }), i._events;
}
function lw() {
  return {
    callbacks: [],
    childEvents: []
  };
}
function cw(i, e) {
  const t = uf(i);
  if (t[e])
    return;
  let n = e, s = null;
  const o = [];
  for (; n !== "" && !t[n]; )
    t[n] = lw(), o.push(t[n]), s && t[n].childEvents.push(s), s = n, n = n.substr(0, n.lastIndexOf(":"));
  if (n !== "") {
    for (const r of o)
      r.callbacks = t[n].callbacks.slice();
    t[n].childEvents.push(s);
  }
}
function Zr(i, e) {
  const t = uf(i)[e];
  if (!t)
    return [];
  let n = [t.callbacks];
  for (let s = 0; s < t.childEvents.length; s++) {
    const o = Zr(i, t.childEvents[s]);
    n = n.concat(o);
  }
  return n;
}
function df(i, e) {
  let t;
  return !i._events || !(t = i._events[e]) || !t.callbacks.length ? e.indexOf(":") > -1 ? df(i, e.substr(0, e.lastIndexOf(":"))) : null : t.callbacks;
}
function ic(i, e, t) {
  for (let [n, s] of i) {
    s ? typeof s == "function" && (s = s(e.name)) : s = e.name;
    const o = new St(e.source, s);
    o.path = [...e.path], n.fire(o, ...t);
  }
}
function uw(i, e, t, n, s) {
  e._addEventListener ? e._addEventListener(t, n, s) : i._addEventListener.call(e, t, n, s);
}
function mr(i, e, t, n) {
  e._removeEventListener ? e._removeEventListener(t, n) : i._removeEventListener.call(e, t, n);
}
var hf = typeof global == "object" && global && global.Object === Object && global, dw = typeof self == "object" && self && self.Object === Object && self, lt = hf || dw || Function("return this")(), gt = lt.Symbol, ff = Object.prototype, hw = ff.hasOwnProperty, fw = ff.toString, pi = gt ? gt.toStringTag : void 0;
function mw(i) {
  var e = hw.call(i, pi), t = i[pi];
  try {
    i[pi] = void 0;
    var n = !0;
  } catch (o) {
  }
  var s = fw.call(i);
  return n && (e ? i[pi] = t : delete i[pi]), s;
}
var gw = Object.prototype, pw = gw.toString;
function bw(i) {
  return pw.call(i);
}
var ww = "[object Null]", _w = "[object Undefined]", sc = gt ? gt.toStringTag : void 0;
function qt(i) {
  return i == null ? i === void 0 ? _w : ww : sc && sc in Object(i) ? mw(i) : bw(i);
}
function Ke(i) {
  return i != null && typeof i == "object";
}
var vw = "[object Symbol]";
function No(i) {
  return typeof i == "symbol" || Ke(i) && qt(i) == vw;
}
function mf(i, e) {
  for (var t = -1, n = i == null ? 0 : i.length, s = Array(n); ++t < n; )
    s[t] = e(i[t], t, i);
  return s;
}
var Be = Array.isArray, yw = 1 / 0, oc = gt ? gt.prototype : void 0, rc = oc ? oc.toString : void 0;
function gf(i) {
  if (typeof i == "string")
    return i;
  if (Be(i))
    return mf(i, gf) + "";
  if (No(i))
    return rc ? rc.call(i) : "";
  var e = i + "";
  return e == "0" && 1 / i == -yw ? "-0" : e;
}
var Cw = /\s/;
function kw(i) {
  for (var e = i.length; e-- && Cw.test(i.charAt(e)); )
    ;
  return e;
}
var Tw = /^\s+/;
function Ew(i) {
  return i && i.slice(0, kw(i) + 1).replace(Tw, "");
}
function J(i) {
  var e = typeof i;
  return i != null && (e == "object" || e == "function");
}
var ac = NaN, Aw = /^[-+]0x[0-9a-f]+$/i, xw = /^0b[01]+$/i, Iw = /^0o[0-7]+$/i, Sw = parseInt;
function lc(i) {
  if (typeof i == "number")
    return i;
  if (No(i))
    return ac;
  if (J(i)) {
    var e = typeof i.valueOf == "function" ? i.valueOf() : i;
    i = J(e) ? e + "" : e;
  }
  if (typeof i != "string")
    return i === 0 ? i : +i;
  i = Ew(i);
  var t = xw.test(i);
  return t || Iw.test(i) ? Sw(i.slice(2), t ? 2 : 8) : Aw.test(i) ? ac : +i;
}
function Dt(i) {
  return i;
}
var Pw = "[object AsyncFunction]", Rw = "[object Function]", Vw = "[object GeneratorFunction]", Mw = "[object Proxy]";
function dn(i) {
  if (!J(i))
    return !1;
  var e = qt(i);
  return e == Rw || e == Vw || e == Pw || e == Mw;
}
var gr = lt["__core-js_shared__"], cc = function() {
  var i = /[^.]+$/.exec(gr && gr.keys && gr.keys.IE_PROTO || "");
  return i ? "Symbol(src)_1." + i : "";
}();
function Bw(i) {
  return !!cc && cc in i;
}
var Lw = Function.prototype, Ow = Lw.toString;
function pn(i) {
  if (i != null) {
    try {
      return Ow.call(i);
    } catch (e) {
    }
    try {
      return i + "";
    } catch (e) {
    }
  }
  return "";
}
var Fw = /[\\^$.*+?()[\]{}|]/g, Nw = /^\[object .+?Constructor\]$/, Dw = Function.prototype, zw = Object.prototype, Hw = Dw.toString, Uw = zw.hasOwnProperty, $w = RegExp(
  "^" + Hw.call(Uw).replace(Fw, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Ww(i) {
  if (!J(i) || Bw(i))
    return !1;
  var e = dn(i) ? $w : Nw;
  return e.test(pn(i));
}
function qw(i, e) {
  return i == null ? void 0 : i[e];
}
function bn(i, e) {
  var t = qw(i, e);
  return Ww(t) ? t : void 0;
}
var Jr = bn(lt, "WeakMap"), uc = Object.create, Gw = /* @__PURE__ */ function() {
  function i() {
  }
  return function(e) {
    if (!J(e))
      return {};
    if (uc)
      return uc(e);
    i.prototype = e;
    var t = new i();
    return i.prototype = void 0, t;
  };
}();
function jw(i, e, t) {
  switch (t.length) {
    case 0:
      return i.call(e);
    case 1:
      return i.call(e, t[0]);
    case 2:
      return i.call(e, t[0], t[1]);
    case 3:
      return i.call(e, t[0], t[1], t[2]);
  }
  return i.apply(e, t);
}
function pf(i, e) {
  var t = -1, n = i.length;
  for (e || (e = Array(n)); ++t < n; )
    e[t] = i[t];
  return e;
}
var Kw = 800, Zw = 16, Jw = Date.now;
function Xw(i) {
  var e = 0, t = 0;
  return function() {
    var n = Jw(), s = Zw - (n - t);
    if (t = n, s > 0) {
      if (++e >= Kw)
        return arguments[0];
    } else
      e = 0;
    return i.apply(void 0, arguments);
  };
}
function Qw(i) {
  return function() {
    return i;
  };
}
var mo = function() {
  try {
    var i = bn(Object, "defineProperty");
    return i({}, "", {}), i;
  } catch (e) {
  }
}(), Yw = mo ? function(i, e) {
  return mo(i, "toString", {
    configurable: !0,
    enumerable: !1,
    value: Qw(e),
    writable: !0
  });
} : Dt, e0 = Xw(Yw);
function t0(i, e) {
  for (var t = -1, n = i == null ? 0 : i.length; ++t < n && e(i[t], t, i) !== !1; )
    ;
  return i;
}
var n0 = 9007199254740991, i0 = /^(?:0|[1-9]\d*)$/;
function Do(i, e) {
  var t = typeof i;
  return e = e == null ? n0 : e, !!e && (t == "number" || t != "symbol" && i0.test(i)) && i > -1 && i % 1 == 0 && i < e;
}
function zo(i, e, t) {
  e == "__proto__" && mo ? mo(i, e, {
    configurable: !0,
    enumerable: !0,
    value: t,
    writable: !0
  }) : i[e] = t;
}
function hs(i, e) {
  return i === e || i !== i && e !== e;
}
var s0 = Object.prototype, o0 = s0.hasOwnProperty;
function ja(i, e, t) {
  var n = i[e];
  (!(o0.call(i, e) && hs(n, t)) || t === void 0 && !(e in i)) && zo(i, e, t);
}
function ai(i, e, t, n) {
  var s = !t;
  t || (t = {});
  for (var o = -1, r = e.length; ++o < r; ) {
    var a = e[o], l = void 0;
    l === void 0 && (l = i[a]), s ? zo(t, a, l) : ja(t, a, l);
  }
  return t;
}
var dc = Math.max;
function r0(i, e, t) {
  return e = dc(e === void 0 ? i.length - 1 : e, 0), function() {
    for (var n = arguments, s = -1, o = dc(n.length - e, 0), r = Array(o); ++s < o; )
      r[s] = n[e + s];
    s = -1;
    for (var a = Array(e + 1); ++s < e; )
      a[s] = n[s];
    return a[e] = t(r), jw(i, this, a);
  };
}
function a0(i, e) {
  return e0(r0(i, e, Dt), i + "");
}
var l0 = 9007199254740991;
function Ka(i) {
  return typeof i == "number" && i > -1 && i % 1 == 0 && i <= l0;
}
function li(i) {
  return i != null && Ka(i.length) && !dn(i);
}
function c0(i, e, t) {
  if (!J(t))
    return !1;
  var n = typeof e;
  return (n == "number" ? li(t) && Do(e, t.length) : n == "string" && e in t) ? hs(t[e], i) : !1;
}
function bf(i) {
  return a0(function(e, t) {
    var n = -1, s = t.length, o = s > 1 ? t[s - 1] : void 0, r = s > 2 ? t[2] : void 0;
    for (o = i.length > 3 && typeof o == "function" ? (s--, o) : void 0, r && c0(t[0], t[1], r) && (o = s < 3 ? void 0 : o, s = 1), e = Object(e); ++n < s; ) {
      var a = t[n];
      a && i(e, a, n, o);
    }
    return e;
  });
}
var u0 = Object.prototype;
function Za(i) {
  var e = i && i.constructor, t = typeof e == "function" && e.prototype || u0;
  return i === t;
}
function d0(i, e) {
  for (var t = -1, n = Array(i); ++t < i; )
    n[t] = e(t);
  return n;
}
var h0 = "[object Arguments]";
function hc(i) {
  return Ke(i) && qt(i) == h0;
}
var wf = Object.prototype, f0 = wf.hasOwnProperty, m0 = wf.propertyIsEnumerable, go = hc(/* @__PURE__ */ function() {
  return arguments;
}()) ? hc : function(i) {
  return Ke(i) && f0.call(i, "callee") && !m0.call(i, "callee");
};
function g0() {
  return !1;
}
var _f = typeof exports == "object" && exports && !exports.nodeType && exports, fc = _f && typeof module == "object" && module && !module.nodeType && module, p0 = fc && fc.exports === _f, mc = p0 ? lt.Buffer : void 0, b0 = mc ? mc.isBuffer : void 0, Gi = b0 || g0, w0 = "[object Arguments]", _0 = "[object Array]", v0 = "[object Boolean]", y0 = "[object Date]", C0 = "[object Error]", k0 = "[object Function]", T0 = "[object Map]", E0 = "[object Number]", A0 = "[object Object]", x0 = "[object RegExp]", I0 = "[object Set]", S0 = "[object String]", P0 = "[object WeakMap]", R0 = "[object ArrayBuffer]", V0 = "[object DataView]", M0 = "[object Float32Array]", B0 = "[object Float64Array]", L0 = "[object Int8Array]", O0 = "[object Int16Array]", F0 = "[object Int32Array]", N0 = "[object Uint8Array]", D0 = "[object Uint8ClampedArray]", z0 = "[object Uint16Array]", H0 = "[object Uint32Array]", te = {};
te[M0] = te[B0] = te[L0] = te[O0] = te[F0] = te[N0] = te[D0] = te[z0] = te[H0] = !0;
te[w0] = te[_0] = te[R0] = te[v0] = te[V0] = te[y0] = te[C0] = te[k0] = te[T0] = te[E0] = te[A0] = te[x0] = te[I0] = te[S0] = te[P0] = !1;
function U0(i) {
  return Ke(i) && Ka(i.length) && !!te[qt(i)];
}
function Ja(i) {
  return function(e) {
    return i(e);
  };
}
var vf = typeof exports == "object" && exports && !exports.nodeType && exports, Li = vf && typeof module == "object" && module && !module.nodeType && module, $0 = Li && Li.exports === vf, pr = $0 && hf.process, Jn = function() {
  try {
    var i = Li && Li.require && Li.require("util").types;
    return i || pr && pr.binding && pr.binding("util");
  } catch (e) {
  }
}(), gc = Jn && Jn.isTypedArray, Xa = gc ? Ja(gc) : U0, W0 = Object.prototype, q0 = W0.hasOwnProperty;
function yf(i, e) {
  var t = Be(i), n = !t && go(i), s = !t && !n && Gi(i), o = !t && !n && !s && Xa(i), r = t || n || s || o, a = r ? d0(i.length, String) : [], l = a.length;
  for (var c in i)
    (e || q0.call(i, c)) && !(r && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    s && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    o && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    Do(c, l))) && a.push(c);
  return a;
}
function Cf(i, e) {
  return function(t) {
    return i(e(t));
  };
}
var G0 = Cf(Object.keys, Object), j0 = Object.prototype, K0 = j0.hasOwnProperty;
function Z0(i) {
  if (!Za(i))
    return G0(i);
  var e = [];
  for (var t in Object(i))
    K0.call(i, t) && t != "constructor" && e.push(t);
  return e;
}
function fs(i) {
  return li(i) ? yf(i) : Z0(i);
}
function J0(i) {
  var e = [];
  if (i != null)
    for (var t in Object(i))
      e.push(t);
  return e;
}
var X0 = Object.prototype, Q0 = X0.hasOwnProperty;
function Y0(i) {
  if (!J(i))
    return J0(i);
  var e = Za(i), t = [];
  for (var n in i)
    n == "constructor" && (e || !Q0.call(i, n)) || t.push(n);
  return t;
}
function ci(i) {
  return li(i) ? yf(i, !0) : Y0(i);
}
var kf = bf(function(i, e) {
  ai(e, ci(e), i);
}), e1 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, t1 = /^\w*$/;
function Qa(i, e) {
  if (Be(i))
    return !1;
  var t = typeof i;
  return t == "number" || t == "symbol" || t == "boolean" || i == null || No(i) ? !0 : t1.test(i) || !e1.test(i) || e != null && i in Object(e);
}
var ji = bn(Object, "create");
function n1() {
  this.__data__ = ji ? ji(null) : {}, this.size = 0;
}
function i1(i) {
  var e = this.has(i) && delete this.__data__[i];
  return this.size -= e ? 1 : 0, e;
}
var s1 = "__lodash_hash_undefined__", o1 = Object.prototype, r1 = o1.hasOwnProperty;
function a1(i) {
  var e = this.__data__;
  if (ji) {
    var t = e[i];
    return t === s1 ? void 0 : t;
  }
  return r1.call(e, i) ? e[i] : void 0;
}
var l1 = Object.prototype, c1 = l1.hasOwnProperty;
function u1(i) {
  var e = this.__data__;
  return ji ? e[i] !== void 0 : c1.call(e, i);
}
var d1 = "__lodash_hash_undefined__";
function h1(i, e) {
  var t = this.__data__;
  return this.size += this.has(i) ? 0 : 1, t[i] = ji && e === void 0 ? d1 : e, this;
}
function hn(i) {
  var e = -1, t = i == null ? 0 : i.length;
  for (this.clear(); ++e < t; ) {
    var n = i[e];
    this.set(n[0], n[1]);
  }
}
hn.prototype.clear = n1;
hn.prototype.delete = i1;
hn.prototype.get = a1;
hn.prototype.has = u1;
hn.prototype.set = h1;
function f1() {
  this.__data__ = [], this.size = 0;
}
function Ho(i, e) {
  for (var t = i.length; t--; )
    if (hs(i[t][0], e))
      return t;
  return -1;
}
var m1 = Array.prototype, g1 = m1.splice;
function p1(i) {
  var e = this.__data__, t = Ho(e, i);
  if (t < 0)
    return !1;
  var n = e.length - 1;
  return t == n ? e.pop() : g1.call(e, t, 1), --this.size, !0;
}
function b1(i) {
  var e = this.__data__, t = Ho(e, i);
  return t < 0 ? void 0 : e[t][1];
}
function w1(i) {
  return Ho(this.__data__, i) > -1;
}
function _1(i, e) {
  var t = this.__data__, n = Ho(t, i);
  return n < 0 ? (++this.size, t.push([i, e])) : t[n][1] = e, this;
}
function Vt(i) {
  var e = -1, t = i == null ? 0 : i.length;
  for (this.clear(); ++e < t; ) {
    var n = i[e];
    this.set(n[0], n[1]);
  }
}
Vt.prototype.clear = f1;
Vt.prototype.delete = p1;
Vt.prototype.get = b1;
Vt.prototype.has = w1;
Vt.prototype.set = _1;
var Ki = bn(lt, "Map");
function v1() {
  this.size = 0, this.__data__ = {
    hash: new hn(),
    map: new (Ki || Vt)(),
    string: new hn()
  };
}
function y1(i) {
  var e = typeof i;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? i !== "__proto__" : i === null;
}
function Uo(i, e) {
  var t = i.__data__;
  return y1(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map;
}
function C1(i) {
  var e = Uo(this, i).delete(i);
  return this.size -= e ? 1 : 0, e;
}
function k1(i) {
  return Uo(this, i).get(i);
}
function T1(i) {
  return Uo(this, i).has(i);
}
function E1(i, e) {
  var t = Uo(this, i), n = t.size;
  return t.set(i, e), this.size += t.size == n ? 0 : 1, this;
}
function Mt(i) {
  var e = -1, t = i == null ? 0 : i.length;
  for (this.clear(); ++e < t; ) {
    var n = i[e];
    this.set(n[0], n[1]);
  }
}
Mt.prototype.clear = v1;
Mt.prototype.delete = C1;
Mt.prototype.get = k1;
Mt.prototype.has = T1;
Mt.prototype.set = E1;
var A1 = "Expected a function";
function Ya(i, e) {
  if (typeof i != "function" || e != null && typeof e != "function")
    throw new TypeError(A1);
  var t = function() {
    var n = arguments, s = e ? e.apply(this, n) : n[0], o = t.cache;
    if (o.has(s))
      return o.get(s);
    var r = i.apply(this, n);
    return t.cache = o.set(s, r) || o, r;
  };
  return t.cache = new (Ya.Cache || Mt)(), t;
}
Ya.Cache = Mt;
var x1 = 500;
function I1(i) {
  var e = Ya(i, function(n) {
    return t.size === x1 && t.clear(), n;
  }), t = e.cache;
  return e;
}
var S1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, P1 = /\\(\\)?/g, R1 = I1(function(i) {
  var e = [];
  return i.charCodeAt(0) === 46 && e.push(""), i.replace(S1, function(t, n, s, o) {
    e.push(s ? o.replace(P1, "$1") : n || t);
  }), e;
});
function el(i) {
  return i == null ? "" : gf(i);
}
function $o(i, e) {
  return Be(i) ? i : Qa(i, e) ? [i] : R1(el(i));
}
var V1 = 1 / 0;
function ui(i) {
  if (typeof i == "string" || No(i))
    return i;
  var e = i + "";
  return e == "0" && 1 / i == -V1 ? "-0" : e;
}
function tl(i, e) {
  e = $o(e, i);
  for (var t = 0, n = e.length; i != null && t < n; )
    i = i[ui(e[t++])];
  return t && t == n ? i : void 0;
}
function Zi(i, e, t) {
  var n = i == null ? void 0 : tl(i, e);
  return n === void 0 ? t : n;
}
function Tf(i, e) {
  for (var t = -1, n = e.length, s = i.length; ++t < n; )
    i[s + t] = e[t];
  return i;
}
var nl = Cf(Object.getPrototypeOf, Object), M1 = "[object Object]", B1 = Function.prototype, L1 = Object.prototype, Ef = B1.toString, O1 = L1.hasOwnProperty, F1 = Ef.call(Object);
function Ne(i) {
  if (!Ke(i) || qt(i) != M1)
    return !1;
  var e = nl(i);
  if (e === null)
    return !0;
  var t = O1.call(e, "constructor") && e.constructor;
  return typeof t == "function" && t instanceof t && Ef.call(t) == F1;
}
function Af(i, e, t) {
  var n = -1, s = i.length;
  e < 0 && (e = -e > s ? 0 : s + e), t = t > s ? s : t, t < 0 && (t += s), s = e > t ? 0 : t - e >>> 0, e >>>= 0;
  for (var o = Array(s); ++n < s; )
    o[n] = i[n + e];
  return o;
}
function N1(i, e, t) {
  var n = i.length;
  return t = t === void 0 ? n : t, !e && t >= n ? i : Af(i, e, t);
}
var D1 = "\\ud800-\\udfff", z1 = "\\u0300-\\u036f", H1 = "\\ufe20-\\ufe2f", U1 = "\\u20d0-\\u20ff", $1 = z1 + H1 + U1, W1 = "\\ufe0e\\ufe0f", q1 = "\\u200d", G1 = RegExp("[" + q1 + D1 + $1 + W1 + "]");
function xf(i) {
  return G1.test(i);
}
function j1(i) {
  return i.split("");
}
var If = "\\ud800-\\udfff", K1 = "\\u0300-\\u036f", Z1 = "\\ufe20-\\ufe2f", J1 = "\\u20d0-\\u20ff", X1 = K1 + Z1 + J1, Q1 = "\\ufe0e\\ufe0f", Y1 = "[" + If + "]", Xr = "[" + X1 + "]", Qr = "\\ud83c[\\udffb-\\udfff]", e_ = "(?:" + Xr + "|" + Qr + ")", Sf = "[^" + If + "]", Pf = "(?:\\ud83c[\\udde6-\\uddff]){2}", Rf = "[\\ud800-\\udbff][\\udc00-\\udfff]", t_ = "\\u200d", Vf = e_ + "?", Mf = "[" + Q1 + "]?", n_ = "(?:" + t_ + "(?:" + [Sf, Pf, Rf].join("|") + ")" + Mf + Vf + ")*", i_ = Mf + Vf + n_, s_ = "(?:" + [Sf + Xr + "?", Xr, Pf, Rf, Y1].join("|") + ")", o_ = RegExp(Qr + "(?=" + Qr + ")|" + s_ + i_, "g");
function r_(i) {
  return i.match(o_) || [];
}
function a_(i) {
  return xf(i) ? r_(i) : j1(i);
}
function l_(i) {
  return function(e) {
    e = el(e);
    var t = xf(e) ? a_(e) : void 0, n = t ? t[0] : e.charAt(0), s = t ? N1(t, 1).join("") : e.slice(1);
    return n[i]() + s;
  };
}
var c_ = l_("toUpperCase");
function u_() {
  this.__data__ = new Vt(), this.size = 0;
}
function d_(i) {
  var e = this.__data__, t = e.delete(i);
  return this.size = e.size, t;
}
function h_(i) {
  return this.__data__.get(i);
}
function f_(i) {
  return this.__data__.has(i);
}
var m_ = 200;
function g_(i, e) {
  var t = this.__data__;
  if (t instanceof Vt) {
    var n = t.__data__;
    if (!Ki || n.length < m_ - 1)
      return n.push([i, e]), this.size = ++t.size, this;
    t = this.__data__ = new Mt(n);
  }
  return t.set(i, e), this.size = t.size, this;
}
function st(i) {
  var e = this.__data__ = new Vt(i);
  this.size = e.size;
}
st.prototype.clear = u_;
st.prototype.delete = d_;
st.prototype.get = h_;
st.prototype.has = f_;
st.prototype.set = g_;
function p_(i, e) {
  return i && ai(e, fs(e), i);
}
function b_(i, e) {
  return i && ai(e, ci(e), i);
}
var Bf = typeof exports == "object" && exports && !exports.nodeType && exports, pc = Bf && typeof module == "object" && module && !module.nodeType && module, w_ = pc && pc.exports === Bf, bc = w_ ? lt.Buffer : void 0, wc = bc ? bc.allocUnsafe : void 0;
function Lf(i, e) {
  if (e)
    return i.slice();
  var t = i.length, n = wc ? wc(t) : new i.constructor(t);
  return i.copy(n), n;
}
function __(i, e) {
  for (var t = -1, n = i == null ? 0 : i.length, s = 0, o = []; ++t < n; ) {
    var r = i[t];
    e(r, t, i) && (o[s++] = r);
  }
  return o;
}
function Of() {
  return [];
}
var v_ = Object.prototype, y_ = v_.propertyIsEnumerable, _c = Object.getOwnPropertySymbols, il = _c ? function(i) {
  return i == null ? [] : (i = Object(i), __(_c(i), function(e) {
    return y_.call(i, e);
  }));
} : Of;
function C_(i, e) {
  return ai(i, il(i), e);
}
var k_ = Object.getOwnPropertySymbols, Ff = k_ ? function(i) {
  for (var e = []; i; )
    Tf(e, il(i)), i = nl(i);
  return e;
} : Of;
function T_(i, e) {
  return ai(i, Ff(i), e);
}
function Nf(i, e, t) {
  var n = e(i);
  return Be(i) ? n : Tf(n, t(i));
}
function Yr(i) {
  return Nf(i, fs, il);
}
function E_(i) {
  return Nf(i, ci, Ff);
}
var ea = bn(lt, "DataView"), ta = bn(lt, "Promise"), na = bn(lt, "Set"), vc = "[object Map]", A_ = "[object Object]", yc = "[object Promise]", Cc = "[object Set]", kc = "[object WeakMap]", Tc = "[object DataView]", x_ = pn(ea), I_ = pn(Ki), S_ = pn(ta), P_ = pn(na), R_ = pn(Jr), et = qt;
(ea && et(new ea(new ArrayBuffer(1))) != Tc || Ki && et(new Ki()) != vc || ta && et(ta.resolve()) != yc || na && et(new na()) != Cc || Jr && et(new Jr()) != kc) && (et = function(i) {
  var e = qt(i), t = e == A_ ? i.constructor : void 0, n = t ? pn(t) : "";
  if (n)
    switch (n) {
      case x_:
        return Tc;
      case I_:
        return vc;
      case S_:
        return yc;
      case P_:
        return Cc;
      case R_:
        return kc;
    }
  return e;
});
var V_ = Object.prototype, M_ = V_.hasOwnProperty;
function B_(i) {
  var e = i.length, t = new i.constructor(e);
  return e && typeof i[0] == "string" && M_.call(i, "index") && (t.index = i.index, t.input = i.input), t;
}
var po = lt.Uint8Array;
function sl(i) {
  var e = new i.constructor(i.byteLength);
  return new po(e).set(new po(i)), e;
}
function L_(i, e) {
  var t = e ? sl(i.buffer) : i.buffer;
  return new i.constructor(t, i.byteOffset, i.byteLength);
}
var O_ = /\w*$/;
function F_(i) {
  var e = new i.constructor(i.source, O_.exec(i));
  return e.lastIndex = i.lastIndex, e;
}
var Ec = gt ? gt.prototype : void 0, Ac = Ec ? Ec.valueOf : void 0;
function N_(i) {
  return Ac ? Object(Ac.call(i)) : {};
}
function Df(i, e) {
  var t = e ? sl(i.buffer) : i.buffer;
  return new i.constructor(t, i.byteOffset, i.length);
}
var D_ = "[object Boolean]", z_ = "[object Date]", H_ = "[object Map]", U_ = "[object Number]", $_ = "[object RegExp]", W_ = "[object Set]", q_ = "[object String]", G_ = "[object Symbol]", j_ = "[object ArrayBuffer]", K_ = "[object DataView]", Z_ = "[object Float32Array]", J_ = "[object Float64Array]", X_ = "[object Int8Array]", Q_ = "[object Int16Array]", Y_ = "[object Int32Array]", ev = "[object Uint8Array]", tv = "[object Uint8ClampedArray]", nv = "[object Uint16Array]", iv = "[object Uint32Array]";
function sv(i, e, t) {
  var n = i.constructor;
  switch (e) {
    case j_:
      return sl(i);
    case D_:
    case z_:
      return new n(+i);
    case K_:
      return L_(i, t);
    case Z_:
    case J_:
    case X_:
    case Q_:
    case Y_:
    case ev:
    case tv:
    case nv:
    case iv:
      return Df(i, t);
    case H_:
      return new n();
    case U_:
    case q_:
      return new n(i);
    case $_:
      return F_(i);
    case W_:
      return new n();
    case G_:
      return N_(i);
  }
}
function zf(i) {
  return typeof i.constructor == "function" && !Za(i) ? Gw(nl(i)) : {};
}
var ov = "[object Map]";
function rv(i) {
  return Ke(i) && et(i) == ov;
}
var xc = Jn && Jn.isMap, av = xc ? Ja(xc) : rv, lv = "[object Set]";
function cv(i) {
  return Ke(i) && et(i) == lv;
}
var Ic = Jn && Jn.isSet, uv = Ic ? Ja(Ic) : cv, dv = 1, hv = 2, fv = 4, Hf = "[object Arguments]", mv = "[object Array]", gv = "[object Boolean]", pv = "[object Date]", bv = "[object Error]", Uf = "[object Function]", wv = "[object GeneratorFunction]", _v = "[object Map]", vv = "[object Number]", $f = "[object Object]", yv = "[object RegExp]", Cv = "[object Set]", kv = "[object String]", Tv = "[object Symbol]", Ev = "[object WeakMap]", Av = "[object ArrayBuffer]", xv = "[object DataView]", Iv = "[object Float32Array]", Sv = "[object Float64Array]", Pv = "[object Int8Array]", Rv = "[object Int16Array]", Vv = "[object Int32Array]", Mv = "[object Uint8Array]", Bv = "[object Uint8ClampedArray]", Lv = "[object Uint16Array]", Ov = "[object Uint32Array]", Q = {};
Q[Hf] = Q[mv] = Q[Av] = Q[xv] = Q[gv] = Q[pv] = Q[Iv] = Q[Sv] = Q[Pv] = Q[Rv] = Q[Vv] = Q[_v] = Q[vv] = Q[$f] = Q[yv] = Q[Cv] = Q[kv] = Q[Tv] = Q[Mv] = Q[Bv] = Q[Lv] = Q[Ov] = !0;
Q[bv] = Q[Uf] = Q[Ev] = !1;
function Kn(i, e, t, n, s, o) {
  var r, a = e & dv, l = e & hv, c = e & fv;
  if (t && (r = s ? t(i, n, s, o) : t(i)), r !== void 0)
    return r;
  if (!J(i))
    return i;
  var u = Be(i);
  if (u) {
    if (r = B_(i), !a)
      return pf(i, r);
  } else {
    var d = et(i), h = d == Uf || d == wv;
    if (Gi(i))
      return Lf(i, a);
    if (d == $f || d == Hf || h && !s) {
      if (r = l || h ? {} : zf(i), !a)
        return l ? T_(i, b_(r, i)) : C_(i, p_(r, i));
    } else {
      if (!Q[d])
        return s ? i : {};
      r = sv(i, d, a);
    }
  }
  o || (o = new st());
  var f = o.get(i);
  if (f)
    return f;
  o.set(i, r), uv(i) ? i.forEach(function(w) {
    r.add(Kn(w, e, t, w, i, o));
  }) : av(i) && i.forEach(function(w, v) {
    r.set(v, Kn(w, e, t, v, i, o));
  });
  var m = c ? l ? E_ : Yr : l ? ci : fs, p = u ? void 0 : m(i);
  return t0(p || i, function(w, v) {
    p && (v = w, w = i[v]), ja(r, v, Kn(w, e, t, v, i, o));
  }), r;
}
var Fv = 4;
function Wf(i) {
  return Kn(i, Fv);
}
var Nv = 1, Dv = 4;
function ct(i) {
  return Kn(i, Nv | Dv);
}
var zv = 1, Hv = 4;
function ol(i, e) {
  return e = typeof e == "function" ? e : void 0, Kn(i, zv | Hv, e);
}
var Uv = "__lodash_hash_undefined__";
function $v(i) {
  return this.__data__.set(i, Uv), this;
}
function Wv(i) {
  return this.__data__.has(i);
}
function bo(i) {
  var e = -1, t = i == null ? 0 : i.length;
  for (this.__data__ = new Mt(); ++e < t; )
    this.add(i[e]);
}
bo.prototype.add = bo.prototype.push = $v;
bo.prototype.has = Wv;
function qv(i, e) {
  for (var t = -1, n = i == null ? 0 : i.length; ++t < n; )
    if (e(i[t], t, i))
      return !0;
  return !1;
}
function Gv(i, e) {
  return i.has(e);
}
var jv = 1, Kv = 2;
function qf(i, e, t, n, s, o) {
  var r = t & jv, a = i.length, l = e.length;
  if (a != l && !(r && l > a))
    return !1;
  var c = o.get(i), u = o.get(e);
  if (c && u)
    return c == e && u == i;
  var d = -1, h = !0, f = t & Kv ? new bo() : void 0;
  for (o.set(i, e), o.set(e, i); ++d < a; ) {
    var m = i[d], p = e[d];
    if (n)
      var w = r ? n(p, m, d, e, i, o) : n(m, p, d, i, e, o);
    if (w !== void 0) {
      if (w)
        continue;
      h = !1;
      break;
    }
    if (f) {
      if (!qv(e, function(v, C) {
        if (!Gv(f, C) && (m === v || s(m, v, t, n, o)))
          return f.push(C);
      })) {
        h = !1;
        break;
      }
    } else if (!(m === p || s(m, p, t, n, o))) {
      h = !1;
      break;
    }
  }
  return o.delete(i), o.delete(e), h;
}
function Zv(i) {
  var e = -1, t = Array(i.size);
  return i.forEach(function(n, s) {
    t[++e] = [s, n];
  }), t;
}
function Jv(i) {
  var e = -1, t = Array(i.size);
  return i.forEach(function(n) {
    t[++e] = n;
  }), t;
}
var Xv = 1, Qv = 2, Yv = "[object Boolean]", ey = "[object Date]", ty = "[object Error]", ny = "[object Map]", iy = "[object Number]", sy = "[object RegExp]", oy = "[object Set]", ry = "[object String]", ay = "[object Symbol]", ly = "[object ArrayBuffer]", cy = "[object DataView]", Sc = gt ? gt.prototype : void 0, br = Sc ? Sc.valueOf : void 0;
function uy(i, e, t, n, s, o, r) {
  switch (t) {
    case cy:
      if (i.byteLength != e.byteLength || i.byteOffset != e.byteOffset)
        return !1;
      i = i.buffer, e = e.buffer;
    case ly:
      return !(i.byteLength != e.byteLength || !o(new po(i), new po(e)));
    case Yv:
    case ey:
    case iy:
      return hs(+i, +e);
    case ty:
      return i.name == e.name && i.message == e.message;
    case sy:
    case ry:
      return i == e + "";
    case ny:
      var a = Zv;
    case oy:
      var l = n & Xv;
      if (a || (a = Jv), i.size != e.size && !l)
        return !1;
      var c = r.get(i);
      if (c)
        return c == e;
      n |= Qv, r.set(i, e);
      var u = qf(a(i), a(e), n, s, o, r);
      return r.delete(i), u;
    case ay:
      if (br)
        return br.call(i) == br.call(e);
  }
  return !1;
}
var dy = 1, hy = Object.prototype, fy = hy.hasOwnProperty;
function my(i, e, t, n, s, o) {
  var r = t & dy, a = Yr(i), l = a.length, c = Yr(e), u = c.length;
  if (l != u && !r)
    return !1;
  for (var d = l; d--; ) {
    var h = a[d];
    if (!(r ? h in e : fy.call(e, h)))
      return !1;
  }
  var f = o.get(i), m = o.get(e);
  if (f && m)
    return f == e && m == i;
  var p = !0;
  o.set(i, e), o.set(e, i);
  for (var w = r; ++d < l; ) {
    h = a[d];
    var v = i[h], C = e[h];
    if (n)
      var L = r ? n(C, v, h, e, i, o) : n(v, C, h, i, e, o);
    if (!(L === void 0 ? v === C || s(v, C, t, n, o) : L)) {
      p = !1;
      break;
    }
    w || (w = h == "constructor");
  }
  if (p && !w) {
    var F = i.constructor, q = e.constructor;
    F != q && "constructor" in i && "constructor" in e && !(typeof F == "function" && F instanceof F && typeof q == "function" && q instanceof q) && (p = !1);
  }
  return o.delete(i), o.delete(e), p;
}
var gy = 1, Pc = "[object Arguments]", Rc = "[object Array]", xs = "[object Object]", py = Object.prototype, Vc = py.hasOwnProperty;
function by(i, e, t, n, s, o) {
  var r = Be(i), a = Be(e), l = r ? Rc : et(i), c = a ? Rc : et(e);
  l = l == Pc ? xs : l, c = c == Pc ? xs : c;
  var u = l == xs, d = c == xs, h = l == c;
  if (h && Gi(i)) {
    if (!Gi(e))
      return !1;
    r = !0, u = !1;
  }
  if (h && !u)
    return o || (o = new st()), r || Xa(i) ? qf(i, e, t, n, s, o) : uy(i, e, l, t, n, s, o);
  if (!(t & gy)) {
    var f = u && Vc.call(i, "__wrapped__"), m = d && Vc.call(e, "__wrapped__");
    if (f || m) {
      var p = f ? i.value() : i, w = m ? e.value() : e;
      return o || (o = new st()), s(p, w, t, n, o);
    }
  }
  return h ? (o || (o = new st()), my(i, e, t, n, s, o)) : !1;
}
function ms(i, e, t, n, s) {
  return i === e ? !0 : i == null || e == null || !Ke(i) && !Ke(e) ? i !== i && e !== e : by(i, e, t, n, ms, s);
}
var wy = 1, _y = 2;
function vy(i, e, t, n) {
  var s = t.length, o = s;
  if (i == null)
    return !o;
  for (i = Object(i); s--; ) {
    var r = t[s];
    if (r[2] ? r[1] !== i[r[0]] : !(r[0] in i))
      return !1;
  }
  for (; ++s < o; ) {
    r = t[s];
    var a = r[0], l = i[a], c = r[1];
    if (r[2]) {
      if (l === void 0 && !(a in i))
        return !1;
    } else {
      var u = new st(), d;
      if (!(d === void 0 ? ms(c, l, wy | _y, n, u) : d))
        return !1;
    }
  }
  return !0;
}
function Gf(i) {
  return i === i && !J(i);
}
function yy(i) {
  for (var e = fs(i), t = e.length; t--; ) {
    var n = e[t], s = i[n];
    e[t] = [n, s, Gf(s)];
  }
  return e;
}
function jf(i, e) {
  return function(t) {
    return t == null ? !1 : t[i] === e && (e !== void 0 || i in Object(t));
  };
}
function Cy(i) {
  var e = yy(i);
  return e.length == 1 && e[0][2] ? jf(e[0][0], e[0][1]) : function(t) {
    return t === i || vy(t, i, e);
  };
}
function ky(i, e) {
  return i != null && e in Object(i);
}
function Ty(i, e, t) {
  e = $o(e, i);
  for (var n = -1, s = e.length, o = !1; ++n < s; ) {
    var r = ui(e[n]);
    if (!(o = i != null && t(i, r)))
      break;
    i = i[r];
  }
  return o || ++n != s ? o : (s = i == null ? 0 : i.length, !!s && Ka(s) && Do(r, s) && (Be(i) || go(i)));
}
function Ey(i, e) {
  return i != null && Ty(i, e, ky);
}
var Ay = 1, xy = 2;
function Iy(i, e) {
  return Qa(i) && Gf(e) ? jf(ui(i), e) : function(t) {
    var n = Zi(t, i);
    return n === void 0 && n === e ? Ey(t, i) : ms(e, n, Ay | xy);
  };
}
function Sy(i) {
  return function(e) {
    return e == null ? void 0 : e[i];
  };
}
function Py(i) {
  return function(e) {
    return tl(e, i);
  };
}
function Ry(i) {
  return Qa(i) ? Sy(ui(i)) : Py(i);
}
function Kf(i) {
  return typeof i == "function" ? i : i == null ? Dt : typeof i == "object" ? Be(i) ? Iy(i[0], i[1]) : Cy(i) : Ry(i);
}
function Vy(i) {
  return function(e, t, n) {
    for (var s = -1, o = Object(e), r = n(e), a = r.length; a--; ) {
      var l = r[++s];
      if (t(o[l], l, o) === !1)
        break;
    }
    return e;
  };
}
var Zf = Vy();
function Jf(i, e) {
  return i && Zf(i, e, fs);
}
function My(i, e) {
  return function(t, n) {
    if (t == null)
      return t;
    if (!li(t))
      return i(t, n);
    for (var s = t.length, o = -1, r = Object(t); ++o < s && n(r[o], o, r) !== !1; )
      ;
    return t;
  };
}
var By = My(Jf), wr = function() {
  return lt.Date.now();
}, Ly = "Expected a function", Oy = Math.max, Fy = Math.min;
function Pt(i, e, t) {
  var n, s, o, r, a, l, c = 0, u = !1, d = !1, h = !0;
  if (typeof i != "function")
    throw new TypeError(Ly);
  e = lc(e) || 0, J(t) && (u = !!t.leading, d = "maxWait" in t, o = d ? Oy(lc(t.maxWait) || 0, e) : o, h = "trailing" in t ? !!t.trailing : h);
  function f(x) {
    var R = n, S = s;
    return n = s = void 0, c = x, r = i.apply(S, R), r;
  }
  function m(x) {
    return c = x, a = setTimeout(v, e), u ? f(x) : r;
  }
  function p(x) {
    var R = x - l, S = x - c, ee = e - R;
    return d ? Fy(ee, o - S) : ee;
  }
  function w(x) {
    var R = x - l, S = x - c;
    return l === void 0 || R >= e || R < 0 || d && S >= o;
  }
  function v() {
    var x = wr();
    if (w(x))
      return C(x);
    a = setTimeout(v, p(x));
  }
  function C(x) {
    return a = void 0, h && n ? f(x) : (n = s = void 0, r);
  }
  function L() {
    a !== void 0 && clearTimeout(a), c = 0, n = l = s = a = void 0;
  }
  function F() {
    return a === void 0 ? r : C(wr());
  }
  function q() {
    var x = wr(), R = w(x);
    if (n = arguments, s = this, l = x, R) {
      if (a === void 0)
        return m(l);
      if (d)
        return clearTimeout(a), a = setTimeout(v, e), f(l);
    }
    return a === void 0 && (a = setTimeout(v, e)), r;
  }
  return q.cancel = L, q.flush = F, q;
}
function ia(i, e, t) {
  (t !== void 0 && !hs(i[e], t) || t === void 0 && !(e in i)) && zo(i, e, t);
}
function Ny(i) {
  return Ke(i) && li(i);
}
function sa(i, e) {
  if (!(e === "constructor" && typeof i[e] == "function") && e != "__proto__")
    return i[e];
}
function Dy(i) {
  return ai(i, ci(i));
}
function zy(i, e, t, n, s, o, r) {
  var a = sa(i, t), l = sa(e, t), c = r.get(l);
  if (c) {
    ia(i, t, c);
    return;
  }
  var u = o ? o(a, l, t + "", i, e, r) : void 0, d = u === void 0;
  if (d) {
    var h = Be(l), f = !h && Gi(l), m = !h && !f && Xa(l);
    u = l, h || f || m ? Be(a) ? u = a : Ny(a) ? u = pf(a) : f ? (d = !1, u = Lf(l, !0)) : m ? (d = !1, u = Df(l, !0)) : u = [] : Ne(l) || go(l) ? (u = a, go(a) ? u = Dy(a) : (!J(a) || dn(a)) && (u = zf(l))) : d = !1;
  }
  d && (r.set(l, u), s(u, l, n, o, r), r.delete(l)), ia(i, t, u);
}
function Xf(i, e, t, n, s) {
  i !== e && Zf(e, function(o, r) {
    if (s || (s = new st()), J(o))
      zy(i, e, r, t, Xf, n, s);
    else {
      var a = n ? n(sa(i, r), o, r + "", i, e, s) : void 0;
      a === void 0 && (a = o), ia(i, r, a);
    }
  }, ci);
}
function Hy(i) {
  var e = i == null ? 0 : i.length;
  return e ? i[e - 1] : void 0;
}
var Qf = /[\\^$.*+?()[\]{}|]/g, Uy = RegExp(Qf.source);
function Yf(i) {
  return i = el(i), i && Uy.test(i) ? i.replace(Qf, "\\$&") : i;
}
function $y(i, e) {
  var t = -1, n = li(i) ? Array(i.length) : [];
  return By(i, function(s, o, r) {
    n[++t] = e(s, o, r);
  }), n;
}
function Wy(i, e) {
  var t = Be(i) ? mf : $y;
  return t(i, Kf(e));
}
var qy = "[object String]";
function Mc(i) {
  return typeof i == "string" || !Be(i) && Ke(i) && qt(i) == qy;
}
function Gy(i, e) {
  return e.length < 2 ? i : tl(i, Af(e, 0, -1));
}
function fn(i) {
  return Ke(i) && i.nodeType === 1 && !Ne(i);
}
function wo(i, e) {
  return ms(i, e);
}
function jy(i, e, t) {
  t = typeof t == "function" ? t : void 0;
  var n = t ? t(i, e) : void 0;
  return n === void 0 ? ms(i, e, void 0, t) : !!n;
}
function Ky(i, e) {
  var t = {};
  return e = Kf(e), Jf(i, function(n, s, o) {
    zo(t, s, e(n, s, o));
  }), t;
}
var rl = bf(function(i, e, t) {
  Xf(i, e, t);
});
function Zy(i, e) {
  return e = $o(e, i), i = Gy(i, e), i == null || delete i[ui(Hy(e))];
}
function Jy(i, e, t, n) {
  if (!J(i))
    return i;
  e = $o(e, i);
  for (var s = -1, o = e.length, r = o - 1, a = i; a != null && ++s < o; ) {
    var l = ui(e[s]), c = t;
    if (l === "__proto__" || l === "constructor" || l === "prototype")
      return i;
    if (s != r) {
      var u = a[l];
      c = void 0, c === void 0 && (c = J(u) ? u : Do(e[s + 1]) ? [] : {});
    }
    ja(a, l, c), a = a[l];
  }
  return i;
}
function Xy(i, e, t) {
  return i == null ? i : Jy(i, e, t);
}
var Qy = "Expected a function";
function Xn(i, e, t) {
  var n = !0, s = !0;
  if (typeof i != "function")
    throw new TypeError(Qy);
  return J(t) && (n = "leading" in t ? !!t.leading : n, s = "trailing" in t ? !!t.trailing : s), Pt(i, e, {
    leading: n,
    maxWait: e,
    trailing: s
  });
}
function Yy(i, e) {
  return i == null ? !0 : Zy(i, e);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const _o = Symbol("observableProperties"), Wo = Symbol("boundObservables"), vo = Symbol("boundProperties"), Rn = Symbol("decoratedMethods"), Bc = Symbol("decoratedOriginal"), em = U(G());
function U(i) {
  if (!i)
    return em;
  class e extends i {
    set(n, s) {
      if (J(n)) {
        Object.keys(n).forEach((r) => {
          this.set(r, n[r]);
        }, this);
        return;
      }
      _r(this);
      const o = this[_o];
      if (n in this && !o.has(n))
        throw new g("observable-set-cannot-override", this);
      Object.defineProperty(this, n, {
        enumerable: !0,
        configurable: !0,
        get() {
          return o.get(n);
        },
        set(r) {
          const a = o.get(n);
          let l = this.fire(`set:${n}`, n, r, a);
          l === void 0 && (l = r), (a !== l || !o.has(n)) && (o.set(n, l), this.fire(`change:${n}`, n, l, a));
        }
      }), this[n] = s;
    }
    bind(...n) {
      if (!n.length || !Lc(n))
        throw new g("observable-bind-wrong-properties", this);
      if (new Set(n).size !== n.length)
        throw new g("observable-bind-duplicate-properties", this);
      _r(this);
      const s = this[vo];
      n.forEach((r) => {
        if (s.has(r))
          throw new g("observable-bind-rebind", this);
      });
      const o = /* @__PURE__ */ new Map();
      return n.forEach((r) => {
        const a = { property: r, to: [] };
        s.set(r, a), o.set(r, a);
      }), {
        to: eC,
        toMany: tC,
        _observable: this,
        _bindProperties: n,
        _to: [],
        _bindings: o
      };
    }
    unbind(...n) {
      if (!this[_o])
        return;
      const s = this[vo], o = this[Wo];
      if (n.length) {
        if (!Lc(n))
          throw new g("observable-unbind-wrong-properties", this);
        n.forEach((r) => {
          const a = s.get(r);
          a && (a.to.forEach(([l, c]) => {
            const u = o.get(l), d = u[c];
            d.delete(a), d.size || delete u[c], Object.keys(u).length || (o.delete(l), this.stopListening(l, "change"));
          }), s.delete(r));
        });
      } else
        o.forEach((r, a) => {
          this.stopListening(a, "change");
        }), o.clear(), s.clear();
    }
    decorate(n) {
      _r(this);
      const s = this[n];
      if (!s)
        throw new g("observablemixin-cannot-decorate-undefined", this, { object: this, methodName: n });
      this.on(n, (o, r) => {
        o.return = s.apply(this, r);
      }), this[n] = function(...o) {
        return this.fire(n, o);
      }, this[n][Bc] = s, this[Rn] || (this[Rn] = []), this[Rn].push(n);
    }
    // Override the EmitterMixin stopListening method to be able to clean (and restore) decorated methods.
    // This is needed in case of:
    //  1. Have x.foo() decorated.
    //  2. Call x.stopListening()
    //  3. Call x.foo(). Problem: nothing happens (the original foo() method is not executed)
    stopListening(n, s, o) {
      if (!n && this[Rn]) {
        for (const r of this[Rn])
          this[r] = this[r][Bc];
        delete this[Rn];
      }
      super.stopListening(n, s, o);
    }
  }
  return e;
}
[
  "set",
  "bind",
  "unbind",
  "decorate",
  "on",
  "once",
  "off",
  "listenTo",
  "stopListening",
  "fire",
  "delegate",
  "stopDelegating",
  "_addEventListener",
  "_removeEventListener"
].forEach((i) => {
  U[i] = em.prototype[i];
});
function _r(i) {
  i[_o] || (Object.defineProperty(i, _o, {
    value: /* @__PURE__ */ new Map()
  }), Object.defineProperty(i, Wo, {
    value: /* @__PURE__ */ new Map()
  }), Object.defineProperty(i, vo, {
    value: /* @__PURE__ */ new Map()
  }));
}
function eC(...i) {
  const e = iC(...i), t = Array.from(this._bindings.keys()), n = t.length;
  if (!e.callback && e.to.length > 1)
    throw new g("observable-bind-to-no-callback", this);
  if (n > 1 && e.callback)
    throw new g("observable-bind-to-extra-callback", this);
  e.to.forEach((s) => {
    if (s.properties.length && s.properties.length !== n)
      throw new g("observable-bind-to-properties-length", this);
    s.properties.length || (s.properties = this._bindProperties);
  }), this._to = e.to, e.callback && (this._bindings.get(t[0]).callback = e.callback), rC(this._observable, this._to), oC(this), this._bindProperties.forEach((s) => {
    tm(this._observable, s);
  });
}
function tC(i, e, t) {
  if (this._bindings.size > 1)
    throw new g("observable-bind-to-many-not-one-binding", this);
  this.to(
    ...nC(i, e),
    // ...using given callback to parse attribute values.
    t
  );
}
function nC(i, e) {
  const t = i.map((n) => [n, e]);
  return Array.prototype.concat.apply([], t);
}
function Lc(i) {
  return i.every((e) => typeof e == "string");
}
function iC(...i) {
  if (!i.length)
    throw new g("observable-bind-to-parse-error", null);
  const e = { to: [] };
  let t;
  return typeof i[i.length - 1] == "function" && (e.callback = i.pop()), i.forEach((n) => {
    if (typeof n == "string")
      t.properties.push(n);
    else if (typeof n == "object")
      t = { observable: n, properties: [] }, e.to.push(t);
    else
      throw new g("observable-bind-to-parse-error", null);
  }), e;
}
function sC(i, e, t, n) {
  const s = i[Wo], o = s.get(t), r = o || {};
  r[n] || (r[n] = /* @__PURE__ */ new Set()), r[n].add(e), o || s.set(t, r);
}
function oC(i) {
  let e;
  i._bindings.forEach((t, n) => {
    i._to.forEach((s) => {
      e = s.properties[t.callback ? 0 : i._bindProperties.indexOf(n)], t.to.push([s.observable, e]), sC(i._observable, t, s.observable, e);
    });
  });
}
function tm(i, e) {
  const n = i[vo].get(e);
  let s;
  n.callback ? s = n.callback.apply(i, n.to.map((o) => o[0][o[1]])) : (s = n.to[0], s = s[0][s[1]]), Object.prototype.hasOwnProperty.call(i, e) ? i[e] = s : i.set(e, s);
}
function rC(i, e) {
  e.forEach((t) => {
    const n = i[Wo];
    let s;
    n.get(t.observable) || i.listenTo(t.observable, "change", (o, r) => {
      s = n.get(t.observable)[r], s && s.forEach((a) => {
        tm(i, a.property);
      });
    });
  });
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class aC {
  constructor() {
    this._replacedElements = [];
  }
  /**
   * Hides the `element` and, if specified, inserts the the given element next to it.
   *
   * The effect of this method can be reverted by {@link #restore}.
   *
   * @param element The element to replace.
   * @param newElement The replacement element. If not passed, then the `element` will just be hidden.
   */
  replace(e, t) {
    this._replacedElements.push({ element: e, newElement: t }), e.style.display = "none", t && e.parentNode.insertBefore(t, e.nextSibling);
  }
  /**
   * Restores what {@link #replace} did.
   */
  restore() {
    this._replacedElements.forEach(({ element: e, newElement: t }) => {
      e.style.display = "", t && t.remove();
    }), this._replacedElements = [];
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function oa(i) {
  let e = 0;
  for (const t of i)
    e++;
  return e;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Ee(i, e) {
  const t = Math.min(i.length, e.length);
  for (let n = 0; n < t; n++)
    if (i[n] != e[n])
      return n;
  return i.length == e.length ? "same" : i.length < e.length ? "prefix" : "extension";
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Ue(i) {
  return !!(i && i[Symbol.iterator]);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Ye(i, e, t = {}, n = []) {
  const s = t && t.xmlns, o = s ? i.createElementNS(s, e) : i.createElement(e);
  for (const r in t)
    o.setAttribute(r, t[r]);
  (Mc(n) || !Ue(n)) && (n = [n]);
  for (let r of n)
    Mc(r) && (r = i.createTextNode(r)), o.appendChild(r);
  return o;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class nm {
  /**
   * Creates an instance of the {@link ~Config} class.
   *
   * @param configurations The initial configurations to be set. Usually, provided by the user.
   * @param defaultConfigurations The default configurations. Usually, provided by the system.
   */
  constructor(e, t) {
    this._config = {}, t && this.define(Oc(t)), e && this._setObjectToTarget(this._config, e);
  }
  set(e, t) {
    this._setToTarget(this._config, e, t);
  }
  define(e, t) {
    this._setToTarget(this._config, e, t, !0);
  }
  /**
   * Gets the value for a configuration entry.
   *
   * ```ts
   * config.get( 'name' );
   * ```
   *
   * Deep configurations can be retrieved by separating each part with a dot.
   *
   * ```ts
   * config.get( 'toolbar.collapsed' );
   * ```
   *
   * @param name The configuration name. Configuration names are case-sensitive.
   * @returns The configuration value or `undefined` if the configuration entry was not found.
   */
  get(e) {
    return this._getFromSource(this._config, e);
  }
  /**
   * Iterates over all top level configuration names.
   */
  *names() {
    for (const e of Object.keys(this._config))
      yield e;
  }
  /**
   * Saves passed configuration to the specified target (nested object).
   *
   * @param target Nested config object.
   * @param name The configuration name or an object from which take properties as
   * configuration entries. Configuration names are case-sensitive.
   * @param value The configuration value. Used if a name is passed.
   * @param isDefine Define if passed configuration should overwrite existing one.
   */
  _setToTarget(e, t, n, s = !1) {
    if (Ne(t)) {
      this._setObjectToTarget(e, t, s);
      return;
    }
    const o = t.split(".");
    t = o.pop();
    for (const r of o)
      Ne(e[r]) || (e[r] = {}), e = e[r];
    if (Ne(n)) {
      Ne(e[t]) || (e[t] = {}), e = e[t], this._setObjectToTarget(e, n, s);
      return;
    }
    s && typeof e[t] != "undefined" || (e[t] = n);
  }
  /**
   * Get specified configuration from specified source (nested object).
   *
   * @param source level of nested object.
   * @param name The configuration name. Configuration names are case-sensitive.
   * @returns The configuration value or `undefined` if the configuration entry was not found.
   */
  _getFromSource(e, t) {
    const n = t.split(".");
    t = n.pop();
    for (const s of n) {
      if (!Ne(e[s])) {
        e = null;
        break;
      }
      e = e[s];
    }
    return e ? Oc(e[t]) : void 0;
  }
  /**
   * Iterates through passed object and calls {@link #_setToTarget} method with object key and value for each property.
   *
   * @param target Nested config object.
   * @param configuration Configuration data set
   * @param isDefine Defines if passed configuration is default configuration or not.
   */
  _setObjectToTarget(e, t, n) {
    Object.keys(t).forEach((s) => {
      this._setToTarget(e, s, t[s], n);
    });
  }
}
function Oc(i) {
  return ol(i, lC);
}
function lC(i) {
  return fn(i) || typeof i == "function" ? i : void 0;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Ut(i) {
  if (i) {
    if (i.defaultView)
      return i instanceof i.defaultView.Document;
    if (i.ownerDocument && i.ownerDocument.defaultView)
      return i instanceof i.ownerDocument.defaultView.Node;
  }
  return !1;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function yo(i) {
  const e = Object.prototype.toString.apply(i);
  return e == "[object Window]" || e == "[object global]";
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const im = Le(G());
function Le(i) {
  if (!i)
    return im;
  class e extends i {
    listenTo(n, s, o, r = {}) {
      if (Ut(n) || yo(n)) {
        const a = {
          capture: !!r.useCapture,
          passive: !!r.usePassive
        }, l = this._getProxyEmitter(n, a) || new cC(n, a);
        this.listenTo(l, s, o, r);
      } else
        super.listenTo(n, s, o, r);
    }
    stopListening(n, s, o) {
      if (Ut(n) || yo(n)) {
        const r = this._getAllProxyEmitters(n);
        for (const a of r)
          this.stopListening(a, s, o);
      } else
        super.stopListening(n, s, o);
    }
    /**
     * Retrieves ProxyEmitter instance for given DOM Node residing in this Host and given options.
     *
     * @param node DOM Node of the ProxyEmitter.
     * @param options Additional options.
     * @param options.useCapture Indicates that events of this type will be dispatched to the registered
     * listener before being dispatched to any EventTarget beneath it in the DOM tree.
     * @param options.usePassive Indicates that the function specified by listener will never call preventDefault()
     * and prevents blocking browser's main thread by this event handler.
     * @returns ProxyEmitter instance bound to the DOM Node.
     */
    _getProxyEmitter(n, s) {
      return aw(this, sm(n, s));
    }
    /**
     * Retrieves all the ProxyEmitter instances for given DOM Node residing in this Host.
     *
     * @param node DOM Node of the ProxyEmitter.
     */
    _getAllProxyEmitters(n) {
      return [
        { capture: !1, passive: !1 },
        { capture: !1, passive: !0 },
        { capture: !0, passive: !1 },
        { capture: !0, passive: !0 }
      ].map((s) => this._getProxyEmitter(n, s)).filter((s) => !!s);
    }
  }
  return e;
}
[
  "_getProxyEmitter",
  "_getAllProxyEmitters",
  "on",
  "once",
  "off",
  "listenTo",
  "stopListening",
  "fire",
  "delegate",
  "stopDelegating",
  "_addEventListener",
  "_removeEventListener"
].forEach((i) => {
  Le[i] = im.prototype[i];
});
class cC extends G() {
  /**
   * @param node DOM Node that fires events.
   * @param options Additional options.
   * @param options.useCapture Indicates that events of this type will be dispatched to the registered
   * listener before being dispatched to any EventTarget beneath it in the DOM tree.
   * @param options.usePassive Indicates that the function specified by listener will never call preventDefault()
   * and prevents blocking browser's main thread by this event handler.
   */
  constructor(e, t) {
    super(), cf(this, sm(e, t)), this._domNode = e, this._options = t;
  }
  /**
   * Registers a callback function to be executed when an event is fired.
   *
   * It attaches a native DOM listener to the DOM Node. When fired,
   * a corresponding Emitter event will also fire with DOM Event object as an argument.
   *
   * **Note**: This is automatically called by the
   * {@link module:utils/emittermixin~Emitter#listenTo `Emitter#listenTo()`}.
   *
   * @param event The name of the event.
   */
  attach(e) {
    if (this._domListeners && this._domListeners[e])
      return;
    const t = this._createDomListener(e);
    this._domNode.addEventListener(e, t, this._options), this._domListeners || (this._domListeners = {}), this._domListeners[e] = t;
  }
  /**
   * Stops executing the callback on the given event.
   *
   * **Note**: This is automatically called by the
   * {@link module:utils/emittermixin~Emitter#stopListening `Emitter#stopListening()`}.
   *
   * @param event The name of the event.
   */
  detach(e) {
    let t;
    this._domListeners[e] && (!(t = this._events[e]) || !t.callbacks.length) && this._domListeners[e].removeListener();
  }
  /**
   * Adds callback to emitter for given event.
   *
   * @internal
   * @param event The name of the event.
   * @param callback The function to be called on event.
   * @param options Additional options.
   */
  _addEventListener(e, t, n) {
    this.attach(e), G().prototype._addEventListener.call(this, e, t, n);
  }
  /**
   * Removes callback from emitter for given event.
   *
   * @internal
   * @param event The name of the event.
   * @param callback The function to stop being called.
   */
  _removeEventListener(e, t) {
    G().prototype._removeEventListener.call(this, e, t), this.detach(e);
  }
  /**
   * Creates a native DOM listener callback. When the native DOM event
   * is fired it will fire corresponding event on this ProxyEmitter.
   * Note: A native DOM Event is passed as an argument.
   *
   * @param event The name of the event.
   * @returns The DOM listener callback.
   */
  _createDomListener(e) {
    const t = (n) => {
      this.fire(e, n);
    };
    return t.removeListener = () => {
      this._domNode.removeEventListener(e, t, this._options), delete this._domListeners[e];
    }, t;
  }
}
function uC(i) {
  return i["data-ck-expando"] || (i["data-ck-expando"] = je());
}
function sm(i, e) {
  let t = uC(i);
  for (const n of Object.keys(e).sort())
    e[n] && (t += "-" + n);
  return t;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function dC(i) {
  const e = [];
  let t = i;
  for (; t && t.nodeType != Node.DOCUMENT_NODE; )
    e.unshift(t), t = t.parentNode;
  return e;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function hC(i) {
  return i instanceof HTMLTextAreaElement ? i.value : i.innerHTML;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function om(i) {
  const e = i.ownerDocument.defaultView.getComputedStyle(i);
  return {
    top: parseInt(e.borderTopWidth, 10),
    right: parseInt(e.borderRightWidth, 10),
    bottom: parseInt(e.borderBottomWidth, 10),
    left: parseInt(e.borderLeftWidth, 10)
  };
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function re(i) {
  return Object.prototype.toString.call(i) == "[object Text]";
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function qo(i) {
  return Object.prototype.toString.apply(i) == "[object Range]";
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function rm(i) {
  return !i || !i.parentNode || i.offsetParent === E.document.body ? null : i.offsetParent;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const am = ["top", "right", "bottom", "left", "width", "height"];
class B {
  /**
   * Creates an instance of rect.
   *
   * ```ts
   * // Rect of an HTMLElement.
   * const rectA = new Rect( document.body );
   *
   * // Rect of a DOM Range.
   * const rectB = new Rect( document.getSelection().getRangeAt( 0 ) );
   *
   * // Rect of a window (web browser viewport).
   * const rectC = new Rect( window );
   *
   * // Rect out of an object.
   * const rectD = new Rect( { top: 0, right: 10, bottom: 10, left: 0, width: 10, height: 10 } );
   *
   * // Rect out of another Rect instance.
   * const rectE = new Rect( rectD );
   *
   * // Rect out of a ClientRect.
   * const rectF = new Rect( document.body.getClientRects().item( 0 ) );
   * ```
   *
   * **Note**: By default a rect of an HTML element includes its CSS borders and scrollbars (if any)
   * ant the rect of a `window` includes scrollbars too. Use {@link #excludeScrollbarsAndBorders}
   * to get the inner part of the rect.
   *
   * @param source A source object to create the rect.
   */
  constructor(e) {
    const t = qo(e);
    if (Object.defineProperty(this, "_source", {
      // If the source is a Rect instance, copy it's #_source.
      value: e._source || e,
      writable: !0,
      enumerable: !1
    }), ra(e) || t)
      if (t) {
        const n = B.getDomRangeRects(e);
        Is(this, B.getBoundingRect(n));
      } else
        Is(this, e.getBoundingClientRect());
    else if (yo(e)) {
      const { innerWidth: n, innerHeight: s } = e;
      Is(this, {
        top: 0,
        right: n,
        bottom: s,
        left: 0,
        width: n,
        height: s
      });
    } else
      Is(this, e);
  }
  /**
   * Returns a clone of the rect.
   *
   * @returns A cloned rect.
   */
  clone() {
    return new B(this);
  }
  /**
   * Moves the rect so that its upper–left corner lands in desired `[ x, y ]` location.
   *
   * @param x Desired horizontal location.
   * @param y Desired vertical location.
   * @returns A rect which has been moved.
   */
  moveTo(e, t) {
    return this.top = t, this.right = e + this.width, this.bottom = t + this.height, this.left = e, this;
  }
  /**
   * Moves the rect in–place by a dedicated offset.
   *
   * @param x A horizontal offset.
   * @param y A vertical offset
   * @returns A rect which has been moved.
   */
  moveBy(e, t) {
    return this.top += t, this.right += e, this.left += e, this.bottom += t, this;
  }
  /**
   * Returns a new rect a a result of intersection with another rect.
   */
  getIntersection(e) {
    const t = {
      top: Math.max(this.top, e.top),
      right: Math.min(this.right, e.right),
      bottom: Math.min(this.bottom, e.bottom),
      left: Math.max(this.left, e.left),
      width: 0,
      height: 0
    };
    if (t.width = t.right - t.left, t.height = t.bottom - t.top, t.width < 0 || t.height < 0)
      return null;
    {
      const n = new B(t);
      return n._source = this._source, n;
    }
  }
  /**
   * Returns the area of intersection with another rect.
   *
   * @returns Area of intersection.
   */
  getIntersectionArea(e) {
    const t = this.getIntersection(e);
    return t ? t.getArea() : 0;
  }
  /**
   * Returns the area of the rect.
   */
  getArea() {
    return this.width * this.height;
  }
  /**
   * Returns a new rect, a part of the original rect, which is actually visible to the user and is relative to the,`body`,
   * e.g. an original rect cropped by parent element rects which have `overflow` set in CSS
   * other than `"visible"`.
   *
   * If there's no such visible rect, which is when the rect is limited by one or many of
   * the ancestors, `null` is returned.
   *
   * **Note**: This method does not consider the boundaries of the viewport (window).
   * To get a rect cropped by all ancestors and the viewport, use an intersection such as:
   *
   * ```ts
   * const visibleInViewportRect = new Rect( window ).getIntersection( new Rect( source ).getVisible() );
   * ```
   *
   * @returns A visible rect instance or `null`, if there's none.
   */
  getVisible() {
    const e = this._source;
    let t = this.clone();
    if (Fc(e))
      return t;
    let n = e, s = e.parentNode || e.commonAncestorContainer, o;
    for (; s && !Fc(s); ) {
      const r = fC(s) === "visible";
      n instanceof HTMLElement && Nc(n) === "absolute" && (o = n);
      const a = Nc(s);
      if (r || o && (a === "relative" && r || a !== "relative")) {
        n = s, s = s.parentNode;
        continue;
      }
      const l = new B(s), c = t.getIntersection(l);
      if (c)
        c.getArea() < t.getArea() && (t = c);
      else
        return null;
      n = s, s = s.parentNode;
    }
    return t;
  }
  /**
   * Checks if all property values ({@link #top}, {@link #left}, {@link #right},
   * {@link #bottom}, {@link #width} and {@link #height}) are the equal in both rect
   * instances.
   *
   * @param anotherRect A rect instance to compare with.
   * @returns `true` when Rects are equal. `false` otherwise.
   */
  isEqual(e) {
    for (const t of am)
      if (this[t] !== e[t])
        return !1;
    return !0;
  }
  /**
   * Checks whether a rect fully contains another rect instance.
   *
   * @param anotherRect
   * @returns `true` if contains, `false` otherwise.
   */
  contains(e) {
    const t = this.getIntersection(e);
    return !!(t && t.isEqual(e));
  }
  /**
   * Recalculates screen coordinates to coordinates relative to the positioned ancestor offset.
   */
  toAbsoluteRect() {
    const { scrollX: e, scrollY: t } = E.window, n = this.clone().moveBy(e, t);
    if (ra(n._source)) {
      const s = rm(n._source);
      s && mC(n, s);
    }
    return n;
  }
  /**
   * Excludes scrollbars and CSS borders from the rect.
   *
   * * Borders are removed when {@link #_source} is an HTML element.
   * * Scrollbars are excluded from HTML elements and the `window`.
   *
   * @returns A rect which has been updated.
   */
  excludeScrollbarsAndBorders() {
    const e = this._source;
    let t, n, s;
    if (yo(e))
      t = e.innerWidth - e.document.documentElement.clientWidth, n = e.innerHeight - e.document.documentElement.clientHeight, s = e.getComputedStyle(e.document.documentElement).direction;
    else {
      const o = om(e);
      t = e.offsetWidth - e.clientWidth - o.left - o.right, n = e.offsetHeight - e.clientHeight - o.top - o.bottom, s = e.ownerDocument.defaultView.getComputedStyle(e).direction, this.left += o.left, this.top += o.top, this.right -= o.right, this.bottom -= o.bottom, this.width = this.right - this.left, this.height = this.bottom - this.top;
    }
    return this.width -= t, s === "ltr" ? this.right -= t : this.left += t, this.height -= n, this.bottom -= n, this;
  }
  /**
   * Returns an array of rects of the given native DOM Range.
   *
   * @param range A native DOM range.
   * @returns DOM Range rects.
   */
  static getDomRangeRects(e) {
    const t = [], n = Array.from(e.getClientRects());
    if (n.length)
      for (const s of n)
        t.push(new B(s));
    else {
      let s = e.startContainer;
      re(s) && (s = s.parentNode);
      const o = new B(s.getBoundingClientRect());
      o.right = o.left, o.width = 0, t.push(o);
    }
    return t;
  }
  /**
   * Returns a bounding rectangle that contains all the given `rects`.
   *
   * @param rects A list of rectangles that should be contained in the result rectangle.
   * @returns Bounding rectangle or `null` if no `rects` were given.
   */
  static getBoundingRect(e) {
    const t = {
      left: Number.POSITIVE_INFINITY,
      top: Number.POSITIVE_INFINITY,
      right: Number.NEGATIVE_INFINITY,
      bottom: Number.NEGATIVE_INFINITY,
      width: 0,
      height: 0
    };
    let n = 0;
    for (const s of e)
      n++, t.left = Math.min(t.left, s.left), t.top = Math.min(t.top, s.top), t.right = Math.max(t.right, s.right), t.bottom = Math.max(t.bottom, s.bottom);
    return n == 0 ? null : (t.width = t.right - t.left, t.height = t.bottom - t.top, new B(t));
  }
}
function Is(i, e) {
  for (const t of am)
    i[t] = e[t];
}
function Fc(i) {
  return ra(i) ? i === i.ownerDocument.body : !1;
}
function ra(i) {
  return i !== null && typeof i == "object" && i.nodeType === 1 && typeof i.getBoundingClientRect == "function";
}
function Nc(i) {
  return i instanceof HTMLElement ? i.ownerDocument.defaultView.getComputedStyle(i).position : "static";
}
function fC(i) {
  return i instanceof HTMLElement ? i.ownerDocument.defaultView.getComputedStyle(i).overflow : "visible";
}
function mC(i, e) {
  const t = new B(e), n = om(e);
  let s = 0, o = 0;
  s -= t.left, o -= t.top, s += e.scrollLeft, o += e.scrollTop, s -= n.left, o -= n.top, i.moveBy(s, o);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Y {
  /**
   * Creates an instance of the `ResizeObserver` class.
   *
   * @param element A DOM element that is to be observed for resizing. Note that
   * the element must be visible (i.e. not detached from DOM) for the observer to work.
   * @param callback A function called when the observed element was resized. It passes
   * the [`ResizeObserverEntry`](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserverEntry)
   * object with information about the resize event.
   */
  constructor(e, t) {
    Y._observerInstance || Y._createObserver(), this._element = e, this._callback = t, Y._addElementCallback(e, t), Y._observerInstance.observe(e);
  }
  /**
   * The element observed by this observer.
   */
  get element() {
    return this._element;
  }
  /**
   * Destroys the observer which disables the `callback` passed to the {@link #constructor}.
   */
  destroy() {
    Y._deleteElementCallback(this._element, this._callback);
  }
  /**
   * Registers a new resize callback for the DOM element.
   */
  static _addElementCallback(e, t) {
    Y._elementCallbacks || (Y._elementCallbacks = /* @__PURE__ */ new Map());
    let n = Y._elementCallbacks.get(e);
    n || (n = /* @__PURE__ */ new Set(), Y._elementCallbacks.set(e, n)), n.add(t);
  }
  /**
   * Removes a resize callback from the DOM element. If no callbacks are left
   * for the element, it removes the element from the native observer.
   */
  static _deleteElementCallback(e, t) {
    const n = Y._getElementCallbacks(e);
    n && (n.delete(t), n.size || (Y._elementCallbacks.delete(e), Y._observerInstance.unobserve(e))), Y._elementCallbacks && !Y._elementCallbacks.size && (Y._observerInstance = null, Y._elementCallbacks = null);
  }
  /**
   * Returns are registered resize callbacks for the DOM element.
   */
  static _getElementCallbacks(e) {
    return Y._elementCallbacks ? Y._elementCallbacks.get(e) : null;
  }
  /**
   * Creates the single native observer shared across all `ResizeObserver` instances.
   */
  static _createObserver() {
    Y._observerInstance = new E.window.ResizeObserver((e) => {
      for (const t of e) {
        const n = Y._getElementCallbacks(t.target);
        if (n)
          for (const s of n)
            s(t);
      }
    });
  }
}
Y._observerInstance = null;
Y._elementCallbacks = null;
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Dc(i, e) {
  i instanceof HTMLTextAreaElement && (i.value = e), i.innerHTML = e;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function di(i) {
  return (e) => e + i;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Pi(i) {
  let e = 0;
  for (; i.previousSibling; )
    i = i.previousSibling, e++;
  return e;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function lm(i, e, t) {
  i.insertBefore(t, i.childNodes[e] || null);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Oi(i) {
  return i && i.nodeType === Node.COMMENT_NODE;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function gC(i) {
  try {
    E.document.createAttribute(i);
  } catch (e) {
    return !1;
  }
  return !0;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function mn(i) {
  return !!(i && i.getClientRects && i.getClientRects().length);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Go({ element: i, target: e, positions: t, limiter: n, fitInViewport: s, viewportOffsetConfig: o }) {
  dn(e) && (e = e()), dn(n) && (n = n());
  const r = rm(i), a = pC(o), l = new B(i), c = zc(e, a);
  let u;
  if (!c || !a.getIntersection(c))
    return null;
  const d = {
    targetRect: c,
    elementRect: l,
    positionedElementAncestor: r,
    viewportRect: a
  };
  if (!n && !s)
    u = new cm(t[0], d);
  else {
    if (n) {
      const h = zc(n, a);
      h && (d.limiterRect = h);
    }
    u = bC(t, d);
  }
  return u;
}
function zc(i, e) {
  const t = new B(i).getVisible();
  return t ? t.getIntersection(e) : null;
}
function pC(i) {
  i = Object.assign({ top: 0, bottom: 0, left: 0, right: 0 }, i);
  const e = new B(E.window);
  return e.top += i.top, e.height -= i.top, e.bottom -= i.bottom, e.height -= i.bottom, e;
}
function bC(i, e) {
  const { elementRect: t } = e, n = t.getArea(), s = i.map((a) => new cm(a, e)).filter((a) => !!a.name);
  let o = 0, r = null;
  for (const a of s) {
    const { limiterIntersectionArea: l, viewportIntersectionArea: c } = a;
    if (l === n)
      return a;
    const u = c ** 2 + l ** 2;
    u > o && (o = u, r = a);
  }
  return r;
}
class cm {
  /**
   * Creates an instance of the {@link module:utils/dom/position~PositionObject} class.
   *
   * @param positioningFunction function The function that defines the expected
   * coordinates the positioned element should move to.
   * @param options options object.
   * @param options.elementRect The positioned element rect.
   * @param options.targetRect The target element rect.
   * @param options.viewportRect The viewport rect.
   * @param options.limiterRect The limiter rect.
   * @param options.positionedElementAncestor Nearest element ancestor element which CSS position is not "static".
   */
  constructor(e, t) {
    const n = e(t.targetRect, t.elementRect, t.viewportRect, t.limiterRect);
    if (!n)
      return;
    const { left: s, top: o, name: r, config: a } = n;
    this.name = r, this.config = a, this._positioningFunctionCoordinates = { left: s, top: o }, this._options = t;
  }
  /**
   * The left value in pixels in the CSS `position: absolute` coordinate system.
   * Set it on the positioned element in DOM to move it to the position.
   */
  get left() {
    return this._absoluteRect.left;
  }
  /**
   * The top value in pixels in the CSS `position: absolute` coordinate system.
   * Set it on the positioned element in DOM to move it to the position.
   */
  get top() {
    return this._absoluteRect.top;
  }
  /**
   * An intersection area between positioned element and limiter within viewport constraints.
   */
  get limiterIntersectionArea() {
    const e = this._options.limiterRect;
    return e ? e.getIntersectionArea(this._rect) : 0;
  }
  /**
   * An intersection area between positioned element and viewport.
   */
  get viewportIntersectionArea() {
    return this._options.viewportRect.getIntersectionArea(this._rect);
  }
  /**
   * An already positioned element rect. A clone of the element rect passed to the constructor
   * but placed in the viewport according to the positioning function.
   */
  get _rect() {
    return this._cachedRect ? this._cachedRect : (this._cachedRect = this._options.elementRect.clone().moveTo(this._positioningFunctionCoordinates.left, this._positioningFunctionCoordinates.top), this._cachedRect);
  }
  /**
   * An already absolutely positioned element rect. See ({@link #_rect}).
   */
  get _absoluteRect() {
    return this._cachedAbsoluteRect ? this._cachedAbsoluteRect : (this._cachedAbsoluteRect = this._rect.toAbsoluteRect(), this._cachedAbsoluteRect);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Hc(i) {
  const e = i.parentNode;
  e && e.removeChild(i);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function wC({ target: i, viewportOffset: e = 0, ancestorOffset: t = 0, alignToTop: n, forceScroll: s }) {
  const o = al(i);
  let r = o, a = null;
  for (e = yC(e); r; ) {
    let l;
    r == o ? l = Uc(i) : l = Uc(a), vC({
      parent: l,
      getRect: () => $c(i, r),
      alignToTop: n,
      ancestorOffset: t,
      forceScroll: s
    });
    const c = $c(i, r);
    if (_C({
      window: r,
      rect: c,
      viewportOffset: e,
      alignToTop: n,
      forceScroll: s
    }), r.parent != r) {
      if (a = r.frameElement, r = r.parent, !a)
        return;
    } else
      r = null;
  }
}
function _C({ window: i, rect: e, alignToTop: t, forceScroll: n, viewportOffset: s }) {
  const o = e.clone().moveBy(0, s.bottom), r = e.clone().moveBy(0, -s.top), a = new B(i).excludeScrollbarsAndBorders(), l = [r, o], c = t && n, u = l.every((p) => a.contains(p));
  let { scrollX: d, scrollY: h } = i;
  const f = d, m = h;
  c ? h -= a.top - e.top + s.top : u || (dm(r, a) ? h -= a.top - e.top + s.top : um(o, a) && (t ? h += e.top - a.top - s.top : h += e.bottom - a.bottom + s.bottom)), u || (hm(e, a) ? d -= a.left - e.left + s.left : fm(e, a) && (d += e.right - a.right + s.right)), (d != f || h !== m) && i.scrollTo(d, h);
}
function vC({ parent: i, getRect: e, alignToTop: t, forceScroll: n, ancestorOffset: s = 0, limiterElement: o }) {
  const r = al(i), a = t && n;
  let l, c, u;
  const d = o || r.document.body;
  for (; i != d; )
    c = e(), l = new B(i).excludeScrollbarsAndBorders(), u = l.contains(c), a ? i.scrollTop -= l.top - c.top + s : u || (dm(c, l) ? i.scrollTop -= l.top - c.top + s : um(c, l) && (t ? i.scrollTop += c.top - l.top - s : i.scrollTop += c.bottom - l.bottom + s)), u || (hm(c, l) ? i.scrollLeft -= l.left - c.left + s : fm(c, l) && (i.scrollLeft += c.right - l.right + s)), i = i.parentNode;
}
function um(i, e) {
  return i.bottom > e.bottom;
}
function dm(i, e) {
  return i.top < e.top;
}
function hm(i, e) {
  return i.left < e.left;
}
function fm(i, e) {
  return i.right > e.right;
}
function al(i) {
  return qo(i) ? i.startContainer.ownerDocument.defaultView : i.ownerDocument.defaultView;
}
function Uc(i) {
  if (qo(i)) {
    let e = i.commonAncestorContainer;
    return re(e) && (e = e.parentNode), e;
  } else
    return i.parentNode;
}
function $c(i, e) {
  const t = al(i), n = new B(i);
  if (t === e)
    return n;
  {
    let s = t;
    for (; s != e; ) {
      const o = s.frameElement, r = new B(o).excludeScrollbarsAndBorders();
      n.moveBy(r.left, r.top), s = s.parent;
    }
  }
  return n;
}
function yC(i) {
  return typeof i == "number" ? {
    top: i,
    bottom: i,
    left: i,
    right: i
  } : i;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const CC = {
  ctrl: "⌃",
  cmd: "⌘",
  alt: "⌥",
  shift: "⇧"
}, kC = {
  ctrl: "Ctrl+",
  alt: "Alt+",
  shift: "Shift+"
}, Wc = {
  37: "←",
  38: "↑",
  39: "→",
  40: "↓",
  9: "⇥",
  33: "Page Up",
  34: "Page Down"
}, N = IC(), TC = Object.fromEntries(Object.entries(N).map(([i, e]) => {
  let t;
  return e in Wc ? t = Wc[e] : t = i.charAt(0).toUpperCase() + i.slice(1), [e, t];
}));
function Qn(i) {
  let e;
  if (typeof i == "string") {
    if (e = N[i.toLowerCase()], !e)
      throw new g("keyboard-unknown-key", null, { key: i });
  } else
    e = i.keyCode + (i.altKey ? N.alt : 0) + (i.ctrlKey ? N.ctrl : 0) + (i.shiftKey ? N.shift : 0) + (i.metaKey ? N.cmd : 0);
  return e;
}
function gs(i) {
  return typeof i == "string" && (i = SC(i)), i.map((e) => typeof e == "string" ? AC(e) : e).reduce((e, t) => t + e, 0);
}
function Co(i) {
  let e = gs(i);
  return Object.entries(M.isMac || M.isiOS ? CC : kC).reduce((s, [o, r]) => (e & N[o] && (e &= ~N[o], s += r), s), "") + (e ? TC[e] : "");
}
function EC(i) {
  return i == N.arrowright || i == N.arrowleft || i == N.arrowup || i == N.arrowdown;
}
function ll(i, e) {
  const t = e === "ltr";
  switch (i) {
    case N.arrowleft:
      return t ? "left" : "right";
    case N.arrowright:
      return t ? "right" : "left";
    case N.arrowup:
      return "up";
    case N.arrowdown:
      return "down";
  }
}
function AC(i) {
  if (i.endsWith("!"))
    return Qn(i.slice(0, -1));
  const e = Qn(i);
  return (M.isMac || M.isiOS) && e == N.ctrl ? N.cmd : e;
}
function xC(i, e) {
  const t = ll(i, e);
  return t === "down" || t === "right";
}
function IC() {
  const i = {
    pageup: 33,
    pagedown: 34,
    arrowleft: 37,
    arrowup: 38,
    arrowright: 39,
    arrowdown: 40,
    backspace: 8,
    delete: 46,
    enter: 13,
    space: 32,
    esc: 27,
    tab: 9,
    // The idea about these numbers is that they do not collide with any real key codes, so we can use them
    // like bit masks.
    ctrl: 1114112,
    shift: 2228224,
    alt: 4456448,
    cmd: 8912896
  };
  for (let e = 65; e <= 90; e++) {
    const t = String.fromCharCode(e);
    i[t.toLowerCase()] = e;
  }
  for (let e = 48; e <= 57; e++)
    i[e - 48] = e;
  for (let e = 112; e <= 123; e++)
    i["f" + (e - 111)] = e;
  return Object.assign(i, {
    "'": 222,
    ",": 108,
    "-": 109,
    ".": 110,
    "/": 111,
    ";": 186,
    "=": 187,
    "[": 219,
    "\\": 220,
    "]": 221,
    "`": 223
  }), i;
}
function SC(i) {
  return i.split("+").map((e) => e.trim());
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const PC = [
  "ar",
  "ara",
  "dv",
  "div",
  "fa",
  "per",
  "fas",
  "he",
  "heb",
  "ku",
  "kur",
  "ug",
  "uig"
  // Uighur, Uyghur
];
function qc(i) {
  return PC.includes(i) ? "rtl" : "ltr";
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Z(i) {
  return Array.isArray(i) ? i : [i];
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
/* istanbul ignore else -- @preserve */
E.window.CKEDITOR_TRANSLATIONS || (E.window.CKEDITOR_TRANSLATIONS = {});
function RC(i, e, t = 1, n) {
  if (typeof t != "number")
    throw new g("translation-service-quantity-not-a-number", null, { quantity: t });
  const s = n || E.window.CKEDITOR_TRANSLATIONS, o = BC(s);
  o === 1 && (i = Object.keys(s)[0]);
  const r = e.id || e.string;
  if (o === 0 || !MC(i, r, s))
    return t !== 1 ? e.plural : e.string;
  const a = s[i].dictionary, l = s[i].getPluralForm || ((d) => d === 1 ? 0 : 1), c = a[r];
  if (typeof c == "string")
    return c;
  const u = Number(l(t));
  return c[u];
}
function VC(i) {
  return Array.isArray(i) ? i.reduce((e, t) => rl(e, t)) : i;
}
function MC(i, e, t) {
  return !!t[i] && !!t[i].dictionary[e];
}
function BC(i) {
  return Object.keys(i).length;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class LC {
  /**
   * Creates a new instance of the locale class. Learn more about
   * {@glink features/ui-language configuring the language of the editor}.
   *
   * @param options Locale configuration.
   * @param options.uiLanguage The editor UI language code in the
   * [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format. See {@link #uiLanguage}.
   * @param options.contentLanguage The editor content language code in the
   * [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format. If not specified, the same as `options.language`.
   * See {@link #contentLanguage}.
   * @param translations Translations passed as a editor config parameter.
   */
  constructor({ uiLanguage: e = "en", contentLanguage: t, translations: n } = {}) {
    this.uiLanguage = e, this.contentLanguage = t || this.uiLanguage, this.uiLanguageDirection = qc(this.uiLanguage), this.contentLanguageDirection = qc(this.contentLanguage), this.translations = VC(n), this.t = (s, o) => this._t(s, o);
  }
  /**
   * The editor UI language code in the [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format.
   *
   * **Note**: This property was deprecated. Please use {@link #uiLanguage} and {@link #contentLanguage}
   * properties instead.
   *
   * @deprecated
   */
  get language() {
    return console.warn("locale-deprecated-language-property: The Locale#language property has been deprecated and will be removed in the near future. Please use #uiLanguage and #contentLanguage properties instead."), this.uiLanguage;
  }
  /**
   * An unbound version of the {@link #t} method.
   */
  _t(e, t = []) {
    t = Z(t), typeof e == "string" && (e = { string: e });
    const s = !!e.plural ? t[0] : 1, o = RC(this.uiLanguage, e, s, this.translations);
    return OC(o, t);
  }
}
function OC(i, e) {
  return i.replace(/%(\d+)/g, (t, n) => n < e.length ? e[n] : t);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ke extends G() {
  constructor(e = {}, t = {}) {
    super();
    const n = Ue(e);
    if (n || (t = e), this._items = [], this._itemMap = /* @__PURE__ */ new Map(), this._idProperty = t.idProperty || "id", this._bindToExternalToInternalMap = /* @__PURE__ */ new WeakMap(), this._bindToInternalToExternalMap = /* @__PURE__ */ new WeakMap(), this._skippedIndexesFromExternal = [], n)
      for (const s of e)
        this._items.push(s), this._itemMap.set(this._getItemIdBeforeAdding(s), s);
  }
  /**
   * The number of items available in the collection.
   */
  get length() {
    return this._items.length;
  }
  /**
   * Returns the first item from the collection or null when collection is empty.
   */
  get first() {
    return this._items[0] || null;
  }
  /**
   * Returns the last item from the collection or null when collection is empty.
   */
  get last() {
    return this._items[this.length - 1] || null;
  }
  /**
   * Adds an item into the collection.
   *
   * If the item does not have an id, then it will be automatically generated and set on the item.
   *
   * @param item
   * @param index The position of the item in the collection. The item
   * is pushed to the collection when `index` not specified.
   * @fires add
   * @fires change
   */
  add(e, t) {
    return this.addMany([e], t);
  }
  /**
   * Adds multiple items into the collection.
   *
   * Any item not containing an id will get an automatically generated one.
   *
   * @param items
   * @param index The position of the insertion. Items will be appended if no `index` is specified.
   * @fires add
   * @fires change
   */
  addMany(e, t) {
    if (t === void 0)
      t = this._items.length;
    else if (t > this._items.length || t < 0)
      throw new g("collection-add-item-invalid-index", this);
    let n = 0;
    for (const s of e) {
      const o = this._getItemIdBeforeAdding(s), r = t + n;
      this._items.splice(r, 0, s), this._itemMap.set(o, s), this.fire("add", s, r), n++;
    }
    return this.fire("change", {
      added: e,
      removed: [],
      index: t
    }), this;
  }
  /**
   * Gets an item by its ID or index.
   *
   * @param idOrIndex The item ID or index in the collection.
   * @returns The requested item or `null` if such item does not exist.
   */
  get(e) {
    let t;
    if (typeof e == "string")
      t = this._itemMap.get(e);
    else if (typeof e == "number")
      t = this._items[e];
    else
      throw new g("collection-get-invalid-arg", this);
    return t || null;
  }
  /**
   * Returns a Boolean indicating whether the collection contains an item.
   *
   * @param itemOrId The item or its ID in the collection.
   * @returns `true` if the collection contains the item, `false` otherwise.
   */
  has(e) {
    if (typeof e == "string")
      return this._itemMap.has(e);
    {
      const t = this._idProperty, n = e[t];
      return n && this._itemMap.has(n);
    }
  }
  /**
   * Gets an index of an item in the collection.
   * When an item is not defined in the collection, the index will equal -1.
   *
   * @param itemOrId The item or its ID in the collection.
   * @returns The index of a given item.
   */
  getIndex(e) {
    let t;
    return typeof e == "string" ? t = this._itemMap.get(e) : t = e, t ? this._items.indexOf(t) : -1;
  }
  /**
   * Removes an item from the collection.
   *
   * @param subject The item to remove, its ID or index in the collection.
   * @returns The removed item.
   * @fires remove
   * @fires change
   */
  remove(e) {
    const [t, n] = this._remove(e);
    return this.fire("change", {
      added: [],
      removed: [t],
      index: n
    }), t;
  }
  /**
   * Executes the callback for each item in the collection and composes an array or values returned by this callback.
   *
   * @typeParam U The result type of the callback.
   * @param callback
   * @param ctx Context in which the `callback` will be called.
   * @returns The result of mapping.
   */
  map(e, t) {
    return this._items.map(e, t);
  }
  /**
   * Performs the specified action for each item in the collection.
   *
   * @param ctx Context in which the `callback` will be called.
   */
  forEach(e, t) {
    this._items.forEach(e, t);
  }
  /**
   * Finds the first item in the collection for which the `callback` returns a true value.
   *
   * @param callback
   * @param ctx Context in which the `callback` will be called.
   * @returns The item for which `callback` returned a true value.
   */
  find(e, t) {
    return this._items.find(e, t);
  }
  /**
   * Returns an array with items for which the `callback` returned a true value.
   *
   * @param callback
   * @param ctx Context in which the `callback` will be called.
   * @returns The array with matching items.
   */
  filter(e, t) {
    return this._items.filter(e, t);
  }
  /**
   * Removes all items from the collection and destroys the binding created using
   * {@link #bindTo}.
   *
   * @fires remove
   * @fires change
   */
  clear() {
    this._bindToCollection && (this.stopListening(this._bindToCollection), this._bindToCollection = null);
    const e = Array.from(this._items);
    for (; this.length; )
      this._remove(0);
    this.fire("change", {
      added: [],
      removed: e,
      index: 0
    });
  }
  /**
   * Binds and synchronizes the collection with another one.
   *
   * The binding can be a simple factory:
   *
   * ```ts
   * class FactoryClass {
   * 	public label: string;
   *
   * 	constructor( data: { label: string } ) {
   * 		this.label = data.label;
   * 	}
   * }
   *
   * const source = new Collection<{ label: string }>( { idProperty: 'label' } );
   * const target = new Collection<FactoryClass>();
   *
   * target.bindTo( source ).as( FactoryClass );
   *
   * source.add( { label: 'foo' } );
   * source.add( { label: 'bar' } );
   *
   * console.log( target.length ); // 2
   * console.log( target.get( 1 ).label ); // 'bar'
   *
   * source.remove( 0 );
   * console.log( target.length ); // 1
   * console.log( target.get( 0 ).label ); // 'bar'
   * ```
   *
   * or the factory driven by a custom callback:
   *
   * ```ts
   * class FooClass {
   * 	public label: string;
   *
   * 	constructor( data: { label: string } ) {
   * 		this.label = data.label;
   * 	}
   * }
   *
   * class BarClass {
   * 	public label: string;
   *
   * 	constructor( data: { label: string } ) {
   * 		this.label = data.label;
   * 	}
   * }
   *
   * const source = new Collection<{ label: string }>( { idProperty: 'label' } );
   * const target = new Collection<FooClass | BarClass>();
   *
   * target.bindTo( source ).using( ( item ) => {
   * 	if ( item.label == 'foo' ) {
   * 		return new FooClass( item );
   * 	} else {
   * 		return new BarClass( item );
   * 	}
   * } );
   *
   * source.add( { label: 'foo' } );
   * source.add( { label: 'bar' } );
   *
   * console.log( target.length ); // 2
   * console.log( target.get( 0 ) instanceof FooClass ); // true
   * console.log( target.get( 1 ) instanceof BarClass ); // true
   * ```
   *
   * or the factory out of property name:
   *
   * ```ts
   * const source = new Collection<{ nested: { value: string } }>();
   * const target = new Collection<{ value: string }>();
   *
   * target.bindTo( source ).using( 'nested' );
   *
   * source.add( { nested: { value: 'foo' } } );
   * source.add( { nested: { value: 'bar' } } );
   *
   * console.log( target.length ); // 2
   * console.log( target.get( 0 ).value ); // 'foo'
   * console.log( target.get( 1 ).value ); // 'bar'
   * ```
   *
   * It's possible to skip specified items by returning null value:
   *
   * ```ts
   * const source = new Collection<{ hidden: boolean }>();
   * const target = new Collection<{ hidden: boolean }>();
   *
   * target.bindTo( source ).using( item => {
   * 	if ( item.hidden ) {
   * 		return null;
   * 	}
   *
   * 	return item;
   * } );
   *
   * source.add( { hidden: true } );
   * source.add( { hidden: false } );
   *
   * console.log( source.length ); // 2
   * console.log( target.length ); // 1
   * ```
   *
   * **Note**: {@link #clear} can be used to break the binding.
   *
   * @typeParam S The type of `externalCollection` element.
   * @param externalCollection A collection to be bound.
   * @returns The binding chain object.
   */
  bindTo(e) {
    if (this._bindToCollection)
      throw new g("collection-bind-to-rebind", this);
    return this._bindToCollection = e, {
      as: (t) => {
        this._setUpBindToBinding((n) => new t(n));
      },
      using: (t) => {
        typeof t == "function" ? this._setUpBindToBinding(t) : this._setUpBindToBinding((n) => n[t]);
      }
    };
  }
  /**
   * Finalizes and activates a binding initiated by {@link #bindTo}.
   *
   * @param factory A function which produces collection items.
   */
  _setUpBindToBinding(e) {
    const t = this._bindToCollection, n = (s, o, r) => {
      const a = t._bindToCollection == this, l = t._bindToInternalToExternalMap.get(o);
      if (a && l)
        this._bindToExternalToInternalMap.set(o, l), this._bindToInternalToExternalMap.set(l, o);
      else {
        const c = e(o);
        if (!c) {
          this._skippedIndexesFromExternal.push(r);
          return;
        }
        let u = r;
        for (const d of this._skippedIndexesFromExternal)
          r > d && u--;
        for (const d of t._skippedIndexesFromExternal)
          u >= d && u++;
        this._bindToExternalToInternalMap.set(o, c), this._bindToInternalToExternalMap.set(c, o), this.add(c, u);
        for (let d = 0; d < t._skippedIndexesFromExternal.length; d++)
          u <= t._skippedIndexesFromExternal[d] && t._skippedIndexesFromExternal[d]++;
      }
    };
    for (const s of t)
      n(null, s, t.getIndex(s));
    this.listenTo(t, "add", n), this.listenTo(t, "remove", (s, o, r) => {
      const a = this._bindToExternalToInternalMap.get(o);
      a && this.remove(a), this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((l, c) => (r < c && l.push(c - 1), r > c && l.push(c), l), []);
    });
  }
  /**
   * Returns an unique id property for a given `item`.
   *
   * The method will generate new id and assign it to the `item` if it doesn't have any.
   *
   * @param item Item to be added.
   */
  _getItemIdBeforeAdding(e) {
    const t = this._idProperty;
    let n;
    if (t in e) {
      if (n = e[t], typeof n != "string")
        throw new g("collection-add-invalid-id", this);
      if (this.get(n))
        throw new g("collection-add-item-already-exists", this);
    } else
      e[t] = n = je();
    return n;
  }
  /**
   * Core {@link #remove} method implementation shared in other functions.
   *
   * In contrast this method **does not** fire the {@link #event:change} event.
   *
   * @param subject The item to remove, its id or index in the collection.
   * @returns Returns an array with the removed item and its index.
   * @fires remove
   */
  _remove(e) {
    let t, n, s, o = !1;
    const r = this._idProperty;
    if (typeof e == "string" ? (n = e, s = this._itemMap.get(n), o = !s, s && (t = this._items.indexOf(s))) : typeof e == "number" ? (t = e, s = this._items[t], o = !s, s && (n = s[r])) : (s = e, n = s[r], t = this._items.indexOf(s), o = t == -1 || !this._itemMap.get(n)), o)
      throw new g("collection-remove-404", this);
    this._items.splice(t, 1), this._itemMap.delete(n);
    const a = this._bindToInternalToExternalMap.get(s);
    return this._bindToInternalToExternalMap.delete(s), this._bindToExternalToInternalMap.delete(a), this.fire("remove", s, t), [s, t];
  }
  /**
   * Iterable interface.
   */
  [Symbol.iterator]() {
    return this._items[Symbol.iterator]();
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function me(i) {
  const e = i.next();
  return e.done ? null : e.value;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class X extends Le(U()) {
  constructor() {
    super(), this._elements = /* @__PURE__ */ new Set(), this._nextEventLoopTimeout = null, this.set("isFocused", !1), this.set("focusedElement", null);
  }
  /**
   * Starts tracking the specified element.
   */
  add(e) {
    if (this._elements.has(e))
      throw new g("focustracker-add-element-already-exist", this);
    this.listenTo(e, "focus", () => this._focus(e), { useCapture: !0 }), this.listenTo(e, "blur", () => this._blur(), { useCapture: !0 }), this._elements.add(e);
  }
  /**
   * Stops tracking the specified element and stops listening on this element.
   */
  remove(e) {
    e === this.focusedElement && this._blur(), this._elements.has(e) && (this.stopListening(e), this._elements.delete(e));
  }
  /**
   * Destroys the focus tracker by:
   * - Disabling all event listeners attached to tracked elements.
   * - Removing all tracked elements that were previously added.
   */
  destroy() {
    this.stopListening();
  }
  /**
   * Stores currently focused element and set {@link #isFocused} as `true`.
   */
  _focus(e) {
    clearTimeout(this._nextEventLoopTimeout), this.focusedElement = e, this.isFocused = !0;
  }
  /**
   * Clears currently focused element and set {@link #isFocused} as `false`.
   * This method uses `setTimeout` to change order of fires `blur` and `focus` events.
   */
  _blur() {
    clearTimeout(this._nextEventLoopTimeout), this._nextEventLoopTimeout = setTimeout(() => {
      this.focusedElement = null, this.isFocused = !1;
    }, 0);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ie {
  /**
   * Creates an instance of the keystroke handler.
   */
  constructor() {
    this._listener = new (Le())();
  }
  /**
   * Starts listening for `keydown` events from a given emitter.
   */
  listenTo(e) {
    this._listener.listenTo(e, "keydown", (t, n) => {
      this._listener.fire("_keydown:" + Qn(n), n);
    });
  }
  /**
   * Registers a handler for the specified keystroke.
   *
   * @param keystroke Keystroke defined in a format accepted by
   * the {@link module:utils/keyboard~parseKeystroke} function.
   * @param callback A function called with the
   * {@link module:engine/view/observer/keyobserver~KeyEventData key event data} object and
   * a helper function to call both `preventDefault()` and `stopPropagation()` on the underlying event.
   * @param options Additional options.
   * @param options.priority The priority of the keystroke
   * callback. The higher the priority value the sooner the callback will be executed. Keystrokes having the same priority
   * are called in the order they were added.
   */
  set(e, t, n = {}) {
    const s = gs(e), o = n.priority;
    this._listener.listenTo(this._listener, "_keydown:" + s, (r, a) => {
      t(a, () => {
        a.preventDefault(), a.stopPropagation(), r.stop();
      }), r.return = !0;
    }, { priority: o });
  }
  /**
   * Triggers a keystroke handler for a specified key combination, if such a keystroke was {@link #set defined}.
   *
   * @param keyEvtData Key event data.
   * @returns Whether the keystroke was handled.
   */
  press(e) {
    return !!this._listener.fire("_keydown:" + Qn(e), e);
  }
  /**
   * Stops listening to `keydown` events from the given emitter.
   */
  stopListening(e) {
    this._listener.stopListening(e);
  }
  /**
   * Destroys the keystroke handler.
   */
  destroy() {
    this.stopListening();
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function FC(i) {
  const e = /* @__PURE__ */ new Map();
  for (const t in i)
    e.set(t, i[t]);
  return e;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function pt(i) {
  return Ue(i) ? new Map(i) : FC(i);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const NC = 1e4;
function DC(i, e, t, n) {
  if (Math.max(e.length, i.length) > NC)
    return i.slice(0, t).concat(e).concat(i.slice(t + n, i.length));
  {
    const s = Array.from(i);
    return s.splice(t, n, ...e), s;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function cl(i, e) {
  let t;
  function n(...s) {
    n.cancel(), t = setTimeout(() => i(...s), e);
  }
  return n.cancel = () => {
    clearTimeout(t);
  }, n;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function zC(i) {
  function e(d) {
    return d.length >= 40 && d.length <= 255 ? "VALID" : "INVALID";
  }
  if (!i)
    return "INVALID";
  let t = "";
  try {
    t = atob(i);
  } catch (d) {
    return "INVALID";
  }
  const n = t.split("-"), s = n[0], o = n[1];
  if (!o)
    return e(i);
  try {
    atob(o);
  } catch (d) {
    try {
      if (atob(s), !atob(s).length)
        return e(i);
    } catch (h) {
      return e(i);
    }
  }
  if (s.length < 40 || s.length > 255)
    return "INVALID";
  let r = "";
  try {
    atob(s), r = atob(o);
  } catch (d) {
    return "INVALID";
  }
  if (r.length !== 8)
    return "INVALID";
  const a = Number(r.substring(0, 4)), l = Number(r.substring(4, 6)) - 1, c = Number(r.substring(6, 8)), u = new Date(a, l, c);
  return u < rw || isNaN(Number(u)) ? "INVALID" : "VALID";
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function HC(i) {
  return !!i && i.length == 1 && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(i);
}
function UC(i) {
  return !!i && i.length == 1 && /[\ud800-\udbff]/.test(i);
}
function $C(i) {
  return !!i && i.length == 1 && /[\udc00-\udfff]/.test(i);
}
function ul(i, e) {
  return UC(i.charAt(e - 1)) && $C(i.charAt(e));
}
function dl(i, e) {
  return HC(i.charAt(e));
}
const WC = qC();
function mm(i, e) {
  const t = String(i).matchAll(WC);
  return Array.from(t).some((n) => n.index < e && e < n.index + n[0].length);
}
function qC() {
  const i = [
    // Emoji Tag Sequence (ETS)
    /\p{Emoji}[\u{E0020}-\u{E007E}]+\u{E007F}/u,
    // Emoji Keycap Sequence
    /\p{Emoji}\u{FE0F}?\u{20E3}/u,
    // Emoji Presentation Sequence
    /\p{Emoji}\u{FE0F}/u,
    // Single-Character Emoji / Emoji Modifier Sequence
    /(?=\p{General_Category=Other_Symbol})\p{Emoji}\p{Emoji_Modifier}*/u
  ], e = /\p{Regional_Indicator}{2}/u.source, t = "(?:" + i.map((s) => s.source).join("|") + ")", n = `${e}|${t}(?:‍${t})*`;
  return new RegExp(n, "ug");
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class b extends U() {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(), this._disableStack = /* @__PURE__ */ new Set(), this.editor = e, this.set("isEnabled", !0);
  }
  /**
   * Disables the plugin.
   *
   * Plugin may be disabled by multiple features or algorithms (at once). When disabling a plugin, unique id should be passed
   * (e.g. feature name). The same identifier should be used when {@link #clearForceDisabled enabling back} the plugin.
   * The plugin becomes enabled only after all features {@link #clearForceDisabled enabled it back}.
   *
   * Disabling and enabling a plugin:
   *
   * ```ts
   * plugin.isEnabled; // -> true
   * plugin.forceDisabled( 'MyFeature' );
   * plugin.isEnabled; // -> false
   * plugin.clearForceDisabled( 'MyFeature' );
   * plugin.isEnabled; // -> true
   * ```
   *
   * Plugin disabled by multiple features:
   *
   * ```ts
   * plugin.forceDisabled( 'MyFeature' );
   * plugin.forceDisabled( 'OtherFeature' );
   * plugin.clearForceDisabled( 'MyFeature' );
   * plugin.isEnabled; // -> false
   * plugin.clearForceDisabled( 'OtherFeature' );
   * plugin.isEnabled; // -> true
   * ```
   *
   * Multiple disabling with the same identifier is redundant:
   *
   * ```ts
   * plugin.forceDisabled( 'MyFeature' );
   * plugin.forceDisabled( 'MyFeature' );
   * plugin.clearForceDisabled( 'MyFeature' );
   * plugin.isEnabled; // -> true
   * ```
   *
   * **Note:** some plugins or algorithms may have more complex logic when it comes to enabling or disabling certain plugins,
   * so the plugin might be still disabled after {@link #clearForceDisabled} was used.
   *
   * @param id Unique identifier for disabling. Use the same id when {@link #clearForceDisabled enabling back} the plugin.
   */
  forceDisabled(e) {
    this._disableStack.add(e), this._disableStack.size == 1 && (this.on("set:isEnabled", Gc, { priority: "highest" }), this.isEnabled = !1);
  }
  /**
   * Clears forced disable previously set through {@link #forceDisabled}. See {@link #forceDisabled}.
   *
   * @param id Unique identifier, equal to the one passed in {@link #forceDisabled} call.
   */
  clearForceDisabled(e) {
    this._disableStack.delete(e), this._disableStack.size == 0 && (this.off("set:isEnabled", Gc), this.isEnabled = !0);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    this.stopListening();
  }
  /**
   * @inheritDoc
   */
  static get isContextPlugin() {
    return !1;
  }
}
function Gc(i) {
  i.return = !1, i.stop();
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class V extends U() {
  /**
   * Creates a new `Command` instance.
   *
   * @param editor The editor on which this command will be used.
   */
  constructor(e) {
    super(), this.editor = e, this.set("value", void 0), this.set("isEnabled", !1), this._affectsData = !0, this._isEnabledBasedOnSelection = !0, this._disableStack = /* @__PURE__ */ new Set(), this.decorate("execute"), this.listenTo(this.editor.model.document, "change", () => {
      this.refresh();
    }), this.listenTo(e, "change:isReadOnly", () => {
      this.refresh();
    }), this.on("set:isEnabled", (t) => {
      if (!this.affectsData)
        return;
      const n = e.model.document.selection, o = !(n.getFirstPosition().root.rootName == "$graveyard") && e.model.canEditAt(n);
      (e.isReadOnly || this._isEnabledBasedOnSelection && !o) && (t.return = !1, t.stop());
    }, { priority: "highest" }), this.on("execute", (t) => {
      this.isEnabled || t.stop();
    }, { priority: "high" });
  }
  /**
   * A flag indicating whether a command execution changes the editor data or not.
   *
   * Commands with `affectsData` set to `false` will not be automatically disabled in
   * the {@link module:core/editor/editor~Editor#isReadOnly read-only mode} and
   * {@glink features/read-only#related-features other editor modes} with restricted user write permissions.
   *
   * **Note:** You do not have to set it for your every command. It is `true` by default.
   *
   * @default true
   */
  get affectsData() {
    return this._affectsData;
  }
  set affectsData(e) {
    this._affectsData = e;
  }
  /**
   * Refreshes the command. The command should update its {@link #isEnabled} and {@link #value} properties
   * in this method.
   *
   * This method is automatically called when
   * {@link module:engine/model/document~Document#event:change any changes are applied to the document}.
   */
  refresh() {
    this.isEnabled = !0;
  }
  /**
   * Disables the command.
   *
   * Command may be disabled by multiple features or algorithms (at once). When disabling a command, unique id should be passed
   * (e.g. the feature name). The same identifier should be used when {@link #clearForceDisabled enabling back} the command.
   * The command becomes enabled only after all features {@link #clearForceDisabled enabled it back}.
   *
   * Disabling and enabling a command:
   *
   * ```ts
   * command.isEnabled; // -> true
   * command.forceDisabled( 'MyFeature' );
   * command.isEnabled; // -> false
   * command.clearForceDisabled( 'MyFeature' );
   * command.isEnabled; // -> true
   * ```
   *
   * Command disabled by multiple features:
   *
   * ```ts
   * command.forceDisabled( 'MyFeature' );
   * command.forceDisabled( 'OtherFeature' );
   * command.clearForceDisabled( 'MyFeature' );
   * command.isEnabled; // -> false
   * command.clearForceDisabled( 'OtherFeature' );
   * command.isEnabled; // -> true
   * ```
   *
   * Multiple disabling with the same identifier is redundant:
   *
   * ```ts
   * command.forceDisabled( 'MyFeature' );
   * command.forceDisabled( 'MyFeature' );
   * command.clearForceDisabled( 'MyFeature' );
   * command.isEnabled; // -> true
   * ```
   *
   * **Note:** some commands or algorithms may have more complex logic when it comes to enabling or disabling certain commands,
   * so the command might be still disabled after {@link #clearForceDisabled} was used.
   *
   * @param id Unique identifier for disabling. Use the same id when {@link #clearForceDisabled enabling back} the command.
   */
  forceDisabled(e) {
    this._disableStack.add(e), this._disableStack.size == 1 && (this.on("set:isEnabled", jc, { priority: "highest" }), this.isEnabled = !1);
  }
  /**
   * Clears forced disable previously set through {@link #forceDisabled}. See {@link #forceDisabled}.
   *
   * @param id Unique identifier, equal to the one passed in {@link #forceDisabled} call.
   */
  clearForceDisabled(e) {
    this._disableStack.delete(e), this._disableStack.size == 0 && (this.off("set:isEnabled", jc), this.refresh());
  }
  /**
   * Executes the command.
   *
   * A command may accept parameters. They will be passed from {@link module:core/editor/editor~Editor#execute `editor.execute()`}
   * to the command.
   *
   * The `execute()` method will automatically abort when the command is disabled ({@link #isEnabled} is `false`).
   * This behavior is implemented by a high priority listener to the {@link #event:execute} event.
   *
   * In order to see how to disable a command from "outside" see the {@link #isEnabled} documentation.
   *
   * This method may return a value, which would be forwarded all the way down to the
   * {@link module:core/editor/editor~Editor#execute `editor.execute()`}.
   *
   * @fires execute
   */
  execute(...e) {
  }
  // eslint-disable-line @typescript-eslint/no-unused-vars
  /**
   * Destroys the command.
   */
  destroy() {
    this.stopListening();
  }
}
function jc(i) {
  i.return = !1, i.stop();
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Kc extends V {
  constructor() {
    super(...arguments), this._childCommandsDefinitions = [];
  }
  /**
   * @inheritDoc
   */
  refresh() {
  }
  /**
   * Executes the first enabled command which has the highest priority of all registered child commands.
   *
   * @returns The value returned by the {@link module:core/command~Command#execute `command.execute()`}.
   */
  execute(...e) {
    const t = this._getFirstEnabledCommand();
    return !!t && t.execute(e);
  }
  /**
   * Registers a child command.
   *
   * @param options An object with configuration options.
   * @param options.priority Priority of a command to register.
   */
  registerChildCommand(e, t = {}) {
    rf(this._childCommandsDefinitions, { command: e, priority: t.priority || "normal" }), e.on("change:isEnabled", () => this._checkEnabled()), this._checkEnabled();
  }
  /**
   * Checks if any of child commands is enabled.
   */
  _checkEnabled() {
    this.isEnabled = !!this._getFirstEnabledCommand();
  }
  /**
   * Returns a first enabled command with the highest priority or `undefined` if none of them is enabled.
   */
  _getFirstEnabledCommand() {
    const e = this._childCommandsDefinitions.find(({ command: t }) => t.isEnabled);
    return e && e.command;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class gm extends G() {
  /**
   * Creates an instance of the plugin collection class.
   * Allows loading and initializing plugins and their dependencies.
   * Allows providing a list of already loaded plugins. These plugins will not be destroyed along with this collection.
   *
   * @param availablePlugins Plugins (constructors) which the collection will be able to use
   * when {@link module:core/plugincollection~PluginCollection#init} is used with the plugin names (strings, instead of constructors).
   * Usually, the editor will pass its built-in plugins to the collection so they can later be
   * used in `config.plugins` or `config.removePlugins` by names.
   * @param contextPlugins A list of already initialized plugins represented by a `[ PluginConstructor, pluginInstance ]` pair.
   */
  constructor(e, t = [], n = []) {
    super(), this._plugins = /* @__PURE__ */ new Map(), this._context = e, this._availablePlugins = /* @__PURE__ */ new Map();
    for (const s of t)
      s.pluginName && this._availablePlugins.set(s.pluginName, s);
    this._contextPlugins = /* @__PURE__ */ new Map();
    for (const [s, o] of n)
      this._contextPlugins.set(s, o), this._contextPlugins.set(o, s), s.pluginName && this._availablePlugins.set(s.pluginName, s);
  }
  /**
   * Iterable interface.
   *
   * Returns `[ PluginConstructor, pluginInstance ]` pairs.
   */
  *[Symbol.iterator]() {
    for (const e of this._plugins)
      typeof e[0] == "function" && (yield e);
  }
  /**
   * Gets the plugin instance by its constructor or name.
   *
   * ```ts
   * // Check if 'Clipboard' plugin was loaded.
   * if ( editor.plugins.has( 'ClipboardPipeline' ) ) {
   * 	// Get clipboard plugin instance
   * 	const clipboard = editor.plugins.get( 'ClipboardPipeline' );
   *
   * 	this.listenTo( clipboard, 'inputTransformation', ( evt, data ) => {
   * 		// Do something on clipboard input.
   * 	} );
   * }
   * ```
   *
   * **Note**: This method will throw an error if a plugin is not loaded. Use `{@link #has editor.plugins.has()}`
   * to check if a plugin is available.
   *
   * @param key The plugin constructor or {@link module:core/plugin~PluginStaticMembers#pluginName name}.
   */
  get(e) {
    const t = this._plugins.get(e);
    if (!t) {
      let n = e;
      throw typeof e == "function" && (n = e.pluginName || e.name), new g("plugincollection-plugin-not-loaded", this._context, { plugin: n });
    }
    return t;
  }
  /**
   * Checks if a plugin is loaded.
   *
   * ```ts
   * // Check if the 'Clipboard' plugin was loaded.
   * if ( editor.plugins.has( 'ClipboardPipeline' ) ) {
   * 	// Now use the clipboard plugin instance:
   * 	const clipboard = editor.plugins.get( 'ClipboardPipeline' );
   *
   * 	// ...
   * }
   * ```
   *
   * @param key The plugin constructor or {@link module:core/plugin~PluginStaticMembers#pluginName name}.
   */
  has(e) {
    return this._plugins.has(e);
  }
  /**
   * Initializes a set of plugins and adds them to the collection.
   *
   * @param plugins An array of {@link module:core/plugin~PluginInterface plugin constructors}
   * or {@link module:core/plugin~PluginStaticMembers#pluginName plugin names}.
   * @param pluginsToRemove Names of the plugins or plugin constructors
   * that should not be loaded (despite being specified in the `plugins` array).
   * @param pluginsSubstitutions An array of {@link module:core/plugin~PluginInterface plugin constructors}
   * that will be used to replace plugins of the same names that were passed in `plugins` or that are in their dependency tree.
   * A useful option for replacing built-in plugins while creating tests (for mocking their APIs). Plugins that will be replaced
   * must follow these rules:
   *   * The new plugin must be a class.
   *   * The new plugin must be named.
   *   * Both plugins must not depend on other plugins.
   * @returns A promise which gets resolved once all plugins are loaded and available in the collection.
   */
  init(e, t = [], n = []) {
    const s = this, o = this._context;
    f(e), p(e);
    const r = e.filter((x) => !d(x, t)), a = [...m(r)];
    q(a, n);
    const l = L(a);
    return F(l, "init").then(() => F(l, "afterInit")).then(() => l);
    function c(x) {
      return typeof x == "function";
    }
    function u(x) {
      return c(x) && !!x.isContextPlugin;
    }
    function d(x, R) {
      return R.some((S) => S === x || h(x) === S || h(S) === x);
    }
    function h(x) {
      return c(x) ? x.pluginName || x.name : x;
    }
    function f(x, R = /* @__PURE__ */ new Set()) {
      x.forEach((S) => {
        c(S) && (R.has(S) || (R.add(S), S.pluginName && !s._availablePlugins.has(S.pluginName) && s._availablePlugins.set(S.pluginName, S), S.requires && f(S.requires, R)));
      });
    }
    function m(x, R = /* @__PURE__ */ new Set()) {
      return x.map((S) => c(S) ? S : s._availablePlugins.get(S)).reduce((S, ee) => R.has(ee) ? S : (R.add(ee), ee.requires && (p(ee.requires, ee), m(ee.requires, R).forEach((Zt) => S.add(Zt))), S.add(ee)), /* @__PURE__ */ new Set());
    }
    function p(x, R = null) {
      x.map((S) => c(S) ? S : s._availablePlugins.get(S) || S).forEach((S) => {
        w(S, R), v(S, R), C(S, R);
      });
    }
    function w(x, R) {
      if (!c(x))
        throw R ? new g("plugincollection-soft-required", o, { missingPlugin: x, requiredBy: h(R) }) : new g("plugincollection-plugin-not-found", o, { plugin: x });
    }
    function v(x, R) {
      if (u(R) && !u(x))
        throw new g("plugincollection-context-required", o, { plugin: h(x), requiredBy: h(R) });
    }
    function C(x, R) {
      if (R && d(x, t))
        throw new g("plugincollection-required", o, { plugin: h(x), requiredBy: h(R) });
    }
    function L(x) {
      return x.map((R) => {
        let S = s._contextPlugins.get(R);
        return S = S || new R(o), s._add(R, S), S;
      });
    }
    function F(x, R) {
      return x.reduce((S, ee) => !ee[R] || s._contextPlugins.has(ee) ? S : S.then(ee[R].bind(ee)), Promise.resolve());
    }
    function q(x, R) {
      for (const S of R) {
        if (typeof S != "function")
          throw new g("plugincollection-replace-plugin-invalid-type", null, { pluginItem: S });
        const ee = S.pluginName;
        if (!ee)
          throw new g("plugincollection-replace-plugin-missing-name", null, { pluginItem: S });
        if (S.requires && S.requires.length)
          throw new g("plugincollection-plugin-for-replacing-cannot-have-dependencies", null, { pluginName: ee });
        const Zt = s._availablePlugins.get(ee);
        if (!Zt)
          throw new g("plugincollection-plugin-for-replacing-not-exist", null, { pluginName: ee });
        const Yl = x.indexOf(Zt);
        if (Yl === -1) {
          if (s._contextPlugins.has(Zt))
            return;
          throw new g("plugincollection-plugin-for-replacing-not-loaded", null, { pluginName: ee });
        }
        if (Zt.requires && Zt.requires.length)
          throw new g("plugincollection-replaced-plugin-cannot-have-dependencies", null, { pluginName: ee });
        x.splice(Yl, 1, S), s._availablePlugins.set(ee, S);
      }
    }
  }
  /**
   * Destroys all loaded plugins.
   */
  destroy() {
    const e = [];
    for (const [, t] of this)
      typeof t.destroy == "function" && !this._contextPlugins.has(t) && e.push(t.destroy());
    return Promise.all(e);
  }
  /**
   * Adds the plugin to the collection. Exposed mainly for testing purposes.
   *
   * @param PluginConstructor The plugin constructor.
   * @param plugin The instance of the plugin.
   */
  _add(e, t) {
    this._plugins.set(e, t);
    const n = e.pluginName;
    if (n) {
      if (this._plugins.has(n))
        throw new g("plugincollection-plugin-name-conflict", null, { pluginName: n, plugin1: this._plugins.get(n).constructor, plugin2: e });
      this._plugins.set(n, t);
    }
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class pm {
  /**
   * Creates a context instance with a given configuration.
   *
   * Usually not to be used directly. See the static {@link module:core/context~Context.create `create()`} method.
   *
   * @param config The context configuration.
   */
  constructor(e) {
    this._contextOwner = null;
    const { translations: t, ...n } = e || {};
    this.config = new nm(n, this.constructor.defaultConfig);
    const s = this.constructor.builtinPlugins;
    this.config.define("plugins", s), this.plugins = new gm(this, s);
    const o = this.config.get("language") || {};
    this.locale = new LC({
      uiLanguage: typeof o == "string" ? o : o.ui,
      contentLanguage: this.config.get("language.content"),
      translations: t
    }), this.t = this.locale.t, this.editors = new ke();
  }
  /**
   * Loads and initializes plugins specified in the configuration.
   *
   * @returns A promise which resolves once the initialization is completed, providing an array of loaded plugins.
   */
  initPlugins() {
    const e = this.config.get("plugins") || [], t = this.config.get("substitutePlugins") || [];
    for (const n of e.concat(t)) {
      if (typeof n != "function")
        throw new g("context-initplugins-constructor-only", null, { Plugin: n });
      if (n.isContextPlugin !== !0)
        throw new g("context-initplugins-invalid-plugin", null, { Plugin: n });
    }
    return this.plugins.init(e, [], t);
  }
  /**
   * Destroys the context instance and all editors used with the context,
   * releasing all resources used by the context.
   *
   * @returns A promise that resolves once the context instance is fully destroyed.
   */
  destroy() {
    return Promise.all(Array.from(this.editors, (e) => e.destroy())).then(() => this.plugins.destroy());
  }
  /**
   * Adds a reference to the editor which is used with this context.
   *
   * When the given editor has created the context, the reference to this editor will be stored
   * as a {@link ~Context#_contextOwner}.
   *
   * This method should only be used by the editor.
   *
   * @internal
   * @param isContextOwner Stores the given editor as a context owner.
   */
  _addEditor(e, t) {
    if (this._contextOwner)
      throw new g("context-addeditor-private-context");
    this.editors.add(e), t && (this._contextOwner = e);
  }
  /**
   * Removes a reference to the editor which was used with this context.
   * When the context was created by the given editor, the context will be destroyed.
   *
   * This method should only be used by the editor.
   *
   * @internal
   * @return A promise that resolves once the editor is removed from the context or when the context was destroyed.
   */
  _removeEditor(e) {
    return this.editors.has(e) && this.editors.remove(e), this._contextOwner === e ? this.destroy() : Promise.resolve();
  }
  /**
   * Returns the context configuration which will be copied to the editors created using this context.
   *
   * The configuration returned by this method has the plugins configuration removed &ndash; plugins are shared with all editors
   * through another mechanism.
   *
   * This method should only be used by the editor.
   *
   * @internal
   * @returns Configuration as a plain object.
   */
  _getEditorConfig() {
    const e = {};
    for (const t of this.config.names())
      ["plugins", "removePlugins", "extraPlugins"].includes(t) || (e[t] = this.config.get(t));
    return e;
  }
  /**
   * Creates and initializes a new context instance.
   *
   * ```ts
   * const commonConfig = { ... }; // Configuration for all the plugins and editors.
   * const editorPlugins = [ ... ]; // Regular plugins here.
   *
   * Context
   * 	.create( {
   * 		// Only context plugins here.
   * 		plugins: [ ... ],
   *
   * 		// Configure the language for all the editors (it cannot be overwritten).
   * 		language: { ... },
   *
   * 		// Configuration for context plugins.
   * 		comments: { ... },
   * 		...
   *
   * 		// Default configuration for editor plugins.
   * 		toolbar: { ... },
   * 		image: { ... },
   * 		...
   * 	} )
   * 	.then( context => {
   * 		const promises = [];
   *
   * 		promises.push( ClassicEditor.create(
   * 			document.getElementById( 'editor1' ),
   * 			{
   * 				editorPlugins,
   * 				context
   * 			}
   * 		) );
   *
   * 		promises.push( ClassicEditor.create(
   * 			document.getElementById( 'editor2' ),
   * 			{
   * 				editorPlugins,
   * 				context,
   * 				toolbar: { ... } // You can overwrite the configuration of the context.
   * 			}
   * 		) );
   *
   * 		return Promise.all( promises );
   * 	} );
   * ```
   *
   * @param config The context configuration.
   * @returns A promise resolved once the context is ready. The promise resolves with the created context instance.
   */
  static create(e) {
    return new Promise((t) => {
      const n = new this(e);
      t(n.initPlugins().then(() => n));
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class jo extends U() {
  /**
   * Creates a new plugin instance.
   */
  constructor(e) {
    super(), this.context = e;
  }
  /**
   * @inheritDoc
   */
  destroy() {
    this.stopListening();
  }
  /**
   * @inheritDoc
   */
  static get isContextPlugin() {
    return !0;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const so = /* @__PURE__ */ new WeakMap();
let Zc = !1;
function hl({ view: i, element: e, text: t, isDirectHost: n = !0, keepOnFocus: s = !1 }) {
  const o = i.document;
  so.has(o) || (so.set(o, /* @__PURE__ */ new Map()), o.registerPostFixer((a) => vr(o, a)), o.on("change:isComposing", () => {
    i.change((a) => vr(o, a));
  }, { priority: "high" })), e.is("editableElement") && e.on("change:placeholder", (a, l, c) => {
    r(c);
  }), e.placeholder ? r(e.placeholder) : t && r(t), t && JC();
  function r(a) {
    so.get(o).set(e, {
      text: a,
      isDirectHost: n,
      keepOnFocus: s,
      hostElement: n ? e : null
    }), i.change((l) => vr(o, l));
  }
}
function GC(i, e) {
  return e.hasClass("ck-placeholder") ? !1 : (i.addClass("ck-placeholder", e), !0);
}
function jC(i, e) {
  return e.hasClass("ck-placeholder") ? (i.removeClass("ck-placeholder", e), !0) : !1;
}
function KC(i, e) {
  if (!i.isAttached() || Array.from(i.getChildren()).some((r) => !r.is("uiElement")))
    return !1;
  const n = i.document, o = n.selection.anchor;
  return n.isComposing && o && o.parent === i ? !1 : e || !n.isFocused ? !0 : !!o && o.parent !== i;
}
function vr(i, e) {
  const t = so.get(i), n = [];
  let s = !1;
  for (const [o, r] of t)
    r.isDirectHost && (n.push(o), Jc(e, o, r) && (s = !0));
  for (const [o, r] of t) {
    if (r.isDirectHost)
      continue;
    const a = ZC(o);
    a && (n.includes(a) || (r.hostElement = a, Jc(e, o, r) && (s = !0)));
  }
  return s;
}
function Jc(i, e, t) {
  const { text: n, isDirectHost: s, hostElement: o } = t;
  let r = !1;
  return o.getAttribute("data-placeholder") !== n && (i.setAttribute("data-placeholder", n, o), r = !0), (s || e.childCount == 1) && KC(o, t.keepOnFocus) ? GC(i, o) && (r = !0) : jC(i, o) && (r = !0), r;
}
function ZC(i) {
  if (i.childCount) {
    const e = i.getChild(0);
    if (e.is("element") && !e.is("uiElement") && !e.is("attributeElement"))
      return e;
  }
  return null;
}
function JC() {
  Zc || D("enableplaceholder-deprecated-text-option"), Zc = !0;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let wn = class {
  /* istanbul ignore next -- @preserve */
  is() {
    throw new Error("is() method is abstract");
  }
};
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let _n = class extends G(wn) {
  /**
   * Creates a tree view node.
   *
   * @param document The document instance to which this node belongs.
   */
  constructor(e) {
    super(), this.document = e, this.parent = null;
  }
  /**
   * Index of the node in the parent element or null if the node has no parent.
   *
   * Accessing this property throws an error if this node's parent element does not contain it.
   * This means that view tree got broken.
   */
  get index() {
    let e;
    if (!this.parent)
      return null;
    if ((e = this.parent.getChildIndex(this)) == -1)
      throw new g("view-node-not-found-in-parent", this);
    return e;
  }
  /**
   * Node's next sibling, or `null` if it is the last child.
   */
  get nextSibling() {
    const e = this.index;
    return e !== null && this.parent.getChild(e + 1) || null;
  }
  /**
   * Node's previous sibling, or `null` if it is the first child.
   */
  get previousSibling() {
    const e = this.index;
    return e !== null && this.parent.getChild(e - 1) || null;
  }
  /**
   * Top-most ancestor of the node. If the node has no parent it is the root itself.
   */
  get root() {
    let e = this;
    for (; e.parent; )
      e = e.parent;
    return e;
  }
  /**
   * Returns true if the node is in a tree rooted in the document (is a descendant of one of its roots).
   */
  isAttached() {
    return this.root.is("rootElement");
  }
  /**
   * Gets a path to the node. The path is an array containing indices of consecutive ancestors of this node,
   * beginning from {@link module:engine/view/node~Node#root root}, down to this node's index.
   *
   * ```ts
   * const abc = downcastWriter.createText( 'abc' );
   * const foo = downcastWriter.createText( 'foo' );
   * const h1 = downcastWriter.createElement( 'h1', null, downcastWriter.createText( 'header' ) );
   * const p = downcastWriter.createElement( 'p', null, [ abc, foo ] );
   * const div = downcastWriter.createElement( 'div', null, [ h1, p ] );
   * foo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.
   * h1.getPath(); // Returns [ 0 ].
   * div.getPath(); // Returns [].
   * ```
   *
   * @returns The path.
   */
  getPath() {
    const e = [];
    let t = this;
    for (; t.parent; )
      e.unshift(t.index), t = t.parent;
    return e;
  }
  /**
   * Returns ancestors array of this node.
   *
   * @param options Options object.
   * @param options.includeSelf When set to `true` this node will be also included in parent's array.
   * @param options.parentFirst When set to `true`, array will be sorted from node's parent to root element,
   * otherwise root element will be the first item in the array.
   * @returns Array with ancestors.
   */
  getAncestors(e = {}) {
    const t = [];
    let n = e.includeSelf ? this : this.parent;
    for (; n; )
      t[e.parentFirst ? "push" : "unshift"](n), n = n.parent;
    return t;
  }
  /**
   * Returns a {@link module:engine/view/element~Element} or {@link module:engine/view/documentfragment~DocumentFragment}
   * which is a common ancestor of both nodes.
   *
   * @param node The second node.
   * @param options Options object.
   * @param options.includeSelf When set to `true` both nodes will be considered "ancestors" too.
   * Which means that if e.g. node A is inside B, then their common ancestor will be B.
   */
  getCommonAncestor(e, t = {}) {
    const n = this.getAncestors(t), s = e.getAncestors(t);
    let o = 0;
    for (; n[o] == s[o] && n[o]; )
      o++;
    return o === 0 ? null : n[o - 1];
  }
  /**
   * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,
   * in different {@link module:engine/view/documentfragment~DocumentFragment}s).
   *
   * @param node Node to compare with.
   */
  isBefore(e) {
    if (this == e || this.root !== e.root)
      return !1;
    const t = this.getPath(), n = e.getPath(), s = Ee(t, n);
    switch (s) {
      case "prefix":
        return !0;
      case "extension":
        return !1;
      default:
        return t[s] < n[s];
    }
  }
  /**
   * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,
   * in different {@link module:engine/view/documentfragment~DocumentFragment}s).
   *
   * @param node Node to compare with.
   */
  isAfter(e) {
    return this == e || this.root !== e.root ? !1 : !this.isBefore(e);
  }
  /**
   * Removes node from parent.
   *
   * @internal
   */
  _remove() {
    this.parent._removeChildren(this.index);
  }
  /**
   * @internal
   * @param type Type of the change.
   * @param node Changed node.
   * @fires change
   */
  _fireChange(e, t) {
    this.fire(`change:${e}`, t), this.parent && this.parent._fireChange(e, t);
  }
  /**
   * Custom toJSON method to solve child-parent circular dependencies.
   *
   * @returns Clone of this object with the parent property removed.
   */
  toJSON() {
    const e = Wf(this);
    return delete e.parent, e;
  }
};
_n.prototype.is = function(i) {
  return i === "node" || i === "view:node";
};
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let ne = class aa extends _n {
  /**
   * Creates a tree view text node.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createText
   * @internal
   * @param document The document instance to which this text node belongs.
   * @param data The text's data.
   */
  constructor(e, t) {
    super(e), this._textData = t;
  }
  /**
   * The text content.
   */
  get data() {
    return this._textData;
  }
  /**
   * The `_data` property is controlled by a getter and a setter.
   *
   * The getter is required when using the addition assignment operator on protected property:
   *
   * ```ts
   * const foo = downcastWriter.createText( 'foo' );
   * const bar = downcastWriter.createText( 'bar' );
   *
   * foo._data += bar.data;   // executes: `foo._data = foo._data + bar.data`
   * console.log( foo.data ); // prints: 'foobar'
   * ```
   *
   * If the protected getter didn't exist, `foo._data` will return `undefined` and result of the merge will be invalid.
   *
   * The setter sets data and fires the {@link module:engine/view/node~Node#event:change:text change event}.
   *
   * @internal
   */
  get _data() {
    return this.data;
  }
  set _data(e) {
    this._fireChange("text", this), this._textData = e;
  }
  /**
   * Checks if this text node is similar to other text node.
   * Both nodes should have the same data to be considered as similar.
   *
   * @param otherNode Node to check if it is same as this node.
   */
  isSimilar(e) {
    return e instanceof aa ? this === e || this.data === e.data : !1;
  }
  /**
   * Clones this node.
   *
   * @internal
   * @returns Text node that is a clone of this node.
   */
  _clone() {
    return new aa(this.document, this.data);
  }
};
ne.prototype.is = function(i) {
  return i === "$text" || i === "view:$text" || // This are legacy values kept for backward compatibility.
  i === "text" || i === "view:text" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "node" || i === "view:node";
};
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let ht = class extends wn {
  /**
   * Creates a text proxy.
   *
   * @internal
   * @param textNode Text node which part is represented by this text proxy.
   * @param offsetInText Offset in {@link module:engine/view/textproxy~TextProxy#textNode text node}
   * from which the text proxy starts.
   * @param length Text proxy length, that is how many text node's characters, starting from `offsetInText` it represents.
   * @constructor
   */
  constructor(e, t, n) {
    if (super(), this.textNode = e, t < 0 || t > e.data.length)
      throw new g("view-textproxy-wrong-offsetintext", this);
    if (n < 0 || t + n > e.data.length)
      throw new g("view-textproxy-wrong-length", this);
    this.data = e.data.substring(t, t + n), this.offsetInText = t;
  }
  /**
   * Offset size of this node.
   */
  get offsetSize() {
    return this.data.length;
  }
  /**
   * Flag indicating whether `TextProxy` instance covers only part of the original {@link module:engine/view/text~Text text node}
   * (`true`) or the whole text node (`false`).
   *
   * This is `false` when text proxy starts at the very beginning of {@link module:engine/view/textproxy~TextProxy#textNode textNode}
   * ({@link module:engine/view/textproxy~TextProxy#offsetInText offsetInText} equals `0`) and text proxy sizes is equal to
   * text node size.
   */
  get isPartial() {
    return this.data.length !== this.textNode.data.length;
  }
  /**
   * Parent of this text proxy, which is same as parent of text node represented by this text proxy.
   */
  get parent() {
    return this.textNode.parent;
  }
  /**
   * Root of this text proxy, which is same as root of text node represented by this text proxy.
   */
  get root() {
    return this.textNode.root;
  }
  /**
   * {@link module:engine/view/document~Document View document} that owns this text proxy, or `null` if the text proxy is inside
   * {@link module:engine/view/documentfragment~DocumentFragment document fragment}.
   */
  get document() {
    return this.textNode.document;
  }
  /**
   * Returns ancestors array of this text proxy.
   *
   * @param options Options object.
   * @param options.includeSelf When set to `true`, textNode will be also included in parent's array.
   * @param options.parentFirst When set to `true`, array will be sorted from text proxy parent to
   * root element, otherwise root element will be the first item in the array.
   * @returns Array with ancestors.
   */
  getAncestors(e = {}) {
    const t = [];
    let n = e.includeSelf ? this.textNode : this.parent;
    for (; n !== null; )
      t[e.parentFirst ? "push" : "unshift"](n), n = n.parent;
    return t;
  }
};
ht.prototype.is = function(i) {
  return i === "$textProxy" || i === "view:$textProxy" || // This are legacy values kept for backward compatibility.
  i === "textProxy" || i === "view:textProxy";
};
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ot {
  /**
   * Creates new instance of Matcher.
   *
   * @param pattern Match patterns. See {@link module:engine/view/matcher~Matcher#add add method} for more information.
   */
  constructor(...e) {
    this._patterns = [], this.add(...e);
  }
  /**
   * Adds pattern or patterns to matcher instance.
   *
   * ```ts
   * // String.
   * matcher.add( 'div' );
   *
   * // Regular expression.
   * matcher.add( /^\w/ );
   *
   * // Single class.
   * matcher.add( {
   * 	classes: 'foobar'
   * } );
   * ```
   *
   * See {@link module:engine/view/matcher~MatcherPattern} for more examples.
   *
   * Multiple patterns can be added in one call:
   *
   * ```ts
   * matcher.add( 'div', { classes: 'foobar' } );
   * ```
   *
   * @param pattern Object describing pattern details. If string or regular expression
   * is provided it will be used to match element's name. Pattern can be also provided in a form
   * of a function - then this function will be called with each {@link module:engine/view/element~Element element} as a parameter.
   * Function's return value will be stored under `match` key of the object returned from
   * {@link module:engine/view/matcher~Matcher#match match} or {@link module:engine/view/matcher~Matcher#matchAll matchAll} methods.
   */
  add(...e) {
    for (let t of e)
      (typeof t == "string" || t instanceof RegExp) && (t = { name: t }), this._patterns.push(t);
  }
  /**
   * Matches elements for currently stored patterns. Returns match information about first found
   * {@link module:engine/view/element~Element element}, otherwise returns `null`.
   *
   * Example of returned object:
   *
   * ```ts
   * {
   * 	element: <instance of found element>,
   * 	pattern: <pattern used to match found element>,
   * 	match: {
   * 		name: true,
   * 		attributes: [ 'title', 'href' ],
   * 		classes: [ 'foo' ],
   * 		styles: [ 'color', 'position' ]
   * 	}
   * }
   * ```
   *
   * @see module:engine/view/matcher~Matcher#add
   * @see module:engine/view/matcher~Matcher#matchAll
   * @param element View element to match against stored patterns.
   */
  match(...e) {
    for (const t of e)
      for (const n of this._patterns) {
        const s = Xc(t, n);
        if (s)
          return {
            element: t,
            pattern: n,
            match: s
          };
      }
    return null;
  }
  /**
   * Matches elements for currently stored patterns. Returns array of match information with all found
   * {@link module:engine/view/element~Element elements}. If no element is found - returns `null`.
   *
   * @see module:engine/view/matcher~Matcher#add
   * @see module:engine/view/matcher~Matcher#match
   * @param element View element to match against stored patterns.
   * @returns Array with match information about found elements or `null`. For more information
   * see {@link module:engine/view/matcher~Matcher#match match method} description.
   */
  matchAll(...e) {
    const t = [];
    for (const n of e)
      for (const s of this._patterns) {
        const o = Xc(n, s);
        o && t.push({
          element: n,
          pattern: s,
          match: o
        });
      }
    return t.length > 0 ? t : null;
  }
  /**
   * Returns the name of the element to match if there is exactly one pattern added to the matcher instance
   * and it matches element name defined by `string` (not `RegExp`). Otherwise, returns `null`.
   *
   * @returns Element name trying to match.
   */
  getElementName() {
    if (this._patterns.length !== 1)
      return null;
    const e = this._patterns[0], t = e.name;
    return typeof e != "function" && t && !(t instanceof RegExp) ? t : null;
  }
}
function Xc(i, e) {
  if (typeof e == "function")
    return e(i);
  const t = {};
  return e.name && (t.name = XC(e.name, i.name), !t.name) || e.attributes && (t.attributes = tk(e.attributes, i), !t.attributes) || e.classes && (t.classes = nk(e.classes, i), !t.classes) || e.styles && (t.styles = ik(e.styles, i), !t.styles) ? null : t;
}
function XC(i, e) {
  return i instanceof RegExp ? !!e.match(i) : i === e;
}
function fl(i, e, t) {
  const n = QC(i), s = Array.from(e), o = [];
  if (n.forEach(([r, a]) => {
    s.forEach((l) => {
      YC(r, l) && ek(a, l, t) && o.push(l);
    });
  }), !(!n.length || o.length < n.length))
    return o;
}
function QC(i) {
  return Array.isArray(i) ? i.map((e) => Ne(e) ? ((e.key === void 0 || e.value === void 0) && D("matcher-pattern-missing-key-or-value", e), [e.key, e.value]) : [e, !0]) : Ne(i) ? Object.entries(i) : [[i, !0]];
}
function YC(i, e) {
  return i === !0 || i === e || i instanceof RegExp && e.match(i);
}
function ek(i, e, t) {
  if (i === !0)
    return !0;
  const n = t(e);
  return i === n || i instanceof RegExp && !!String(n).match(i);
}
function tk(i, e) {
  const t = new Set(e.getAttributeKeys());
  return Ne(i) ? (i.style !== void 0 && D("matcher-pattern-deprecated-attributes-style-key", i), i.class !== void 0 && D("matcher-pattern-deprecated-attributes-class-key", i)) : (t.delete("style"), t.delete("class")), fl(i, t, (n) => e.getAttribute(n));
}
function nk(i, e) {
  return fl(
    i,
    e.getClassNames(),
    /* istanbul ignore next -- @preserve */
    () => {
    }
  );
}
function ik(i, e) {
  return fl(i, e.getStyleNames(!0), (t) => e.getStyle(t));
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class la {
  /**
   * Creates Styles instance.
   */
  constructor(e) {
    this._styles = {}, this._styleProcessor = e;
  }
  /**
   * Returns true if style map has no styles set.
   */
  get isEmpty() {
    return !Object.entries(this._styles).length;
  }
  /**
   * Number of styles defined.
   */
  get size() {
    return this.isEmpty ? 0 : this.getStyleNames().length;
  }
  /**
   * Set styles map to a new value.
   *
   * ```ts
   * styles.setTo( 'border:1px solid blue;margin-top:1px;' );
   * ```
   */
  setTo(e) {
    this.clear();
    const t = ok(e);
    for (const [n, s] of t)
      this._styleProcessor.toNormalizedForm(n, s, this._styles);
  }
  /**
   * Checks if a given style is set.
   *
   * ```ts
   * styles.setTo( 'margin-left:1px;' );
   *
   * styles.has( 'margin-left' );    // -> true
   * styles.has( 'padding' );        // -> false
   * ```
   *
   * **Note**: This check supports normalized style names.
   *
   * ```ts
   * // Enable 'margin' shorthand processing:
   * editor.data.addStyleProcessorRules( addMarginRules );
   *
   * styles.setTo( 'margin:2px;' );
   *
   * styles.has( 'margin' );         // -> true
   * styles.has( 'margin-top' );     // -> true
   * styles.has( 'margin-left' );    // -> true
   *
   * styles.remove( 'margin-top' );
   *
   * styles.has( 'margin' );         // -> false
   * styles.has( 'margin-top' );     // -> false
   * styles.has( 'margin-left' );    // -> true
   * ```
   *
   * @param name Style name.
   */
  has(e) {
    if (this.isEmpty)
      return !1;
    const n = this._styleProcessor.getReducedForm(e, this._styles).find(([s]) => s === e);
    return Array.isArray(n);
  }
  set(e, t) {
    if (J(e))
      for (const [n, s] of Object.entries(e))
        this._styleProcessor.toNormalizedForm(n, s, this._styles);
    else
      this._styleProcessor.toNormalizedForm(e, t, this._styles);
  }
  /**
   * Removes given style.
   *
   * ```ts
   * styles.setTo( 'background:#f00;margin-right:2px;' );
   *
   * styles.remove( 'background' );
   *
   * styles.toString();   // -> 'margin-right:2px;'
   * ```
   *
   * ***Note**:* This method uses {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules
   * enabled style processor rules} to normalize passed values.
   *
   * ```ts
   * // Enable 'margin' shorthand processing:
   * editor.data.addStyleProcessorRules( addMarginRules );
   *
   * styles.setTo( 'margin:1px' );
   *
   * styles.remove( 'margin-top' );
   * styles.remove( 'margin-right' );
   *
   * styles.toString(); // -> 'margin-bottom:1px;margin-left:1px;'
   * ```
   *
   * @param name Style name.
   */
  remove(e) {
    const t = ca(e);
    Yy(this._styles, t), delete this._styles[e], this._cleanEmptyObjectsOnPath(t);
  }
  /**
   * Returns a normalized style object or a single value.
   *
   * ```ts
   * // Enable 'margin' shorthand processing:
   * editor.data.addStyleProcessorRules( addMarginRules );
   *
   * const styles = new Styles();
   * styles.setTo( 'margin:1px 2px 3em;' );
   *
   * styles.getNormalized( 'margin' );
   * // will log:
   * // {
   * //     top: '1px',
   * //     right: '2px',
   * //     bottom: '3em',
   * //     left: '2px'     // normalized value from margin shorthand
   * // }
   *
   * styles.getNormalized( 'margin-left' ); // -> '2px'
   * ```
   *
   * **Note**: This method will only return normalized styles if a style processor was defined.
   *
   * @param name Style name.
   */
  getNormalized(e) {
    return this._styleProcessor.getNormalized(e, this._styles);
  }
  /**
   * Returns a normalized style string. Styles are sorted by name.
   *
   * ```ts
   * styles.set( 'margin' , '1px' );
   * styles.set( 'background', '#f00' );
   *
   * styles.toString(); // -> 'background:#f00;margin:1px;'
   * ```
   *
   * **Note**: This method supports normalized styles if defined.
   *
   * ```ts
   * // Enable 'margin' shorthand processing:
   * editor.data.addStyleProcessorRules( addMarginRules );
   *
   * styles.set( 'margin' , '1px' );
   * styles.set( 'background', '#f00' );
   * styles.remove( 'margin-top' );
   * styles.remove( 'margin-right' );
   *
   * styles.toString(); // -> 'background:#f00;margin-bottom:1px;margin-left:1px;'
   * ```
   */
  toString() {
    return this.isEmpty ? "" : this.getStylesEntries().map((e) => e.join(":")).sort().join(";") + ";";
  }
  /**
   * Returns property as a value string or undefined if property is not set.
   *
   * ```ts
   * // Enable 'margin' shorthand processing:
   * editor.data.addStyleProcessorRules( addMarginRules );
   *
   * const styles = new Styles();
   * styles.setTo( 'margin:1px;' );
   * styles.set( 'margin-bottom', '3em' );
   *
   * styles.getAsString( 'margin' ); // -> 'margin: 1px 1px 3em;'
   * ```
   *
   * Note, however, that all sub-values must be set for the longhand property name to return a value:
   *
   * ```ts
   * const styles = new Styles();
   * styles.setTo( 'margin:1px;' );
   * styles.remove( 'margin-bottom' );
   *
   * styles.getAsString( 'margin' ); // -> undefined
   * ```
   *
   * In the above scenario, it is not possible to return a `margin` value, so `undefined` is returned.
   * Instead, you should use:
   *
   * ```ts
   * const styles = new Styles();
   * styles.setTo( 'margin:1px;' );
   * styles.remove( 'margin-bottom' );
   *
   * for ( const styleName of styles.getStyleNames() ) {
   * 	console.log( styleName, styles.getAsString( styleName ) );
   * }
   * // 'margin-top', '1px'
   * // 'margin-right', '1px'
   * // 'margin-left', '1px'
   * ```
   *
   * In general, it is recommend to iterate over style names like in the example above. This way, you will always get all
   * the currently set style values. So, if all the 4 margin values would be set
   * the for-of loop above would yield only `'margin'`, `'1px'`:
   *
   * ```ts
   * const styles = new Styles();
   * styles.setTo( 'margin:1px;' );
   *
   * for ( const styleName of styles.getStyleNames() ) {
   * 	console.log( styleName, styles.getAsString( styleName ) );
   * }
   * // 'margin', '1px'
   * ```
   *
   * **Note**: To get a normalized version of a longhand property use the {@link #getNormalized `#getNormalized()`} method.
   */
  getAsString(e) {
    if (this.isEmpty)
      return;
    if (this._styles[e] && !J(this._styles[e]))
      return this._styles[e];
    const n = this._styleProcessor.getReducedForm(e, this._styles).find(([s]) => s === e);
    if (Array.isArray(n))
      return n[1];
  }
  /**
   * Returns all style properties names as they would appear when using {@link #toString `#toString()`}.
   *
   * When `expand` is set to true and there's a shorthand style property set, it will also return all equivalent styles:
   *
   * ```ts
   * stylesMap.setTo( 'margin: 1em' )
   * ```
   *
   * will be expanded to:
   *
   * ```ts
   * [ 'margin', 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ]
   * ```
   *
   * @param expand Expand shorthand style properties and all return equivalent style representations.
   */
  getStyleNames(e = !1) {
    return this.isEmpty ? [] : e ? this._styleProcessor.getStyleNames(this._styles) : this.getStylesEntries().map(([n]) => n);
  }
  /**
   * Removes all styles.
   */
  clear() {
    this._styles = {};
  }
  /**
   * Returns normalized styles entries for further processing.
   */
  getStylesEntries() {
    const e = [], t = Object.keys(this._styles);
    for (const n of t)
      e.push(...this._styleProcessor.getReducedForm(n, this._styles));
    return e;
  }
  /**
   * Removes empty objects upon removing an entry from internal object.
   */
  _cleanEmptyObjectsOnPath(e) {
    const t = e.split(".");
    if (!(t.length > 1))
      return;
    const s = t.splice(0, t.length - 1).join("."), o = Zi(this._styles, s);
    if (!o)
      return;
    !Object.keys(o).length && this.remove(s);
  }
}
class sk {
  /**
   * Creates StylesProcessor instance.
   *
   * @internal
   */
  constructor() {
    this._normalizers = /* @__PURE__ */ new Map(), this._extractors = /* @__PURE__ */ new Map(), this._reducers = /* @__PURE__ */ new Map(), this._consumables = /* @__PURE__ */ new Map();
  }
  /**
   * Parse style string value to a normalized object and appends it to styles object.
   *
   * ```ts
   * const styles = {};
   *
   * stylesProcessor.toNormalizedForm( 'margin', '1px', styles );
   *
   * // styles will consist: { margin: { top: '1px', right: '1px', bottom: '1px', left: '1px; } }
   * ```
   *
   * **Note**: To define normalizer callbacks use {@link #setNormalizer}.
   *
   * @param name Name of style property.
   * @param propertyValue Value of style property.
   * @param styles Object holding normalized styles.
   */
  toNormalizedForm(e, t, n) {
    if (J(t)) {
      yr(n, ca(e), t);
      return;
    }
    if (this._normalizers.has(e)) {
      const s = this._normalizers.get(e), { path: o, value: r } = s(t);
      yr(n, o, r);
    } else
      yr(n, e, t);
  }
  /**
   * Returns a normalized version of a style property.
   *
   * ```ts
   * const styles = {
   * 	margin: { top: '1px', right: '1px', bottom: '1px', left: '1px; },
   * 	background: { color: '#f00' }
   * };
   *
   * stylesProcessor.getNormalized( 'background' );
   * // will return: { color: '#f00' }
   *
   * stylesProcessor.getNormalized( 'margin-top' );
   * // will return: '1px'
   * ```
   *
   * **Note**: In some cases extracting single value requires defining an extractor callback {@link #setExtractor}.
   *
   * @param name Name of style property.
   * @param styles Object holding normalized styles.
   */
  getNormalized(e, t) {
    if (!e)
      return rl({}, t);
    if (t[e] !== void 0)
      return t[e];
    if (this._extractors.has(e)) {
      const n = this._extractors.get(e);
      if (typeof n == "string")
        return Zi(t, n);
      const s = n(e, t);
      if (s)
        return s;
    }
    return Zi(t, ca(e));
  }
  /**
   * Returns a reduced form of style property form normalized object.
   *
   * For default margin reducer, the below code:
   *
   * ```ts
   * stylesProcessor.getReducedForm( 'margin', {
   * 	margin: { top: '1px', right: '1px', bottom: '2px', left: '1px; }
   * } );
   * ```
   *
   * will return:
   *
   * ```ts
   * [
   * 	[ 'margin', '1px 1px 2px' ]
   * ]
   * ```
   *
   * because it might be represented as a shorthand 'margin' value. However if one of margin long hand values is missing it should return:
   *
   * ```ts
   * [
   * 	[ 'margin-top', '1px' ],
   * 	[ 'margin-right', '1px' ],
   * 	[ 'margin-bottom', '2px' ]
   * 	// the 'left' value is missing - cannot use 'margin' shorthand.
   * ]
   * ```
   *
   * **Note**: To define reducer callbacks use {@link #setReducer}.
   *
   * @param name Name of style property.
   */
  getReducedForm(e, t) {
    const n = this.getNormalized(e, t);
    return n === void 0 ? [] : this._reducers.has(e) ? this._reducers.get(e)(n) : [[e, n]];
  }
  /**
   * Return all style properties. Also expand shorthand properties (e.g. `margin`, `background`) if respective extractor is available.
   *
   * @param styles Object holding normalized styles.
   */
  getStyleNames(e) {
    const t = Array.from(this._consumables.keys()).filter((s) => {
      const o = this.getNormalized(s, e);
      return o && typeof o == "object" ? Object.keys(o).length : o;
    }), n = /* @__PURE__ */ new Set([
      ...t,
      ...Object.keys(e)
    ]);
    return Array.from(n);
  }
  /**
   * Returns related style names.
   *
   * ```ts
   * stylesProcessor.getRelatedStyles( 'margin' );
   * // will return: [ 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ];
   *
   * stylesProcessor.getRelatedStyles( 'margin-top' );
   * // will return: [ 'margin' ];
   * ```
   *
   * **Note**: To define new style relations load an existing style processor or use
   * {@link module:engine/view/stylesmap~StylesProcessor#setStyleRelation `StylesProcessor.setStyleRelation()`}.
   */
  getRelatedStyles(e) {
    return this._consumables.get(e) || [];
  }
  /**
   * Adds a normalizer method for a style property.
   *
   * A normalizer returns describing how the value should be normalized.
   *
   * For instance 'margin' style is a shorthand for four margin values:
   *
   * - 'margin-top'
   * - 'margin-right'
   * - 'margin-bottom'
   * - 'margin-left'
   *
   * and can be written in various ways if some values are equal to others. For instance `'margin: 1px 2em;'` is a shorthand for
   * `'margin-top: 1px;margin-right: 2em;margin-bottom: 1px;margin-left: 2em'`.
   *
   * A normalizer should parse various margin notations as a single object:
   *
   * ```ts
   * const styles = {
   * 	margin: {
   * 		top: '1px',
   * 		right: '2em',
   * 		bottom: '1px',
   * 		left: '2em'
   * 	}
   * };
   * ```
   *
   * Thus a normalizer for 'margin' style should return an object defining style path and value to store:
   *
   * ```ts
   * const returnValue = {
   * 	path: 'margin',
   * 	value: {
   * 		top: '1px',
   * 		right: '2em',
   * 		bottom: '1px',
   * 		left: '2em'
   * 	}
   * };
   * ```
   *
   * Additionally to fully support all margin notations there should be also defined 4 normalizers for longhand margin notations. Below
   * is an example for 'margin-top' style property normalizer:
   *
   * ```ts
   * stylesProcessor.setNormalizer( 'margin-top', valueString => {
   * 	return {
   * 		path: 'margin.top',
   * 		value: valueString
   * 	}
   * } );
   * ```
   */
  setNormalizer(e, t) {
    this._normalizers.set(e, t);
  }
  /**
   * Adds a extractor callback for a style property.
   *
   * Most normalized style values are stored as one level objects. It is assumed that `'margin-top'` style will be stored as:
   *
   * ```ts
   * const styles = {
   * 	margin: {
   * 		top: 'value'
   * 	}
   * }
   * ```
   *
   * However, some styles can have conflicting notations and thus it might be harder to extract a style value from shorthand. For instance
   * the 'border-top-style' can be defined using `'border-top:solid'`, `'border-style:solid none none none'` or by `'border:solid'`
   * shorthands. The default border styles processors stores styles as:
   *
   * ```ts
   * const styles = {
   * 	border: {
   * 		style: {
   * 			top: 'solid'
   * 		}
   * 	}
   * }
   * ```
   *
   * as it is better to modify border style independently from other values. On the other part the output of the border might be
   * desired as `border-top`, `border-left`, etc notation.
   *
   * In the above example an extractor should return a side border value that combines style, color and width:
   *
   * ```ts
   * styleProcessor.setExtractor( 'border-top', styles => {
   * 	return {
   * 		color: styles.border.color.top,
   * 		style: styles.border.style.top,
   * 		width: styles.border.width.top
   * 	}
   * } );
   * ```
   *
   * @param callbackOrPath Callback that return a requested value or path string for single values.
   */
  setExtractor(e, t) {
    this._extractors.set(e, t);
  }
  /**
   * Adds a reducer callback for a style property.
   *
   * Reducer returns a minimal notation for given style name. For longhand properties it is not required to write a reducer as
   * by default the direct value from style path is taken.
   *
   * For shorthand styles a reducer should return minimal style notation either by returning single name-value tuple or multiple tuples
   * if a shorthand cannot be used. For instance for a margin shorthand a reducer might return:
   *
   * ```ts
   * const marginShortHandTuple = [
   * 	[ 'margin', '1px 1px 2px' ]
   * ];
   * ```
   *
   * or a longhand tuples for defined values:
   *
   * ```ts
   * // Considering margin.bottom and margin.left are undefined.
   * const marginLonghandsTuples = [
   * 	[ 'margin-top', '1px' ],
   * 	[ 'margin-right', '1px' ]
   * ];
   * ```
   *
   * A reducer obtains a normalized style value:
   *
   * ```ts
   * // Simplified reducer that always outputs 4 values which are always present:
   * stylesProcessor.setReducer( 'margin', margin => {
   * 	return [
   * 		[ 'margin', `${ margin.top } ${ margin.right } ${ margin.bottom } ${ margin.left }` ]
   * 	]
   * } );
   * ```
   */
  setReducer(e, t) {
    this._reducers.set(e, t);
  }
  /**
   * Defines a style shorthand relation to other style notations.
   *
   * ```ts
   * stylesProcessor.setStyleRelation( 'margin', [
   * 	'margin-top',
   * 	'margin-right',
   * 	'margin-bottom',
   * 	'margin-left'
   * ] );
   * ```
   *
   * This enables expanding of style names for shorthands. For instance, if defined,
   * {@link module:engine/conversion/viewconsumable~ViewConsumable view consumable} items are automatically created
   * for long-hand margin style notation alongside the `'margin'` item.
   *
   * This means that when an element being converted has a style `margin`, a converter for `margin-left` will work just
   * fine since the view consumable will contain a consumable `margin-left` item (thanks to the relation) and
   * `element.getStyle( 'margin-left' )` will work as well assuming that the style processor was correctly configured.
   * However, once `margin-left` is consumed, `margin` will not be consumable anymore.
   */
  setStyleRelation(e, t) {
    this._mapStyleNames(e, t);
    for (const n of t)
      this._mapStyleNames(n, [e]);
  }
  /**
   * Set two-way binding of style names.
   */
  _mapStyleNames(e, t) {
    this._consumables.has(e) || this._consumables.set(e, []), this._consumables.get(e).push(...t);
  }
}
function ok(i) {
  let e = null, t = 0, n = 0, s = null;
  const o = /* @__PURE__ */ new Map();
  if (i === "")
    return o;
  i.charAt(i.length - 1) != ";" && (i = i + ";");
  for (let r = 0; r < i.length; r++) {
    const a = i.charAt(r);
    if (e === null)
      switch (a) {
        case ":":
          s || (s = i.substr(t, r - t), n = r + 1);
          break;
        case '"':
        case "'":
          e = a;
          break;
        case ";": {
          const l = i.substr(n, r - n);
          s && o.set(s.trim(), l.trim()), s = null, t = r + 1;
          break;
        }
      }
    else a === e && (e = null);
  }
  return o;
}
function ca(i) {
  return i.replace("-", ".");
}
function yr(i, e, t) {
  let n = t;
  J(t) && (n = rl({}, Zi(i, e), t)), Xy(i, e, n);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let rt = class bm extends _n {
  /**
   * Creates a view element.
   *
   * Attributes can be passed in various formats:
   *
   * ```ts
   * new Element( viewDocument, 'div', { class: 'editor', contentEditable: 'true' } ); // object
   * new Element( viewDocument, 'div', [ [ 'class', 'editor' ], [ 'contentEditable', 'true' ] ] ); // map-like iterator
   * new Element( viewDocument, 'div', mapOfAttributes ); // map
   * ```
   *
   * @internal
   * @param document The document instance to which this element belongs.
   * @param name Node name.
   * @param attrs Collection of attributes.
   * @param children A list of nodes to be inserted into created element.
   */
  constructor(e, t, n, s) {
    if (super(e), this._unsafeAttributesToRender = [], this._customProperties = /* @__PURE__ */ new Map(), this.name = t, this._attrs = rk(n), this._children = [], s && this._insertChild(0, s), this._classes = /* @__PURE__ */ new Set(), this._attrs.has("class")) {
      const o = this._attrs.get("class");
      Qc(this._classes, o), this._attrs.delete("class");
    }
    this._styles = new la(this.document.stylesProcessor), this._attrs.has("style") && (this._styles.setTo(this._attrs.get("style")), this._attrs.delete("style"));
  }
  /**
   * Number of element's children.
   */
  get childCount() {
    return this._children.length;
  }
  /**
   * Is `true` if there are no nodes inside this element, `false` otherwise.
   */
  get isEmpty() {
    return this._children.length === 0;
  }
  /**
   * Gets child at the given index.
   *
   * @param index Index of child.
   * @returns Child node.
   */
  getChild(e) {
    return this._children[e];
  }
  /**
   * Gets index of the given child node. Returns `-1` if child node is not found.
   *
   * @param node Child node.
   * @returns Index of the child node.
   */
  getChildIndex(e) {
    return this._children.indexOf(e);
  }
  /**
   * Gets child nodes iterator.
   *
   * @returns Child nodes iterator.
   */
  getChildren() {
    return this._children[Symbol.iterator]();
  }
  /**
   * Returns an iterator that contains the keys for attributes. Order of inserting attributes is not preserved.
   *
   * @returns Keys for attributes.
   */
  *getAttributeKeys() {
    this._classes.size > 0 && (yield "class"), this._styles.isEmpty || (yield "style"), yield* this._attrs.keys();
  }
  /**
   * Returns iterator that iterates over this element's attributes.
   *
   * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
   */
  *getAttributes() {
    yield* this._attrs.entries(), this._classes.size > 0 && (yield ["class", this.getAttribute("class")]), this._styles.isEmpty || (yield ["style", this.getAttribute("style")]);
  }
  /**
   * Gets attribute by key. If attribute is not present - returns undefined.
   *
   * @param key Attribute key.
   * @returns Attribute value.
   */
  getAttribute(e) {
    if (e == "class")
      return this._classes.size > 0 ? [...this._classes].join(" ") : void 0;
    if (e == "style") {
      const t = this._styles.toString();
      return t == "" ? void 0 : t;
    }
    return this._attrs.get(e);
  }
  /**
   * Returns a boolean indicating whether an attribute with the specified key exists in the element.
   *
   * @param key Attribute key.
   * @returns `true` if attribute with the specified key exists in the element, `false` otherwise.
   */
  hasAttribute(e) {
    return e == "class" ? this._classes.size > 0 : e == "style" ? !this._styles.isEmpty : this._attrs.has(e);
  }
  /**
   * Checks if this element is similar to other element.
   * Both elements should have the same name and attributes to be considered as similar. Two similar elements
   * can contain different set of children nodes.
   */
  isSimilar(e) {
    if (!(e instanceof bm))
      return !1;
    if (this === e)
      return !0;
    if (this.name != e.name || this._attrs.size !== e._attrs.size || this._classes.size !== e._classes.size || this._styles.size !== e._styles.size)
      return !1;
    for (const [t, n] of this._attrs)
      if (!e._attrs.has(t) || e._attrs.get(t) !== n)
        return !1;
    for (const t of this._classes)
      if (!e._classes.has(t))
        return !1;
    for (const t of this._styles.getStyleNames())
      if (!e._styles.has(t) || e._styles.getAsString(t) !== this._styles.getAsString(t))
        return !1;
    return !0;
  }
  /**
   * Returns true if class is present.
   * If more then one class is provided - returns true only when all classes are present.
   *
   * ```ts
   * element.hasClass( 'foo' ); // Returns true if 'foo' class is present.
   * element.hasClass( 'foo', 'bar' ); // Returns true if 'foo' and 'bar' classes are both present.
   * ```
   */
  hasClass(...e) {
    for (const t of e)
      if (!this._classes.has(t))
        return !1;
    return !0;
  }
  /**
   * Returns iterator that contains all class names.
   */
  getClassNames() {
    return this._classes.keys();
  }
  /**
   * Returns style value for the given property mae.
   * If the style does not exist `undefined` is returned.
   *
   * **Note**: This method can work with normalized style names if
   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
   * See {@link module:engine/view/stylesmap~StylesMap#getAsString `StylesMap#getAsString()`} for details.
   *
   * For an element with style set to `'margin:1px'`:
   *
   * ```ts
   * // Enable 'margin' shorthand processing:
   * editor.data.addStyleProcessorRules( addMarginRules );
   *
   * const element = view.change( writer => {
   * 	const element = writer.createElement();
   * 	writer.setStyle( 'margin', '1px' );
   * 	writer.setStyle( 'margin-bottom', '3em' );
   *
   * 	return element;
   * } );
   *
   * element.getStyle( 'margin' ); // -> 'margin: 1px 1px 3em;'
   * ```
   */
  getStyle(e) {
    return this._styles.getAsString(e);
  }
  /**
   * Returns a normalized style object or single style value.
   *
   * For an element with style set to: margin:1px 2px 3em;
   *
   * ```ts
   * element.getNormalizedStyle( 'margin' ) );
   * ```
   *
   * will return:
   *
   * ```ts
   * {
   * 	top: '1px',
   * 	right: '2px',
   * 	bottom: '3em',
   * 	left: '2px'    // a normalized value from margin shorthand
   * }
   * ```
   *
   * and reading for single style value:
   *
   * ```ts
   * styles.getNormalizedStyle( 'margin-left' );
   * ```
   *
   * Will return a `2px` string.
   *
   * **Note**: This method will return normalized values only if
   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
   * See {@link module:engine/view/stylesmap~StylesMap#getNormalized `StylesMap#getNormalized()`} for details.
   *
   * @param property Name of CSS property
   */
  getNormalizedStyle(e) {
    return this._styles.getNormalized(e);
  }
  /**
   * Returns iterator that contains all style names.
   *
   * @param expand Expand shorthand style properties and return all equivalent style representations.
   */
  getStyleNames(e) {
    return this._styles.getStyleNames(e);
  }
  /**
   * Returns true if style keys are present.
   * If more then one style property is provided - returns true only when all properties are present.
   *
   * ```ts
   * element.hasStyle( 'color' ); // Returns true if 'border-top' style is present.
   * element.hasStyle( 'color', 'border-top' ); // Returns true if 'color' and 'border-top' styles are both present.
   * ```
   */
  hasStyle(...e) {
    for (const t of e)
      if (!this._styles.has(t))
        return !1;
    return !0;
  }
  /**
   * Returns ancestor element that match specified pattern.
   * Provided patterns should be compatible with {@link module:engine/view/matcher~Matcher Matcher} as it is used internally.
   *
   * @see module:engine/view/matcher~Matcher
   * @param patterns Patterns used to match correct ancestor. See {@link module:engine/view/matcher~Matcher}.
   * @returns Found element or `null` if no matching ancestor was found.
   */
  findAncestor(...e) {
    const t = new ot(...e);
    let n = this.parent;
    for (; n && !n.is("documentFragment"); ) {
      if (t.match(n))
        return n;
      n = n.parent;
    }
    return null;
  }
  /**
   * Returns the custom property value for the given key.
   */
  getCustomProperty(e) {
    return this._customProperties.get(e);
  }
  /**
   * Returns an iterator which iterates over this element's custom properties.
   * Iterator provides `[ key, value ]` pairs for each stored property.
   */
  *getCustomProperties() {
    yield* this._customProperties.entries();
  }
  /**
   * Returns identity string based on element's name, styles, classes and other attributes.
   * Two elements that {@link #isSimilar are similar} will have same identity string.
   * It has the following format:
   *
   * ```ts
   * 'name class="class1,class2" style="style1:value1;style2:value2" attr1="val1" attr2="val2"'
   * ```
   *
   * For example:
   *
   * ```ts
   * const element = writer.createContainerElement( 'foo', {
   * 	banana: '10',
   * 	apple: '20',
   * 	style: 'color: red; border-color: white;',
   * 	class: 'baz'
   * } );
   *
   * // returns 'foo class="baz" style="border-color:white;color:red" apple="20" banana="10"'
   * element.getIdentity();
   * ```
   *
   * **Note**: Classes, styles and other attributes are sorted alphabetically.
   */
  getIdentity() {
    const e = Array.from(this._classes).sort().join(","), t = this._styles.toString(), n = Array.from(this._attrs).map((s) => `${s[0]}="${s[1]}"`).sort().join(" ");
    return this.name + (e == "" ? "" : ` class="${e}"`) + (t ? ` style="${t}"` : "") + (n == "" ? "" : ` ${n}`);
  }
  /**
   * Decides whether an unsafe attribute is whitelisted and should be rendered in the editing pipeline even though filtering mechanisms
   * like {@link module:engine/view/domconverter~DomConverter#shouldRenderAttribute} say it should not.
   *
   * Unsafe attribute names can be specified when creating an element via {@link module:engine/view/downcastwriter~DowncastWriter}.
   *
   * @param attributeName The name of the attribute to be checked.
   */
  shouldRenderUnsafeAttribute(e) {
    return this._unsafeAttributesToRender.includes(e);
  }
  /**
   * Clones provided element.
   *
   * @internal
   * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
   * element will be cloned without any children.
   * @returns Clone of this element.
   */
  _clone(e = !1) {
    const t = [];
    if (e)
      for (const s of this.getChildren())
        t.push(s._clone(e));
    const n = new this.constructor(this.document, this.name, this._attrs, t);
    return n._classes = new Set(this._classes), n._styles.set(this._styles.getNormalized()), n._customProperties = new Map(this._customProperties), n.getFillerOffset = this.getFillerOffset, n._unsafeAttributesToRender = this._unsafeAttributesToRender, n;
  }
  /**
   * {@link module:engine/view/element~Element#_insertChild Insert} a child node or a list of child nodes at the end of this node
   * and sets the parent of these nodes to this element.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#insert
   * @internal
   * @param items Items to be inserted.
   * @fires change
   * @returns Number of appended nodes.
   */
  _appendChild(e) {
    return this._insertChild(this.childCount, e);
  }
  /**
   * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
   * this element.
   *
   * @internal
   * @see module:engine/view/downcastwriter~DowncastWriter#insert
   * @param index Position where nodes should be inserted.
   * @param items Items to be inserted.
   * @fires change
   * @returns Number of inserted nodes.
   */
  _insertChild(e, t) {
    this._fireChange("children", this);
    let n = 0;
    const s = ak(this.document, t);
    for (const o of s)
      o.parent !== null && o._remove(), o.parent = this, o.document = this.document, this._children.splice(e, 0, o), e++, n++;
    return n;
  }
  /**
   * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#remove
   * @internal
   * @param index Number of the first node to remove.
   * @param howMany Number of nodes to remove.
   * @fires change
   * @returns The array of removed nodes.
   */
  _removeChildren(e, t = 1) {
    this._fireChange("children", this);
    for (let n = e; n < e + t; n++)
      this._children[n].parent = null;
    return this._children.splice(e, t);
  }
  /**
   * Adds or overwrite attribute with a specified key and value.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#setAttribute
   * @internal
   * @param key Attribute key.
   * @param value Attribute value.
   * @fires change
   */
  _setAttribute(e, t) {
    const n = String(t);
    this._fireChange("attributes", this), e == "class" ? Qc(this._classes, n) : e == "style" ? this._styles.setTo(n) : this._attrs.set(e, n);
  }
  /**
   * Removes attribute from the element.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#removeAttribute
   * @internal
   * @param key Attribute key.
   * @returns Returns true if an attribute existed and has been removed.
   * @fires change
   */
  _removeAttribute(e) {
    return this._fireChange("attributes", this), e == "class" ? this._classes.size > 0 ? (this._classes.clear(), !0) : !1 : e == "style" ? this._styles.isEmpty ? !1 : (this._styles.clear(), !0) : this._attrs.delete(e);
  }
  /**
   * Adds specified class.
   *
   * ```ts
   * element._addClass( 'foo' ); // Adds 'foo' class.
   * element._addClass( [ 'foo', 'bar' ] ); // Adds 'foo' and 'bar' classes.
   * ```
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#addClass
   * @internal
   * @fires change
   */
  _addClass(e) {
    this._fireChange("attributes", this);
    for (const t of Z(e))
      this._classes.add(t);
  }
  /**
   * Removes specified class.
   *
   * ```ts
   * element._removeClass( 'foo' );  // Removes 'foo' class.
   * element._removeClass( [ 'foo', 'bar' ] ); // Removes both 'foo' and 'bar' classes.
   * ```
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#removeClass
   * @internal
   * @fires change
   */
  _removeClass(e) {
    this._fireChange("attributes", this);
    for (const t of Z(e))
      this._classes.delete(t);
  }
  _setStyle(e, t) {
    this._fireChange("attributes", this), typeof e != "string" ? this._styles.set(e) : this._styles.set(e, t);
  }
  /**
   * Removes specified style.
   *
   * ```ts
   * element._removeStyle( 'color' );  // Removes 'color' style.
   * element._removeStyle( [ 'color', 'border-top' ] ); // Removes both 'color' and 'border-top' styles.
   * ```
   *
   * **Note**: This method can work with normalized style names if
   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
   * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#removeStyle
   * @internal
   * @fires change
   */
  _removeStyle(e) {
    this._fireChange("attributes", this);
    for (const t of Z(e))
      this._styles.remove(t);
  }
  /**
   * Sets a custom property. Unlike attributes, custom properties are not rendered to the DOM,
   * so they can be used to add special data to elements.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#setCustomProperty
   * @internal
   */
  _setCustomProperty(e, t) {
    this._customProperties.set(e, t);
  }
  /**
   * Removes the custom property stored under the given key.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#removeCustomProperty
   * @internal
   * @returns Returns true if property was removed.
   */
  _removeCustomProperty(e) {
    return this._customProperties.delete(e);
  }
};
rt.prototype.is = function(i, e) {
  return e ? e === this.name && (i === "element" || i === "view:element") : i === "element" || i === "view:element" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "node" || i === "view:node";
};
function rk(i) {
  const e = pt(i);
  for (const [t, n] of e)
    n === null ? e.delete(t) : typeof n != "string" && e.set(t, String(n));
  return e;
}
function Qc(i, e) {
  const t = e.split(/\s+/);
  i.clear(), t.forEach((n) => i.add(n));
}
function ak(i, e) {
  return typeof e == "string" ? [new ne(i, e)] : (Ue(e) || (e = [e]), Array.from(e).map((t) => typeof t == "string" ? new ne(i, t) : t instanceof ht ? new ne(i, t.data) : t));
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Ji extends rt {
  /**
   * Creates a container element.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createContainerElement
   * @see module:engine/view/element~Element
   * @internal
   * @param document The document instance to which this element belongs.
   * @param name Node name.
   * @param attrs Collection of attributes.
   * @param children A list of nodes to be inserted into created element.
   */
  constructor(e, t, n, s) {
    super(e, t, n, s), this.getFillerOffset = lk;
  }
}
Ji.prototype.is = function(i, e) {
  return e ? e === this.name && (i === "containerElement" || i === "view:containerElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "element" || i === "view:element") : i === "containerElement" || i === "view:containerElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "element" || i === "view:element" || i === "node" || i === "view:node";
};
function lk() {
  const i = [...this.getChildren()], e = i[this.childCount - 1];
  if (e && e.is("element", "br"))
    return this.childCount;
  for (const t of i)
    if (!t.is("uiElement"))
      return null;
  return this.childCount;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Ko extends U(Ji) {
  /**
   * Creates an editable element.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createEditableElement
   * @internal
   * @param document The document instance to which this element belongs.
   * @param name Node name.
   * @param attrs Collection of attributes.
   * @param children A list of nodes to be inserted into created element.
   */
  constructor(e, t, n, s) {
    super(e, t, n, s), this.set("isReadOnly", !1), this.set("isFocused", !1), this.set("placeholder", void 0), this.bind("isReadOnly").to(e), this.bind("isFocused").to(e, "isFocused", (o) => o && e.selection.editableElement == this), this.listenTo(e.selection, "change", () => {
      this.isFocused = e.isFocused && e.selection.editableElement == this;
    });
  }
  destroy() {
    this.stopListening();
  }
}
Ko.prototype.is = function(i, e) {
  return e ? e === this.name && (i === "editableElement" || i === "view:editableElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "containerElement" || i === "view:containerElement" || i === "element" || i === "view:element") : i === "editableElement" || i === "view:editableElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "containerElement" || i === "view:containerElement" || i === "element" || i === "view:element" || i === "node" || i === "view:node";
};
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Yc = Symbol("rootName");
class wm extends Ko {
  /**
   * Creates root editable element.
   *
   * @param document The document instance to which this element belongs.
   * @param name Node name.
   */
  constructor(e, t) {
    super(e, t), this.rootName = "main";
  }
  /**
   * Name of this root inside {@link module:engine/view/document~Document} that is an owner of this root. If no
   * other name is set, `main` name is used.
   *
   * @readonly
   */
  get rootName() {
    return this.getCustomProperty(Yc);
  }
  set rootName(e) {
    this._setCustomProperty(Yc, e);
  }
  /**
   * Overrides old element name and sets new one.
   * This is needed because view roots are created before they are attached to the DOM.
   * The name of the root element is temporary at this stage. It has to be changed when the
   * view root element is attached to the DOM element.
   *
   * @internal
   * @param name The new name of element.
   */
  set _name(e) {
    this.name = e;
  }
}
wm.prototype.is = function(i, e) {
  return e ? e === this.name && (i === "rootElement" || i === "view:rootElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "editableElement" || i === "view:editableElement" || i === "containerElement" || i === "view:containerElement" || i === "element" || i === "view:element") : i === "rootElement" || i === "view:rootElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "editableElement" || i === "view:editableElement" || i === "containerElement" || i === "view:containerElement" || i === "element" || i === "view:element" || i === "node" || i === "view:node";
};
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let sn = class {
  /**
   * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.
   *
   * @param options Object with configuration.
   */
  constructor(e = {}) {
    if (!e.boundaries && !e.startPosition)
      throw new g("view-tree-walker-no-start-position", null);
    if (e.direction && e.direction != "forward" && e.direction != "backward")
      throw new g("view-tree-walker-unknown-direction", e.startPosition, { direction: e.direction });
    this.boundaries = e.boundaries || null, e.startPosition ? this._position = k._createAt(e.startPosition) : this._position = k._createAt(e.boundaries[e.direction == "backward" ? "end" : "start"]), this.direction = e.direction || "forward", this.singleCharacters = !!e.singleCharacters, this.shallow = !!e.shallow, this.ignoreElementEnd = !!e.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
  }
  /**
   * Iterable interface.
   */
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Iterator position. If start position is not defined then position depends on {@link #direction}. If direction is
   * `'forward'` position starts form the beginning, when direction is `'backward'` position starts from the end.
   */
  get position() {
    return this._position;
  }
  /**
   * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.
   *
   * For example:
   *
   * ```ts
   * walker.skip( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>
   * walker.skip( value => true ); // Move the position to the end: <p>{}foo</p> -> <p>foo</p>[]
   * walker.skip( value => false ); // Do not move the position.
   * ```
   *
   * @param skip Callback function. Gets {@link module:engine/view/treewalker~TreeWalkerValue} and should
   * return `true` if the value should be skipped or `false` if not.
   */
  skip(e) {
    let t, n;
    do
      n = this.position, t = this.next();
    while (!t.done && e(t.value));
    t.done || (this._position = n);
  }
  /**
   * Gets the next tree walker's value.
   *
   * @returns Object implementing iterator interface, returning
   * information about taken step.
   */
  next() {
    return this.direction == "forward" ? this._next() : this._previous();
  }
  /**
   * Makes a step forward in view. Moves the {@link #position} to the next position and returns the encountered value.
   */
  _next() {
    let e = this.position.clone();
    const t = this.position, n = e.parent;
    if (n.parent === null && e.offset === n.childCount)
      return { done: !0, value: void 0 };
    if (n === this._boundaryEndParent && e.offset == this.boundaries.end.offset)
      return { done: !0, value: void 0 };
    let s;
    if (n instanceof ne) {
      if (e.isAtEnd)
        return this._position = k._createAfter(n), this._next();
      s = n.data[e.offset];
    } else
      s = n.getChild(e.offset);
    if (s instanceof rt) {
      if (!this.shallow)
        e = new k(s, 0);
      else {
        if (this.boundaries && this.boundaries.end.isBefore(e))
          return { done: !0, value: void 0 };
        e.offset++;
      }
      return this._position = e, this._formatReturnValue("elementStart", s, t, e, 1);
    }
    if (s instanceof ne) {
      if (this.singleCharacters)
        return e = new k(s, 0), this._position = e, this._next();
      let o = s.data.length, r;
      return s == this._boundaryEndParent ? (o = this.boundaries.end.offset, r = new ht(s, 0, o), e = k._createAfter(r)) : (r = new ht(s, 0, s.data.length), e.offset++), this._position = e, this._formatReturnValue("text", r, t, e, o);
    }
    if (typeof s == "string") {
      let o;
      this.singleCharacters ? o = 1 : o = (n === this._boundaryEndParent ? this.boundaries.end.offset : n.data.length) - e.offset;
      const r = new ht(n, e.offset, o);
      return e.offset += o, this._position = e, this._formatReturnValue("text", r, t, e, o);
    }
    return e = k._createAfter(n), this._position = e, this.ignoreElementEnd ? this._next() : this._formatReturnValue("elementEnd", n, t, e);
  }
  /**
   * Makes a step backward in view. Moves the {@link #position} to the previous position and returns the encountered value.
   */
  _previous() {
    let e = this.position.clone();
    const t = this.position, n = e.parent;
    if (n.parent === null && e.offset === 0)
      return { done: !0, value: void 0 };
    if (n == this._boundaryStartParent && e.offset == this.boundaries.start.offset)
      return { done: !0, value: void 0 };
    let s;
    if (n instanceof ne) {
      if (e.isAtStart)
        return this._position = k._createBefore(n), this._previous();
      s = n.data[e.offset - 1];
    } else
      s = n.getChild(e.offset - 1);
    if (s instanceof rt)
      return this.shallow ? (e.offset--, this._position = e, this._formatReturnValue("elementStart", s, t, e, 1)) : (e = new k(s, s.childCount), this._position = e, this.ignoreElementEnd ? this._previous() : this._formatReturnValue("elementEnd", s, t, e));
    if (s instanceof ne) {
      if (this.singleCharacters)
        return e = new k(s, s.data.length), this._position = e, this._previous();
      let o = s.data.length, r;
      if (s == this._boundaryStartParent) {
        const a = this.boundaries.start.offset;
        r = new ht(s, a, s.data.length - a), o = r.data.length, e = k._createBefore(r);
      } else
        r = new ht(s, 0, s.data.length), e.offset--;
      return this._position = e, this._formatReturnValue("text", r, t, e, o);
    }
    if (typeof s == "string") {
      let o;
      if (this.singleCharacters)
        o = 1;
      else {
        const a = n === this._boundaryStartParent ? this.boundaries.start.offset : 0;
        o = e.offset - a;
      }
      e.offset -= o;
      const r = new ht(n, e.offset, o);
      return this._position = e, this._formatReturnValue("text", r, t, e, o);
    }
    return e = k._createBefore(n), this._position = e, this._formatReturnValue("elementStart", n, t, e, 1);
  }
  /**
   * Format returned data and adjust `previousPosition` and `nextPosition` if reach the bound of the {@link module:engine/view/text~Text}.
   *
   * @param type Type of step.
   * @param item Item between old and new position.
   * @param previousPosition Previous position of iterator.
   * @param nextPosition Next position of iterator.
   * @param length Length of the item.
   */
  _formatReturnValue(e, t, n, s, o) {
    return t instanceof ht && (t.offsetInText + t.data.length == t.textNode.data.length && (this.direction == "forward" && !(this.boundaries && this.boundaries.end.isEqual(this.position)) ? (s = k._createAfter(t.textNode), this._position = s) : n = k._createAfter(t.textNode)), t.offsetInText === 0 && (this.direction == "backward" && !(this.boundaries && this.boundaries.start.isEqual(this.position)) ? (s = k._createBefore(t.textNode), this._position = s) : n = k._createBefore(t.textNode))), {
      done: !1,
      value: {
        type: e,
        item: t,
        previousPosition: n,
        nextPosition: s,
        length: o
      }
    };
  }
};
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let k = class yt extends wn {
  /**
   * Creates a position.
   *
   * @param parent Position parent.
   * @param offset Position offset.
   */
  constructor(e, t) {
    super(), this.parent = e, this.offset = t;
  }
  /**
   * Node directly after the position. Equals `null` when there is no node after position or position is located
   * inside text node.
   */
  get nodeAfter() {
    return this.parent.is("$text") ? null : this.parent.getChild(this.offset) || null;
  }
  /**
   * Node directly before the position. Equals `null` when there is no node before position or position is located
   * inside text node.
   */
  get nodeBefore() {
    return this.parent.is("$text") ? null : this.parent.getChild(this.offset - 1) || null;
  }
  /**
   * Is `true` if position is at the beginning of its {@link module:engine/view/position~Position#parent parent}, `false` otherwise.
   */
  get isAtStart() {
    return this.offset === 0;
  }
  /**
   * Is `true` if position is at the end of its {@link module:engine/view/position~Position#parent parent}, `false` otherwise.
   */
  get isAtEnd() {
    const e = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount;
    return this.offset === e;
  }
  /**
   * Position's root, that is the root of the position's parent element.
   */
  get root() {
    return this.parent.root;
  }
  /**
   * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this position, or `null` if
   * position is not inside an editable element.
   */
  get editableElement() {
    let e = this.parent;
    for (; !(e instanceof Ko); )
      if (e.parent)
        e = e.parent;
      else
        return null;
    return e;
  }
  /**
   * Returns a new instance of Position with offset incremented by `shift` value.
   *
   * @param shift How position offset should get changed. Accepts negative values.
   * @returns Shifted position.
   */
  getShiftedBy(e) {
    const t = yt._createAt(this), n = t.offset + e;
    return t.offset = n < 0 ? 0 : n, t;
  }
  /**
   * Gets the farthest position which matches the callback using
   * {@link module:engine/view/treewalker~TreeWalker TreeWalker}.
   *
   * For example:
   *
   * ```ts
   * getLastMatchingPosition( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>
   * getLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } ); // <p>foo[]</p> -> <p>{}foo</p>
   * getLastMatchingPosition( value => false ); // Do not move the position.
   * ```
   *
   * @param skip Callback function. Gets {@link module:engine/view/treewalker~TreeWalkerValue} and should
   * return `true` if the value should be skipped or `false` if not.
   * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
   * @returns The position after the last item which matches the `skip` callback test.
   */
  getLastMatchingPosition(e, t = {}) {
    t.startPosition = this;
    const n = new sn(t);
    return n.skip(e), n.position;
  }
  /**
   * Returns ancestors array of this position, that is this position's parent and it's ancestors.
   *
   * @returns Array with ancestors.
   */
  getAncestors() {
    return this.parent.is("documentFragment") ? [this.parent] : this.parent.getAncestors({ includeSelf: !0 });
  }
  /**
   * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}
   * which is a common ancestor of both positions.
   */
  getCommonAncestor(e) {
    const t = this.getAncestors(), n = e.getAncestors();
    let s = 0;
    for (; t[s] == n[s] && t[s]; )
      s++;
    return s === 0 ? null : t[s - 1];
  }
  /**
   * Checks whether this position equals given position.
   *
   * @param otherPosition Position to compare with.
   * @returns True if positions are same.
   */
  isEqual(e) {
    return this.parent == e.parent && this.offset == e.offset;
  }
  /**
   * Checks whether this position is located before given position. When method returns `false` it does not mean that
   * this position is after give one. Two positions may be located inside separate roots and in that situation this
   * method will still return `false`.
   *
   * @see module:engine/view/position~Position#isAfter
   * @see module:engine/view/position~Position#compareWith
   * @param otherPosition Position to compare with.
   * @returns Returns `true` if this position is before given position.
   */
  isBefore(e) {
    return this.compareWith(e) == "before";
  }
  /**
   * Checks whether this position is located after given position. When method returns `false` it does not mean that
   * this position is before give one. Two positions may be located inside separate roots and in that situation this
   * method will still return `false`.
   *
   * @see module:engine/view/position~Position#isBefore
   * @see module:engine/view/position~Position#compareWith
   * @param otherPosition Position to compare with.
   * @returns Returns `true` if this position is after given position.
   */
  isAfter(e) {
    return this.compareWith(e) == "after";
  }
  /**
   * Checks whether this position is before, after or in same position that other position. Two positions may be also
   * different when they are located in separate roots.
   *
   * @param otherPosition Position to compare with.
   */
  compareWith(e) {
    if (this.root !== e.root)
      return "different";
    if (this.isEqual(e))
      return "same";
    const t = this.parent.is("node") ? this.parent.getPath() : [], n = e.parent.is("node") ? e.parent.getPath() : [];
    t.push(this.offset), n.push(e.offset);
    const s = Ee(t, n);
    switch (s) {
      case "prefix":
        return "before";
      case "extension":
        return "after";
      default:
        return t[s] < n[s] ? "before" : "after";
    }
  }
  /**
   * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this positions as a start position.
   *
   * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}
   */
  getWalker(e = {}) {
    return e.startPosition = this, new sn(e);
  }
  /**
   * Clones this position.
   */
  clone() {
    return new yt(this.parent, this.offset);
  }
  /**
   * Creates position at the given location. The location can be specified as:
   *
   * * a {@link module:engine/view/position~Position position},
   * * parent element and offset (offset defaults to `0`),
   * * parent element and `'end'` (sets position at the end of that element),
   * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
   *
   * This method is a shortcut to other constructors such as:
   *
   * * {@link module:engine/view/position~Position._createBefore},
   * * {@link module:engine/view/position~Position._createAfter}.
   *
   * @internal
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
   */
  static _createAt(e, t) {
    if (e instanceof yt)
      return new this(e.parent, e.offset);
    {
      const n = e;
      if (t == "end")
        t = n.is("$text") ? n.data.length : n.childCount;
      else {
        if (t == "before")
          return this._createBefore(n);
        if (t == "after")
          return this._createAfter(n);
        if (t !== 0 && !t)
          throw new g("view-createpositionat-offset-required", n);
      }
      return new yt(n, t);
    }
  }
  /**
   * Creates a new position after given view item.
   *
   * @internal
   * @param item View item after which the position should be located.
   */
  static _createAfter(e) {
    if (e.is("$textProxy"))
      return new yt(e.textNode, e.offsetInText + e.data.length);
    if (!e.parent)
      throw new g("view-position-after-root", e, { root: e });
    return new yt(e.parent, e.index + 1);
  }
  /**
   * Creates a new position before given view item.
   *
   * @internal
   * @param item View item before which the position should be located.
   */
  static _createBefore(e) {
    if (e.is("$textProxy"))
      return new yt(e.textNode, e.offsetInText);
    if (!e.parent)
      throw new g("view-position-before-root", e, { root: e });
    return new yt(e.parent, e.index);
  }
};
k.prototype.is = function(i) {
  return i === "position" || i === "view:position";
};
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let O = class Ft extends wn {
  /**
   * Creates a range spanning from `start` position to `end` position.
   *
   * **Note:** Constructor creates it's own {@link module:engine/view/position~Position} instances basing on passed values.
   *
   * @param start Start position.
   * @param end End position. If not set, range will be collapsed at the `start` position.
   */
  constructor(e, t = null) {
    super(), this.start = e.clone(), this.end = t ? t.clone() : e.clone();
  }
  /**
   * Iterable interface.
   *
   * Iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns
   * them together with additional information like length or {@link module:engine/view/position~Position positions},
   * grouped as {@link module:engine/view/treewalker~TreeWalkerValue}.
   *
   * This iterator uses {@link module:engine/view/treewalker~TreeWalker TreeWalker} with `boundaries` set to this range and
   * `ignoreElementEnd` option
   * set to `true`.
   */
  *[Symbol.iterator]() {
    yield* new sn({ boundaries: this, ignoreElementEnd: !0 });
  }
  /**
   * Returns whether the range is collapsed, that is it start and end positions are equal.
   */
  get isCollapsed() {
    return this.start.isEqual(this.end);
  }
  /**
   * Returns whether this range is flat, that is if {@link module:engine/view/range~Range#start start} position and
   * {@link module:engine/view/range~Range#end end} position are in the same {@link module:engine/view/position~Position#parent parent}.
   */
  get isFlat() {
    return this.start.parent === this.end.parent;
  }
  /**
   * Range root element.
   */
  get root() {
    return this.start.root;
  }
  /**
   * Creates a maximal range that has the same content as this range but is expanded in both ways (at the beginning
   * and at the end).
   *
   * For example:
   *
   * ```html
   * <p>Foo</p><p><b>{Bar}</b></p> -> <p>Foo</p>[<p><b>Bar</b>]</p>
   * <p><b>foo</b>{bar}<span></span></p> -> <p><b>foo[</b>bar<span></span>]</p>
   * ```
   *
   * Note that in the sample above:
   *
   * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},
   * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},
   * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.
   *
   * @returns Enlarged range.
   */
  getEnlarged() {
    let e = this.start.getLastMatchingPosition(Ss, { direction: "backward" }), t = this.end.getLastMatchingPosition(Ss);
    return e.parent.is("$text") && e.isAtStart && (e = k._createBefore(e.parent)), t.parent.is("$text") && t.isAtEnd && (t = k._createAfter(t.parent)), new Ft(e, t);
  }
  /**
   * Creates a minimum range that has the same content as this range but is trimmed in both ways (at the beginning
   * and at the end).
   *
   * For example:
   *
   * ```html
   * <p>Foo</p>[<p><b>Bar</b>]</p> -> <p>Foo</p><p><b>{Bar}</b></p>
   * <p><b>foo[</b>bar<span></span>]</p> -> <p><b>foo</b>{bar}<span></span></p>
   * ```
   *
   * Note that in the sample above:
   *
   * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},
   * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},
   * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.
   *
   * @returns Shrunk range.
   */
  getTrimmed() {
    let e = this.start.getLastMatchingPosition(Ss);
    if (e.isAfter(this.end) || e.isEqual(this.end))
      return new Ft(e, e);
    let t = this.end.getLastMatchingPosition(Ss, { direction: "backward" });
    const n = e.nodeAfter, s = t.nodeBefore;
    return n && n.is("$text") && (e = new k(n, 0)), s && s.is("$text") && (t = new k(s, s.data.length)), new Ft(e, t);
  }
  /**
   * Two ranges are equal if their start and end positions are equal.
   *
   * @param otherRange Range to compare with.
   * @returns `true` if ranges are equal, `false` otherwise
   */
  isEqual(e) {
    return this == e || this.start.isEqual(e.start) && this.end.isEqual(e.end);
  }
  /**
   * Checks whether this range contains given {@link module:engine/view/position~Position position}.
   *
   * @param position Position to check.
   * @returns `true` if given {@link module:engine/view/position~Position position} is contained in this range, `false` otherwise.
   */
  containsPosition(e) {
    return e.isAfter(this.start) && e.isBefore(this.end);
  }
  /**
   * Checks whether this range contains given {@link module:engine/view/range~Range range}.
   *
   * @param otherRange Range to check.
   * @param loose Whether the check is loose or strict. If the check is strict (`false`), compared range cannot
   * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or
   * even be equal to this range. Note that collapsed ranges are always compared in strict mode.
   * @returns `true` if given {@link module:engine/view/range~Range range} boundaries are contained by this range, `false`
   * otherwise.
   */
  containsRange(e, t = !1) {
    e.isCollapsed && (t = !1);
    const n = this.containsPosition(e.start) || t && this.start.isEqual(e.start), s = this.containsPosition(e.end) || t && this.end.isEqual(e.end);
    return n && s;
  }
  /**
   * Computes which part(s) of this {@link module:engine/view/range~Range range} is not a part of given
   * {@link module:engine/view/range~Range range}.
   * Returned array contains zero, one or two {@link module:engine/view/range~Range ranges}.
   *
   * Examples:
   *
   * ```ts
   * let foo = downcastWriter.createText( 'foo' );
   * let img = downcastWriter.createContainerElement( 'img' );
   * let bar = downcastWriter.createText( 'bar' );
   * let p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );
   *
   * let range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // "o", img, "b" are in range.
   * let otherRange = view.createRange( // "oo", img, "ba" are in range.
   * 	view.createPositionAt( foo, 1 ),
   * 	view.createPositionAt( bar, 2 )
   * );
   * let transformed = range.getDifference( otherRange );
   * // transformed array has no ranges because `otherRange` contains `range`
   *
   * otherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // "oo", img are in range.
   * transformed = range.getDifference( otherRange );
   * // transformed array has one range: from ( p, 2 ) to ( bar, 1 )
   *
   * otherRange = view.createRange( view.createPositionAt( p, 1 ), view.createPositionAt( p, 2 ) ); // img is in range.
   * transformed = range.getDifference( otherRange );
   * // transformed array has two ranges: from ( foo, 1 ) to ( p, 1 ) and from ( p, 2 ) to ( bar, 1 )
   * ```
   *
   * @param otherRange Range to differentiate against.
   * @returns The difference between ranges.
   */
  getDifference(e) {
    const t = [];
    return this.isIntersecting(e) ? (this.containsPosition(e.start) && t.push(new Ft(this.start, e.start)), this.containsPosition(e.end) && t.push(new Ft(e.end, this.end))) : t.push(this.clone()), t;
  }
  /**
   * Returns an intersection of this {@link module:engine/view/range~Range range} and given {@link module:engine/view/range~Range range}.
   * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.
   *
   * Examples:
   *
   * ```ts
   * let foo = downcastWriter.createText( 'foo' );
   * let img = downcastWriter.createContainerElement( 'img' );
   * let bar = downcastWriter.createText( 'bar' );
   * let p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );
   *
   * let range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // "o", img, "b" are in range.
   * let otherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // "oo", img are in range.
   * let transformed = range.getIntersection( otherRange ); // range from ( foo, 1 ) to ( p, 2 ).
   *
   * otherRange = view.createRange( view.createPositionAt( bar, 1 ), view.createPositionAt( bar, 3 ); "ar" is in range.
   * transformed = range.getIntersection( otherRange ); // null - no common part.
   * ```
   *
   * @param otherRange Range to check for intersection.
   * @returns A common part of given ranges or `null` if ranges have no common part.
   */
  getIntersection(e) {
    if (this.isIntersecting(e)) {
      let t = this.start, n = this.end;
      return this.containsPosition(e.start) && (t = e.start), this.containsPosition(e.end) && (n = e.end), new Ft(t, n);
    }
    return null;
  }
  /**
   * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.
   *
   * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
   */
  getWalker(e = {}) {
    return e.boundaries = this, new sn(e);
  }
  /**
   * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}
   * which is a common ancestor of range's both ends (in which the entire range is contained).
   */
  getCommonAncestor() {
    return this.start.getCommonAncestor(this.end);
  }
  /**
   * Returns an {@link module:engine/view/element~Element Element} contained by the range.
   * The element will be returned when it is the **only** node within the range and **fully–contained**
   * at the same time.
   */
  getContainedElement() {
    if (this.isCollapsed)
      return null;
    let e = this.start.nodeAfter, t = this.end.nodeBefore;
    return this.start.parent.is("$text") && this.start.isAtEnd && this.start.parent.nextSibling && (e = this.start.parent.nextSibling), this.end.parent.is("$text") && this.end.isAtStart && this.end.parent.previousSibling && (t = this.end.parent.previousSibling), e && e.is("element") && e === t ? e : null;
  }
  /**
   * Clones this range.
   */
  clone() {
    return new Ft(this.start, this.end);
  }
  /**
   * Returns an iterator that iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns
   * them.
   *
   * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option
   * set to `true`. However it returns only {@link module:engine/view/item~Item items},
   * not {@link module:engine/view/treewalker~TreeWalkerValue}.
   *
   * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for
   * a full list of available options.
   *
   * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
   */
  *getItems(e = {}) {
    e.boundaries = this, e.ignoreElementEnd = !0;
    const t = new sn(e);
    for (const n of t)
      yield n.item;
  }
  /**
   * Returns an iterator that iterates over all {@link module:engine/view/position~Position positions} that are boundaries or
   * contained in this range.
   *
   * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only
   * {@link module:engine/view/position~Position positions}, not {@link module:engine/view/treewalker~TreeWalkerValue}.
   *
   * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for
   * a full list of available options.
   *
   * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
   */
  *getPositions(e = {}) {
    e.boundaries = this;
    const t = new sn(e);
    yield t.position;
    for (const n of t)
      yield n.nextPosition;
  }
  /**
   * Checks and returns whether this range intersects with the given range.
   *
   * @param otherRange Range to compare with.
   * @returns True if ranges intersect.
   */
  isIntersecting(e) {
    return this.start.isBefore(e.end) && this.end.isAfter(e.start);
  }
  /**
   * Creates a range from the given parents and offsets.
   *
   * @internal
   * @param startElement Start position parent element.
   * @param startOffset Start position offset.
   * @param endElement End position parent element.
   * @param endOffset End position offset.
   * @returns Created range.
   */
  static _createFromParentsAndOffsets(e, t, n, s) {
    return new this(new k(e, t), new k(n, s));
  }
  /**
   * Creates a new range, spreading from specified {@link module:engine/view/position~Position position} to a position moved by
   * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.
   *
   * @internal
   * @param position Beginning of the range.
   * @param shift How long the range should be.
   */
  static _createFromPositionAndShift(e, t) {
    const n = e, s = e.getShiftedBy(t);
    return t > 0 ? new this(n, s) : new this(s, n);
  }
  /**
   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * @internal
   * @param element Element which is a parent for the range.
   */
  static _createIn(e) {
    return this._createFromParentsAndOffsets(e, 0, e, e.childCount);
  }
  /**
   * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
   *
   * @internal
   */
  static _createOn(e) {
    const t = e.is("$textProxy") ? e.offsetSize : 1;
    return this._createFromPositionAndShift(k._createBefore(e), t);
  }
};
O.prototype.is = function(i) {
  return i === "range" || i === "view:range";
};
function Ss(i) {
  return !!(i.item.is("attributeElement") || i.item.is("uiElement"));
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let xt = class _m extends G(wn) {
  /**
   * Creates new selection instance.
   *
   * **Note**: The selection constructor is available as a factory method:
   *
   * * {@link module:engine/view/view~View#createSelection `View#createSelection()`},
   * * {@link module:engine/view/upcastwriter~UpcastWriter#createSelection `UpcastWriter#createSelection()`}.
   *
   * ```ts
   * // Creates empty selection without ranges.
   * const selection = writer.createSelection();
   *
   * // Creates selection at the given range.
   * const range = writer.createRange( start, end );
   * const selection = writer.createSelection( range );
   *
   * // Creates selection at the given ranges
   * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
   * const selection = writer.createSelection( ranges );
   *
   * // Creates selection from the other selection.
   * const otherSelection = writer.createSelection();
   * const selection = writer.createSelection( otherSelection );
   *
   * // Creates selection from the document selection.
   * const selection = writer.createSelection( editor.editing.view.document.selection );
   *
   * // Creates selection at the given position.
   * const position = writer.createPositionFromPath( root, path );
   * const selection = writer.createSelection( position );
   *
   * // Creates collapsed selection at the position of given item and offset.
   * const paragraph = writer.createContainerElement( 'paragraph' );
   * const selection = writer.createSelection( paragraph, offset );
   *
   * // Creates a range inside an {@link module:engine/view/element~Element element} which starts before the
   * // first child of that element and ends after the last child of that element.
   * const selection = writer.createSelection( paragraph, 'in' );
   *
   * // Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends
   * // just after the item.
   * const selection = writer.createSelection( paragraph, 'on' );
   * ```
   *
   * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.
   *
   * ```ts
   * // Creates backward selection.
   * const selection = writer.createSelection( range, { backward: true } );
   * ```
   *
   * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
   * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
   * represented in other way, for example by applying proper CSS class.
   *
   * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM
   * (and be  properly handled by screen readers).
   *
   * ```ts
   * // Creates fake selection with label.
   * const selection = writer.createSelection( range, { fake: true, label: 'foo' } );
   * ```
   *
   * @internal
   */
  constructor(...e) {
    super(), this._ranges = [], this._lastRangeBackward = !1, this._isFake = !1, this._fakeSelectionLabel = "", e.length && this.setTo(...e);
  }
  /**
   * Returns true if selection instance is marked as `fake`.
   *
   * @see #setTo
   */
  get isFake() {
    return this._isFake;
  }
  /**
   * Returns fake selection label.
   *
   * @see #setTo
   */
  get fakeSelectionLabel() {
    return this._fakeSelectionLabel;
  }
  /**
   * Selection anchor. Anchor may be described as a position where the selection starts. Together with
   * {@link #focus focus} they define the direction of selection, which is important
   * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.
   * It may be a bit unintuitive when there are multiple ranges in selection.
   *
   * @see #focus
   */
  get anchor() {
    if (!this._ranges.length)
      return null;
    const e = this._ranges[this._ranges.length - 1];
    return (this._lastRangeBackward ? e.end : e.start).clone();
  }
  /**
   * Selection focus. Focus is a position where the selection ends.
   *
   * @see #anchor
   */
  get focus() {
    if (!this._ranges.length)
      return null;
    const e = this._ranges[this._ranges.length - 1];
    return (this._lastRangeBackward ? e.start : e.end).clone();
  }
  /**
   * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
   * collapsed.
   */
  get isCollapsed() {
    return this.rangeCount === 1 && this._ranges[0].isCollapsed;
  }
  /**
   * Returns number of ranges in selection.
   */
  get rangeCount() {
    return this._ranges.length;
  }
  /**
   * Specifies whether the {@link #focus} precedes {@link #anchor}.
   */
  get isBackward() {
    return !this.isCollapsed && this._lastRangeBackward;
  }
  /**
   * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this selection, or `null`
   * if the selection is not inside an editable element.
   */
  get editableElement() {
    return this.anchor ? this.anchor.editableElement : null;
  }
  /**
   * Returns an iterable that contains copies of all ranges added to the selection.
   */
  *getRanges() {
    for (const e of this._ranges)
      yield e.clone();
  }
  /**
   * Returns copy of the first range in the selection. First range is the one which
   * {@link module:engine/view/range~Range#start start} position {@link module:engine/view/position~Position#isBefore is before} start
   * position of all other ranges (not to confuse with the first range added to the selection).
   * Returns `null` if no ranges are added to selection.
   */
  getFirstRange() {
    let e = null;
    for (const t of this._ranges)
      (!e || t.start.isBefore(e.start)) && (e = t);
    return e ? e.clone() : null;
  }
  /**
   * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~Range#end end}
   * position {@link module:engine/view/position~Position#isAfter is after} end position of all other ranges (not to confuse
   * with the last range added to the selection). Returns `null` if no ranges are added to selection.
   */
  getLastRange() {
    let e = null;
    for (const t of this._ranges)
      (!e || t.end.isAfter(e.end)) && (e = t);
    return e ? e.clone() : null;
  }
  /**
   * Returns copy of the first position in the selection. First position is the position that
   * {@link module:engine/view/position~Position#isBefore is before} any other position in the selection ranges.
   * Returns `null` if no ranges are added to selection.
   */
  getFirstPosition() {
    const e = this.getFirstRange();
    return e ? e.start.clone() : null;
  }
  /**
   * Returns copy of the last position in the selection. Last position is the position that
   * {@link module:engine/view/position~Position#isAfter is after} any other position in the selection ranges.
   * Returns `null` if no ranges are added to selection.
   */
  getLastPosition() {
    const e = this.getLastRange();
    return e ? e.end.clone() : null;
  }
  /**
   * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,
   * same number of ranges and all ranges from one selection equal to a range from other selection.
   *
   * @param otherSelection Selection to compare with.
   * @returns `true` if selections are equal, `false` otherwise.
   */
  isEqual(e) {
    if (this.isFake != e.isFake || this.isFake && this.fakeSelectionLabel != e.fakeSelectionLabel || this.rangeCount != e.rangeCount)
      return !1;
    if (this.rangeCount === 0)
      return !0;
    if (!this.anchor.isEqual(e.anchor) || !this.focus.isEqual(e.focus))
      return !1;
    for (const t of this._ranges) {
      let n = !1;
      for (const s of e._ranges)
        if (t.isEqual(s)) {
          n = !0;
          break;
        }
      if (!n)
        return !1;
    }
    return !0;
  }
  /**
   * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same
   * number of ranges, and all {@link module:engine/view/range~Range#getTrimmed trimmed} ranges from one selection are
   * equal to any trimmed range from other selection.
   *
   * @param otherSelection Selection to compare with.
   * @returns `true` if selections are similar, `false` otherwise.
   */
  isSimilar(e) {
    if (this.isBackward != e.isBackward)
      return !1;
    const t = oa(this.getRanges()), n = oa(e.getRanges());
    if (t != n)
      return !1;
    if (t == 0)
      return !0;
    for (let s of this.getRanges()) {
      s = s.getTrimmed();
      let o = !1;
      for (let r of e.getRanges())
        if (r = r.getTrimmed(), s.start.isEqual(r.start) && s.end.isEqual(r.end)) {
          o = !0;
          break;
        }
      if (!o)
        return !1;
    }
    return !0;
  }
  /**
   * Returns the selected element. {@link module:engine/view/element~Element Element} is considered as selected if there is only
   * one range in the selection, and that range contains exactly one element.
   * Returns `null` if there is no selected element.
   */
  getSelectedElement() {
    return this.rangeCount !== 1 ? null : this.getFirstRange().getContainedElement();
  }
  /**
   * Sets this selection's ranges and direction to the specified location based on the given
   * {@link module:engine/view/selection~Selectable selectable}.
   *
   * ```ts
   * // Sets selection to the given range.
   * const range = writer.createRange( start, end );
   * selection.setTo( range );
   *
   * // Sets selection to given ranges.
   * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
   * selection.setTo( range );
   *
   * // Sets selection to the other selection.
   * const otherSelection = writer.createSelection();
   * selection.setTo( otherSelection );
   *
   * // Sets selection to contents of DocumentSelection.
   * selection.setTo( editor.editing.view.document.selection );
   *
   * // Sets collapsed selection at the given position.
   * const position = writer.createPositionAt( root, path );
   * selection.setTo( position );
   *
   * // Sets collapsed selection at the position of given item and offset.
   * selection.setTo( paragraph, offset );
   * ```
   *
   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * ```ts
   * selection.setTo( paragraph, 'in' );
   * ```
   *
   * Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.
   *
   * ```ts
   * selection.setTo( paragraph, 'on' );
   *
   * // Clears selection. Removes all ranges.
   * selection.setTo( null );
   * ```
   *
   * `Selection#setTo()` method allow passing additional options (`backward`, `fake` and `label`) as the last argument.
   *
   * ```ts
   * // Sets selection as backward.
   * selection.setTo( range, { backward: true } );
   * ```
   *
   * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
   * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
   * represented in other way, for example by applying proper CSS class.
   *
   * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM
   * (and be  properly handled by screen readers).
   *
   * ```ts
   * // Creates fake selection with label.
   * selection.setTo( range, { fake: true, label: 'foo' } );
   * ```
   *
   * @fires change
   */
  setTo(...e) {
    let [t, n, s] = e;
    if (typeof n == "object" && (s = n, n = void 0), t === null)
      this._setRanges([]), this._setFakeOptions(s);
    else if (t instanceof _m || t instanceof ml)
      this._setRanges(t.getRanges(), t.isBackward), this._setFakeOptions({ fake: t.isFake, label: t.fakeSelectionLabel });
    else if (t instanceof O)
      this._setRanges([t], s && s.backward), this._setFakeOptions(s);
    else if (t instanceof k)
      this._setRanges([new O(t)]), this._setFakeOptions(s);
    else if (t instanceof _n) {
      const o = !!s && !!s.backward;
      let r;
      if (n === void 0)
        throw new g("view-selection-setto-required-second-parameter", this);
      n == "in" ? r = O._createIn(t) : n == "on" ? r = O._createOn(t) : r = new O(k._createAt(t, n)), this._setRanges([r], o), this._setFakeOptions(s);
    } else if (Ue(t))
      this._setRanges(t, s && s.backward), this._setFakeOptions(s);
    else
      throw new g("view-selection-setto-not-selectable", this);
    this.fire("change");
  }
  /**
   * Moves {@link #focus} to the specified location.
   *
   * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}
   * parameters.
   *
   * @fires change
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
   */
  setFocus(e, t) {
    if (this.anchor === null)
      throw new g("view-selection-setfocus-no-ranges", this);
    const n = k._createAt(e, t);
    if (n.compareWith(this.focus) == "same")
      return;
    const s = this.anchor;
    this._ranges.pop(), n.compareWith(s) == "before" ? this._addRange(new O(n, s), !0) : this._addRange(new O(s, n)), this.fire("change");
  }
  /**
   * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array
   * is treated like the last added range and is used to set {@link #anchor anchor} and {@link #focus focus}.
   * Accepts a flag describing in which way the selection is made.
   *
   * @param newRanges Iterable object of ranges to set.
   * @param isLastBackward Flag describing if last added range was selected forward - from start to end
   * (`false`) or backward - from end to start (`true`). Defaults to `false`.
   */
  _setRanges(e, t = !1) {
    e = Array.from(e), this._ranges = [];
    for (const n of e)
      this._addRange(n);
    this._lastRangeBackward = !!t;
  }
  /**
   * Sets this selection instance to be marked as `fake`. A fake selection does not render as browser native selection
   * over selected elements and is hidden to the user. This way, no native selection UI artifacts are displayed to
   * the user and selection over elements can be represented in other way, for example by applying proper CSS class.
   *
   * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM (and be
   * properly handled by screen readers).
   */
  _setFakeOptions(e = {}) {
    this._isFake = !!e.fake, this._fakeSelectionLabel = e.fake && e.label || "";
  }
  /**
   * Adds a range to the selection. Added range is copied. This means that passed range is not saved in the
   * selection instance and you can safely operate on it.
   *
   * Accepts a flag describing in which way the selection is made - passed range might be selected from
   * {@link module:engine/view/range~Range#start start} to {@link module:engine/view/range~Range#end end}
   * or from {@link module:engine/view/range~Range#end end} to {@link module:engine/view/range~Range#start start}.
   * The flag is used to set {@link #anchor anchor} and {@link #focus focus} properties.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects
   * with ranges already stored in Selection instance.
   */
  _addRange(e, t = !1) {
    if (!(e instanceof O))
      throw new g("view-selection-add-range-not-range", this);
    this._pushRange(e), this._lastRangeBackward = !!t;
  }
  /**
   * Adds range to selection - creates copy of given range so it can be safely used and modified.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects
   * with ranges already stored in selection instance.
   */
  _pushRange(e) {
    for (const t of this._ranges)
      if (e.isIntersecting(t))
        throw new g("view-selection-range-intersects", this, { addedRange: e, intersectingRange: t });
    this._ranges.push(new O(e.start, e.end));
  }
};
xt.prototype.is = function(i) {
  return i === "selection" || i === "view:selection";
};
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let ml = class extends G(wn) {
  constructor(...e) {
    super(), this._selection = new xt(), this._selection.delegate("change").to(this), e.length && this._selection.setTo(...e);
  }
  /**
   * Returns true if selection instance is marked as `fake`.
   *
   * @see #_setTo
   */
  get isFake() {
    return this._selection.isFake;
  }
  /**
   * Returns fake selection label.
   *
   * @see #_setTo
   */
  get fakeSelectionLabel() {
    return this._selection.fakeSelectionLabel;
  }
  /**
   * Selection anchor. Anchor may be described as a position where the selection starts. Together with
   * {@link #focus focus} they define the direction of selection, which is important
   * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.
   * It may be a bit unintuitive when there are multiple ranges in selection.
   *
   * @see #focus
   */
  get anchor() {
    return this._selection.anchor;
  }
  /**
   * Selection focus. Focus is a position where the selection ends.
   *
   * @see #anchor
   */
  get focus() {
    return this._selection.focus;
  }
  /**
   * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
   * collapsed.
   */
  get isCollapsed() {
    return this._selection.isCollapsed;
  }
  /**
   * Returns number of ranges in selection.
   */
  get rangeCount() {
    return this._selection.rangeCount;
  }
  /**
   * Specifies whether the {@link #focus} precedes {@link #anchor}.
   */
  get isBackward() {
    return this._selection.isBackward;
  }
  /**
   * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this selection, or `null`
   * if the selection is not inside an editable element.
   */
  get editableElement() {
    return this._selection.editableElement;
  }
  /**
   * Used for the compatibility with the {@link module:engine/view/selection~Selection#isEqual} method.
   *
   * @internal
   */
  get _ranges() {
    return this._selection._ranges;
  }
  /**
   * Returns an iterable that contains copies of all ranges added to the selection.
   */
  *getRanges() {
    yield* this._selection.getRanges();
  }
  /**
   * Returns copy of the first range in the selection. First range is the one which
   * {@link module:engine/view/range~Range#start start} position {@link module:engine/view/position~Position#isBefore is before} start
   * position of all other ranges (not to confuse with the first range added to the selection).
   * Returns `null` if no ranges are added to selection.
   */
  getFirstRange() {
    return this._selection.getFirstRange();
  }
  /**
   * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~Range#end end}
   * position {@link module:engine/view/position~Position#isAfter is after} end position of all other ranges (not to confuse
   * with the last range added to the selection). Returns `null` if no ranges are added to selection.
   */
  getLastRange() {
    return this._selection.getLastRange();
  }
  /**
   * Returns copy of the first position in the selection. First position is the position that
   * {@link module:engine/view/position~Position#isBefore is before} any other position in the selection ranges.
   * Returns `null` if no ranges are added to selection.
   */
  getFirstPosition() {
    return this._selection.getFirstPosition();
  }
  /**
   * Returns copy of the last position in the selection. Last position is the position that
   * {@link module:engine/view/position~Position#isAfter is after} any other position in the selection ranges.
   * Returns `null` if no ranges are added to selection.
   */
  getLastPosition() {
    return this._selection.getLastPosition();
  }
  /**
   * Returns the selected element. {@link module:engine/view/element~Element Element} is considered as selected if there is only
   * one range in the selection, and that range contains exactly one element.
   * Returns `null` if there is no selected element.
   */
  getSelectedElement() {
    return this._selection.getSelectedElement();
  }
  /**
   * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,
   * same number of ranges and all ranges from one selection equal to a range from other selection.
   *
   * @param otherSelection Selection to compare with.
   * @returns `true` if selections are equal, `false` otherwise.
   */
  isEqual(e) {
    return this._selection.isEqual(e);
  }
  /**
   * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same
   * number of ranges, and all {@link module:engine/view/range~Range#getTrimmed trimmed} ranges from one selection are
   * equal to any trimmed range from other selection.
   *
   * @param otherSelection Selection to compare with.
   * @returns `true` if selections are similar, `false` otherwise.
   */
  isSimilar(e) {
    return this._selection.isSimilar(e);
  }
  /**
   * Sets this selection's ranges and direction to the specified location based on the given
   * {@link module:engine/view/selection~Selectable selectable}.
   *
   * ```ts
   * // Sets selection to the given range.
   * const range = writer.createRange( start, end );
   * documentSelection._setTo( range );
   *
   * // Sets selection to given ranges.
   * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( start2, end2 ) ];
   * documentSelection._setTo( range );
   *
   * // Sets selection to the other selection.
   * const otherSelection = writer.createSelection();
   * documentSelection._setTo( otherSelection );
   *
   * // Sets collapsed selection at the given position.
   * const position = writer.createPositionAt( root, offset );
   * documentSelection._setTo( position );
   *
   * // Sets collapsed selection at the position of given item and offset.
   * documentSelection._setTo( paragraph, offset );
   * ```
   *
   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * ```ts
   * documentSelection._setTo( paragraph, 'in' );
   * ```
   *
   * Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.
   *
   * ```ts
   * documentSelection._setTo( paragraph, 'on' );
   *
   * // Clears selection. Removes all ranges.
   * documentSelection._setTo( null );
   * ```
   *
   * `Selection#_setTo()` method allow passing additional options (`backward`, `fake` and `label`) as the last argument.
   *
   * ```ts
   * // Sets selection as backward.
   * documentSelection._setTo( range, { backward: true } );
   * ```
   *
   * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
   * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
   * represented in other way, for example by applying proper CSS class.
   *
   * Additionally fake's selection label can be provided. It will be used to des cribe fake selection in DOM
   * (and be  properly handled by screen readers).
   *
   * ```ts
   * // Creates fake selection with label.
   * documentSelection._setTo( range, { fake: true, label: 'foo' } );
   * ```
   *
   * @internal
   * @fires change
   */
  _setTo(...e) {
    this._selection.setTo(...e);
  }
  /**
   * Moves {@link #focus} to the specified location.
   *
   * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}
   * parameters.
   *
   * @internal
   * @fires change
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
   */
  _setFocus(e, t) {
    this._selection.setFocus(e, t);
  }
};
ml.prototype.is = function(i) {
  return i === "selection" || i == "documentSelection" || i == "view:selection" || i == "view:documentSelection";
};
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class hi extends St {
  /**
   * @param source The emitter.
   * @param name The event name.
   * @param startRange The view range that the bubbling should start from.
   */
  constructor(e, t, n) {
    super(e, t), this.startRange = n, this._eventPhase = "none", this._currentTarget = null;
  }
  /**
   * The current event phase.
   */
  get eventPhase() {
    return this._eventPhase;
  }
  /**
   * The current bubbling target.
   */
  get currentTarget() {
    return this._currentTarget;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Cr = Symbol("bubbling contexts");
function ua(i) {
  class e extends i {
    fire(n, ...s) {
      try {
        const o = n instanceof St ? n : new St(this, n), r = kr(this);
        if (!r.size)
          return;
        if (bi(o, "capturing", this), Vn(r, "$capture", o, ...s))
          return o.return;
        const a = o.startRange || this.selection.getFirstRange(), l = a ? a.getContainedElement() : null, c = l ? !!vm(r, l) : !1;
        let u = l || ck(a);
        if (bi(o, "atTarget", u), !c) {
          if (Vn(r, "$text", o, ...s))
            return o.return;
          bi(o, "bubbling", u);
        }
        for (; u; ) {
          if (u.is("rootElement")) {
            if (Vn(r, "$root", o, ...s))
              return o.return;
          } else if (u.is("element") && Vn(r, u.name, o, ...s))
            return o.return;
          if (Vn(r, u, o, ...s))
            return o.return;
          u = u.parent, bi(o, "bubbling", u);
        }
        return bi(o, "bubbling", this), Vn(r, "$document", o, ...s), o.return;
      } catch (o) {
        /* istanbul ignore next -- @preserve */
        g.rethrowUnexpectedError(o, this);
      }
    }
    _addEventListener(n, s, o) {
      const r = Z(o.context || "$document"), a = kr(this);
      for (const l of r) {
        let c = a.get(l);
        c || (c = new (G())(), a.set(l, c)), this.listenTo(c, n, s, o);
      }
    }
    _removeEventListener(n, s) {
      const o = kr(this);
      for (const r of o.values())
        this.stopListening(r, n, s);
    }
  }
  return e;
}
{
  const i = ua(Object);
  ["fire", "_addEventListener", "_removeEventListener"].forEach((e) => {
    ua[e] = i.prototype[e];
  });
}
function bi(i, e, t) {
  i instanceof hi && (i._eventPhase = e, i._currentTarget = t);
}
function Vn(i, e, t, ...n) {
  const s = typeof e == "string" ? i.get(e) : vm(i, e);
  return s ? (s.fire(t, ...n), t.stop.called) : !1;
}
function vm(i, e) {
  for (const [t, n] of i)
    if (typeof t == "function" && t(e))
      return n;
  return null;
}
function kr(i) {
  return i[Cr] || (i[Cr] = /* @__PURE__ */ new Map()), i[Cr];
}
function ck(i) {
  if (!i)
    return null;
  const e = i.start.parent, t = i.end.parent, n = e.getPath(), s = t.getPath();
  return n.length > s.length ? e : t;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let Zo = class extends ua(U()) {
  /**
   * Creates a Document instance.
   *
   * @param stylesProcessor The styles processor instance.
   */
  constructor(e) {
    super(), this._postFixers = /* @__PURE__ */ new Set(), this.selection = new ml(), this.roots = new ke({ idProperty: "rootName" }), this.stylesProcessor = e, this.set("isReadOnly", !1), this.set("isFocused", !1), this.set("isSelecting", !1), this.set("isComposing", !1);
  }
  /**
   * Gets a {@link module:engine/view/document~Document#roots view root element} with the specified name. If the name is not
   * specific "main" root is returned.
   *
   * @param name Name of the root.
   * @returns The view root element with the specified name or null when there is no root of given name.
   */
  getRoot(e = "main") {
    return this.roots.get(e);
  }
  /**
   * Allows registering post-fixer callbacks. A post-fixers mechanism allows to update the view tree just before it is rendered
   * to the DOM.
   *
   * Post-fixers are executed right after all changes from the outermost change block were applied but
   * before the {@link module:engine/view/view~View#event:render render event} is fired. If a post-fixer callback made
   * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should
   * not be fixed in the new document tree state.
   *
   * View post-fixers are useful when you want to apply some fixes whenever the view structure changes. Keep in mind that
   * changes executed in a view post-fixer should not break model-view mapping.
   *
   * The types of changes which should be safe:
   *
   * * adding or removing attribute from elements,
   * * changes inside of {@link module:engine/view/uielement~UIElement UI elements},
   * * {@link module:engine/controller/editingcontroller~EditingController#reconvertItem marking some of the model elements to be
   * re-converted}.
   *
   * Try to avoid changes which touch view structure:
   *
   * * you should not add or remove nor wrap or unwrap any view elements,
   * * you should not change the editor data model in a view post-fixer.
   *
   * As a parameter, a post-fixer callback receives a {@link module:engine/view/downcastwriter~DowncastWriter downcast writer}.
   *
   * Typically, a post-fixer will look like this:
   *
   * ```ts
   * editor.editing.view.document.registerPostFixer( writer => {
   * 	if ( checkSomeCondition() ) {
   * 		writer.doSomething();
   *
   * 		// Let other post-fixers know that something changed.
   * 		return true;
   * 	}
   *
   * 	return false;
   * } );
   * ```
   *
   * Note that nothing happens right after you register a post-fixer (e.g. execute such a code in the console).
   * That is because adding a post-fixer does not execute it.
   * The post-fixer will be executed as soon as any change in the document needs to cause its rendering.
   * If you want to re-render the editor's view after registering the post-fixer then you should do it manually by calling
   * {@link module:engine/view/view~View#forceRender `view.forceRender()`}.
   *
   * If you need to register a callback which is executed when DOM elements are already updated,
   * use {@link module:engine/view/view~View#event:render render event}.
   */
  registerPostFixer(e) {
    this._postFixers.add(e);
  }
  /**
   * Destroys this instance. Makes sure that all observers are destroyed and listeners removed.
   */
  destroy() {
    this.roots.forEach((e) => e.destroy()), this.stopListening();
  }
  /**
   * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.
   *
   * @internal
   */
  _callPostFixers(e) {
    let t = !1;
    do
      for (const n of this._postFixers)
        if (t = n(e), t)
          break;
    while (t);
  }
};
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const ym = 10;
class on extends rt {
  /**
   * Creates an attribute element.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createAttributeElement
   * @see module:engine/view/element~Element
   * @protected
   * @param document The document instance to which this element belongs.
   * @param name Node name.
   * @param attrs Collection of attributes.
   * @param children A list of nodes to be inserted into created element.
   */
  constructor(e, t, n, s) {
    super(e, t, n, s), this._priority = ym, this._id = null, this._clonesGroup = null, this.getFillerOffset = uk;
  }
  /**
   * Element priority. Decides in what order elements are wrapped by {@link module:engine/view/downcastwriter~DowncastWriter}.
   */
  get priority() {
    return this._priority;
  }
  /**
   * Element identifier. If set, it is used by {@link module:engine/view/element~Element#isSimilar},
   * and then two elements are considered similar if, and only if they have the same `id`.
   */
  get id() {
    return this._id;
  }
  /**
   * Returns all {@link module:engine/view/attributeelement~AttributeElement attribute elements} that has the
   * same {@link module:engine/view/attributeelement~AttributeElement#id id} and are in the view tree (were not removed).
   *
   * Note: If this element has been removed from the tree, returned set will not include it.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError attribute-element-get-elements-with-same-id-no-id}
   * if this element has no `id`.
   *
   * @returns Set containing all the attribute elements
   * with the same `id` that were added and not removed from the view tree.
   */
  getElementsWithSameId() {
    if (this.id === null)
      throw new g("attribute-element-get-elements-with-same-id-no-id", this);
    return new Set(this._clonesGroup);
  }
  /**
   * Checks if this element is similar to other element.
   *
   * If none of elements has set {@link module:engine/view/attributeelement~AttributeElement#id}, then both elements
   * should have the same name, attributes and priority to be considered as similar. Two similar elements can contain
   * different set of children nodes.
   *
   * If at least one element has {@link module:engine/view/attributeelement~AttributeElement#id} set, then both
   * elements have to have the same {@link module:engine/view/attributeelement~AttributeElement#id} value to be
   * considered similar.
   *
   * Similarity is important for {@link module:engine/view/downcastwriter~DowncastWriter}. For example:
   *
   * * two following similar elements can be merged together into one, longer element,
   * * {@link module:engine/view/downcastwriter~DowncastWriter#unwrap} checks similarity of passed element and processed element to
   * decide whether processed element should be unwrapped,
   * * etc.
   */
  isSimilar(e) {
    return this.id !== null || e.id !== null ? this.id === e.id : super.isSimilar(e) && this.priority == e.priority;
  }
  /**
   * Clones provided element with priority.
   *
   * @internal
   * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
   * element will be cloned without any children.
   * @returns Clone of this element.
   */
  _clone(e = !1) {
    const t = super._clone(e);
    return t._priority = this._priority, t._id = this._id, t;
  }
}
on.DEFAULT_PRIORITY = ym;
on.prototype.is = function(i, e) {
  return e ? e === this.name && (i === "attributeElement" || i === "view:attributeElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "element" || i === "view:element") : i === "attributeElement" || i === "view:attributeElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "element" || i === "view:element" || i === "node" || i === "view:node";
};
function uk() {
  if (Tr(this))
    return null;
  let i = this.parent;
  for (; i && i.is("attributeElement"); ) {
    if (Tr(i) > 1)
      return null;
    i = i.parent;
  }
  return !i || Tr(i) > 1 ? null : this.childCount;
}
function Tr(i) {
  return Array.from(i.getChildren()).filter((e) => !e.is("uiElement")).length;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class gl extends rt {
  /**
   * Creates new instance of EmptyElement.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-emptyelement-cannot-add` when third parameter is passed,
   * to inform that usage of EmptyElement is incorrect (adding child nodes to EmptyElement is forbidden).
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createEmptyElement
   * @internal
   * @param document The document instance to which this element belongs.
   * @param name Node name.
   * @param attrs Collection of attributes.
   * @param children A list of nodes to be inserted into created element.
   */
  constructor(e, t, n, s) {
    super(e, t, n, s), this.getFillerOffset = dk;
  }
  /**
   * Overrides {@link module:engine/view/element~Element#_insertChild} method.
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-emptyelement-cannot-add` to prevent
   * adding any child nodes to EmptyElement.
   *
   * @internal
   */
  _insertChild(e, t) {
    if (t && (t instanceof _n || Array.from(t).length > 0))
      throw new g("view-emptyelement-cannot-add", [this, t]);
    return 0;
  }
}
gl.prototype.is = function(i, e) {
  return e ? e === this.name && (i === "emptyElement" || i === "view:emptyElement" || i === "element" || i === "view:element") : i === "emptyElement" || i === "view:emptyElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "element" || i === "view:element" || i === "node" || i === "view:node";
};
function dk() {
  return null;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Jo extends rt {
  /**
   * Creates new instance of UIElement.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` when third parameter is passed,
   * to inform that usage of UIElement is incorrect (adding child nodes to UIElement is forbidden).
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createUIElement
   * @internal
   * @param document The document instance to which this element belongs.
   * @param name Node name.
   * @param attrs Collection of attributes.
   * @param children A list of nodes to be inserted into created element.
   */
  constructor(e, t, n, s) {
    super(e, t, n, s), this.getFillerOffset = fk;
  }
  /**
   * Overrides {@link module:engine/view/element~Element#_insertChild} method.
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` to prevent adding any child nodes
   * to UIElement.
   *
   * @internal
   */
  _insertChild(e, t) {
    if (t && (t instanceof _n || Array.from(t).length > 0))
      throw new g("view-uielement-cannot-add", [this, t]);
    return 0;
  }
  /**
   * Renders this {@link module:engine/view/uielement~UIElement} to DOM. This method is called by
   * {@link module:engine/view/domconverter~DomConverter}.
   * Do not use inheritance to create custom rendering method, replace `render()` method instead:
   *
   * ```ts
   * const myUIElement = downcastWriter.createUIElement( 'span' );
   * myUIElement.render = function( domDocument, domConverter ) {
   * 	const domElement = this.toDomElement( domDocument );
   *
   * 	domConverter.setContentOf( domElement, '<b>this is ui element</b>' );
   *
   * 	return domElement;
   * };
   * ```
   *
   * If changes in your UI element should trigger some editor UI update you should call
   * the {@link module:ui/editorui/editorui~EditorUI#update `editor.ui.update()`} method
   * after rendering your UI element.
   *
   * @param domConverter Instance of the DomConverter used to optimize the output.
   */
  render(e, t) {
    return this.toDomElement(e);
  }
  /**
   * Creates DOM element based on this view UIElement.
   * Note that each time this method is called new DOM element is created.
   */
  toDomElement(e) {
    const t = e.createElement(this.name);
    for (const n of this.getAttributeKeys())
      t.setAttribute(n, this.getAttribute(n));
    return t;
  }
}
Jo.prototype.is = function(i, e) {
  return e ? e === this.name && (i === "uiElement" || i === "view:uiElement" || i === "element" || i === "view:element") : i === "uiElement" || i === "view:uiElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "element" || i === "view:element" || i === "node" || i === "view:node";
};
function hk(i) {
  i.document.on("arrowKey", (e, t) => mk(e, t, i.domConverter), { priority: "low" });
}
function fk() {
  return null;
}
function mk(i, e, t) {
  if (e.keyCode == N.arrowright) {
    const n = e.domTarget.ownerDocument.defaultView.getSelection(), s = n.rangeCount == 1 && n.getRangeAt(0).collapsed;
    if (s || e.shiftKey) {
      const o = n.focusNode, r = n.focusOffset, a = t.domPositionToView(o, r);
      if (a === null)
        return;
      let l = !1;
      const c = a.getLastMatchingPosition((u) => (u.item.is("uiElement") && (l = !0), !!(u.item.is("uiElement") || u.item.is("attributeElement"))));
      if (l) {
        const u = t.viewPositionToDom(c);
        s ? n.collapse(u.parent, u.offset) : n.extend(u.parent, u.offset);
      }
    }
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class pl extends rt {
  /**
   * Creates a new instance of a raw element.
   *
   * Throws the `view-rawelement-cannot-add` {@link module:utils/ckeditorerror~CKEditorError CKEditorError} when the `children`
   * parameter is passed to inform that the usage of `RawElement` is incorrect (adding child nodes to `RawElement` is forbidden).
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createRawElement
   * @internal
   * @param document The document instance to which this element belongs.
   * @param name Node name.
   * @param attrs Collection of attributes.
   * @param children A list of nodes to be inserted into created element.
   */
  constructor(e, t, n, s) {
    super(e, t, n, s), this.getFillerOffset = gk;
  }
  /**
   * Overrides the {@link module:engine/view/element~Element#_insertChild} method.
   * Throws the `view-rawelement-cannot-add` {@link module:utils/ckeditorerror~CKEditorError CKEditorError} to prevent
   * adding any child nodes to a raw element.
   *
   * @internal
   */
  _insertChild(e, t) {
    if (t && (t instanceof _n || Array.from(t).length > 0))
      throw new g("view-rawelement-cannot-add", [this, t]);
    return 0;
  }
  /**
   * This allows rendering the children of a {@link module:engine/view/rawelement~RawElement} on the DOM level.
   * This method is called by the {@link module:engine/view/domconverter~DomConverter} with the raw DOM element
   * passed as an argument, leaving the number and shape of the children up to the integrator.
   *
   * This method **must be defined** for the raw element to work:
   *
   * ```ts
   * const myRawElement = downcastWriter.createRawElement( 'div' );
   *
   * myRawElement.render = function( domElement, domConverter ) {
   * 	domConverter.setContentOf( domElement, '<b>This is the raw content of myRawElement.</b>' );
   * };
   * ```
   *
   * @param domElement The native DOM element representing the raw view element.
   * @param domConverter Instance of the DomConverter used to optimize the output.
   */
  render(e, t) {
  }
}
pl.prototype.is = function(i, e) {
  return e ? e === this.name && (i === "rawElement" || i === "view:rawElement" || i === "element" || i === "view:element") : i === "rawElement" || i === "view:rawElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === this.name || i === "view:" + this.name || i === "element" || i === "view:element" || i === "node" || i === "view:node";
};
function gk() {
  return null;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let rn = class extends G(wn) {
  /**
   * Creates new DocumentFragment instance.
   *
   * @internal
   * @param document The document to which this document fragment belongs.
   * @param children A list of nodes to be inserted into the created document fragment.
   */
  constructor(e, t) {
    super(), this._children = [], this._customProperties = /* @__PURE__ */ new Map(), this.document = e, t && this._insertChild(0, t);
  }
  /**
   * Iterable interface.
   *
   * Iterates over nodes added to this document fragment.
   */
  [Symbol.iterator]() {
    return this._children[Symbol.iterator]();
  }
  /**
   * Number of child nodes in this document fragment.
   */
  get childCount() {
    return this._children.length;
  }
  /**
   * Is `true` if there are no nodes inside this document fragment, `false` otherwise.
   */
  get isEmpty() {
    return this.childCount === 0;
  }
  /**
   * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.
   */
  get root() {
    return this;
  }
  /**
   * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.
   */
  get parent() {
    return null;
  }
  /**
   * Artificial element name. Returns `undefined`. Added for compatibility reasons.
   */
  get name() {
  }
  /**
   * Artificial element getFillerOffset. Returns `undefined`. Added for compatibility reasons.
   */
  get getFillerOffset() {
  }
  /**
   * Returns the custom property value for the given key.
   */
  getCustomProperty(e) {
    return this._customProperties.get(e);
  }
  /**
   * Returns an iterator which iterates over this document fragment's custom properties.
   * Iterator provides `[ key, value ]` pairs for each stored property.
   */
  *getCustomProperties() {
    yield* this._customProperties.entries();
  }
  /**
   * {@link module:engine/view/documentfragment~DocumentFragment#_insertChild Insert} a child node or a list of child nodes at the end
   * and sets the parent of these nodes to this fragment.
   *
   * @internal
   * @param items Items to be inserted.
   * @returns Number of appended nodes.
   */
  _appendChild(e) {
    return this._insertChild(this.childCount, e);
  }
  /**
   * Gets child at the given index.
   *
   * @param index Index of child.
   * @returns Child node.
   */
  getChild(e) {
    return this._children[e];
  }
  /**
   * Gets index of the given child node. Returns `-1` if child node is not found.
   *
   * @param node Child node.
   * @returns Index of the child node.
   */
  getChildIndex(e) {
    return this._children.indexOf(e);
  }
  /**
   * Gets child nodes iterator.
   *
   * @returns Child nodes iterator.
   */
  getChildren() {
    return this._children[Symbol.iterator]();
  }
  /**
   * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
   * this fragment.
   *
   * @internal
   * @param index Position where nodes should be inserted.
   * @param items Items to be inserted.
   * @returns Number of inserted nodes.
   */
  _insertChild(e, t) {
    this._fireChange("children", this);
    let n = 0;
    const s = pk(this.document, t);
    for (const o of s)
      o.parent !== null && o._remove(), o.parent = this, this._children.splice(e, 0, o), e++, n++;
    return n;
  }
  /**
   * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.
   *
   * @internal
   * @param index Number of the first node to remove.
   * @param howMany Number of nodes to remove.
   * @returns The array of removed nodes.
   */
  _removeChildren(e, t = 1) {
    this._fireChange("children", this);
    for (let n = e; n < e + t; n++)
      this._children[n].parent = null;
    return this._children.splice(e, t);
  }
  /**
   * Fires `change` event with given type of the change.
   *
   * @internal
   * @param type Type of the change.
   * @param node Changed node.
   */
  _fireChange(e, t) {
    this.fire("change:" + e, t);
  }
  /**
   * Sets a custom property. They can be used to add special data to elements.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#setCustomProperty
   * @internal
   */
  _setCustomProperty(e, t) {
    this._customProperties.set(e, t);
  }
  /**
   * Removes the custom property stored under the given key.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#removeCustomProperty
   * @internal
   * @returns Returns true if property was removed.
   */
  _removeCustomProperty(e) {
    return this._customProperties.delete(e);
  }
};
rn.prototype.is = function(i) {
  return i === "documentFragment" || i === "view:documentFragment";
};
function pk(i, e) {
  return typeof e == "string" ? [new ne(i, e)] : (Ue(e) || (e = [e]), Array.from(e).map((t) => typeof t == "string" ? new ne(i, t) : t instanceof ht ? new ne(i, t.data) : t));
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Cm {
  /**
   * @param document The view document instance.
   */
  constructor(e) {
    this._cloneGroups = /* @__PURE__ */ new Map(), this._slotFactory = null, this.document = e;
  }
  setSelection(...e) {
    this.document.selection._setTo(...e);
  }
  /**
   * Moves {@link module:engine/view/documentselection~DocumentSelection#focus selection's focus} to the specified location.
   *
   * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}
   * parameters.
   *
   * @param Offset or one of the flags. Used only when the first parameter is a {@link module:engine/view/item~Item view item}.
   */
  setSelectionFocus(e, t) {
    this.document.selection._setFocus(e, t);
  }
  /**
   * Creates a new {@link module:engine/view/documentfragment~DocumentFragment} instance.
   *
   * @param children A list of nodes to be inserted into the created document fragment.
   * @returns The created document fragment.
   */
  createDocumentFragment(e) {
    return new rn(this.document, e);
  }
  /**
   * Creates a new {@link module:engine/view/text~Text text node}.
   *
   * ```ts
   * writer.createText( 'foo' );
   * ```
   *
   * @param data The text's data.
   * @returns The created text node.
   */
  createText(e) {
    return new ne(this.document, e);
  }
  /**
   * Creates a new {@link module:engine/view/attributeelement~AttributeElement}.
   *
   * ```ts
   * writer.createAttributeElement( 'strong' );
   * writer.createAttributeElement( 'a', { href: 'foo.bar' } );
   *
   * // Make `<a>` element contain other attributes element so the `<a>` element is not broken.
   * writer.createAttributeElement( 'a', { href: 'foo.bar' }, { priority: 5 } );
   *
   * // Set `id` of a marker element so it is not joined or merged with "normal" elements.
   * writer.createAttributeElement( 'span', { class: 'my-marker' }, { id: 'marker:my' } );
   * ```
   *
   * @param name Name of the element.
   * @param attributes Element's attributes.
   * @param options Element's options.
   * @param options.priority Element's {@link module:engine/view/attributeelement~AttributeElement#priority priority}.
   * @param options.id Element's {@link module:engine/view/attributeelement~AttributeElement#id id}.
   * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
   * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
   * @returns Created element.
   */
  createAttributeElement(e, t, n = {}) {
    const s = new on(this.document, e, t);
    return typeof n.priority == "number" && (s._priority = n.priority), n.id && (s._id = n.id), n.renderUnsafeAttributes && s._unsafeAttributesToRender.push(...n.renderUnsafeAttributes), s;
  }
  createContainerElement(e, t, n = {}, s = {}) {
    let o = null;
    Ne(n) ? s = n : o = n;
    const r = new Ji(this.document, e, t, o);
    return s.renderUnsafeAttributes && r._unsafeAttributesToRender.push(...s.renderUnsafeAttributes), r;
  }
  /**
   * Creates a new {@link module:engine/view/editableelement~EditableElement}.
   *
   * ```ts
   * writer.createEditableElement( 'div' );
   * writer.createEditableElement( 'div', { id: 'foo-1234' } );
   * ```
   *
   * Note: The editable element is to be used in the editing pipeline. Usually, together with
   * {@link module:widget/utils~toWidgetEditable `toWidgetEditable()`}.
   *
   * @param name Name of the element.
   * @param attributes Elements attributes.
   * @param options Element's options.
   * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
   * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
   * @returns Created element.
   */
  createEditableElement(e, t, n = {}) {
    const s = new Ko(this.document, e, t);
    return n.renderUnsafeAttributes && s._unsafeAttributesToRender.push(...n.renderUnsafeAttributes), s;
  }
  /**
   * Creates a new {@link module:engine/view/emptyelement~EmptyElement}.
   *
   * ```ts
   * writer.createEmptyElement( 'img' );
   * writer.createEmptyElement( 'img', { id: 'foo-1234' } );
   * ```
   *
   * @param name Name of the element.
   * @param attributes Elements attributes.
   * @param options Element's options.
   * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
   * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
   * @returns Created element.
   */
  createEmptyElement(e, t, n = {}) {
    const s = new gl(this.document, e, t);
    return n.renderUnsafeAttributes && s._unsafeAttributesToRender.push(...n.renderUnsafeAttributes), s;
  }
  /**
   * Creates a new {@link module:engine/view/uielement~UIElement}.
   *
   * ```ts
   * writer.createUIElement( 'span' );
   * writer.createUIElement( 'span', { id: 'foo-1234' } );
   * ```
   *
   * A custom render function can be provided as the third parameter:
   *
   * ```ts
   * writer.createUIElement( 'span', null, function( domDocument ) {
   * 	const domElement = this.toDomElement( domDocument );
   * 	domElement.innerHTML = '<b>this is ui element</b>';
   *
   * 	return domElement;
   * } );
   * ```
   *
   * Unlike {@link #createRawElement raw elements}, UI elements are by no means editor content, for instance,
   * they are ignored by the editor selection system.
   *
   * You should not use UI elements as data containers. Check out {@link #createRawElement} instead.
   *
   * @param name The name of the element.
   * @param attributes Element attributes.
   * @param renderFunction A custom render function.
   * @returns The created element.
   */
  createUIElement(e, t, n) {
    const s = new Jo(this.document, e, t);
    return n && (s.render = n), s;
  }
  /**
   * Creates a new {@link module:engine/view/rawelement~RawElement}.
   *
   * ```ts
   * writer.createRawElement( 'span', { id: 'foo-1234' }, function( domElement ) {
   * 	domElement.innerHTML = '<b>This is the raw content of the raw element.</b>';
   * } );
   * ```
   *
   * Raw elements work as data containers ("wrappers", "sandboxes") but their children are not managed or
   * even recognized by the editor. This encapsulation allows integrations to maintain custom DOM structures
   * in the editor content without, for instance, worrying about compatibility with other editor features.
   * Raw elements are a perfect tool for integration with external frameworks and data sources.
   *
   * Unlike {@link #createUIElement UI elements}, raw elements act like "real" editor content (similar to
   * {@link module:engine/view/containerelement~ContainerElement} or {@link module:engine/view/emptyelement~EmptyElement}),
   * and they are considered by the editor selection.
   *
   * You should not use raw elements to render the UI in the editor content. Check out {@link #createUIElement `#createUIElement()`}
   * instead.
   *
   * @param name The name of the element.
   * @param attributes Element attributes.
   * @param renderFunction A custom render function.
   * @param options Element's options.
   * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
   * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
   * @returns The created element.
   */
  createRawElement(e, t, n, s = {}) {
    const o = new pl(this.document, e, t);
    return n && (o.render = n), s.renderUnsafeAttributes && o._unsafeAttributesToRender.push(...s.renderUnsafeAttributes), o;
  }
  /**
   * Adds or overwrites the element's attribute with a specified key and value.
   *
   * ```ts
   * writer.setAttribute( 'href', 'http://ckeditor.com', linkElement );
   * ```
   *
   * @param key The attribute key.
   * @param value The attribute value.
   */
  setAttribute(e, t, n) {
    n._setAttribute(e, t);
  }
  /**
   * Removes attribute from the element.
   *
   * ```ts
   * writer.removeAttribute( 'href', linkElement );
   * ```
   *
   * @param key Attribute key.
   */
  removeAttribute(e, t) {
    t._removeAttribute(e);
  }
  /**
   * Adds specified class to the element.
   *
   * ```ts
   * writer.addClass( 'foo', linkElement );
   * writer.addClass( [ 'foo', 'bar' ], linkElement );
   * ```
   */
  addClass(e, t) {
    t._addClass(e);
  }
  /**
   * Removes specified class from the element.
   *
   * ```ts
   * writer.removeClass( 'foo', linkElement );
   * writer.removeClass( [ 'foo', 'bar' ], linkElement );
   * ```
   */
  removeClass(e, t) {
    t._removeClass(e);
  }
  setStyle(e, t, n) {
    Ne(e) && n === void 0 ? t._setStyle(e) : n._setStyle(e, t);
  }
  /**
   * Removes specified style from the element.
   *
   * ```ts
   * writer.removeStyle( 'color', element ); // Removes 'color' style.
   * writer.removeStyle( [ 'color', 'border-top' ], element ); // Removes both 'color' and 'border-top' styles.
   * ```
   *
   * **Note**: This method can work with normalized style names if
   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
   * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.
   */
  removeStyle(e, t) {
    t._removeStyle(e);
  }
  /**
   * Sets a custom property on element. Unlike attributes, custom properties are not rendered to the DOM,
   * so they can be used to add special data to elements.
   */
  setCustomProperty(e, t, n) {
    n._setCustomProperty(e, t);
  }
  /**
   * Removes a custom property stored under the given key.
   *
   * @returns Returns true if property was removed.
   */
  removeCustomProperty(e, t) {
    return t._removeCustomProperty(e);
  }
  /**
   * Breaks attribute elements at the provided position or at the boundaries of a provided range. It breaks attribute elements
   * up to their first ancestor that is a container element.
   *
   * In following examples `<p>` is a container, `<b>` and `<u>` are attribute elements:
   *
   * ```html
   * <p>foo<b><u>bar{}</u></b></p> -> <p>foo<b><u>bar</u></b>[]</p>
   * <p>foo<b><u>{}bar</u></b></p> -> <p>foo{}<b><u>bar</u></b></p>
   * <p>foo<b><u>b{}ar</u></b></p> -> <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>
   * <p><b>fo{o</b><u>ba}r</u></p> -> <p><b>fo</b><b>o</b><u>ba</u><u>r</u></b></p>
   * ```
   *
   * **Note:** {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.
   *
   * **Note:** The difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes()} and
   * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer()} is that `breakAttributes()` breaks all
   * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of a given `position`,
   * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.
   * `breakContainer()` assumes that a given `position` is directly in the container element and breaks that container element.
   *
   * Throws the `view-writer-invalid-range-container` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
   * when the {@link module:engine/view/range~Range#start start}
   * and {@link module:engine/view/range~Range#end end} positions of a passed range are not placed inside same parent container.
   *
   * Throws the `view-writer-cannot-break-empty-element` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
   * when trying to break attributes inside an {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.
   *
   * Throws the `view-writer-cannot-break-ui-element` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
   * when trying to break attributes inside a {@link module:engine/view/uielement~UIElement UIElement}.
   *
   * @see module:engine/view/attributeelement~AttributeElement
   * @see module:engine/view/containerelement~ContainerElement
   * @see module:engine/view/downcastwriter~DowncastWriter#breakContainer
   * @param positionOrRange The position where to break attribute elements.
   * @returns The new position or range, after breaking the attribute elements.
   */
  breakAttributes(e) {
    return e instanceof k ? this._breakAttributes(e) : this._breakAttributesRange(e);
  }
  /**
   * Breaks a {@link module:engine/view/containerelement~ContainerElement container view element} into two, at the given position.
   * The position has to be directly inside the container element and cannot be in the root. It does not break the conrainer view element
   * if the position is at the beginning or at the end of its parent element.
   *
   * ```html
   * <p>foo^bar</p> -> <p>foo</p><p>bar</p>
   * <div><p>foo</p>^<p>bar</p></div> -> <div><p>foo</p></div><div><p>bar</p></div>
   * <p>^foobar</p> -> ^<p>foobar</p>
   * <p>foobar^</p> -> <p>foobar</p>^
   * ```
   *
   * **Note:** The difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes()} and
   * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer()} is that `breakAttributes()` breaks all
   * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of a given `position`,
   * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.
   * `breakContainer()` assumes that the given `position` is directly in the container element and breaks that container element.
   *
   * @see module:engine/view/attributeelement~AttributeElement
   * @see module:engine/view/containerelement~ContainerElement
   * @see module:engine/view/downcastwriter~DowncastWriter#breakAttributes
   * @param position The position where to break the element.
   * @returns The position between broken elements. If an element has not been broken,
   * the returned position is placed either before or after it.
   */
  breakContainer(e) {
    const t = e.parent;
    if (!t.is("containerElement"))
      throw new g("view-writer-break-non-container-element", this.document);
    if (!t.parent)
      throw new g("view-writer-break-root", this.document);
    if (e.isAtStart)
      return k._createBefore(t);
    if (!e.isAtEnd) {
      const n = t._clone(!1);
      this.insert(k._createAfter(t), n);
      const s = new O(e, k._createAt(t, "end")), o = new k(n, 0);
      this.move(s, o);
    }
    return k._createAfter(t);
  }
  /**
   * Merges {@link module:engine/view/attributeelement~AttributeElement attribute elements}. It also merges text nodes if needed.
   * Only {@link module:engine/view/attributeelement~AttributeElement#isSimilar similar} attribute elements can be merged.
   *
   * In following examples `<p>` is a container and `<b>` is an attribute element:
   *
   * ```html
   * <p>foo[]bar</p> -> <p>foo{}bar</p>
   * <p><b>foo</b>[]<b>bar</b></p> -> <p><b>foo{}bar</b></p>
   * <p><b foo="bar">a</b>[]<b foo="baz">b</b></p> -> <p><b foo="bar">a</b>[]<b foo="baz">b</b></p>
   * ```
   *
   * It will also take care about empty attributes when merging:
   *
   * ```html
   * <p><b>[]</b></p> -> <p>[]</p>
   * <p><b>foo</b><i>[]</i><b>bar</b></p> -> <p><b>foo{}bar</b></p>
   * ```
   *
   * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and
   * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two
   * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}
   * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.
   *
   * @see module:engine/view/attributeelement~AttributeElement
   * @see module:engine/view/containerelement~ContainerElement
   * @see module:engine/view/downcastwriter~DowncastWriter#mergeContainers
   * @param position Merge position.
   * @returns Position after merge.
   */
  mergeAttributes(e) {
    const t = e.offset, n = e.parent;
    if (n.is("$text"))
      return e;
    if (n.is("attributeElement") && n.childCount === 0) {
      const r = n.parent, a = n.index;
      return n._remove(), this._removeFromClonedElementsGroup(n), this.mergeAttributes(new k(r, a));
    }
    const s = n.getChild(t - 1), o = n.getChild(t);
    if (!s || !o)
      return e;
    if (s.is("$text") && o.is("$text"))
      return tu(s, o);
    if (s.is("attributeElement") && o.is("attributeElement") && s.isSimilar(o)) {
      const r = s.childCount;
      return s._appendChild(o.getChildren()), o._remove(), this._removeFromClonedElementsGroup(o), this.mergeAttributes(new k(s, r));
    }
    return e;
  }
  /**
   * Merges two {@link module:engine/view/containerelement~ContainerElement container elements} that are before and after given position.
   * Precisely, the element after the position is removed and it's contents are moved to element before the position.
   *
   * ```html
   * <p>foo</p>^<p>bar</p> -> <p>foo^bar</p>
   * <div>foo</div>^<p>bar</p> -> <div>foo^bar</div>
   * ```
   *
   * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and
   * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two
   * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}
   * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.
   *
   * @see module:engine/view/attributeelement~AttributeElement
   * @see module:engine/view/containerelement~ContainerElement
   * @see module:engine/view/downcastwriter~DowncastWriter#mergeAttributes
   * @param position Merge position.
   * @returns Position after merge.
   */
  mergeContainers(e) {
    const t = e.nodeBefore, n = e.nodeAfter;
    if (!t || !n || !t.is("containerElement") || !n.is("containerElement"))
      throw new g("view-writer-merge-containers-invalid-position", this.document);
    const s = t.getChild(t.childCount - 1), o = s instanceof ne ? k._createAt(s, "end") : k._createAt(t, "end");
    return this.move(O._createIn(n), k._createAt(t, "end")), this.remove(O._createOn(n)), o;
  }
  /**
   * Inserts a node or nodes at specified position. Takes care about breaking attributes before insertion
   * and merging them afterwards.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert
   * contains instances that are not {@link module:engine/view/text~Text Texts},
   * {@link module:engine/view/attributeelement~AttributeElement AttributeElements},
   * {@link module:engine/view/containerelement~ContainerElement ContainerElements},
   * {@link module:engine/view/emptyelement~EmptyElement EmptyElements},
   * {@link module:engine/view/rawelement~RawElement RawElements} or
   * {@link module:engine/view/uielement~UIElement UIElements}.
   *
   * @param position Insertion position.
   * @param nodes Node or nodes to insert.
   * @returns Range around inserted nodes.
   */
  insert(e, t) {
    t = Ue(t) ? [...t] : [t], km(t, this.document);
    const n = t.reduce((r, a) => {
      const l = r[r.length - 1], c = !a.is("uiElement");
      return !l || l.breakAttributes != c ? r.push({
        breakAttributes: c,
        nodes: [a]
      }) : l.nodes.push(a), r;
    }, []);
    let s = null, o = e;
    for (const { nodes: r, breakAttributes: a } of n) {
      const l = this._insertNodes(o, r, a);
      s || (s = l.start), o = l.end;
    }
    return s ? new O(s, o) : new O(e);
  }
  /**
   * Removes provided range from the container.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
   * same parent container.
   *
   * @param rangeOrItem Range to remove from container
   * or an {@link module:engine/view/item~Item item} to remove. If range is provided, after removing, it will be updated
   * to a collapsed range showing the new position.
   * @returns Document fragment containing removed nodes.
   */
  remove(e) {
    const t = e instanceof O ? e : O._createOn(e);
    if (wi(t, this.document), t.isCollapsed)
      return new rn(this.document);
    const { start: n, end: s } = this._breakAttributesRange(t, !0), o = n.parent, r = s.offset - n.offset, a = o._removeChildren(n.offset, r);
    for (const c of a)
      this._removeFromClonedElementsGroup(c);
    const l = this.mergeAttributes(n);
    return t.start = l, t.end = l.clone(), new rn(this.document, a);
  }
  /**
   * Removes matching elements from given range.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
   * same parent container.
   *
   * @param range Range to clear.
   * @param element Element to remove.
   */
  clear(e, t) {
    wi(e, this.document);
    const n = e.getWalker({
      direction: "backward",
      ignoreElementEnd: !0
    });
    for (const s of n) {
      const o = s.item;
      let r;
      if (o.is("element") && t.isSimilar(o))
        r = O._createOn(o);
      else if (!s.nextPosition.isAfter(e.start) && o.is("$textProxy")) {
        const a = o.getAncestors().find((l) => l.is("element") && t.isSimilar(l));
        a && (r = O._createIn(a));
      }
      r && (r.end.isAfter(e.end) && (r.end = e.end), r.start.isBefore(e.start) && (r.start = e.start), this.remove(r));
    }
  }
  /**
   * Moves nodes from provided range to target position.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
   * same parent container.
   *
   * @param sourceRange Range containing nodes to move.
   * @param targetPosition Position to insert.
   * @returns Range in target container. Inserted nodes are placed between
   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions.
   */
  move(e, t) {
    let n;
    if (t.isAfter(e.end)) {
      t = this._breakAttributes(t, !0);
      const s = t.parent, o = s.childCount;
      e = this._breakAttributesRange(e, !0), n = this.remove(e), t.offset += s.childCount - o;
    } else
      n = this.remove(e);
    return this.insert(t, n);
  }
  /**
   * Wraps elements within range with provided {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
   * If a collapsed range is provided, it will be wrapped only if it is equal to view selection.
   *
   * If a collapsed range was passed and is same as selection, the selection
   * will be moved to the inside of the wrapped attribute element.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-invalid-range-container`
   * when {@link module:engine/view/range~Range#start}
   * and {@link module:engine/view/range~Range#end} positions are not placed inside same parent container.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
   * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-nonselection-collapsed-range` when passed range
   * is collapsed and different than view selection.
   *
   * @param range Range to wrap.
   * @param attribute Attribute element to use as wrapper.
   * @returns range Range after wrapping, spanning over wrapping attribute element.
   */
  wrap(e, t) {
    if (!(t instanceof on))
      throw new g("view-writer-wrap-invalid-attribute", this.document);
    if (wi(e, this.document), e.isCollapsed) {
      let n = e.start;
      n.parent.is("element") && !bk(n.parent) && (n = n.getLastMatchingPosition((o) => o.item.is("uiElement"))), n = this._wrapPosition(n, t);
      const s = this.document.selection;
      return s.isCollapsed && s.getFirstPosition().isEqual(e.start) && this.setSelection(n), new O(n);
    } else
      return this._wrapRange(e, t);
  }
  /**
   * Unwraps nodes within provided range from attribute element.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
   * same parent container.
   */
  unwrap(e, t) {
    if (!(t instanceof on))
      throw new g("view-writer-unwrap-invalid-attribute", this.document);
    if (wi(e, this.document), e.isCollapsed)
      return e;
    const { start: n, end: s } = this._breakAttributesRange(e, !0), o = n.parent, r = this._unwrapChildren(o, n.offset, s.offset, t), a = this.mergeAttributes(r.start);
    a.isEqual(r.start) || r.end.offset--;
    const l = this.mergeAttributes(r.end);
    return new O(a, l);
  }
  /**
   * Renames element by creating a copy of renamed element but with changed name and then moving contents of the
   * old element to the new one. Keep in mind that this will invalidate all {@link module:engine/view/position~Position positions} which
   * has renamed element as {@link module:engine/view/position~Position#parent a parent}.
   *
   * New element has to be created because `Element#tagName` property in DOM is readonly.
   *
   * Since this function creates a new element and removes the given one, the new element is returned to keep reference.
   *
   * @param newName New name for element.
   * @param viewElement Element to be renamed.
   * @returns Element created due to rename.
   */
  rename(e, t) {
    const n = new Ji(this.document, e, t.getAttributes());
    return this.insert(k._createAfter(t), n), this.move(O._createIn(t), k._createAt(n, 0)), this.remove(O._createOn(t)), n;
  }
  /**
   * Cleans up memory by removing obsolete cloned elements group from the writer.
   *
   * Should be used whenever all {@link module:engine/view/attributeelement~AttributeElement attribute elements}
   * with the same {@link module:engine/view/attributeelement~AttributeElement#id id} are going to be removed from the view and
   * the group will no longer be needed.
   *
   * Cloned elements group are not removed automatically in case if the group is still needed after all its elements
   * were removed from the view.
   *
   * Keep in mind that group names are equal to the `id` property of the attribute element.
   *
   * @param groupName Name of the group to clear.
   */
  clearClonedElementsGroup(e) {
    this._cloneGroups.delete(e);
  }
  /**
   * Creates position at the given location. The location can be specified as:
   *
   * * a {@link module:engine/view/position~Position position},
   * * parent element and offset (offset defaults to `0`),
   * * parent element and `'end'` (sets position at the end of that element),
   * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
   *
   * This method is a shortcut to other constructors such as:
   *
   * * {@link #createPositionBefore},
   * * {@link #createPositionAfter},
   *
   * @param offset Offset or one of the flags. Used only when the first parameter is a {@link module:engine/view/item~Item view item}.
   */
  createPositionAt(e, t) {
    return k._createAt(e, t);
  }
  /**
   * Creates a new position after given view item.
   *
   * @param item View item after which the position should be located.
   */
  createPositionAfter(e) {
    return k._createAfter(e);
  }
  /**
   * Creates a new position before given view item.
   *
   * @param item View item before which the position should be located.
   */
  createPositionBefore(e) {
    return k._createBefore(e);
  }
  /**
   * Creates a range spanning from `start` position to `end` position.
   *
   * **Note:** This factory method creates its own {@link module:engine/view/position~Position} instances basing on passed values.
   *
   * @param start Start position.
   * @param end End position. If not set, range will be collapsed at `start` position.
   */
  createRange(e, t) {
    return new O(e, t);
  }
  /**
   * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
   */
  createRangeOn(e) {
    return O._createOn(e);
  }
  /**
   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * @param element Element which is a parent for the range.
   */
  createRangeIn(e) {
    return O._createIn(e);
  }
  createSelection(...e) {
    return new xt(...e);
  }
  /**
   * Creates placeholders for child elements of the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure
   * `elementToStructure()`} conversion helper.
   *
   * ```ts
   * const viewSlot = conversionApi.writer.createSlot();
   * const viewPosition = conversionApi.writer.createPositionAt( viewElement, 0 );
   *
   * conversionApi.writer.insert( viewPosition, viewSlot );
   * ```
   *
   * It could be filtered down to a specific subset of children (only `<foo>` model elements in this case):
   *
   * ```ts
   * const viewSlot = conversionApi.writer.createSlot( node => node.is( 'element', 'foo' ) );
   * const viewPosition = conversionApi.writer.createPositionAt( viewElement, 0 );
   *
   * conversionApi.writer.insert( viewPosition, viewSlot );
   * ```
   *
   * While providing a filtered slot, make sure to provide slots for all child nodes. A single node can not be downcasted into
   * multiple slots.
   *
   * **Note**: You should not change the order of nodes. View elements should be in the same order as model nodes.
   *
   * @param modeOrFilter The filter for child nodes.
   * @returns The slot element to be placed in to the view structure while processing
   * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure `elementToStructure()`}.
   */
  createSlot(e = "children") {
    if (!this._slotFactory)
      throw new g("view-writer-invalid-create-slot-context", this.document);
    return this._slotFactory(this, e);
  }
  /**
   * Registers a slot factory.
   *
   * @internal
   * @param slotFactory The slot factory.
   */
  _registerSlotFactory(e) {
    this._slotFactory = e;
  }
  /**
   * Clears the registered slot factory.
   *
   * @internal
   */
  _clearSlotFactory() {
    this._slotFactory = null;
  }
  /**
   * Inserts a node or nodes at the specified position. Takes care of breaking attributes before insertion
   * and merging them afterwards if requested by the breakAttributes param.
   *
   * @param position Insertion position.
   * @param nodes Node or nodes to insert.
   * @param breakAttributes Whether attributes should be broken.
   * @returns Range around inserted nodes.
   */
  _insertNodes(e, t, n) {
    let s;
    if (n ? s = da(e) : s = e.parent.is("$text") ? e.parent.parent : e.parent, !s)
      throw new g("view-writer-invalid-position-container", this.document);
    let o;
    n ? o = this._breakAttributes(e, !0) : o = e.parent.is("$text") ? Er(e) : e;
    const r = s._insertChild(o.offset, t);
    for (const u of t)
      this._addToClonedElementsGroup(u);
    const a = o.getShiftedBy(r), l = this.mergeAttributes(o);
    l.isEqual(o) || a.offset--;
    const c = this.mergeAttributes(a);
    return new O(l, c);
  }
  /**
   * Wraps children with provided `wrapElement`. Only children contained in `parent` element between
   * `startOffset` and `endOffset` will be wrapped.
   */
  _wrapChildren(e, t, n, s) {
    let o = t;
    const r = [];
    for (; o < n; ) {
      const l = e.getChild(o), c = l.is("$text"), u = l.is("attributeElement");
      if (u && this._wrapAttributeElement(s, l))
        r.push(new k(e, o));
      else if (c || !u || wk(s, l)) {
        const d = s._clone();
        l._remove(), d._appendChild(l), e._insertChild(o, d), this._addToClonedElementsGroup(d), r.push(new k(e, o));
      } else
        this._wrapChildren(l, 0, l.childCount, s);
      o++;
    }
    let a = 0;
    for (const l of r) {
      if (l.offset -= a, l.offset == t)
        continue;
      this.mergeAttributes(l).isEqual(l) || (a++, n--);
    }
    return O._createFromParentsAndOffsets(e, t, e, n);
  }
  /**
   * Unwraps children from provided `unwrapElement`. Only children contained in `parent` element between
   * `startOffset` and `endOffset` will be unwrapped.
   */
  _unwrapChildren(e, t, n, s) {
    let o = t;
    const r = [];
    for (; o < n; ) {
      const l = e.getChild(o);
      if (!l.is("attributeElement")) {
        o++;
        continue;
      }
      if (l.isSimilar(s)) {
        const c = l.getChildren(), u = l.childCount;
        l._remove(), e._insertChild(o, c), this._removeFromClonedElementsGroup(l), r.push(new k(e, o), new k(e, o + u)), o += u, n += u - 1;
        continue;
      }
      if (this._unwrapAttributeElement(s, l)) {
        r.push(new k(e, o), new k(e, o + 1)), o++;
        continue;
      }
      this._unwrapChildren(l, 0, l.childCount, s), o++;
    }
    let a = 0;
    for (const l of r) {
      if (l.offset -= a, l.offset == t || l.offset == n)
        continue;
      this.mergeAttributes(l).isEqual(l) || (a++, n--);
    }
    return O._createFromParentsAndOffsets(e, t, e, n);
  }
  /**
   * Helper function for `view.writer.wrap`. Wraps range with provided attribute element.
   * This method will also merge newly added attribute element with its siblings whenever possible.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
   * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
   *
   * @returns New range after wrapping, spanning over wrapping attribute element.
   */
  _wrapRange(e, t) {
    const { start: n, end: s } = this._breakAttributesRange(e, !0), o = n.parent, r = this._wrapChildren(o, n.offset, s.offset, t), a = this.mergeAttributes(r.start);
    a.isEqual(r.start) || r.end.offset--;
    const l = this.mergeAttributes(r.end);
    return new O(a, l);
  }
  /**
   * Helper function for {@link #wrap}. Wraps position with provided attribute element.
   * This method will also merge newly added attribute element with its siblings whenever possible.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
   * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
   *
   * @returns New position after wrapping.
   */
  _wrapPosition(e, t) {
    if (t.isSimilar(e.parent))
      return eu(e.clone());
    e.parent.is("$text") && (e = Er(e));
    const n = this.createAttributeElement("_wrapPosition-fake-element");
    n._priority = Number.POSITIVE_INFINITY, n.isSimilar = () => !1, e.parent._insertChild(e.offset, n);
    const s = new O(e, e.getShiftedBy(1));
    this.wrap(s, t);
    const o = new k(n.parent, n.index);
    n._remove();
    const r = o.nodeBefore, a = o.nodeAfter;
    return r instanceof ne && a instanceof ne ? tu(r, a) : eu(o);
  }
  /**
   * Wraps one {@link module:engine/view/attributeelement~AttributeElement AttributeElement} into another by
   * merging them if possible. When merging is possible - all attributes, styles and classes are moved from wrapper
   * element to element being wrapped.
   *
   * @param wrapper Wrapper AttributeElement.
   * @param toWrap AttributeElement to wrap using wrapper element.
   * @returns Returns `true` if elements are merged.
   */
  _wrapAttributeElement(e, t) {
    if (!nu(e, t) || e.name !== t.name || e.priority !== t.priority)
      return !1;
    for (const n of e.getAttributeKeys())
      if (!(n === "class" || n === "style") && t.hasAttribute(n) && t.getAttribute(n) !== e.getAttribute(n))
        return !1;
    for (const n of e.getStyleNames())
      if (t.hasStyle(n) && t.getStyle(n) !== e.getStyle(n))
        return !1;
    for (const n of e.getAttributeKeys())
      n === "class" || n === "style" || t.hasAttribute(n) || this.setAttribute(n, e.getAttribute(n), t);
    for (const n of e.getStyleNames())
      t.hasStyle(n) || this.setStyle(n, e.getStyle(n), t);
    for (const n of e.getClassNames())
      t.hasClass(n) || this.addClass(n, t);
    return !0;
  }
  /**
   * Unwraps {@link module:engine/view/attributeelement~AttributeElement AttributeElement} from another by removing
   * corresponding attributes, classes and styles. All attributes, classes and styles from wrapper should be present
   * inside element being unwrapped.
   *
   * @param wrapper Wrapper AttributeElement.
   * @param toUnwrap AttributeElement to unwrap using wrapper element.
   * @returns Returns `true` if elements are unwrapped.
   **/
  _unwrapAttributeElement(e, t) {
    if (!nu(e, t) || e.name !== t.name || e.priority !== t.priority)
      return !1;
    for (const n of e.getAttributeKeys())
      if (!(n === "class" || n === "style") && (!t.hasAttribute(n) || t.getAttribute(n) !== e.getAttribute(n)))
        return !1;
    if (!t.hasClass(...e.getClassNames()))
      return !1;
    for (const n of e.getStyleNames())
      if (!t.hasStyle(n) || t.getStyle(n) !== e.getStyle(n))
        return !1;
    for (const n of e.getAttributeKeys())
      n === "class" || n === "style" || this.removeAttribute(n, t);
    return this.removeClass(Array.from(e.getClassNames()), t), this.removeStyle(Array.from(e.getStyleNames()), t), !0;
  }
  /**
   * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at the boundaries of given range.
   *
   * @param range Range which `start` and `end` positions will be used to break attributes.
   * @param forceSplitText If set to `true`, will break text nodes even if they are directly in container element.
   * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.
   * @returns New range with located at break positions.
   */
  _breakAttributesRange(e, t = !1) {
    const n = e.start, s = e.end;
    if (wi(e, this.document), e.isCollapsed) {
      const l = this._breakAttributes(e.start, t);
      return new O(l, l);
    }
    const o = this._breakAttributes(s, t), r = o.parent.childCount, a = this._breakAttributes(n, t);
    return o.offset += o.parent.childCount - r, new O(a, o);
  }
  /**
   * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at given position.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-empty-element` when break position
   * is placed inside {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-ui-element` when break position
   * is placed inside {@link module:engine/view/uielement~UIElement UIElement}.
   *
   * @param position Position where to break attributes.
   * @param forceSplitText If set to `true`, will break text nodes even if they are directly in container element.
   * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.
   * @returns New position after breaking the attributes.
   */
  _breakAttributes(e, t = !1) {
    const n = e.offset, s = e.parent;
    if (e.parent.is("emptyElement"))
      throw new g("view-writer-cannot-break-empty-element", this.document);
    if (e.parent.is("uiElement"))
      throw new g("view-writer-cannot-break-ui-element", this.document);
    if (e.parent.is("rawElement"))
      throw new g("view-writer-cannot-break-raw-element", this.document);
    if (!t && s.is("$text") && ha(s.parent) || ha(s))
      return e.clone();
    if (s.is("$text"))
      return this._breakAttributes(Er(e), t);
    const o = s.childCount;
    if (n == o) {
      const r = new k(s.parent, s.index + 1);
      return this._breakAttributes(r, t);
    } else if (n === 0) {
      const r = new k(s.parent, s.index);
      return this._breakAttributes(r, t);
    } else {
      const r = s.index + 1, a = s._clone();
      s.parent._insertChild(r, a), this._addToClonedElementsGroup(a);
      const l = s.childCount - n, c = s._removeChildren(n, l);
      a._appendChild(c);
      const u = new k(s.parent, r);
      return this._breakAttributes(u, t);
    }
  }
  /**
   * Stores the information that an {@link module:engine/view/attributeelement~AttributeElement attribute element} was
   * added to the tree. Saves the reference to the group in the given element and updates the group, so other elements
   * from the group now keep a reference to the given attribute element.
   *
   * The clones group can be obtained using {@link module:engine/view/attributeelement~AttributeElement#getElementsWithSameId}.
   *
   * Does nothing if added element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.
   *
   * @param element Attribute element to save.
   */
  _addToClonedElementsGroup(e) {
    if (!e.root.is("rootElement"))
      return;
    if (e.is("element"))
      for (const s of e.getChildren())
        this._addToClonedElementsGroup(s);
    const t = e.id;
    if (!t)
      return;
    let n = this._cloneGroups.get(t);
    n || (n = /* @__PURE__ */ new Set(), this._cloneGroups.set(t, n)), n.add(e), e._clonesGroup = n;
  }
  /**
   * Removes all the information about the given {@link module:engine/view/attributeelement~AttributeElement attribute element}
   * from its clones group.
   *
   * Keep in mind, that the element will still keep a reference to the group (but the group will not keep a reference to it).
   * This allows to reference the whole group even if the element was already removed from the tree.
   *
   * Does nothing if the element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.
   *
   * @param element Attribute element to remove.
   */
  _removeFromClonedElementsGroup(e) {
    if (e.is("element"))
      for (const s of e.getChildren())
        this._removeFromClonedElementsGroup(s);
    const t = e.id;
    if (!t)
      return;
    const n = this._cloneGroups.get(t);
    n && n.delete(e);
  }
}
function bk(i) {
  return Array.from(i.getChildren()).some((e) => !e.is("uiElement"));
}
function da(i) {
  let e = i.parent;
  for (; !ha(e); ) {
    if (!e)
      return;
    e = e.parent;
  }
  return e;
}
function wk(i, e) {
  return i.priority < e.priority ? !0 : i.priority > e.priority ? !1 : i.getIdentity() < e.getIdentity();
}
function eu(i) {
  const e = i.nodeBefore;
  if (e && e.is("$text"))
    return new k(e, e.data.length);
  const t = i.nodeAfter;
  return t && t.is("$text") ? new k(t, 0) : i;
}
function Er(i) {
  if (i.offset == i.parent.data.length)
    return new k(i.parent.parent, i.parent.index + 1);
  if (i.offset === 0)
    return new k(i.parent.parent, i.parent.index);
  const e = i.parent.data.slice(i.offset);
  return i.parent._data = i.parent.data.slice(0, i.offset), i.parent.parent._insertChild(i.parent.index + 1, new ne(i.root.document, e)), new k(i.parent.parent, i.parent.index + 1);
}
function tu(i, e) {
  const t = i.data.length;
  return i._data += e.data, e._remove(), new k(i, t);
}
const _k = [ne, on, Ji, gl, pl, Jo];
function km(i, e) {
  for (const t of i) {
    if (!_k.some((n) => t instanceof n))
      throw new g("view-writer-insert-invalid-node-type", e);
    t.is("$text") || km(t.getChildren(), e);
  }
}
function ha(i) {
  return i && (i.is("containerElement") || i.is("documentFragment"));
}
function wi(i, e) {
  const t = da(i.start), n = da(i.end);
  if (!t || !n || t !== n)
    throw new g("view-writer-invalid-range-container", e);
}
function nu(i, e) {
  return i.id === null && e.id === null;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Tm = (i) => i.createTextNode(" "), Em = (i) => {
  const e = i.createElement("span");
  return e.dataset.ckeFiller = "true", e.innerText = " ", e;
}, Am = (i) => {
  const e = i.createElement("br");
  return e.dataset.ckeFiller = "true", e;
}, nt = 7, Xi = "⁠".repeat(nt);
function Fe(i) {
  return typeof i == "string" ? i.substr(0, nt) === Xi : re(i) && i.data.substr(0, nt) === Xi;
}
function Gn(i) {
  return i.data.length == nt && Fe(i);
}
function iu(i) {
  const e = typeof i == "string" ? i : i.data;
  return Fe(i) ? e.slice(nt) : e;
}
function vk(i) {
  i.document.on("arrowKey", yk, { priority: "low" });
}
function yk(i, e) {
  if (e.keyCode == N.arrowleft) {
    const t = e.domTarget.ownerDocument.defaultView.getSelection();
    if (t.rangeCount == 1 && t.getRangeAt(0).collapsed) {
      const n = t.getRangeAt(0).startContainer, s = t.getRangeAt(0).startOffset;
      Fe(n) && s <= nt && t.collapse(n, 0);
    }
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Ck extends U() {
  /**
   * Creates a renderer instance.
   *
   * @param domConverter Converter instance.
   * @param selection View selection.
   */
  constructor(e, t) {
    super(), this.domDocuments = /* @__PURE__ */ new Set(), this.markedAttributes = /* @__PURE__ */ new Set(), this.markedChildren = /* @__PURE__ */ new Set(), this.markedTexts = /* @__PURE__ */ new Set(), this._inlineFiller = null, this._fakeSelectionContainer = null, this.domConverter = e, this.selection = t, this.set("isFocused", !1), this.set("isSelecting", !1), M.isBlink && !M.isAndroid && this.on("change:isSelecting", () => {
      this.isSelecting || this.render();
    }), this.set("isComposing", !1), this.on("change:isComposing", () => {
      this.isComposing || this.render();
    });
  }
  /**
   * Marks a view node to be updated in the DOM by {@link #render `render()`}.
   *
   * Note that only view nodes whose parents have corresponding DOM elements need to be marked to be synchronized.
   *
   * @see #markedAttributes
   * @see #markedChildren
   * @see #markedTexts
   *
   * @param type Type of the change.
   * @param node ViewNode to be marked.
   */
  markToSync(e, t) {
    if (e === "text")
      this.domConverter.mapViewToDom(t.parent) && this.markedTexts.add(t);
    else {
      if (!this.domConverter.mapViewToDom(t))
        return;
      if (e === "attributes")
        this.markedAttributes.add(t);
      else if (e === "children")
        this.markedChildren.add(t);
      else
        throw new g("view-renderer-unknown-type", this);
    }
  }
  /**
   * Renders all buffered changes ({@link #markedAttributes}, {@link #markedChildren} and {@link #markedTexts}) and
   * the current view selection (if needed) to the DOM by applying a minimal set of changes to it.
   *
   * Renderer tries not to break the text composition (e.g. IME) and x-index of the selection,
   * so it does as little as it is needed to update the DOM.
   *
   * Renderer also handles {@link module:engine/view/filler fillers}. Especially, it checks if the inline filler is needed
   * at the selection position and adds or removes it. To prevent breaking text composition inline filler will not be
   * removed as long as the selection is in the text node which needed it at first.
   */
  render() {
    if (this.isComposing && !M.isAndroid)
      return;
    let e = null;
    const t = M.isBlink && !M.isAndroid ? !this.isSelecting : !0;
    for (const n of this.markedChildren)
      this._updateChildrenMappings(n);
    t ? (this._inlineFiller && !this._isSelectionInInlineFiller() && this._removeInlineFiller(), this._inlineFiller ? e = this._getInlineFillerPosition() : this._needsInlineFillerAtSelection() && (e = this.selection.getFirstPosition(), this.markedChildren.add(e.parent))) : this._inlineFiller && this._inlineFiller.parentNode && (e = this.domConverter.domPositionToView(this._inlineFiller), e && e.parent.is("$text") && (e = k._createBefore(e.parent)));
    for (const n of this.markedAttributes)
      this._updateAttrs(n);
    for (const n of this.markedChildren)
      this._updateChildren(n, { inlineFillerPosition: e });
    for (const n of this.markedTexts)
      !this.markedChildren.has(n.parent) && this.domConverter.mapViewToDom(n.parent) && this._updateText(n, { inlineFillerPosition: e });
    if (t)
      if (e) {
        const n = this.domConverter.viewPositionToDom(e), s = n.parent.ownerDocument;
        Fe(n.parent) ? this._inlineFiller = n.parent : this._inlineFiller = su(s, n.parent, n.offset);
      } else
        this._inlineFiller = null;
    this._updateFocus(), this._updateSelection(), this.domConverter._clearTemporaryCustomProperties(), this.markedTexts.clear(), this.markedAttributes.clear(), this.markedChildren.clear();
  }
  /**
   * Updates mappings of view element's children.
   *
   * Children that were replaced in the view structure by similar elements (same tag name) are treated as 'replaced'.
   * This means that their mappings can be updated so the new view elements are mapped to the existing DOM elements.
   * Thanks to that these elements do not need to be re-rendered completely.
   *
   * @param viewElement The view element whose children mappings will be updated.
   */
  _updateChildrenMappings(e) {
    const t = this.domConverter.mapViewToDom(e);
    if (!t)
      return;
    const n = Array.from(t.childNodes), s = Array.from(this.domConverter.viewChildrenToDom(e, { withChildren: !1 })), o = this._diffNodeLists(n, s), r = this._findUpdateActions(o, n, s, Tk);
    if (r.indexOf("update") !== -1) {
      const a = { equal: 0, insert: 0, delete: 0 };
      for (const l of r)
        if (l === "update") {
          const c = a.equal + a.insert, u = a.equal + a.delete, d = e.getChild(c);
          d && !d.is("uiElement") && !d.is("rawElement") && this._updateElementMappings(d, n[u]), Hc(s[c]), a.equal++;
        } else
          a[l]++;
    }
  }
  /**
   * Updates mappings of a given view element.
   *
   * @param viewElement The view element whose mappings will be updated.
   * @param domElement The DOM element representing the given view element.
   */
  _updateElementMappings(e, t) {
    this.domConverter.unbindDomElement(t), this.domConverter.bindElements(t, e), this.markedChildren.add(e), this.markedAttributes.add(e);
  }
  /**
   * Gets the position of the inline filler based on the current selection.
   * Here, we assume that we know that the filler is needed and
   * {@link #_isSelectionInInlineFiller is at the selection position}, and, since it is needed,
   * it is somewhere at the selection position.
   *
   * Note: The filler position cannot be restored based on the filler's DOM text node, because
   * when this method is called (before rendering), the bindings will often be broken. View-to-DOM
   * bindings are only dependable after rendering.
   */
  _getInlineFillerPosition() {
    const e = this.selection.getFirstPosition();
    return e.parent.is("$text") ? k._createBefore(e.parent) : e;
  }
  /**
   * Returns `true` if the selection has not left the inline filler's text node.
   * If it is `true`, it means that the filler had been added for a reason and the selection did not
   * leave the filler's text node. For example, the user can be in the middle of a composition so it should not be touched.
   *
   * @returns `true` if the inline filler and selection are in the same place.
   */
  _isSelectionInInlineFiller() {
    if (this.selection.rangeCount != 1 || !this.selection.isCollapsed)
      return !1;
    const e = this.selection.getFirstPosition(), t = this.domConverter.viewPositionToDom(e);
    return !!(t && re(t.parent) && Fe(t.parent));
  }
  /**
   * Removes the inline filler.
   */
  _removeInlineFiller() {
    const e = this._inlineFiller;
    if (!Fe(e))
      throw new g("view-renderer-filler-was-lost", this);
    Gn(e) ? e.remove() : e.data = e.data.substr(nt), this._inlineFiller = null;
  }
  /**
   * Checks if the inline {@link module:engine/view/filler filler} should be added.
   *
   * @returns `true` if the inline filler should be added.
   */
  _needsInlineFillerAtSelection() {
    if (this.selection.rangeCount != 1 || !this.selection.isCollapsed)
      return !1;
    const e = this.selection.getFirstPosition(), t = e.parent, n = e.offset;
    if (!this.domConverter.mapViewToDom(t.root) || !t.is("element") || !kk(t))
      return !1;
    const s = e.nodeBefore, o = e.nodeAfter;
    return !(s instanceof ne || o instanceof ne || n === t.getFillerOffset() && (!s || !s.is("element", "br")) || M.isAndroid && (s || o));
  }
  /**
   * Checks if text needs to be updated and possibly updates it.
   *
   * @param viewText View text to update.
   * @param options.inlineFillerPosition The position where the inline filler should be rendered.
   */
  _updateText(e, t) {
    const n = this.domConverter.findCorrespondingDomText(e);
    let o = this.domConverter.viewToDom(e).data;
    const r = t.inlineFillerPosition;
    r && r.parent == e.parent && r.offset == e.index && (o = Xi + o), ou(n, o);
  }
  /**
   * Checks if attribute list needs to be updated and possibly updates it.
   *
   * @param viewElement The view element to update.
   */
  _updateAttrs(e) {
    const t = this.domConverter.mapViewToDom(e);
    if (!t)
      return;
    const n = Array.from(t.attributes).map((o) => o.name), s = e.getAttributeKeys();
    for (const o of s)
      this.domConverter.setDomElementAttribute(t, o, e.getAttribute(o), e);
    for (const o of n)
      e.hasAttribute(o) || this.domConverter.removeDomElementAttribute(t, o);
  }
  /**
   * Checks if elements child list needs to be updated and possibly updates it.
   *
   * Note that on Android, to reduce the risk of composition breaks, it tries to update data of an existing
   * child text nodes instead of replacing them completely.
   *
   * @param viewElement View element to update.
   * @param options.inlineFillerPosition The position where the inline filler should be rendered.
   */
  _updateChildren(e, t) {
    const n = this.domConverter.mapViewToDom(e);
    if (!n)
      return;
    if (M.isAndroid) {
      let d = null;
      for (const h of Array.from(n.childNodes)) {
        if (d && re(d) && re(h)) {
          n.normalize();
          break;
        }
        d = h;
      }
    }
    const s = t.inlineFillerPosition, o = n.childNodes, r = Array.from(this.domConverter.viewChildrenToDom(e, { bind: !0 }));
    s && s.parent === e && su(n.ownerDocument, r, s.offset);
    const a = this._diffNodeLists(o, r), l = this._findUpdateActions(a, o, r, Ek);
    let c = 0;
    const u = /* @__PURE__ */ new Set();
    for (const d of l)
      d === "delete" ? (u.add(o[c]), Hc(o[c])) : (d === "equal" || d === "update") && c++;
    c = 0;
    for (const d of l)
      d === "insert" ? (lm(n, c, r[c]), c++) : d === "update" ? (ou(o[c], r[c].data), c++) : d === "equal" && (this._markDescendantTextToSync(this.domConverter.domToView(r[c])), c++);
    for (const d of u)
      d.parentNode || this.domConverter.unbindDomElement(d);
  }
  /**
   * Shorthand for diffing two arrays or node lists of DOM nodes.
   *
   * @param actualDomChildren Actual DOM children
   * @param expectedDomChildren Expected DOM children.
   * @returns The list of actions based on the {@link module:utils/diff~diff} function.
   */
  _diffNodeLists(e, t) {
    return e = Ik(e, this._fakeSelectionContainer), Bi(e, t, Ak.bind(null, this.domConverter));
  }
  /**
   * Finds DOM nodes that were replaced with the similar nodes (same tag name) in the view. All nodes are compared
   * within one `insert`/`delete` action group, for example:
   *
   * ```
   * Actual DOM:		<p><b>Foo</b>Bar<i>Baz</i><b>Bax</b></p>
   * Expected DOM:	<p>Bar<b>123</b><i>Baz</i><b>456</b></p>
   * Input actions:	[ insert, insert, delete, delete, equal, insert, delete ]
   * Output actions:	[ insert, replace, delete, equal, replace ]
   * ```
   *
   * @param actions Actions array which is a result of the {@link module:utils/diff~diff} function.
   * @param actualDom Actual DOM children
   * @param expectedDom Expected DOM children.
   * @param comparator A comparator function that should return `true` if the given node should be reused
   * (either by the update of a text node data or an element children list for similar elements).
   * @returns Actions array modified with the `update` actions.
   */
  _findUpdateActions(e, t, n, s) {
    if (e.indexOf("insert") === -1 || e.indexOf("delete") === -1)
      return e;
    let o = [], r = [], a = [];
    const l = { equal: 0, insert: 0, delete: 0 };
    for (const c of e)
      c === "insert" ? a.push(n[l.equal + l.insert]) : c === "delete" ? r.push(t[l.equal + l.delete]) : (o = o.concat(Bi(r, a, s).map((u) => u === "equal" ? "update" : u)), o.push("equal"), r = [], a = []), l[c]++;
    return o.concat(Bi(r, a, s).map((c) => c === "equal" ? "update" : c));
  }
  /**
   * Marks text nodes to be synchronized.
   *
   * If a text node is passed, it will be marked. If an element is passed, all descendant text nodes inside it will be marked.
   *
   * @param viewNode View node to sync.
   */
  _markDescendantTextToSync(e) {
    if (e) {
      if (e.is("$text"))
        this.markedTexts.add(e);
      else if (e.is("element"))
        for (const t of e.getChildren())
          this._markDescendantTextToSync(t);
    }
  }
  /**
   * Checks if the selection needs to be updated and possibly updates it.
   */
  _updateSelection() {
    if (M.isBlink && !M.isAndroid && this.isSelecting && !this.markedChildren.size)
      return;
    if (this.selection.rangeCount === 0) {
      this._removeDomSelection(), this._removeFakeSelection();
      return;
    }
    const e = this.domConverter.mapViewToDom(this.selection.editableElement);
    !this.isFocused || !e || (this.selection.isFake ? this._updateFakeSelection(e) : this._fakeSelectionContainer && this._fakeSelectionContainer.isConnected ? (this._removeFakeSelection(), this._updateDomSelection(e)) : this.isComposing && M.isAndroid || this._updateDomSelection(e));
  }
  /**
   * Updates the fake selection.
   *
   * @param domRoot A valid DOM root where the fake selection container should be added.
   */
  _updateFakeSelection(e) {
    const t = e.ownerDocument;
    this._fakeSelectionContainer || (this._fakeSelectionContainer = Sk(t));
    const n = this._fakeSelectionContainer;
    if (this.domConverter.bindFakeSelection(n, this.selection), !this._fakeSelectionNeedsUpdate(e))
      return;
    (!n.parentElement || n.parentElement != e) && e.appendChild(n), n.textContent = this.selection.fakeSelectionLabel || " ";
    const s = t.getSelection(), o = t.createRange();
    s.removeAllRanges(), o.selectNodeContents(n), s.addRange(o);
  }
  /**
   * Updates the DOM selection.
   *
   * @param domRoot A valid DOM root where the DOM selection should be rendered.
   */
  _updateDomSelection(e) {
    const t = e.ownerDocument.defaultView.getSelection();
    if (!this._domSelectionNeedsUpdate(t))
      return;
    const n = this.domConverter.viewPositionToDom(this.selection.anchor), s = this.domConverter.viewPositionToDom(this.selection.focus);
    t.setBaseAndExtent(n.parent, n.offset, s.parent, s.offset), M.isGecko && xk(s, t);
  }
  /**
   * Checks whether a given DOM selection needs to be updated.
   *
   * @param domSelection The DOM selection to check.
   */
  _domSelectionNeedsUpdate(e) {
    if (!this.domConverter.isDomSelectionCorrect(e))
      return !0;
    const t = e && this.domConverter.domSelectionToView(e);
    return !(t && this.selection.isEqual(t) || !this.selection.isCollapsed && this.selection.isSimilar(t));
  }
  /**
   * Checks whether the fake selection needs to be updated.
   *
   * @param domRoot A valid DOM root where a new fake selection container should be added.
   */
  _fakeSelectionNeedsUpdate(e) {
    const t = this._fakeSelectionContainer, n = e.ownerDocument.getSelection();
    return !t || t.parentElement !== e || n.anchorNode !== t && !t.contains(n.anchorNode) ? !0 : t.textContent !== this.selection.fakeSelectionLabel;
  }
  /**
   * Removes the DOM selection.
   */
  _removeDomSelection() {
    for (const e of this.domDocuments) {
      const t = e.getSelection();
      if (t.rangeCount) {
        const n = e.activeElement, s = this.domConverter.mapDomToView(n);
        n && s && t.removeAllRanges();
      }
    }
  }
  /**
   * Removes the fake selection.
   */
  _removeFakeSelection() {
    const e = this._fakeSelectionContainer;
    e && e.remove();
  }
  /**
   * Checks if focus needs to be updated and possibly updates it.
   */
  _updateFocus() {
    if (this.isFocused) {
      const e = this.selection.editableElement;
      e && this.domConverter.focus(e);
    }
  }
}
function kk(i) {
  if (i.getAttribute("contenteditable") == "false")
    return !1;
  const e = i.findAncestor((t) => t.hasAttribute("contenteditable"));
  return !e || e.getAttribute("contenteditable") == "true";
}
function su(i, e, t) {
  const n = e instanceof Array ? e : e.childNodes, s = n[t];
  if (re(s))
    return s.data = Xi + s.data, s;
  {
    const o = i.createTextNode(Xi);
    return Array.isArray(e) ? n.splice(t, 0, o) : lm(e, t, o), o;
  }
}
function Tk(i, e) {
  return Ut(i) && Ut(e) && !re(i) && !re(e) && !Oi(i) && !Oi(e) && i.tagName.toLowerCase() === e.tagName.toLowerCase();
}
function Ek(i, e) {
  return Ut(i) && Ut(e) && re(i) && re(e);
}
function Ak(i, e, t) {
  return e === t ? !0 : re(e) && re(t) ? e.data === t.data : !!(i.isBlockFiller(e) && i.isBlockFiller(t));
}
function xk(i, e) {
  let t = i.parent, n = i.offset;
  if (re(t) && Gn(t) && (n = Pi(t) + 1, t = t.parentNode), t.nodeType != Node.ELEMENT_NODE || n != t.childNodes.length - 1)
    return;
  const s = t.childNodes[n];
  s && s.tagName == "BR" && e.addRange(e.getRangeAt(0));
}
function Ik(i, e) {
  const t = Array.from(i);
  return t.length == 0 || !e || t[t.length - 1] == e && t.pop(), t;
}
function Sk(i) {
  const e = i.createElement("div");
  return e.className = "ck-fake-selection-container", Object.assign(e.style, {
    position: "fixed",
    top: 0,
    left: "-9999px",
    // See https://github.com/ckeditor/ckeditor5/issues/752.
    width: "42px"
  }), e.textContent = " ", e;
}
function ou(i, e) {
  const t = i.data;
  if (t == e)
    return;
  const n = of(t, e);
  for (const s of n)
    s.type === "insert" ? i.insertData(s.index, s.values.join("")) : i.deleteData(s.index, s.howMany);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Pk = Am(E.document), Rk = Tm(E.document), Vk = Em(E.document), Ps = "data-ck-unsafe-attribute-", ru = "data-ck-unsafe-element";
class Xo {
  /**
   * Creates a DOM converter.
   *
   * @param document The view document instance.
   * @param options An object with configuration options.
   * @param options.blockFillerMode The type of the block filler to use.
   * Default value depends on the options.renderingMode:
   *  'nbsp' when options.renderingMode == 'data',
   *  'br' when options.renderingMode == 'editing'.
   * @param options.renderingMode Whether to leave the View-to-DOM conversion result unchanged
   * or improve editing experience by filtering out interactive data.
   */
  constructor(e, { blockFillerMode: t, renderingMode: n = "editing" } = {}) {
    this._domToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToDomMapping = /* @__PURE__ */ new WeakMap(), this._fakeSelectionMapping = /* @__PURE__ */ new WeakMap(), this._rawContentElementMatcher = new ot(), this._inlineObjectElementMatcher = new ot(), this._elementsWithTemporaryCustomProperties = /* @__PURE__ */ new Set(), this.document = e, this.renderingMode = n, this.blockFillerMode = t || (n === "editing" ? "br" : "nbsp"), this.preElements = ["pre"], this.blockElements = [
      "address",
      "article",
      "aside",
      "blockquote",
      "caption",
      "center",
      "dd",
      "details",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "legend",
      "li",
      "main",
      "menu",
      "nav",
      "ol",
      "p",
      "pre",
      "section",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "tr",
      "ul"
    ], this.inlineObjectElements = [
      "object",
      "iframe",
      "input",
      "button",
      "textarea",
      "select",
      "option",
      "video",
      "embed",
      "audio",
      "img",
      "canvas"
    ], this.unsafeElements = ["script", "style"], this._domDocument = this.renderingMode === "editing" ? E.document : E.document.implementation.createHTMLDocument("");
  }
  /**
   * Binds a given DOM element that represents fake selection to a **position** of a
   * {@link module:engine/view/documentselection~DocumentSelection document selection}.
   * Document selection copy is stored and can be retrieved by the
   * {@link module:engine/view/domconverter~DomConverter#fakeSelectionToView} method.
   */
  bindFakeSelection(e, t) {
    this._fakeSelectionMapping.set(e, new xt(t));
  }
  /**
   * Returns a {@link module:engine/view/selection~Selection view selection} instance corresponding to a given
   * DOM element that represents fake selection. Returns `undefined` if binding to the given DOM element does not exist.
   */
  fakeSelectionToView(e) {
    return this._fakeSelectionMapping.get(e);
  }
  /**
   * Binds DOM and view elements, so it will be possible to get corresponding elements using
   * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and
   * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.
   *
   * @param domElement The DOM element to bind.
   * @param viewElement The view element to bind.
   */
  bindElements(e, t) {
    this._domToViewMapping.set(e, t), this._viewToDomMapping.set(t, e);
  }
  /**
   * Unbinds a given DOM element from the view element it was bound to. Unbinding is deep, meaning that all children of
   * the DOM element will be unbound too.
   *
   * @param domElement The DOM element to unbind.
   */
  unbindDomElement(e) {
    const t = this._domToViewMapping.get(e);
    if (t) {
      this._domToViewMapping.delete(e), this._viewToDomMapping.delete(t);
      for (const n of Array.from(e.children))
        this.unbindDomElement(n);
    }
  }
  /**
   * Binds DOM and view document fragments, so it will be possible to get corresponding document fragments using
   * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and
   * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.
   *
   * @param domFragment The DOM document fragment to bind.
   * @param viewFragment The view document fragment to bind.
   */
  bindDocumentFragments(e, t) {
    this._domToViewMapping.set(e, t), this._viewToDomMapping.set(t, e);
  }
  /**
   * Decides whether a given pair of attribute key and value should be passed further down the pipeline.
   *
   * @param elementName Element name in lower case.
   */
  shouldRenderAttribute(e, t, n) {
    return this.renderingMode === "data" ? !0 : (e = e.toLowerCase(), e.startsWith("on") || e === "srcdoc" && t.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i) ? !1 : n === "img" && (e === "src" || e === "srcset") || n === "source" && e === "srcset" ? !0 : !t.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i));
  }
  /**
   * Set `domElement`'s content using provided `html` argument. Apply necessary filtering for the editing pipeline.
   *
   * @param domElement DOM element that should have `html` set as its content.
   * @param html Textual representation of the HTML that will be set on `domElement`.
   */
  setContentOf(e, t) {
    if (this.renderingMode === "data") {
      e.innerHTML = t;
      return;
    }
    const n = new DOMParser().parseFromString(t, "text/html"), s = n.createDocumentFragment(), o = n.body.childNodes;
    for (; o.length > 0; )
      s.appendChild(o[0]);
    const r = n.createTreeWalker(s, NodeFilter.SHOW_ELEMENT), a = [];
    let l;
    for (; l = r.nextNode(); )
      a.push(l);
    for (const c of a) {
      for (const d of c.getAttributeNames())
        this.setDomElementAttribute(c, d, c.getAttribute(d));
      const u = c.tagName.toLowerCase();
      this._shouldRenameElement(u) && (lu(u), c.replaceWith(this._createReplacementDomElement(u, c)));
    }
    for (; e.firstChild; )
      e.firstChild.remove();
    e.append(s);
  }
  /**
   * Converts the view to the DOM. For all text nodes, not bound elements and document fragments new items will
   * be created. For bound elements and document fragments the method will return corresponding items.
   *
   * @param viewNode View node or document fragment to transform.
   * @param options Conversion options.
   * @param options.bind Determines whether new elements will be bound.
   * @param options.withChildren If `false`, node's and document fragment's children will not be converted.
   * @returns Converted node or DocumentFragment.
   */
  viewToDom(e, t = {}) {
    if (e.is("$text")) {
      const n = this._processDataFromViewText(e);
      return this._domDocument.createTextNode(n);
    } else {
      const n = e;
      if (this.mapViewToDom(n))
        if (n.getCustomProperty("editingPipeline:doNotReuseOnce"))
          this._elementsWithTemporaryCustomProperties.add(n);
        else
          return this.mapViewToDom(n);
      let s;
      if (n.is("documentFragment"))
        s = this._domDocument.createDocumentFragment(), t.bind && this.bindDocumentFragments(s, n);
      else {
        if (n.is("uiElement"))
          return n.name === "$comment" ? s = this._domDocument.createComment(n.getCustomProperty("$rawContent")) : s = n.render(this._domDocument, this), t.bind && this.bindElements(s, n), s;
        this._shouldRenameElement(n.name) ? (lu(n.name), s = this._createReplacementDomElement(n.name)) : n.hasAttribute("xmlns") ? s = this._domDocument.createElementNS(n.getAttribute("xmlns"), n.name) : s = this._domDocument.createElement(n.name), n.is("rawElement") && n.render(s, this), t.bind && this.bindElements(s, n);
        for (const o of n.getAttributeKeys())
          this.setDomElementAttribute(s, o, n.getAttribute(o), n);
      }
      if (t.withChildren !== !1)
        for (const o of this.viewChildrenToDom(n, t))
          s instanceof HTMLTemplateElement ? s.content.appendChild(o) : s.appendChild(o);
      return s;
    }
  }
  /**
   * Sets the attribute on a DOM element.
   *
   * **Note**: To remove the attribute, use {@link #removeDomElementAttribute}.
   *
   * @param domElement The DOM element the attribute should be set on.
   * @param key The name of the attribute.
   * @param value The value of the attribute.
   * @param relatedViewElement The view element related to the `domElement` (if there is any).
   * It helps decide whether the attribute set is unsafe. For instance, view elements created via the
   * {@link module:engine/view/downcastwriter~DowncastWriter} methods can allow certain attributes that would normally be filtered out.
   */
  setDomElementAttribute(e, t, n, s) {
    const o = this.shouldRenderAttribute(t, n, e.tagName.toLowerCase()) || s && s.shouldRenderUnsafeAttribute(t);
    if (o || D("domconverter-unsafe-attribute-detected", { domElement: e, key: t, value: n }), !gC(t)) {
      D("domconverter-invalid-attribute-detected", { domElement: e, key: t, value: n });
      return;
    }
    e.hasAttribute(t) && !o ? e.removeAttribute(t) : e.hasAttribute(Ps + t) && o && e.removeAttribute(Ps + t), e.setAttribute(o ? t : Ps + t, n);
  }
  /**
   * Removes an attribute from a DOM element.
   *
   * **Note**: To set the attribute, use {@link #setDomElementAttribute}.
   *
   * @param domElement The DOM element the attribute should be removed from.
   * @param key The name of the attribute.
   */
  removeDomElementAttribute(e, t) {
    t != ru && (e.removeAttribute(t), e.removeAttribute(Ps + t));
  }
  /**
   * Converts children of the view element to DOM using the
   * {@link module:engine/view/domconverter~DomConverter#viewToDom} method.
   * Additionally, this method adds block {@link module:engine/view/filler filler} to the list of children, if needed.
   *
   * @param viewElement Parent view element.
   * @param options See {@link module:engine/view/domconverter~DomConverter#viewToDom} options parameter.
   * @returns DOM nodes.
   */
  *viewChildrenToDom(e, t = {}) {
    const n = e.getFillerOffset && e.getFillerOffset();
    let s = 0;
    for (const o of e.getChildren()) {
      n === s && (yield this._getBlockFiller());
      const r = o.is("element") && !!o.getCustomProperty("dataPipeline:transparentRendering") && !me(o.getAttributes());
      r && this.renderingMode == "data" ? yield* this.viewChildrenToDom(o, t) : (r && D("domconverter-transparent-rendering-unsupported-in-editing-pipeline", { viewElement: o }), yield this.viewToDom(o, t)), s++;
    }
    n === s && (yield this._getBlockFiller());
  }
  /**
   * Converts view {@link module:engine/view/range~Range} to DOM range.
   * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.
   *
   * @param viewRange View range.
   * @returns DOM range.
   */
  viewRangeToDom(e) {
    const t = this.viewPositionToDom(e.start), n = this.viewPositionToDom(e.end), s = this._domDocument.createRange();
    return s.setStart(t.parent, t.offset), s.setEnd(n.parent, n.offset), s;
  }
  /**
   * Converts view {@link module:engine/view/position~Position} to DOM parent and offset.
   *
   * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.
   * If the converted position is directly before inline filler it is moved inside the filler.
   *
   * @param viewPosition View position.
   * @returns DOM position or `null` if view position could not be converted to DOM.
   * DOM position has two properties:
   * * `parent` - DOM position parent.
   * * `offset` - DOM position offset.
   */
  viewPositionToDom(e) {
    const t = e.parent;
    if (t.is("$text")) {
      const n = this.findCorrespondingDomText(t);
      if (!n)
        return null;
      let s = e.offset;
      return Fe(n) && (s += nt), { parent: n, offset: s };
    } else {
      let n, s, o;
      if (e.offset === 0) {
        if (n = this.mapViewToDom(t), !n)
          return null;
        o = n.childNodes[0];
      } else {
        const a = e.nodeBefore;
        if (s = a.is("$text") ? this.findCorrespondingDomText(a) : this.mapViewToDom(a), !s)
          return null;
        n = s.parentNode, o = s.nextSibling;
      }
      if (re(o) && Fe(o))
        return { parent: o, offset: nt };
      const r = s ? Pi(s) + 1 : 0;
      return { parent: n, offset: r };
    }
  }
  /**
   * Converts DOM to view. For all text nodes, not bound elements and document fragments new items will
   * be created. For bound elements and document fragments function will return corresponding items. For
   * {@link module:engine/view/filler fillers} `null` will be returned.
   * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.
   *
   * @param domNode DOM node or document fragment to transform.
   * @param options Conversion options.
   * @param options.bind Determines whether new elements will be bound. False by default.
   * @param options.withChildren If `true`, node's and document fragment's children will be converted too. True by default.
   * @param options.keepOriginalCase If `false`, node's tag name will be converted to lower case. False by default.
   * @param options.skipComments If `false`, comment nodes will be converted to `$comment`
   * {@link module:engine/view/uielement~UIElement view UI elements}. False by default.
   * @returns Converted node or document fragment or `null` if DOM node is a {@link module:engine/view/filler filler}
   * or the given node is an empty text node.
   */
  domToView(e, t = {}) {
    const n = [], s = this._domToView(e, t, n), o = s.next().value;
    return !o || (s.next(), this._processDomInlineNodes(null, n, t), o.is("$text") && o.data.length == 0) ? null : o;
  }
  /**
   * Converts children of the DOM element to view nodes using
   * the {@link module:engine/view/domconverter~DomConverter#domToView} method.
   * Additionally this method omits block {@link module:engine/view/filler filler}, if it exists in the DOM parent.
   *
   * @param domElement Parent DOM element.
   * @param options See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.
   * @param inlineNodes An array that will be populated with inline nodes. It's used internally for whitespace processing.
   * @returns View nodes.
   */
  *domChildrenToView(e, t = {}, n = []) {
    let s = [];
    e instanceof HTMLTemplateElement ? s = [...e.content.childNodes] : s = [...e.childNodes];
    for (let o = 0; o < s.length; o++) {
      const r = s[o], a = this._domToView(r, t, n), l = a.next().value;
      l !== null && (this._isBlockViewElement(l) && this._processDomInlineNodes(e, n, t), yield l, a.next());
    }
    this._processDomInlineNodes(e, n, t);
  }
  /**
   * Converts DOM selection to view {@link module:engine/view/selection~Selection}.
   * Ranges which cannot be converted will be omitted.
   *
   * @param domSelection DOM selection.
   * @returns View selection.
   */
  domSelectionToView(e) {
    if (Lk(e))
      return new xt([]);
    if (e.rangeCount === 1) {
      let s = e.getRangeAt(0).startContainer;
      re(s) && (s = s.parentNode);
      const o = this.fakeSelectionToView(s);
      if (o)
        return o;
    }
    const t = this.isDomSelectionBackward(e), n = [];
    for (let s = 0; s < e.rangeCount; s++) {
      const o = e.getRangeAt(s), r = this.domRangeToView(o);
      r && n.push(r);
    }
    return new xt(n, { backward: t });
  }
  /**
   * Converts DOM Range to view {@link module:engine/view/range~Range}.
   * If the start or end position can not be converted `null` is returned.
   *
   * @param domRange DOM range.
   * @returns View range.
   */
  domRangeToView(e) {
    const t = this.domPositionToView(e.startContainer, e.startOffset), n = this.domPositionToView(e.endContainer, e.endOffset);
    return t && n ? new O(t, n) : null;
  }
  /**
   * Converts DOM parent and offset to view {@link module:engine/view/position~Position}.
   *
   * If the position is inside a {@link module:engine/view/filler filler} which has no corresponding view node,
   * position of the filler will be converted and returned.
   *
   * If the position is inside DOM element rendered by {@link module:engine/view/uielement~UIElement}
   * that position will be converted to view position before that UIElement.
   *
   * If structures are too different and it is not possible to find corresponding position then `null` will be returned.
   *
   * @param domParent DOM position parent.
   * @param domOffset DOM position offset. You can skip it when converting the inline filler node.
   * @returns View position.
   */
  domPositionToView(e, t = 0) {
    if (this.isBlockFiller(e))
      return this.domPositionToView(e.parentNode, Pi(e));
    const n = this.mapDomToView(e);
    if (n && (n.is("uiElement") || n.is("rawElement")))
      return k._createBefore(n);
    if (re(e)) {
      if (Gn(e))
        return this.domPositionToView(e.parentNode, Pi(e));
      const s = this.findCorrespondingViewText(e);
      let o = t;
      return s ? (Fe(e) && (o -= nt, o = o < 0 ? 0 : o), new k(s, o)) : null;
    } else {
      if (t === 0) {
        const s = this.mapDomToView(e);
        if (s)
          return new k(s, 0);
      } else {
        const s = e.childNodes[t - 1];
        if (re(s) && Gn(s) || s && this.isBlockFiller(s))
          return this.domPositionToView(s.parentNode, Pi(s));
        const o = re(s) ? this.findCorrespondingViewText(s) : this.mapDomToView(s);
        if (o && o.parent)
          return new k(o.parent, o.index + 1);
      }
      return null;
    }
  }
  /**
   * Returns corresponding view {@link module:engine/view/element~Element Element} or
   * {@link module:engine/view/documentfragment~DocumentFragment} for provided DOM element or
   * document fragment. If there is no view item {@link module:engine/view/domconverter~DomConverter#bindElements bound}
   * to the given DOM - `undefined` is returned.
   *
   * For all DOM elements rendered by a {@link module:engine/view/uielement~UIElement} or
   * a {@link module:engine/view/rawelement~RawElement}, the parent `UIElement` or `RawElement` will be returned.
   *
   * @param domElementOrDocumentFragment DOM element or document fragment.
   * @returns Corresponding view element, document fragment or `undefined` if no element was bound.
   */
  mapDomToView(e) {
    return this.getHostViewElement(e) || this._domToViewMapping.get(e);
  }
  /**
   * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},
   * corresponding text node is returned based on the sibling or parent.
   *
   * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used
   * to find the corresponding text node.
   *
   * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}
   * element, it is used to find the corresponding text node.
   *
   * For all text nodes rendered by a {@link module:engine/view/uielement~UIElement} or
   * a {@link module:engine/view/rawelement~RawElement}, the parent `UIElement` or `RawElement` will be returned.
   *
   * Otherwise `null` is returned.
   *
   * Note that for the block or inline {@link module:engine/view/filler filler} this method returns `null`.
   *
   * @param domText DOM text node.
   * @returns Corresponding view text node or `null`, if it was not possible to find a corresponding node.
   */
  findCorrespondingViewText(e) {
    if (Gn(e))
      return null;
    const t = this.getHostViewElement(e);
    if (t)
      return t;
    const n = e.previousSibling;
    if (n) {
      if (!this.isElement(n))
        return null;
      const s = this.mapDomToView(n);
      if (s) {
        const o = s.nextSibling;
        return o instanceof ne ? o : null;
      }
    } else {
      const s = this.mapDomToView(e.parentNode);
      if (s) {
        const o = s.getChild(0);
        return o instanceof ne ? o : null;
      }
    }
    return null;
  }
  mapViewToDom(e) {
    return this._viewToDomMapping.get(e);
  }
  /**
   * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},
   * corresponding text node is returned based on the sibling or parent.
   *
   * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used
   * to find the corresponding text node.
   *
   * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}
   * element, it is used to find the corresponding text node.
   *
   * Otherwise `null` is returned.
   *
   * @param viewText View text node.
   * @returns Corresponding DOM text node or `null`, if it was not possible to find a corresponding node.
   */
  findCorrespondingDomText(e) {
    const t = e.previousSibling;
    return t && this.mapViewToDom(t) ? this.mapViewToDom(t).nextSibling : !t && e.parent && this.mapViewToDom(e.parent) ? this.mapViewToDom(e.parent).childNodes[0] : null;
  }
  /**
   * Focuses DOM editable that is corresponding to provided {@link module:engine/view/editableelement~EditableElement}.
   */
  focus(e) {
    const t = this.mapViewToDom(e);
    if (t && t.ownerDocument.activeElement !== t) {
      const { scrollX: n, scrollY: s } = E.window, o = [];
      au(t, (r) => {
        const { scrollLeft: a, scrollTop: l } = r;
        o.push([a, l]);
      }), t.focus(), au(t, (r) => {
        const [a, l] = o.shift();
        r.scrollLeft = a, r.scrollTop = l;
      }), E.window.scrollTo(n, s);
    }
  }
  /**
   * Remove DOM selection from blurred editable, so it won't interfere with clicking on dropdowns (especially on iOS).
   *
   * @internal
   */
  _clearDomSelection() {
    const e = this.mapViewToDom(this.document.selection.editableElement);
    if (!e)
      return;
    const t = e.ownerDocument.defaultView.getSelection(), n = this.domSelectionToView(t);
    n && n.rangeCount > 0 && t.removeAllRanges();
  }
  /**
   * Returns `true` when `node.nodeType` equals `Node.ELEMENT_NODE`.
   *
   * @param node Node to check.
   */
  isElement(e) {
    return e && e.nodeType == Node.ELEMENT_NODE;
  }
  /**
   * Returns `true` when `node.nodeType` equals `Node.DOCUMENT_FRAGMENT_NODE`.
   *
   * @param node Node to check.
   */
  isDocumentFragment(e) {
    return e && e.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
  }
  /**
   * Checks if the node is an instance of the block filler for this DOM converter.
   *
   * ```ts
   * const converter = new DomConverter( viewDocument, { blockFillerMode: 'br' } );
   *
   * converter.isBlockFiller( BR_FILLER( document ) ); // true
   * converter.isBlockFiller( NBSP_FILLER( document ) ); // false
   * ```
   *
   * **Note:**: For the `'nbsp'` mode the method also checks context of a node so it cannot be a detached node.
   *
   * **Note:** A special case in the `'nbsp'` mode exists where the `<br>` in `<p><br></p>` is treated as a block filler.
   *
   * @param domNode DOM node to check.
   * @returns True if a node is considered a block filler for given mode.
   */
  isBlockFiller(e) {
    return this.blockFillerMode == "br" ? e.isEqualNode(Pk) : e.tagName === "BR" && xm(e, this.blockElements) && e.parentNode.childNodes.length === 1 ? !0 : e.isEqualNode(Vk) || Bk(e, this.blockElements);
  }
  /**
   * Returns `true` if given selection is a backward selection, that is, if it's `focus` is before `anchor`.
   *
   * @param DOM Selection instance to check.
   */
  isDomSelectionBackward(e) {
    if (e.isCollapsed)
      return !1;
    const t = this._domDocument.createRange();
    try {
      t.setStart(e.anchorNode, e.anchorOffset), t.setEnd(e.focusNode, e.focusOffset);
    } catch (s) {
      return !1;
    }
    const n = t.collapsed;
    return t.detach(), n;
  }
  /**
   * Returns a parent {@link module:engine/view/uielement~UIElement} or {@link module:engine/view/rawelement~RawElement}
   * that hosts the provided DOM node. Returns `null` if there is no such parent.
   */
  getHostViewElement(e) {
    const t = dC(e);
    for (t.pop(); t.length; ) {
      const n = t.pop(), s = this._domToViewMapping.get(n);
      if (s && (s.is("uiElement") || s.is("rawElement")))
        return s;
    }
    return null;
  }
  /**
   * Checks if the given selection's boundaries are at correct places.
   *
   * The following places are considered as incorrect for selection boundaries:
   *
   * * before or in the middle of an inline filler sequence,
   * * inside a DOM element which represents {@link module:engine/view/uielement~UIElement a view UI element},
   * * inside a DOM element which represents {@link module:engine/view/rawelement~RawElement a view raw element}.
   *
   * @param domSelection The DOM selection object to be checked.
   * @returns `true` if the given selection is at a correct place, `false` otherwise.
   */
  isDomSelectionCorrect(e) {
    return this._isDomSelectionPositionCorrect(e.anchorNode, e.anchorOffset) && this._isDomSelectionPositionCorrect(e.focusNode, e.focusOffset);
  }
  /**
   * Registers a {@link module:engine/view/matcher~MatcherPattern} for view elements whose content should be treated as raw data
   * and not processed during the conversion from DOM nodes to view elements.
   *
   * This is affecting how {@link module:engine/view/domconverter~DomConverter#domToView} and
   * {@link module:engine/view/domconverter~DomConverter#domChildrenToView} process DOM nodes.
   *
   * The raw data can be later accessed by a
   * {@link module:engine/view/element~Element#getCustomProperty custom property of a view element} called `"$rawContent"`.
   *
   * @param pattern Pattern matching a view element whose content should
   * be treated as raw data.
   */
  registerRawContentMatcher(e) {
    this._rawContentElementMatcher.add(e);
  }
  /**
   * Registers a {@link module:engine/view/matcher~MatcherPattern} for inline object view elements.
   *
   * This is affecting how {@link module:engine/view/domconverter~DomConverter#domToView} and
   * {@link module:engine/view/domconverter~DomConverter#domChildrenToView} process DOM nodes.
   *
   * This is an extension of a simple {@link #inlineObjectElements} array of element names.
   *
   * @param pattern Pattern matching a view element which should be treated as an inline object.
   */
  registerInlineObjectMatcher(e) {
    this._inlineObjectElementMatcher.add(e);
  }
  /**
   * Clear temporary custom properties.
   *
   * @internal
   */
  _clearTemporaryCustomProperties() {
    for (const e of this._elementsWithTemporaryCustomProperties)
      e._removeCustomProperty("editingPipeline:doNotReuseOnce");
    this._elementsWithTemporaryCustomProperties.clear();
  }
  /**
   * Returns the block {@link module:engine/view/filler filler} node based on the current {@link #blockFillerMode} setting.
   */
  _getBlockFiller() {
    switch (this.blockFillerMode) {
      case "nbsp":
        return Tm(this._domDocument);
      case "markedNbsp":
        return Em(this._domDocument);
      case "br":
        return Am(this._domDocument);
    }
  }
  /**
   * Checks if the given DOM position is a correct place for selection boundary. See {@link #isDomSelectionCorrect}.
   *
   * @param domParent Position parent.
   * @param offset Position offset.
   * @returns `true` if given position is at a correct place for selection boundary, `false` otherwise.
   */
  _isDomSelectionPositionCorrect(e, t) {
    if (re(e) && Fe(e) && t < nt || this.isElement(e) && Fe(e.childNodes[t]))
      return !1;
    const n = this.mapDomToView(e);
    return !(n && (n.is("uiElement") || n.is("rawElement")));
  }
  /**
   * Internal generator for {@link #domToView}. Also used by {@link #domChildrenToView}.
   * Separates DOM nodes conversion from whitespaces processing.
   *
   * @param domNode DOM node or document fragment to transform.
   * @param inlineNodes An array of recently encountered inline nodes truncated to the block element boundaries.
   * Used later to process whitespaces.
   */
  *_domToView(e, t, n) {
    if (this.isBlockFiller(e))
      return null;
    const s = this.getHostViewElement(e);
    if (s)
      return s;
    if (Oi(e) && t.skipComments)
      return null;
    if (re(e)) {
      if (Gn(e))
        return null;
      {
        const o = e.data;
        if (o === "")
          return null;
        const r = new ne(this.document, o);
        return n.push(r), r;
      }
    } else {
      let o = this.mapDomToView(e);
      if (o)
        return this._isInlineObjectElement(o) && n.push(o), o;
      if (this.isDocumentFragment(e))
        o = new rn(this.document), t.bind && this.bindDocumentFragments(e, o);
      else {
        o = this._createViewElement(e, t), t.bind && this.bindElements(e, o);
        const a = e.attributes;
        if (a)
          for (let l = a.length, c = 0; c < l; c++)
            o._setAttribute(a[c].name, a[c].value);
        if (this._isViewElementWithRawContent(o, t))
          return o._setCustomProperty("$rawContent", e.innerHTML), this._isBlockViewElement(o) || n.push(o), o;
        if (Oi(e))
          return o._setCustomProperty("$rawContent", e.data), o;
      }
      yield o;
      const r = [];
      if (t.withChildren !== !1)
        for (const a of this.domChildrenToView(e, t, r))
          o._appendChild(a);
      if (this._isInlineObjectElement(o))
        n.push(o);
      else
        for (const a of r)
          n.push(a);
    }
  }
  /**
   * Internal helper that walks the list of inline view nodes already generated from DOM nodes
   * and handles whitespaces and NBSPs.
   *
   * @param domParent The DOM parent of the given inline nodes. This should be a document fragment or
   * a block element to whitespace processing start cleaning.
   * @param inlineNodes An array of recently encountered inline nodes truncated to the block element boundaries.
   */
  _processDomInlineNodes(e, t, n) {
    if (!t.length || e && !this.isDocumentFragment(e) && !this._isBlockDomElement(e))
      return;
    let s = !1;
    for (let o = 0; o < t.length; o++) {
      const r = t[o];
      if (!r.is("$text")) {
        s = !1;
        continue;
      }
      let a, l = !1;
      if (Mk(r, this.preElements))
        a = iu(r.data);
      else {
        a = r.data.replace(/[ \n\t\r]{1,}/g, " "), l = /[^\S\u00A0]/.test(a.charAt(a.length - 1));
        const c = o > 0 ? t[o - 1] : null, u = o + 1 < t.length ? t[o + 1] : null, d = !c || c.is("element") && c.name == "br" || s, h = u ? !1 : !Fe(r.data);
        n.withChildren !== !1 && (d && (a = a.replace(/^ /, "")), h && (a = a.replace(/ $/, ""))), a = iu(a), a = a.replace(/ \u00A0/g, "  ");
        const f = u && u.is("element") && u.name != "br", m = u && u.is("$text") && u.data.charAt(0) == " ";
        (/[ \u00A0]\u00A0$/.test(a) || !u || f || m) && (a = a.replace(/\u00A0$/, " ")), (d || c && c.is("element") && c.name != "br") && (a = a.replace(/^\u00A0/, " "));
      }
      a.length == 0 && r.parent ? (r._remove(), t.splice(o, 1), o--) : (r._data = a, s = l);
    }
    t.length = 0;
  }
  /**
   * Takes text data from a given {@link module:engine/view/text~Text#data} and processes it so
   * it is correctly displayed in the DOM.
   *
   * Following changes are done:
   *
   * * a space at the beginning is changed to `&nbsp;` if this is the first text node in its container
   * element or if a previous text node ends with a space character,
   * * space at the end of the text node is changed to `&nbsp;` if there are two spaces at the end of a node or if next node
   * starts with a space or if it is the last text node in its container,
   * * remaining spaces are replaced to a chain of spaces and `&nbsp;` (e.g. `'x   x'` becomes `'x &nbsp; x'`).
   *
   * Content of {@link #preElements} is not processed.
   *
   * @param node View text node to process.
   * @returns Processed text data.
   */
  _processDataFromViewText(e) {
    let t = e.data;
    if (e.getAncestors().some((n) => this.preElements.includes(n.name)))
      return t;
    if (t.charAt(0) == " ") {
      const n = this._getTouchingInlineViewNode(e, !1);
      (n && n.is("$textProxy") && this._nodeEndsWithSpace(n) || !n) && (t = " " + t.substr(1));
    }
    if (t.charAt(t.length - 1) == " ") {
      const n = this._getTouchingInlineViewNode(e, !0), s = n && n.is("$textProxy") && n.data.charAt(0) == " ";
      (t.charAt(t.length - 2) == " " || !n || s) && (t = t.substr(0, t.length - 1) + " ");
    }
    return t.replace(/ {2}/g, "  ");
  }
  /**
   * Checks whether given node ends with a space character after changing appropriate space characters to `&nbsp;`s.
   *
   * @param  node Node to check.
   * @returns `true` if given `node` ends with space, `false` otherwise.
   */
  _nodeEndsWithSpace(e) {
    if (e.getAncestors().some((n) => this.preElements.includes(n.name)))
      return !1;
    const t = this._processDataFromViewText(e);
    return t.charAt(t.length - 1) == " ";
  }
  /**
   * Helper function. For given {@link module:engine/view/text~Text view text node}, it finds previous or next sibling
   * that is contained in the same container element. If there is no such sibling, `null` is returned.
   *
   * @param node Reference node.
   * @returns Touching text node, an inline object
   * or `null` if there is no next or previous touching text node.
   */
  _getTouchingInlineViewNode(e, t) {
    const n = new sn({
      startPosition: t ? k._createAfter(e) : k._createBefore(e),
      direction: t ? "forward" : "backward"
    });
    for (const s of n) {
      if (s.item.is("element", "br"))
        return null;
      if (this._isInlineObjectElement(s.item))
        return s.item;
      if (s.item.is("containerElement"))
        return null;
      if (s.item.is("$textProxy"))
        return s.item;
    }
    return null;
  }
  /**
   * Returns `true` if a DOM node belongs to {@link #blockElements}. `false` otherwise.
   */
  _isBlockDomElement(e) {
    return this.isElement(e) && this.blockElements.includes(e.tagName.toLowerCase());
  }
  /**
   * Returns `true` if a view node belongs to {@link #blockElements}. `false` otherwise.
   */
  _isBlockViewElement(e) {
    return e.is("element") && this.blockElements.includes(e.name);
  }
  /**
   * Returns `true` if a DOM node belongs to {@link #inlineObjectElements}. `false` otherwise.
   */
  _isInlineObjectElement(e) {
    return e.is("element") ? e.name == "br" || this.inlineObjectElements.includes(e.name) || !!this._inlineObjectElementMatcher.match(e) : !1;
  }
  /**
   * Creates view element basing on the node type.
   *
   * @param node DOM node to check.
   * @param options Conversion options. See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.
   */
  _createViewElement(e, t) {
    if (Oi(e))
      return new Jo(this.document, "$comment");
    const n = t.keepOriginalCase ? e.tagName : e.tagName.toLowerCase();
    return new rt(this.document, n);
  }
  /**
   * Checks if view element's content should be treated as a raw data.
   *
   * @param viewElement View element to check.
   * @param options Conversion options. See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.
   */
  _isViewElementWithRawContent(e, t) {
    return t.withChildren !== !1 && e.is("element") && !!this._rawContentElementMatcher.match(e);
  }
  /**
   * Checks whether a given element name should be renamed in a current rendering mode.
   *
   * @param elementName The name of view element.
   */
  _shouldRenameElement(e) {
    const t = e.toLowerCase();
    return this.renderingMode === "editing" && this.unsafeElements.includes(t);
  }
  /**
   * Return a <span> element with a special attribute holding the name of the original element.
   * Optionally, copy all the attributes of the original element if that element is provided.
   *
   * @param elementName The name of view element.
   * @param originalDomElement The original DOM element to copy attributes and content from.
   */
  _createReplacementDomElement(e, t) {
    const n = this._domDocument.createElement("span");
    if (n.setAttribute(ru, e), t) {
      for (; t.firstChild; )
        n.appendChild(t.firstChild);
      for (const s of t.getAttributeNames())
        n.setAttribute(s, t.getAttribute(s));
    }
    return n;
  }
}
function Mk(i, e) {
  return i.getAncestors().some((t) => t.is("element") && e.includes(t.name));
}
function au(i, e) {
  let t = i;
  for (; t; )
    e(t), t = t.parentElement;
}
function Bk(i, e) {
  return i.isEqualNode(Rk) && xm(i, e) && i.parentNode.childNodes.length === 1;
}
function xm(i, e) {
  const t = i.parentNode;
  return !!t && !!t.tagName && e.includes(t.tagName.toLowerCase());
}
function lu(i) {
  i === "script" && D("domconverter-unsafe-script-element-detected"), i === "style" && D("domconverter-unsafe-style-element-detected");
}
function Lk(i) {
  if (!M.isGecko || !i.rangeCount)
    return !1;
  const e = i.getRangeAt(0).startContainer;
  try {
    Object.prototype.toString.call(e);
  } catch (t) {
    return !0;
  }
  return !1;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class wt extends Le() {
  /**
   * Creates an instance of the observer.
   */
  constructor(e) {
    super(), this._isEnabled = !1, this.view = e, this.document = e.document;
  }
  /**
   * The state of the observer. If it is disabled, no events will be fired.
   */
  get isEnabled() {
    return this._isEnabled;
  }
  /**
   * Enables the observer. This method is called when the observer is registered to the
   * {@link module:engine/view/view~View} and after {@link module:engine/view/view~View#forceRender rendering}
   * (all observers are {@link #disable disabled} before rendering).
   *
   * A typical use case for disabling observers is that mutation observers need to be disabled for the rendering.
   * However, a child class may not need to be disabled, so it can implement an empty method.
   *
   * @see module:engine/view/observer/observer~Observer#disable
   */
  enable() {
    this._isEnabled = !0;
  }
  /**
   * Disables the observer. This method is called before
   * {@link module:engine/view/view~View#forceRender rendering} to prevent firing events during rendering.
   *
   * @see module:engine/view/observer/observer~Observer#enable
   */
  disable() {
    this._isEnabled = !1;
  }
  /**
   * Disables and destroys the observer, among others removes event listeners created by the observer.
   */
  destroy() {
    this.disable(), this.stopListening();
  }
  /**
   * Checks whether a given DOM event should be ignored (should not be turned into a synthetic view document event).
   *
   * Currently, an event will be ignored only if its target or any of its ancestors has the `data-cke-ignore-events` attribute.
   * This attribute can be used inside the structures generated by
   * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement `DowncastWriter#createUIElement()`} to ignore events
   * fired within a UI that should be excluded from CKEditor 5's realms.
   *
   * @param domTarget The DOM event target to check (usually an element, sometimes a text node and
   * potentially sometimes a document, too).
   * @returns Whether this event should be ignored by the observer.
   */
  checkShouldIgnoreEventFromTarget(e) {
    return e && e.nodeType === 3 && (e = e.parentNode), !e || e.nodeType !== 1 ? !1 : e.matches("[data-cke-ignore-events], [data-cke-ignore-events] *");
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Yn {
  /**
   * @param view The instance of the view controller.
   * @param domEvent The DOM event.
   * @param additionalData Additional properties that the instance should contain.
   */
  constructor(e, t, n) {
    this.view = e, this.document = e.document, this.domEvent = t, this.domTarget = t.target, kf(this, n);
  }
  /**
   * The tree view element representing the target.
   */
  get target() {
    return this.view.domConverter.mapDomToView(this.domTarget);
  }
  /**
   * Prevents the native's event default action.
   */
  preventDefault() {
    this.domEvent.preventDefault();
  }
  /**
   * Stops native event propagation.
   */
  stopPropagation() {
    this.domEvent.stopPropagation();
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Gt extends wt {
  constructor() {
    super(...arguments), this.useCapture = !1;
  }
  /**
   * @inheritDoc
   */
  observe(e) {
    (typeof this.domEventType == "string" ? [this.domEventType] : this.domEventType).forEach((n) => {
      this.listenTo(e, n, (s, o) => {
        this.isEnabled && !this.checkShouldIgnoreEventFromTarget(o.target) && this.onDomEvent(o);
      }, { useCapture: this.useCapture });
    });
  }
  /**
   * @inheritDoc
   */
  stopObserving(e) {
    this.stopListening(e);
  }
  /**
   * Calls `Document#fire()` if observer {@link #isEnabled is enabled}.
   *
   * @see module:utils/emittermixin~Emitter#fire
   * @param eventType The event type (name).
   * @param domEvent The DOM event.
   * @param additionalData The additional data which should extend the
   * {@link module:engine/view/observer/domeventdata~DomEventData event data} object.
   */
  fire(e, t, n) {
    this.isEnabled && this.document.fire(e, new Yn(this.view, t, n));
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Ok extends Gt {
  constructor() {
    super(...arguments), this.domEventType = ["keydown", "keyup"];
  }
  /**
   * @inheritDoc
   */
  onDomEvent(e) {
    const t = {
      keyCode: e.keyCode,
      altKey: e.altKey,
      ctrlKey: e.ctrlKey,
      shiftKey: e.shiftKey,
      metaKey: e.metaKey,
      get keystroke() {
        return Qn(this);
      }
    };
    this.fire(e.type, e, t);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Fk extends wt {
  /**
   * Creates new FakeSelectionObserver instance.
   */
  constructor(e) {
    super(e), this._fireSelectionChangeDoneDebounced = Pt((t) => {
      this.document.fire("selectionChangeDone", t);
    }, 200);
  }
  /**
   * @inheritDoc
   */
  observe() {
    const e = this.document;
    e.on("arrowKey", (t, n) => {
      e.selection.isFake && this.isEnabled && n.preventDefault();
    }, { context: "$capture" }), e.on("arrowKey", (t, n) => {
      e.selection.isFake && this.isEnabled && this._handleSelectionMove(n.keyCode);
    }, { priority: "lowest" });
  }
  /**
   * @inheritDoc
   */
  stopObserving() {
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this._fireSelectionChangeDoneDebounced.cancel();
  }
  /**
   * Handles collapsing view selection according to given key code. If left or up key is provided - new selection will be
   * collapsed to left. If right or down key is pressed - new selection will be collapsed to right.
   *
   * This method fires {@link module:engine/view/document~Document#event:selectionChange} and
   * {@link module:engine/view/document~Document#event:selectionChangeDone} events imitating behaviour of
   * {@link module:engine/view/observer/selectionobserver~SelectionObserver}.
   */
  _handleSelectionMove(e) {
    const t = this.document.selection, n = new xt(t.getRanges(), { backward: t.isBackward, fake: !1 });
    (e == N.arrowleft || e == N.arrowup) && n.setTo(n.getFirstPosition()), (e == N.arrowright || e == N.arrowdown) && n.setTo(n.getLastPosition());
    const s = {
      oldSelection: t,
      newSelection: n,
      domSelection: null
    };
    this.document.fire("selectionChange", s), this._fireSelectionChangeDoneDebounced(s);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let Im = class extends wt {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this._config = {
      childList: !0,
      characterData: !0,
      subtree: !0
    }, this.domConverter = e.domConverter, this.renderer = e._renderer, this._domElements = /* @__PURE__ */ new Set(), this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this));
  }
  /**
   * Synchronously handles mutations and empties the queue.
   */
  flush() {
    this._onMutations(this._mutationObserver.takeRecords());
  }
  /**
   * @inheritDoc
   */
  observe(e) {
    this._domElements.add(e), this.isEnabled && this._mutationObserver.observe(e, this._config);
  }
  /**
   * @inheritDoc
   */
  stopObserving(e) {
    if (this._domElements.delete(e), this.isEnabled) {
      this._mutationObserver.disconnect();
      for (const t of this._domElements)
        this._mutationObserver.observe(t, this._config);
    }
  }
  /**
   * @inheritDoc
   */
  enable() {
    super.enable();
    for (const e of this._domElements)
      this._mutationObserver.observe(e, this._config);
  }
  /**
   * @inheritDoc
   */
  disable() {
    super.disable(), this._mutationObserver.disconnect();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this._mutationObserver.disconnect();
  }
  /**
   * Handles mutations. Mark view elements to sync and call render.
   *
   * @param domMutations Array of native mutations.
   */
  _onMutations(e) {
    if (e.length === 0)
      return;
    const t = this.domConverter, n = /* @__PURE__ */ new Set(), s = /* @__PURE__ */ new Set();
    for (const r of e) {
      const a = t.mapDomToView(r.target);
      a && (a.is("uiElement") || a.is("rawElement") || r.type === "childList" && !this._isBogusBrMutation(r) && s.add(a));
    }
    for (const r of e) {
      const a = t.mapDomToView(r.target);
      if (!(a && (a.is("uiElement") || a.is("rawElement"))) && r.type === "characterData") {
        const l = t.findCorrespondingViewText(r.target);
        l && !s.has(l.parent) ? n.add(l) : !l && Fe(r.target) && s.add(t.mapDomToView(r.target.parentNode));
      }
    }
    let o = !1;
    for (const r of n)
      o = !0, this.renderer.markToSync("text", r);
    for (const r of s) {
      const a = t.mapViewToDom(r), l = Array.from(r.getChildren()), c = Array.from(t.domChildrenToView(a, { withChildren: !1 }));
      jy(l, c, Nk) || (o = !0, this.renderer.markToSync("children", r));
    }
    o && this.view.forceRender();
  }
  /**
   * Checks if mutation was generated by the browser inserting bogus br on the end of the block element.
   * Such mutations are generated while pressing space or performing native spellchecker correction
   * on the end of the block element in Firefox browser.
   *
   * @param mutation Native mutation object.
   */
  _isBogusBrMutation(e) {
    let t = null;
    return e.nextSibling === null && e.removedNodes.length === 0 && e.addedNodes.length == 1 && (t = this.domConverter.domToView(e.addedNodes[0], {
      withChildren: !1
    })), t && t.is("element", "br");
  }
};
function Nk(i, e) {
  if (!Array.isArray(i))
    return i === e ? !0 : i.is("$text") && e.is("$text") ? i.data === e.data : !1;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ko extends Gt {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this._isFocusChanging = !1, this.domEventType = ["focus", "blur"], this.useCapture = !0;
    const t = this.document;
    t.on("focus", () => {
      this._isFocusChanging = !0, this._renderTimeoutId = setTimeout(() => {
        this.flush(), e.change(() => {
        });
      }, 50);
    }), t.on("blur", (n, s) => {
      const o = t.selection.editableElement;
      (o === null || o === s.target) && (t.isFocused = !1, this._isFocusChanging = !1, e.change(() => {
      }));
    });
  }
  /**
   * Finishes setting the document focus state.
   */
  flush() {
    this._isFocusChanging && (this._isFocusChanging = !1, this.document.isFocused = !0);
  }
  /**
   * @inheritDoc
   */
  onDomEvent(e) {
    this.fire(e.type, e);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    this._renderTimeoutId && clearTimeout(this._renderTimeoutId), super.destroy();
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Dk extends wt {
  constructor(e) {
    super(e), this.mutationObserver = e.getObserver(Im), this.focusObserver = e.getObserver(ko), this.selection = this.document.selection, this.domConverter = e.domConverter, this._documents = /* @__PURE__ */ new WeakSet(), this._fireSelectionChangeDoneDebounced = Pt((t) => {
      this.document.fire("selectionChangeDone", t);
    }, 200), this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1e3), this._documentIsSelectingInactivityTimeoutDebounced = Pt(() => this.document.isSelecting = !1, 5e3), this._loopbackCounter = 0;
  }
  /**
   * @inheritDoc
   */
  observe(e) {
    const t = e.ownerDocument, n = () => {
      this.document.isSelecting = !0, this._documentIsSelectingInactivityTimeoutDebounced();
    }, s = () => {
      this.document.isSelecting && (this._handleSelectionChange(null, t), this.document.isSelecting = !1, this._documentIsSelectingInactivityTimeoutDebounced.cancel());
    };
    this.listenTo(e, "selectstart", n, { priority: "highest" }), this.listenTo(e, "keydown", s, { priority: "highest", useCapture: !0 }), this.listenTo(e, "keyup", s, { priority: "highest", useCapture: !0 }), !this._documents.has(t) && (this.listenTo(t, "mouseup", s, { priority: "highest", useCapture: !0 }), this.listenTo(t, "selectionchange", (o, r) => {
      this.document.isComposing && !M.isAndroid || (this._handleSelectionChange(r, t), this._documentIsSelectingInactivityTimeoutDebounced());
    }), this._documents.add(t));
  }
  /**
   * @inheritDoc
   */
  stopObserving(e) {
    this.stopListening(e);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), clearInterval(this._clearInfiniteLoopInterval), this._fireSelectionChangeDoneDebounced.cancel(), this._documentIsSelectingInactivityTimeoutDebounced.cancel();
  }
  /* istanbul ignore next -- @preserve */
  _reportInfiniteLoop() {
  }
  /**
   * Selection change listener. {@link module:engine/view/observer/mutationobserver~MutationObserver#flush Flush} mutations, check if
   * a selection changes and fires {@link module:engine/view/document~Document#event:selectionChange} event on every change
   * and {@link module:engine/view/document~Document#event:selectionChangeDone} when a selection stop changing.
   *
   * @param domEvent DOM event.
   * @param domDocument DOM document.
   */
  _handleSelectionChange(e, t) {
    if (!this.isEnabled)
      return;
    const n = t.defaultView.getSelection();
    if (this.checkShouldIgnoreEventFromTarget(n.anchorNode))
      return;
    this.mutationObserver.flush();
    const s = this.domConverter.domSelectionToView(n);
    if (s.rangeCount == 0) {
      this.view.hasDomSelection = !1;
      return;
    }
    if (this.view.hasDomSelection = !0, this.focusObserver.flush(), !(this.selection.isEqual(s) && this.domConverter.isDomSelectionCorrect(n))) {
      if (++this._loopbackCounter > 60) {
        this._reportInfiniteLoop();
        return;
      }
      if (this.selection.isSimilar(s))
        this.view.forceRender();
      else {
        const o = {
          oldSelection: this.selection,
          newSelection: s,
          domSelection: n
        };
        this.document.fire("selectionChange", o), this._fireSelectionChangeDoneDebounced(o);
      }
    }
  }
  /**
   * Clears `SelectionObserver` internal properties connected with preventing infinite loop.
   */
  _clearInfiniteLoop() {
    this._loopbackCounter = 0;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class zk extends Gt {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.domEventType = ["compositionstart", "compositionupdate", "compositionend"];
    const t = this.document;
    t.on("compositionstart", () => {
      t.isComposing = !0;
    }, { priority: "low" }), t.on("compositionend", () => {
      t.isComposing = !1;
    }, { priority: "low" });
  }
  /**
   * @inheritDoc
   */
  onDomEvent(e) {
    this.fire(e.type, e, {
      data: e.data
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Sm {
  /**
   * @param nativeDataTransfer The native [`DataTransfer`](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer) object.
   * @param options.cacheFiles Whether `files` list should be initialized in the constructor.
   */
  constructor(e, t = {}) {
    this._files = t.cacheFiles ? cu(e) : null, this._native = e;
  }
  /**
   * The array of files created from the native `DataTransfer#files` or `DataTransfer#items`.
   */
  get files() {
    return this._files || (this._files = cu(this._native)), this._files;
  }
  /**
   * Returns an array of available native content types.
   */
  get types() {
    return this._native.types;
  }
  /**
   * Gets the data from the data transfer by its MIME type.
   *
   * ```ts
   * dataTransfer.getData( 'text/plain' );
   * ```
   *
   * @param type The MIME type. E.g. `text/html` or `text/plain`.
   */
  getData(e) {
    return this._native.getData(e);
  }
  /**
   * Sets the data in the data transfer.
   *
   * @param type The MIME type. E.g. `text/html` or `text/plain`.
   */
  setData(e, t) {
    this._native.setData(e, t);
  }
  /**
   * The effect that is allowed for a drag operation.
   */
  set effectAllowed(e) {
    this._native.effectAllowed = e;
  }
  get effectAllowed() {
    return this._native.effectAllowed;
  }
  /**
   * The actual drop effect.
   */
  set dropEffect(e) {
    this._native.dropEffect = e;
  }
  get dropEffect() {
    return this._native.dropEffect;
  }
  /**
   * Set a preview image of the dragged content.
   */
  setDragImage(e, t, n) {
    this._native.setDragImage(e, t, n);
  }
  /**
   * Whether the dragging operation was canceled.
   */
  get isCanceled() {
    return this._native.dropEffect == "none" || !!this._native.mozUserCancelled;
  }
}
function cu(i) {
  const e = Array.from(i.files || []), t = Array.from(i.items || []);
  return e.length ? e : t.filter((n) => n.kind === "file").map((n) => n.getAsFile());
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Hk extends Gt {
  constructor() {
    super(...arguments), this.domEventType = "beforeinput";
  }
  /**
   * @inheritDoc
   */
  onDomEvent(e) {
    const t = e.getTargetRanges(), n = this.view, s = n.document;
    let o = null, r = null, a = [];
    if (e.dataTransfer && (o = new Sm(e.dataTransfer)), e.data !== null ? r = e.data : o && (r = o.getData("text/plain")), s.selection.isFake)
      a = Array.from(s.selection.getRanges());
    else if (t.length)
      a = t.map((l) => {
        const c = n.domConverter.domPositionToView(l.startContainer, l.startOffset), u = n.domConverter.domPositionToView(l.endContainer, l.endOffset);
        if (c)
          return n.createRange(c, u);
        if (u)
          return n.createRange(u);
      }).filter((l) => !!l);
    else if (M.isAndroid) {
      const l = e.target.ownerDocument.defaultView.getSelection();
      a = Array.from(n.domConverter.domSelectionToView(l).getRanges());
    }
    if (M.isAndroid && e.inputType == "insertCompositionText" && r && r.endsWith(`
`)) {
      this.fire(e.type, e, {
        inputType: "insertParagraph",
        targetRanges: [n.createRange(a[0].end)]
      });
      return;
    }
    if (e.inputType == "insertText" && r && r.includes(`
`)) {
      const l = r.split(/\n{1,2}/g);
      let c = a;
      for (let u = 0; u < l.length; u++) {
        const d = l[u];
        d != "" && (this.fire(e.type, e, {
          data: d,
          dataTransfer: o,
          targetRanges: c,
          inputType: e.inputType,
          isComposing: e.isComposing
        }), c = [s.selection.getFirstRange()]), u + 1 < l.length && (this.fire(e.type, e, {
          inputType: "insertParagraph",
          targetRanges: c
        }), c = [s.selection.getFirstRange()]);
      }
      return;
    }
    this.fire(e.type, e, {
      data: r,
      dataTransfer: o,
      targetRanges: a,
      inputType: e.inputType,
      isComposing: e.isComposing
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Uk extends wt {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.document.on("keydown", (t, n) => {
      if (this.isEnabled && EC(n.keyCode)) {
        const s = new hi(this.document, "arrowKey", this.document.selection.getFirstRange());
        this.document.fire(s, n), s.stop.called && t.stop();
      }
    });
  }
  /**
   * @inheritDoc
   */
  observe() {
  }
  /**
   * @inheritDoc
   */
  stopObserving() {
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class $k extends wt {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e);
    const t = this.document;
    t.on("keydown", (n, s) => {
      if (!this.isEnabled || s.keyCode != N.tab || s.ctrlKey)
        return;
      const o = new hi(t, "tab", t.selection.getFirstRange());
      t.fire(o, s), o.stop.called && n.stop();
    });
  }
  /**
   * @inheritDoc
   */
  observe() {
  }
  /**
   * @inheritDoc
   */
  stopObserving() {
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let Wk = class extends U() {
  /**
   * @param stylesProcessor The styles processor instance.
   */
  constructor(e) {
    super(), this.domRoots = /* @__PURE__ */ new Map(), this._initialDomRootAttributes = /* @__PURE__ */ new WeakMap(), this._observers = /* @__PURE__ */ new Map(), this._ongoingChange = !1, this._postFixersInProgress = !1, this._renderingDisabled = !1, this._hasChangedSinceTheLastRendering = !1, this.document = new Zo(e), this.domConverter = new Xo(this.document), this.set("isRenderingInProgress", !1), this.set("hasDomSelection", !1), this._renderer = new Ck(this.domConverter, this.document.selection), this._renderer.bind("isFocused", "isSelecting", "isComposing").to(this.document, "isFocused", "isSelecting", "isComposing"), this._writer = new Cm(this.document), this.addObserver(Im), this.addObserver(ko), this.addObserver(Dk), this.addObserver(Ok), this.addObserver(Fk), this.addObserver(zk), this.addObserver(Uk), this.addObserver(Hk), this.addObserver($k), vk(this), hk(this), this.on("render", () => {
      this._render(), this.document.fire("layoutChanged"), this._hasChangedSinceTheLastRendering = !1;
    }), this.listenTo(this.document.selection, "change", () => {
      this._hasChangedSinceTheLastRendering = !0;
    }), this.listenTo(this.document, "change:isFocused", () => {
      this._hasChangedSinceTheLastRendering = !0;
    }), M.isiOS && this.listenTo(this.document, "blur", (t, n) => {
      this.domConverter.mapDomToView(n.domEvent.relatedTarget) || this.domConverter._clearDomSelection();
    });
  }
  /**
   * Attaches a DOM root element to the view element and enable all observers on that element.
   * Also {@link module:engine/view/renderer~Renderer#markToSync mark element} to be synchronized
   * with the view what means that all child nodes will be removed and replaced with content of the view root.
   *
   * This method also will change view element name as the same as tag name of given dom root.
   * Name is always transformed to lower case.
   *
   * **Note:** Use {@link #detachDomRoot `detachDomRoot()`} to revert this action.
   *
   * @param domRoot DOM root element.
   * @param name Name of the root.
   */
  attachDomRoot(e, t = "main") {
    const n = this.document.getRoot(t);
    n._name = e.tagName.toLowerCase();
    const s = {};
    for (const { name: r, value: a } of Array.from(e.attributes))
      s[r] = a, r === "class" ? this._writer.addClass(a.split(" "), n) : this._writer.setAttribute(r, a, n);
    this._initialDomRootAttributes.set(e, s);
    const o = () => {
      this._writer.setAttribute("contenteditable", (!n.isReadOnly).toString(), n), n.isReadOnly ? this._writer.addClass("ck-read-only", n) : this._writer.removeClass("ck-read-only", n);
    };
    o(), this.domRoots.set(t, e), this.domConverter.bindElements(e, n), this._renderer.markToSync("children", n), this._renderer.markToSync("attributes", n), this._renderer.domDocuments.add(e.ownerDocument), n.on("change:children", (r, a) => this._renderer.markToSync("children", a)), n.on("change:attributes", (r, a) => this._renderer.markToSync("attributes", a)), n.on("change:text", (r, a) => this._renderer.markToSync("text", a)), n.on("change:isReadOnly", () => this.change(o)), n.on("change", () => {
      this._hasChangedSinceTheLastRendering = !0;
    });
    for (const r of this._observers.values())
      r.observe(e, t);
  }
  /**
   * Detaches a DOM root element from the view element and restores its attributes to the state before
   * {@link #attachDomRoot `attachDomRoot()`}.
   *
   * @param name Name of the root to detach.
   */
  detachDomRoot(e) {
    const t = this.domRoots.get(e);
    Array.from(t.attributes).forEach(({ name: s }) => t.removeAttribute(s));
    const n = this._initialDomRootAttributes.get(t);
    for (const s in n)
      t.setAttribute(s, n[s]);
    this.domRoots.delete(e), this.domConverter.unbindDomElement(t);
    for (const s of this._observers.values())
      s.stopObserving(t);
  }
  /**
   * Gets DOM root element.
   *
   * @param name  Name of the root.
   * @returns DOM root element instance.
   */
  getDomRoot(e = "main") {
    return this.domRoots.get(e);
  }
  /**
   * Creates observer of the given type if not yet created, {@link module:engine/view/observer/observer~Observer#enable enables} it
   * and {@link module:engine/view/observer/observer~Observer#observe attaches} to all existing and future
   * {@link #domRoots DOM roots}.
   *
   * Note: Observers are recognized by their constructor (classes). A single observer will be instantiated and used only
   * when registered for the first time. This means that features and other components can register a single observer
   * multiple times without caring whether it has been already added or not.
   *
   * @param ObserverConstructor The constructor of an observer to add.
   * Should create an instance inheriting from {@link module:engine/view/observer/observer~Observer}.
   * @returns Added observer instance.
   */
  addObserver(e) {
    let t = this._observers.get(e);
    if (t)
      return t;
    t = new e(this), this._observers.set(e, t);
    for (const [n, s] of this.domRoots)
      t.observe(s, n);
    return t.enable(), t;
  }
  /**
   * Returns observer of the given type or `undefined` if such observer has not been added yet.
   *
   * @param ObserverConstructor The constructor of an observer to get.
   * @returns Observer instance or undefined.
   */
  getObserver(e) {
    return this._observers.get(e);
  }
  /**
   * Disables all added observers.
   */
  disableObservers() {
    for (const e of this._observers.values())
      e.disable();
  }
  /**
   * Enables all added observers.
   */
  enableObservers() {
    for (const e of this._observers.values())
      e.enable();
  }
  /**
   * Scrolls the page viewport and {@link #domRoots} with their ancestors to reveal the
   * caret, **if not already visible to the user**.
   *
   * **Note**: Calling this method fires the {@link module:engine/view/view~ViewScrollToTheSelectionEvent} event that
   * allows custom behaviors.
   *
   * @param options Additional configuration of the scrolling behavior.
   * @param options.viewportOffset A distance between the DOM selection and the viewport boundary to be maintained
   * while scrolling to the selection (default is 20px). Setting this value to `0` will reveal the selection precisely at
   * the viewport boundary.
   * @param options.ancestorOffset A distance between the DOM selection and scrollable DOM root ancestor(s) to be maintained
   * while scrolling to the selection (default is 20px). Setting this value to `0` will reveal the selection precisely at
   * the scrollable ancestor(s) boundary.
   * @param options.alignToTop When set `true`, the DOM selection will be aligned to the top of the viewport if not already visible
   * (see `forceScroll` to learn more).
   * @param options.forceScroll When set `true`, the DOM selection will be aligned to the top of the viewport and scrollable ancestors
   * whether it is already visible or not. This option will only work when `alignToTop` is `true`.
   */
  scrollToTheSelection({ alignToTop: e, forceScroll: t, viewportOffset: n = 20, ancestorOffset: s = 20 } = {}) {
    const o = this.document.selection.getFirstRange();
    if (!o)
      return;
    const r = ct({ alignToTop: e, forceScroll: t, viewportOffset: n, ancestorOffset: s });
    typeof n == "number" && (n = {
      top: n,
      bottom: n,
      left: n,
      right: n
    });
    const a = {
      target: this.domConverter.viewRangeToDom(o),
      viewportOffset: n,
      ancestorOffset: s,
      alignToTop: e,
      forceScroll: t
    };
    this.fire("scrollToTheSelection", a, r), wC(a);
  }
  /**
   * It will focus DOM element representing {@link module:engine/view/editableelement~EditableElement EditableElement}
   * that is currently having selection inside.
   */
  focus() {
    if (!this.document.isFocused) {
      const e = this.document.selection.editableElement;
      e && (this.domConverter.focus(e), this.forceRender());
    }
  }
  /**
   * The `change()` method is the primary way of changing the view. You should use it to modify any node in the view tree.
   * It makes sure that after all changes are made the view is rendered to the DOM (assuming that the view will be changed
   * inside the callback). It prevents situations when the DOM is updated when the view state is not yet correct. It allows
   * to nest calls one inside another and still performs a single rendering after all those changes are made.
   * It also returns the return value of its callback.
   *
   * ```ts
   * const text = view.change( writer => {
   * 	const newText = writer.createText( 'foo' );
   * 	writer.insert( position1, newText );
   *
   * 	view.change( writer => {
   * 		writer.insert( position2, writer.createText( 'bar' ) );
   * 	} );
   *
   * 	writer.remove( range );
   *
   * 	return newText;
   * } );
   * ```
   *
   * When the outermost change block is done and rendering to the DOM is over the
   * {@link module:engine/view/view~View#event:render `View#render`} event is fired.
   *
   * This method throws a `applying-view-changes-on-rendering` error when
   * the change block is used after rendering to the DOM has started.
   *
   * @param callback Callback function which may modify the view.
   * @returns Value returned by the callback.
   */
  change(e) {
    if (this.isRenderingInProgress || this._postFixersInProgress)
      throw new g("cannot-change-view-tree", this);
    try {
      if (this._ongoingChange)
        return e(this._writer);
      this._ongoingChange = !0;
      const t = e(this._writer);
      return this._ongoingChange = !1, !this._renderingDisabled && this._hasChangedSinceTheLastRendering && (this._postFixersInProgress = !0, this.document._callPostFixers(this._writer), this._postFixersInProgress = !1, this.fire("render")), t;
    } catch (t) {
      /* istanbul ignore next -- @preserve */
      g.rethrowUnexpectedError(t, this);
    }
  }
  /**
   * Forces rendering {@link module:engine/view/document~Document view document} to DOM. If any view changes are
   * currently in progress, rendering will start after all {@link #change change blocks} are processed.
   *
   * Note that this method is dedicated for special cases. All view changes should be wrapped in the {@link #change}
   * block and the view will automatically check whether it needs to render DOM or not.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `applying-view-changes-on-rendering` when
   * trying to re-render when rendering to DOM has already started.
   */
  forceRender() {
    this._hasChangedSinceTheLastRendering = !0, this.getObserver(ko).flush(), this.change(() => {
    });
  }
  /**
   * Destroys this instance. Makes sure that all observers are destroyed and listeners removed.
   */
  destroy() {
    for (const e of this._observers.values())
      e.destroy();
    this.document.destroy(), this.stopListening();
  }
  /**
   * Creates position at the given location. The location can be specified as:
   *
   * * a {@link module:engine/view/position~Position position},
   * * parent element and offset (offset defaults to `0`),
   * * parent element and `'end'` (sets position at the end of that element),
   * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
   *
   * This method is a shortcut to other constructors such as:
   *
   * * {@link #createPositionBefore},
   * * {@link #createPositionAfter},
   *
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
   */
  createPositionAt(e, t) {
    return k._createAt(e, t);
  }
  /**
   * Creates a new position after given view item.
   *
   * @param item View item after which the position should be located.
   */
  createPositionAfter(e) {
    return k._createAfter(e);
  }
  /**
   * Creates a new position before given view item.
   *
   * @param item View item before which the position should be located.
   */
  createPositionBefore(e) {
    return k._createBefore(e);
  }
  /**
   * Creates a range spanning from `start` position to `end` position.
   *
   * **Note:** This factory method creates it's own {@link module:engine/view/position~Position} instances basing on passed values.
   *
   * @param start Start position.
   * @param end End position. If not set, range will be collapsed at `start` position.
   */
  createRange(e, t) {
    return new O(e, t);
  }
  /**
   * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
   */
  createRangeOn(e) {
    return O._createOn(e);
  }
  /**
   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * @param element Element which is a parent for the range.
   */
  createRangeIn(e) {
    return O._createIn(e);
  }
  createSelection(...e) {
    return new xt(...e);
  }
  /**
   * Disables or enables rendering. If the flag is set to `true` then the rendering will be disabled.
   * If the flag is set to `false` and if there was some change in the meantime, then the rendering action will be performed.
   *
   * @internal
   * @param flag A flag indicates whether the rendering should be disabled.
   */
  _disableRendering(e) {
    this._renderingDisabled = e, e == !1 && this.change(() => {
    });
  }
  /**
   * Renders all changes. In order to avoid triggering the observers (e.g. selection) all observers are disabled
   * before rendering and re-enabled after that.
   */
  _render() {
    this.isRenderingInProgress = !0, this.disableObservers(), this._renderer.render(), this.enableObservers(), this.isRenderingInProgress = !1;
  }
};
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class jt {
  /* istanbul ignore next -- @preserve */
  is() {
    throw new Error("is() method is abstract");
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let vn = class extends jt {
  /**
   * Creates a model node.
   *
   * This is an abstract class, so this constructor should not be used directly.
   *
   * @param attrs Node's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.
   */
  constructor(e) {
    super(), this.parent = null, this._attrs = pt(e);
  }
  /**
   * {@link module:engine/model/document~Document Document} that owns this root element.
   */
  get document() {
    return null;
  }
  /**
   * Index of this node in its parent or `null` if the node has no parent.
   *
   * Accessing this property throws an error if this node's parent element does not contain it.
   * This means that model tree got broken.
   */
  get index() {
    let e;
    if (!this.parent)
      return null;
    if ((e = this.parent.getChildIndex(this)) === null)
      throw new g("model-node-not-found-in-parent", this);
    return e;
  }
  /**
   * Offset at which this node starts in its parent. It is equal to the sum of {@link #offsetSize offsetSize}
   * of all its previous siblings. Equals to `null` if node has no parent.
   *
   * Accessing this property throws an error if this node's parent element does not contain it.
   * This means that model tree got broken.
   */
  get startOffset() {
    let e;
    if (!this.parent)
      return null;
    if ((e = this.parent.getChildStartOffset(this)) === null)
      throw new g("model-node-not-found-in-parent", this);
    return e;
  }
  /**
   * Offset size of this node. Represents how much "offset space" is occupied by the node in it's parent.
   * It is important for {@link module:engine/model/position~Position position}. When node has `offsetSize` greater than `1`, position
   * can be placed between that node start and end. `offsetSize` greater than `1` is for nodes that represents more
   * than one entity, i.e. {@link module:engine/model/text~Text text node}.
   */
  get offsetSize() {
    return 1;
  }
  /**
   * Offset at which this node ends in it's parent. It is equal to the sum of this node's
   * {@link module:engine/model/node~Node#startOffset start offset} and {@link #offsetSize offset size}.
   * Equals to `null` if the node has no parent.
   */
  get endOffset() {
    return this.parent ? this.startOffset + this.offsetSize : null;
  }
  /**
   * Node's next sibling or `null` if the node is a last child of it's parent or if the node has no parent.
   */
  get nextSibling() {
    const e = this.index;
    return e !== null && this.parent.getChild(e + 1) || null;
  }
  /**
   * Node's previous sibling or `null` if the node is a first child of it's parent or if the node has no parent.
   */
  get previousSibling() {
    const e = this.index;
    return e !== null && this.parent.getChild(e - 1) || null;
  }
  /**
   * The top-most ancestor of the node. If node has no parent it is the root itself. If the node is a part
   * of {@link module:engine/model/documentfragment~DocumentFragment}, it's `root` is equal to that `DocumentFragment`.
   */
  get root() {
    let e = this;
    for (; e.parent; )
      e = e.parent;
    return e;
  }
  /**
   * Returns `true` if the node is inside a document root that is attached to the document.
   */
  isAttached() {
    return this.parent === null ? !1 : this.root.isAttached();
  }
  /**
   * Gets path to the node. The path is an array containing starting offsets of consecutive ancestors of this node,
   * beginning from {@link module:engine/model/node~Node#root root}, down to this node's starting offset. The path can be used to
   * create {@link module:engine/model/position~Position Position} instance.
   *
   * ```ts
   * const abc = new Text( 'abc' );
   * const foo = new Text( 'foo' );
   * const h1 = new Element( 'h1', null, new Text( 'header' ) );
   * const p = new Element( 'p', null, [ abc, foo ] );
   * const div = new Element( 'div', null, [ h1, p ] );
   * foo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.
   * h1.getPath(); // Returns [ 0 ].
   * div.getPath(); // Returns [].
   * ```
   */
  getPath() {
    const e = [];
    let t = this;
    for (; t.parent; )
      e.unshift(t.startOffset), t = t.parent;
    return e;
  }
  /**
   * Returns ancestors array of this node.
   *
   * @param options Options object.
   * @param options.includeSelf When set to `true` this node will be also included in parent's array.
   * @param options.parentFirst When set to `true`, array will be sorted from node's parent to root element,
   * otherwise root element will be the first item in the array.
   * @returns Array with ancestors.
   */
  getAncestors(e = {}) {
    const t = [];
    let n = e.includeSelf ? this : this.parent;
    for (; n; )
      t[e.parentFirst ? "push" : "unshift"](n), n = n.parent;
    return t;
  }
  /**
   * Returns a {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}
   * which is a common ancestor of both nodes.
   *
   * @param node The second node.
   * @param options Options object.
   * @param options.includeSelf When set to `true` both nodes will be considered "ancestors" too.
   * Which means that if e.g. node A is inside B, then their common ancestor will be B.
   */
  getCommonAncestor(e, t = {}) {
    const n = this.getAncestors(t), s = e.getAncestors(t);
    let o = 0;
    for (; n[o] == s[o] && n[o]; )
      o++;
    return o === 0 ? null : n[o - 1];
  }
  /**
   * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,
   * in different {@link module:engine/model/documentfragment~DocumentFragment}s).
   *
   * @param node Node to compare with.
   */
  isBefore(e) {
    if (this == e || this.root !== e.root)
      return !1;
    const t = this.getPath(), n = e.getPath(), s = Ee(t, n);
    switch (s) {
      case "prefix":
        return !0;
      case "extension":
        return !1;
      default:
        return t[s] < n[s];
    }
  }
  /**
   * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,
   * in different {@link module:engine/model/documentfragment~DocumentFragment}s).
   *
   * @param node Node to compare with.
   */
  isAfter(e) {
    return this == e || this.root !== e.root ? !1 : !this.isBefore(e);
  }
  /**
   * Checks if the node has an attribute with given key.
   *
   * @param key Key of attribute to check.
   * @returns `true` if attribute with given key is set on node, `false` otherwise.
   */
  hasAttribute(e) {
    return this._attrs.has(e);
  }
  /**
   * Gets an attribute value for given key or `undefined` if that attribute is not set on node.
   *
   * @param key Key of attribute to look for.
   * @returns Attribute value or `undefined`.
   */
  getAttribute(e) {
    return this._attrs.get(e);
  }
  /**
   * Returns iterator that iterates over this node's attributes.
   *
   * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
   */
  getAttributes() {
    return this._attrs.entries();
  }
  /**
   * Returns iterator that iterates over this node's attribute keys.
   */
  getAttributeKeys() {
    return this._attrs.keys();
  }
  /**
   * Converts `Node` to plain object and returns it.
   *
   * @returns `Node` converted to plain object.
   */
  toJSON() {
    const e = {};
    return this._attrs.size && (e.attributes = Array.from(this._attrs).reduce((t, n) => (t[n[0]] = n[1], t), {})), e;
  }
  /**
   * Creates a copy of this node, that is a node with exactly same attributes, and returns it.
   *
   * @internal
   * @returns Node with same attributes as this node.
   */
  _clone(e) {
    return new this.constructor(this._attrs);
  }
  /**
   * Removes this node from it's parent.
   *
   * @internal
   * @see module:engine/model/writer~Writer#remove
   */
  _remove() {
    this.parent._removeChildren(this.index);
  }
  /**
   * Sets attribute on the node. If attribute with the same key already is set, it's value is overwritten.
   *
   * @see module:engine/model/writer~Writer#setAttribute
   * @internal
   * @param key Key of attribute to set.
   * @param value Attribute value.
   */
  _setAttribute(e, t) {
    this._attrs.set(e, t);
  }
  /**
   * Removes all attributes from the node and sets given attributes.
   *
   * @see module:engine/model/writer~Writer#setAttributes
   * @internal
   * @param attrs Attributes to set. See {@link module:utils/tomap~toMap} for a list of accepted values.
   */
  _setAttributesTo(e) {
    this._attrs = pt(e);
  }
  /**
   * Removes an attribute with given key from the node.
   *
   * @see module:engine/model/writer~Writer#removeAttribute
   * @internal
   * @param key Key of attribute to remove.
   * @returns `true` if the attribute was set on the element, `false` otherwise.
   */
  _removeAttribute(e) {
    return this._attrs.delete(e);
  }
  /**
   * Removes all attributes from the node.
   *
   * @see module:engine/model/writer~Writer#clearAttributes
   * @internal
   */
  _clearAttributes() {
    this._attrs.clear();
  }
};
vn.prototype.is = function(i) {
  return i === "node" || i === "model:node";
};
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Fi {
  /**
   * Creates an empty node list.
   *
   * @internal
   * @param nodes Nodes contained in this node list.
   */
  constructor(e) {
    this._nodes = [], e && this._insertNodes(0, e);
  }
  /**
   * Iterable interface.
   *
   * Iterates over all nodes contained inside this node list.
   */
  [Symbol.iterator]() {
    return this._nodes[Symbol.iterator]();
  }
  /**
   * Number of nodes contained inside this node list.
   */
  get length() {
    return this._nodes.length;
  }
  /**
   * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all nodes contained inside this node list.
   */
  get maxOffset() {
    return this._nodes.reduce((e, t) => e + t.offsetSize, 0);
  }
  /**
   * Gets the node at the given index. Returns `null` if incorrect index was passed.
   */
  getNode(e) {
    return this._nodes[e] || null;
  }
  /**
   * Returns an index of the given node. Returns `null` if given node is not inside this node list.
   */
  getNodeIndex(e) {
    const t = this._nodes.indexOf(e);
    return t == -1 ? null : t;
  }
  /**
   * Returns the starting offset of given node. Starting offset is equal to the sum of
   * {@link module:engine/model/node~Node#offsetSize offset sizes} of all nodes that are before this node in this node list.
   */
  getNodeStartOffset(e) {
    const t = this.getNodeIndex(e);
    return t === null ? null : this._nodes.slice(0, t).reduce((n, s) => n + s.offsetSize, 0);
  }
  /**
   * Converts index to offset in node list.
   *
   * Returns starting offset of a node that is at given index. Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
   * `model-nodelist-index-out-of-bounds` if given index is less than `0` or more than {@link #length}.
   */
  indexToOffset(e) {
    if (e == this._nodes.length)
      return this.maxOffset;
    const t = this._nodes[e];
    if (!t)
      throw new g("model-nodelist-index-out-of-bounds", this);
    return this.getNodeStartOffset(t);
  }
  /**
   * Converts offset in node list to index.
   *
   * Returns index of a node that occupies given offset. Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
   * `model-nodelist-offset-out-of-bounds` if given offset is less than `0` or more than {@link #maxOffset}.
   */
  offsetToIndex(e) {
    let t = 0;
    for (const n of this._nodes) {
      if (e >= t && e < t + n.offsetSize)
        return this.getNodeIndex(n);
      t += n.offsetSize;
    }
    if (t != e)
      throw new g("model-nodelist-offset-out-of-bounds", this, {
        offset: e,
        nodeList: this
      });
    return this.length;
  }
  /**
   * Inserts given nodes at given index.
   *
   * @internal
   * @param index Index at which nodes should be inserted.
   * @param nodes Nodes to be inserted.
   */
  _insertNodes(e, t) {
    for (const n of t)
      if (!(n instanceof vn))
        throw new g("model-nodelist-insertnodes-not-node", this);
    this._nodes = DC(this._nodes, Array.from(t), e, 0);
  }
  /**
   * Removes one or more nodes starting at the given index.
   *
   * @internal
   * @param indexStart Index of the first node to remove.
   * @param howMany Number of nodes to remove.
   * @returns Array containing removed nodes.
   */
  _removeNodes(e, t = 1) {
    return this._nodes.splice(e, t);
  }
  /**
   * Converts `NodeList` instance to an array containing nodes that were inserted in the node list. Nodes
   * are also converted to their plain object representation.
   *
   * @returns `NodeList` instance converted to `Array`.
   */
  toJSON() {
    return this._nodes.map((e) => e.toJSON());
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class j extends vn {
  /**
   * Creates a text node.
   *
   * **Note:** Constructor of this class shouldn't be used directly in the code.
   * Use the {@link module:engine/model/writer~Writer#createText} method instead.
   *
   * @internal
   * @param data Node's text.
   * @param attrs Node's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.
   */
  constructor(e, t) {
    super(t), this._data = e || "";
  }
  /**
   * @inheritDoc
   */
  get offsetSize() {
    return this.data.length;
  }
  /**
   * Returns a text data contained in the node.
   */
  get data() {
    return this._data;
  }
  /**
   * Converts `Text` instance to plain object and returns it.
   *
   * @returns`Text` instance converted to plain object.
   */
  toJSON() {
    const e = super.toJSON();
    return e.data = this.data, e;
  }
  /**
   * Creates a copy of this text node and returns it. Created text node has same text data and attributes as original text node.
   *
   * @internal
   * @returns `Text` instance created using given plain object.
   */
  _clone() {
    return new j(this.data, this.getAttributes());
  }
  /**
   * Creates a `Text` instance from given plain object (i.e. parsed JSON string).
   *
   * @param json Plain object to be converted to `Text`.
   * @returns `Text` instance created using given plain object.
   */
  static fromJSON(e) {
    return new j(e.data, e.attributes);
  }
}
j.prototype.is = function(i) {
  return i === "$text" || i === "model:$text" || // This are legacy values kept for backward compatibility.
  i === "text" || i === "model:text" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "node" || i === "model:node";
};
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class it extends jt {
  /**
   * Creates a text proxy.
   *
   * @internal
   * @param textNode Text node which part is represented by this text proxy.
   * @param offsetInText Offset in {@link module:engine/model/textproxy~TextProxy#textNode text node} from which the text proxy
   * starts.
   * @param length Text proxy length, that is how many text node's characters, starting from `offsetInText` it represents.
   */
  constructor(e, t, n) {
    if (super(), this.textNode = e, t < 0 || t > e.offsetSize)
      throw new g("model-textproxy-wrong-offsetintext", this);
    if (n < 0 || t + n > e.offsetSize)
      throw new g("model-textproxy-wrong-length", this);
    this.data = e.data.substring(t, t + n), this.offsetInText = t;
  }
  /**
   * Offset at which this text proxy starts in it's parent.
   *
   * @see module:engine/model/node~Node#startOffset
   */
  get startOffset() {
    return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null;
  }
  /**
   * Offset size of this text proxy. Equal to the number of characters represented by the text proxy.
   *
   * @see module:engine/model/node~Node#offsetSize
   */
  get offsetSize() {
    return this.data.length;
  }
  /**
   * Offset at which this text proxy ends in it's parent.
   *
   * @see module:engine/model/node~Node#endOffset
   */
  get endOffset() {
    return this.startOffset !== null ? this.startOffset + this.offsetSize : null;
  }
  /**
   * Flag indicating whether `TextProxy` instance covers only part of the original {@link module:engine/model/text~Text text node}
   * (`true`) or the whole text node (`false`).
   *
   * This is `false` when text proxy starts at the very beginning of {@link module:engine/model/textproxy~TextProxy#textNode textNode}
   * ({@link module:engine/model/textproxy~TextProxy#offsetInText offsetInText} equals `0`) and text proxy sizes is equal to
   * text node size.
   */
  get isPartial() {
    return this.offsetSize !== this.textNode.offsetSize;
  }
  /**
   * Parent of this text proxy, which is same as parent of text node represented by this text proxy.
   */
  get parent() {
    return this.textNode.parent;
  }
  /**
   * Root of this text proxy, which is same as root of text node represented by this text proxy.
   */
  get root() {
    return this.textNode.root;
  }
  /**
   * Gets path to this text proxy.
   *
   * @see module:engine/model/node~Node#getPath
   */
  getPath() {
    const e = this.textNode.getPath();
    return e.length > 0 && (e[e.length - 1] += this.offsetInText), e;
  }
  /**
   * Returns ancestors array of this text proxy.
   *
   * @param options Options object.
   * @param options.includeSelf When set to `true` this text proxy will be also included in parent's array.
   * @param options.parentFirst When set to `true`, array will be sorted from text proxy parent to root element,
   * otherwise root element will be the first item in the array.
   * @returns Array with ancestors.
   */
  getAncestors(e = {}) {
    const t = [];
    let n = e.includeSelf ? this : this.parent;
    for (; n; )
      t[e.parentFirst ? "push" : "unshift"](n), n = n.parent;
    return t;
  }
  /**
   * Checks if this text proxy has an attribute for given key.
   *
   * @param key Key of attribute to check.
   * @returns `true` if attribute with given key is set on text proxy, `false` otherwise.
   */
  hasAttribute(e) {
    return this.textNode.hasAttribute(e);
  }
  /**
   * Gets an attribute value for given key or `undefined` if that attribute is not set on text proxy.
   *
   * @param key Key of attribute to look for.
   * @returns Attribute value or `undefined`.
   */
  getAttribute(e) {
    return this.textNode.getAttribute(e);
  }
  /**
   * Returns iterator that iterates over this node's attributes. Attributes are returned as arrays containing two
   * items. First one is attribute key and second is attribute value.
   *
   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
   */
  getAttributes() {
    return this.textNode.getAttributes();
  }
  /**
   * Returns iterator that iterates over this node's attribute keys.
   */
  getAttributeKeys() {
    return this.textNode.getAttributeKeys();
  }
}
it.prototype.is = function(i) {
  return i === "$textProxy" || i === "model:$textProxy" || // This are legacy values kept for backward compatibility.
  i === "textProxy" || i === "model:textProxy";
};
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class $ extends vn {
  /**
   * Creates a model element.
   *
   * **Note:** Constructor of this class shouldn't be used directly in the code.
   * Use the {@link module:engine/model/writer~Writer#createElement} method instead.
   *
   * @internal
   * @param name Element's name.
   * @param attrs Element's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.
   * @param children One or more nodes to be inserted as children of created element.
   */
  constructor(e, t, n) {
    super(t), this._children = new Fi(), this.name = e, n && this._insertChild(0, n);
  }
  /**
   * Number of this element's children.
   */
  get childCount() {
    return this._children.length;
  }
  /**
   * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this element's children.
   */
  get maxOffset() {
    return this._children.maxOffset;
  }
  /**
   * Is `true` if there are no nodes inside this element, `false` otherwise.
   */
  get isEmpty() {
    return this.childCount === 0;
  }
  /**
   * Gets the child at the given index.
   */
  getChild(e) {
    return this._children.getNode(e);
  }
  /**
   * Returns an iterator that iterates over all of this element's children.
   */
  getChildren() {
    return this._children[Symbol.iterator]();
  }
  /**
   * Returns an index of the given child node. Returns `null` if given node is not a child of this element.
   *
   * @param node Child node to look for.
   * @returns Child node's index in this element.
   */
  getChildIndex(e) {
    return this._children.getNodeIndex(e);
  }
  /**
   * Returns the starting offset of given child. Starting offset is equal to the sum of
   * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if
   * given node is not a child of this element.
   *
   * @param node Child node to look for.
   * @returns Child node's starting offset.
   */
  getChildStartOffset(e) {
    return this._children.getNodeStartOffset(e);
  }
  /**
   * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is
   * too high, returns {@link module:engine/model/element~Element#getChildIndex index after last child}.
   *
   * ```ts
   * const textNode = new Text( 'foo' );
   * const pElement = new Element( 'p' );
   * const divElement = new Element( [ textNode, pElement ] );
   * divElement.offsetToIndex( -1 ); // Returns 0, because offset is too low.
   * divElement.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.
   * divElement.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.
   * divElement.offsetToIndex( 2 ); // Returns 0.
   * divElement.offsetToIndex( 3 ); // Returns 1.
   * divElement.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.
   * ```
   */
  offsetToIndex(e) {
    return this._children.offsetToIndex(e);
  }
  /**
   * Returns a descendant node by its path relative to this element.
   *
   * ```ts
   * // <this>a<b>c</b></this>
   * this.getNodeByPath( [ 0 ] );     // -> "a"
   * this.getNodeByPath( [ 1 ] );     // -> <b>
   * this.getNodeByPath( [ 1, 0 ] );  // -> "c"
   * ```
   *
   * @param relativePath Path of the node to find, relative to this element.
   */
  getNodeByPath(e) {
    let t = this;
    for (const n of e)
      t = t.getChild(t.offsetToIndex(n));
    return t;
  }
  /**
   * Returns the parent element of the given name. Returns null if the element is not inside the desired parent.
   *
   * @param parentName The name of the parent element to find.
   * @param options Options object.
   * @param options.includeSelf When set to `true` this node will be also included while searching.
   */
  findAncestor(e, t = {}) {
    let n = t.includeSelf ? this : this.parent;
    for (; n; ) {
      if (n.name === e)
        return n;
      n = n.parent;
    }
    return null;
  }
  /**
   * Converts `Element` instance to plain object and returns it. Takes care of converting all of this element's children.
   *
   * @returns `Element` instance converted to plain object.
   */
  toJSON() {
    const e = super.toJSON();
    if (e.name = this.name, this._children.length > 0) {
      e.children = [];
      for (const t of this._children)
        e.children.push(t.toJSON());
    }
    return e;
  }
  /**
   * Creates a copy of this element and returns it. Created element has the same name and attributes as the original element.
   * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.
   *
   * @internal
   * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
   * element will be cloned without any child.
   */
  _clone(e = !1) {
    const t = e ? Array.from(this._children).map((n) => n._clone(!0)) : void 0;
    return new $(this.name, this.getAttributes(), t);
  }
  /**
   * {@link module:engine/model/element~Element#_insertChild Inserts} one or more nodes at the end of this element.
   *
   * @see module:engine/model/writer~Writer#append
   * @internal
   * @param nodes Nodes to be inserted.
   */
  _appendChild(e) {
    this._insertChild(this.childCount, e);
  }
  /**
   * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes
   * to this element.
   *
   * @see module:engine/model/writer~Writer#insert
   * @internal
   * @param index Index at which nodes should be inserted.
   * @param items Items to be inserted.
   */
  _insertChild(e, t) {
    const n = qk(t);
    for (const s of n)
      s.parent !== null && s._remove(), s.parent = this;
    this._children._insertNodes(e, n);
  }
  /**
   * Removes one or more nodes starting at the given index and sets
   * {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.
   *
   * @see module:engine/model/writer~Writer#remove
   * @internal
   * @param index Index of the first node to remove.
   * @param howMany Number of nodes to remove.
   * @returns Array containing removed nodes.
   */
  _removeChildren(e, t = 1) {
    const n = this._children._removeNodes(e, t);
    for (const s of n)
      s.parent = null;
    return n;
  }
  /**
   * Creates an `Element` instance from given plain object (i.e. parsed JSON string).
   * Converts `Element` children to proper nodes.
   *
   * @param json Plain object to be converted to `Element`.
   * @returns `Element` instance created using given plain object.
   */
  static fromJSON(e) {
    let t;
    if (e.children) {
      t = [];
      for (const n of e.children)
        n.name ? t.push($.fromJSON(n)) : t.push(j.fromJSON(n));
    }
    return new $(e.name, e.attributes, t);
  }
}
$.prototype.is = function(i, e) {
  return e ? e === this.name && (i === "element" || i === "model:element") : i === "element" || i === "model:element" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "node" || i === "model:node";
};
function qk(i) {
  return typeof i == "string" ? [new j(i)] : (Ue(i) || (i = [i]), Array.from(i).map((e) => typeof e == "string" ? new j(e) : e instanceof it ? new j(e.data, e.getAttributes()) : e));
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class At {
  /**
   * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.
   *
   * @param options Object with configuration.
   */
  constructor(e) {
    if (!e || !e.boundaries && !e.startPosition)
      throw new g("model-tree-walker-no-start-position", null);
    const t = e.direction || "forward";
    if (t != "forward" && t != "backward")
      throw new g("model-tree-walker-unknown-direction", e, { direction: t });
    this.direction = t, this.boundaries = e.boundaries || null, e.startPosition ? this._position = e.startPosition.clone() : this._position = y._createAt(this.boundaries[this.direction == "backward" ? "end" : "start"]), this.position.stickiness = "toNone", this.singleCharacters = !!e.singleCharacters, this.shallow = !!e.shallow, this.ignoreElementEnd = !!e.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null, this._visitedParent = this.position.parent;
  }
  /**
   * Iterable interface.
   *
   * @returns {Iterable.<module:engine/model/treewalker~TreeWalkerValue>}
   */
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Iterator position. This is always static position, even if the initial position was a
   * {@link module:engine/model/liveposition~LivePosition live position}. If start position is not defined then position depends
   * on {@link #direction}. If direction is `'forward'` position starts form the beginning, when direction
   * is `'backward'` position starts from the end.
   */
  get position() {
    return this._position;
  }
  /**
   * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.
   *
   * For example:
   *
   * ```ts
   * walker.skip( value => value.type == 'text' ); // <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>
   * walker.skip( () => true ); // Move the position to the end: <paragraph>[]foo</paragraph> -> <paragraph>foo</paragraph>[]
   * walker.skip( () => false ); // Do not move the position.
   * ```
   *
   * @param skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should
   * return `true` if the value should be skipped or `false` if not.
   */
  skip(e) {
    let t, n, s, o;
    do
      s = this.position, o = this._visitedParent, { done: t, value: n } = this.next();
    while (!t && e(n));
    t || (this._position = s, this._visitedParent = o);
  }
  /**
   * Gets the next tree walker's value.
   */
  next() {
    return this.direction == "forward" ? this._next() : this._previous();
  }
  /**
   * Makes a step forward in model. Moves the {@link #position} to the next position and returns the encountered value.
   */
  _next() {
    const e = this.position, t = this.position.clone(), n = this._visitedParent;
    if (n.parent === null && t.offset === n.maxOffset)
      return { done: !0, value: void 0 };
    if (n === this._boundaryEndParent && t.offset == this.boundaries.end.offset)
      return { done: !0, value: void 0 };
    const s = Ni(t, n), o = s || Pm(t, n, s);
    if (o instanceof $) {
      if (!this.shallow)
        t.path.push(0), this._visitedParent = o;
      else {
        if (this.boundaries && this.boundaries.end.isBefore(t))
          return { done: !0, value: void 0 };
        t.offset++;
      }
      return this._position = t, Xt("elementStart", o, e, t, 1);
    }
    if (o instanceof j) {
      let r;
      if (this.singleCharacters)
        r = 1;
      else {
        let c = o.endOffset;
        this._boundaryEndParent == n && this.boundaries.end.offset < c && (c = this.boundaries.end.offset), r = c - t.offset;
      }
      const a = t.offset - o.startOffset, l = new it(o, a, r);
      return t.offset += r, this._position = t, Xt("text", l, e, t, r);
    }
    return t.path.pop(), t.offset++, this._position = t, this._visitedParent = n.parent, this.ignoreElementEnd ? this._next() : Xt("elementEnd", n, e, t);
  }
  /**
   * Makes a step backward in model. Moves the {@link #position} to the previous position and returns the encountered value.
   */
  _previous() {
    const e = this.position, t = this.position.clone(), n = this._visitedParent;
    if (n.parent === null && t.offset === 0)
      return { done: !0, value: void 0 };
    if (n == this._boundaryStartParent && t.offset == this.boundaries.start.offset)
      return { done: !0, value: void 0 };
    const s = t.parent, o = Ni(t, s), r = o || Rm(t, s, o);
    if (r instanceof $)
      return t.offset--, this.shallow ? (this._position = t, Xt("elementStart", r, e, t, 1)) : (t.path.push(r.maxOffset), this._position = t, this._visitedParent = r, this.ignoreElementEnd ? this._previous() : Xt("elementEnd", r, e, t));
    if (r instanceof j) {
      let a;
      if (this.singleCharacters)
        a = 1;
      else {
        let u = r.startOffset;
        this._boundaryStartParent == n && this.boundaries.start.offset > u && (u = this.boundaries.start.offset), a = t.offset - u;
      }
      const l = t.offset - r.startOffset, c = new it(r, l - a, a);
      return t.offset -= a, this._position = t, Xt("text", c, e, t, a);
    }
    return t.path.pop(), this._position = t, this._visitedParent = n.parent, Xt("elementStart", n, e, t, 1);
  }
}
function Xt(i, e, t, n, s) {
  return {
    done: !1,
    value: {
      type: i,
      item: e,
      previousPosition: t,
      nextPosition: n,
      length: s
    }
  };
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class y extends jt {
  /**
   * Creates a position.
   *
   * @param root Root of the position.
   * @param path Position path. See {@link module:engine/model/position~Position#path}.
   * @param stickiness Position stickiness. See {@link module:engine/model/position~PositionStickiness}.
   */
  constructor(e, t, n = "toNone") {
    if (super(), !e.is("element") && !e.is("documentFragment"))
      throw new g("model-position-root-invalid", e);
    if (!(t instanceof Array) || t.length === 0)
      throw new g("model-position-path-incorrect-format", e, { path: t });
    e.is("rootElement") ? t = t.slice() : (t = [...e.getPath(), ...t], e = e.root), this.root = e, this.path = t, this.stickiness = n;
  }
  /**
   * Offset at which this position is located in its {@link module:engine/model/position~Position#parent parent}. It is equal
   * to the last item in position {@link module:engine/model/position~Position#path path}.
   *
   * @type {Number}
   */
  get offset() {
    return this.path[this.path.length - 1];
  }
  set offset(e) {
    this.path[this.path.length - 1] = e;
  }
  /**
   * Parent element of this position.
   *
   * Keep in mind that `parent` value is calculated when the property is accessed.
   * If {@link module:engine/model/position~Position#path position path}
   * leads to a non-existing element, `parent` property will throw error.
   *
   * Also it is a good idea to cache `parent` property if it is used frequently in an algorithm (i.e. in a long loop).
   */
  get parent() {
    let e = this.root;
    for (let t = 0; t < this.path.length - 1; t++)
      if (e = e.getChild(e.offsetToIndex(this.path[t])), !e)
        throw new g("model-position-path-incorrect", this, { position: this });
    if (e.is("$text"))
      throw new g("model-position-path-incorrect", this, { position: this });
    return e;
  }
  /**
   * Position {@link module:engine/model/position~Position#offset offset} converted to an index in position's parent node. It is
   * equal to the {@link module:engine/model/node~Node#index index} of a node after this position. If position is placed
   * in text node, position index is equal to the index of that text node.
   */
  get index() {
    return this.parent.offsetToIndex(this.offset);
  }
  /**
   * Returns {@link module:engine/model/text~Text text node} instance in which this position is placed or `null` if this
   * position is not in a text node.
   */
  get textNode() {
    return Ni(this, this.parent);
  }
  /**
   * Node directly after this position or `null` if this position is in text node.
   */
  get nodeAfter() {
    const e = this.parent;
    return Pm(this, e, Ni(this, e));
  }
  /**
   * Node directly before this position or `null` if this position is in text node.
   */
  get nodeBefore() {
    const e = this.parent;
    return Rm(this, e, Ni(this, e));
  }
  /**
   * Is `true` if position is at the beginning of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.
   */
  get isAtStart() {
    return this.offset === 0;
  }
  /**
   * Is `true` if position is at the end of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.
   */
  get isAtEnd() {
    return this.offset == this.parent.maxOffset;
  }
  /**
   * Checks whether this position is before or after given position.
   *
   * This method is safe to use it on non-existing positions (for example during operational transformation).
   */
  compareWith(e) {
    if (this.root != e.root)
      return "different";
    const t = Ee(this.path, e.path);
    switch (t) {
      case "same":
        return "same";
      case "prefix":
        return "before";
      case "extension":
        return "after";
      default:
        return this.path[t] < e.path[t] ? "before" : "after";
    }
  }
  /**
   * Gets the farthest position which matches the callback using
   * {@link module:engine/model/treewalker~TreeWalker TreeWalker}.
   *
   * For example:
   *
   * ```ts
   * getLastMatchingPosition( value => value.type == 'text' );
   * // <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>
   *
   * getLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } );
   * // <paragraph>foo[]</paragraph> -> <paragraph>[]foo</paragraph>
   *
   * getLastMatchingPosition( value => false );
   * // Do not move the position.
   * ```
   *
   * @param skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should
   * return `true` if the value should be skipped or `false` if not.
   * @param options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
   *
   * @returns The position after the last item which matches the `skip` callback test.
   */
  getLastMatchingPosition(e, t = {}) {
    t.startPosition = this;
    const n = new At(t);
    return n.skip(e), n.position;
  }
  /**
   * Returns a path to this position's parent. Parent path is equal to position {@link module:engine/model/position~Position#path path}
   * but without the last item.
   *
   * This method is safe to use it on non-existing positions (for example during operational transformation).
   *
   * @returns Path to the parent.
   */
  getParentPath() {
    return this.path.slice(0, -1);
  }
  /**
   * Returns ancestors array of this position, that is this position's parent and its ancestors.
   *
   * @returns Array with ancestors.
   */
  getAncestors() {
    const e = this.parent;
    return e.is("documentFragment") ? [e] : e.getAncestors({ includeSelf: !0 });
  }
  /**
   * Returns the parent element of the given name. Returns null if the position is not inside the desired parent.
   *
   * @param parentName The name of the parent element to find.
   */
  findAncestor(e) {
    const t = this.parent;
    return t.is("element") ? t.findAncestor(e, { includeSelf: !0 }) : null;
  }
  /**
   * Returns the slice of two position {@link #path paths} which is identical. The {@link #root roots}
   * of these two paths must be identical.
   *
   * This method is safe to use it on non-existing positions (for example during operational transformation).
   *
   * @param position The second position.
   * @returns The common path.
   */
  getCommonPath(e) {
    if (this.root != e.root)
      return [];
    const t = Ee(this.path, e.path), n = typeof t == "string" ? Math.min(this.path.length, e.path.length) : t;
    return this.path.slice(0, n);
  }
  /**
   * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}
   * which is a common ancestor of both positions. The {@link #root roots} of these two positions must be identical.
   *
   * @param position The second position.
   */
  getCommonAncestor(e) {
    const t = this.getAncestors(), n = e.getAncestors();
    let s = 0;
    for (; t[s] == n[s] && t[s]; )
      s++;
    return s === 0 ? null : t[s - 1];
  }
  /**
   * Returns a new instance of `Position`, that has same {@link #parent parent} but it's offset
   * is shifted by `shift` value (can be a negative value).
   *
   * This method is safe to use it on non-existing positions (for example during operational transformation).
   *
   * @param shift Offset shift. Can be a negative value.
   * @returns Shifted position.
   */
  getShiftedBy(e) {
    const t = this.clone(), n = t.offset + e;
    return t.offset = n < 0 ? 0 : n, t;
  }
  /**
   * Checks whether this position is after given position.
   *
   * This method is safe to use it on non-existing positions (for example during operational transformation).
   *
   * @see module:engine/model/position~Position#isBefore
   * @param  otherPosition Position to compare with.
   * @returns True if this position is after given position.
   */
  isAfter(e) {
    return this.compareWith(e) == "after";
  }
  /**
   * Checks whether this position is before given position.
   *
   * **Note:** watch out when using negation of the value returned by this method, because the negation will also
   * be `true` if positions are in different roots and you might not expect this. You should probably use
   * `a.isAfter( b ) || a.isEqual( b )` or `!a.isBefore( p ) && a.root == b.root` in most scenarios. If your
   * condition uses multiple `isAfter` and `isBefore` checks, build them so they do not use negated values, i.e.:
   *
   * ```ts
   * if ( a.isBefore( b ) && c.isAfter( d ) ) {
   * 	// do A.
   * } else {
   * 	// do B.
   * }
   * ```
   *
   * or, if you have only one if-branch:
   *
   * ```ts
   * if ( !( a.isBefore( b ) && c.isAfter( d ) ) {
   * 	// do B.
   * }
   * ```
   *
   * rather than:
   *
   * ```ts
   * if ( !a.isBefore( b ) || && !c.isAfter( d ) ) {
   * 	// do B.
   * } else {
   * 	// do A.
   * }
   * ```
   *
   * This method is safe to use it on non-existing positions (for example during operational transformation).
   *
   * @param otherPosition Position to compare with.
   * @returns True if this position is before given position.
   */
  isBefore(e) {
    return this.compareWith(e) == "before";
  }
  /**
   * Checks whether this position is equal to given position.
   *
   * This method is safe to use it on non-existing positions (for example during operational transformation).
   *
   * @param otherPosition Position to compare with.
   * @returns True if positions are same.
   */
  isEqual(e) {
    return this.compareWith(e) == "same";
  }
  /**
   * Checks whether this position is touching given position. Positions touch when there are no text nodes
   * or empty nodes in a range between them. Technically, those positions are not equal but in many cases
   * they are very similar or even indistinguishable.
   *
   * @param otherPosition Position to compare with.
   * @returns True if positions touch.
   */
  isTouching(e) {
    if (this.root !== e.root)
      return !1;
    const t = Math.min(this.path.length, e.path.length);
    for (let n = 0; n < t; n++) {
      const s = this.path[n] - e.path[n];
      if (s < -1 || s > 1)
        return !1;
      if (s === 1)
        return uu(e, this, n);
      if (s === -1)
        return uu(this, e, n);
    }
    return this.path.length === e.path.length ? !0 : this.path.length > e.path.length ? fa(this.path, t) : fa(e.path, t);
  }
  /**
   * Checks if two positions are in the same parent.
   *
   * This method is safe to use it on non-existing positions (for example during operational transformation).
   *
   * @param position Position to compare with.
   * @returns `true` if positions have the same parent, `false` otherwise.
   */
  hasSameParentAs(e) {
    if (this.root !== e.root)
      return !1;
    const t = this.getParentPath(), n = e.getParentPath();
    return Ee(t, n) == "same";
  }
  /**
   * Returns a copy of this position that is transformed by given `operation`.
   *
   * The new position's parameters are updated accordingly to the effect of the `operation`.
   *
   * For example, if `n` nodes are inserted before the position, the returned position {@link ~Position#offset} will be
   * increased by `n`. If the position was in a merged element, it will be accordingly moved to the new element, etc.
   *
   * This method is safe to use it on non-existing positions (for example during operational transformation).
   *
   * @param operation Operation to transform by.
   * @returns Transformed position.
   */
  getTransformedByOperation(e) {
    let t;
    switch (e.type) {
      case "insert":
        t = this._getTransformedByInsertOperation(e);
        break;
      case "move":
      case "remove":
      case "reinsert":
        t = this._getTransformedByMoveOperation(e);
        break;
      case "split":
        t = this._getTransformedBySplitOperation(e);
        break;
      case "merge":
        t = this._getTransformedByMergeOperation(e);
        break;
      default:
        t = y._createAt(this);
        break;
    }
    return t;
  }
  /**
   * Returns a copy of this position transformed by an insert operation.
   *
   * @internal
   */
  _getTransformedByInsertOperation(e) {
    return this._getTransformedByInsertion(e.position, e.howMany);
  }
  /**
   * Returns a copy of this position transformed by a move operation.
   *
   * @internal
   */
  _getTransformedByMoveOperation(e) {
    return this._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany);
  }
  /**
   * Returns a copy of this position transformed by a split operation.
   *
   * @internal
   */
  _getTransformedBySplitOperation(e) {
    const t = e.movedRange;
    return t.containsPosition(this) || t.start.isEqual(this) && this.stickiness == "toNext" ? this._getCombined(e.splitPosition, e.moveTargetPosition) : e.graveyardPosition ? this._getTransformedByMove(e.graveyardPosition, e.insertionPosition, 1) : this._getTransformedByInsertion(e.insertionPosition, 1);
  }
  /**
   * Returns a copy of this position transformed by merge operation.
   *
   * @internal
   */
  _getTransformedByMergeOperation(e) {
    const t = e.movedRange, n = t.containsPosition(this) || t.start.isEqual(this);
    let s;
    return n ? (s = this._getCombined(e.sourcePosition, e.targetPosition), e.sourcePosition.isBefore(e.targetPosition) && (s = s._getTransformedByDeletion(e.deletionPosition, 1))) : this.isEqual(e.deletionPosition) ? s = y._createAt(e.deletionPosition) : s = this._getTransformedByMove(e.deletionPosition, e.graveyardPosition, 1), s;
  }
  /**
   * Returns a copy of this position that is updated by removing `howMany` nodes starting from `deletePosition`.
   * It may happen that this position is in a removed node. If that is the case, `null` is returned instead.
   *
   * @internal
   * @param deletePosition Position before the first removed node.
   * @param howMany How many nodes are removed.
   * @returns Transformed position or `null`.
   */
  _getTransformedByDeletion(e, t) {
    const n = y._createAt(this);
    if (this.root != e.root)
      return n;
    if (Ee(e.getParentPath(), this.getParentPath()) == "same") {
      if (e.offset < this.offset) {
        if (e.offset + t > this.offset)
          return null;
        n.offset -= t;
      }
    } else if (Ee(e.getParentPath(), this.getParentPath()) == "prefix") {
      const s = e.path.length - 1;
      if (e.offset <= this.path[s]) {
        if (e.offset + t > this.path[s])
          return null;
        n.path[s] -= t;
      }
    }
    return n;
  }
  /**
   * Returns a copy of this position that is updated by inserting `howMany` nodes at `insertPosition`.
   *
   * @internal
   * @param insertPosition Position where nodes are inserted.
   * @param howMany How many nodes are inserted.
   * @returns Transformed position.
   */
  _getTransformedByInsertion(e, t) {
    const n = y._createAt(this);
    if (this.root != e.root)
      return n;
    if (Ee(e.getParentPath(), this.getParentPath()) == "same")
      (e.offset < this.offset || e.offset == this.offset && this.stickiness != "toPrevious") && (n.offset += t);
    else if (Ee(e.getParentPath(), this.getParentPath()) == "prefix") {
      const s = e.path.length - 1;
      e.offset <= this.path[s] && (n.path[s] += t);
    }
    return n;
  }
  /**
   * Returns a copy of this position that is updated by moving `howMany` nodes from `sourcePosition` to `targetPosition`.
   *
   * @internal
   * @param sourcePosition Position before the first element to move.
   * @param targetPosition Position where moved elements will be inserted.
   * @param howMany How many consecutive nodes to move, starting from `sourcePosition`.
   * @returns Transformed position.
   */
  _getTransformedByMove(e, t, n) {
    if (t = t._getTransformedByDeletion(e, n), e.isEqual(t))
      return y._createAt(this);
    const s = this._getTransformedByDeletion(e, n);
    return s === null || e.isEqual(this) && this.stickiness == "toNext" || e.getShiftedBy(n).isEqual(this) && this.stickiness == "toPrevious" ? this._getCombined(e, t) : s._getTransformedByInsertion(t, n);
  }
  /**
   * Returns a new position that is a combination of this position and given positions.
   *
   * The combined position is a copy of this position transformed by moving a range starting at `source` position
   * to the `target` position. It is expected that this position is inside the moved range.
   *
   * Example:
   *
   * ```ts
   * let original = model.createPositionFromPath( root, [ 2, 3, 1 ] );
   * let source = model.createPositionFromPath( root, [ 2, 2 ] );
   * let target = model.createPositionFromPath( otherRoot, [ 1, 1, 3 ] );
   * original._getCombined( source, target ); // path is [ 1, 1, 4, 1 ], root is `otherRoot`
   * ```
   *
   * Explanation:
   *
   * We have a position `[ 2, 3, 1 ]` and move some nodes from `[ 2, 2 ]` to `[ 1, 1, 3 ]`. The original position
   * was inside moved nodes and now should point to the new place. The moved nodes will be after
   * positions `[ 1, 1, 3 ]`, `[ 1, 1, 4 ]`, `[ 1, 1, 5 ]`. Since our position was in the second moved node,
   * the transformed position will be in a sub-tree of a node at `[ 1, 1, 4 ]`. Looking at original path, we
   * took care of `[ 2, 3 ]` part of it. Now we have to add the rest of the original path to the transformed path.
   * Finally, the transformed position will point to `[ 1, 1, 4, 1 ]`.
   *
   * @internal
   * @param source Beginning of the moved range.
   * @param target Position where the range is moved.
   * @returns Combined position.
   */
  _getCombined(e, t) {
    const n = e.path.length - 1, s = y._createAt(t);
    return s.stickiness = this.stickiness, s.offset = s.offset + this.path[n] - e.offset, s.path = [...s.path, ...this.path.slice(n + 1)], s;
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    return {
      root: this.root.toJSON(),
      path: Array.from(this.path),
      stickiness: this.stickiness
    };
  }
  /**
   * Returns a new position that is equal to current position.
   */
  clone() {
    return new this.constructor(this.root, this.path, this.stickiness);
  }
  /**
   * Creates position at the given location. The location can be specified as:
   *
   * * a {@link module:engine/model/position~Position position},
   * * parent element and offset (offset defaults to `0`),
   * * parent element and `'end'` (sets position at the end of that element),
   * * {@link module:engine/model/item~Item model item} and `'before'` or `'after'` (sets position before or after given model item).
   *
   * This method is a shortcut to other factory methods such as:
   *
   * * {@link module:engine/model/position~Position._createBefore},
   * * {@link module:engine/model/position~Position._createAfter}.
   *
   * @internal
   * @param offset Offset or one of the flags. Used only when the first parameter is a {@link module:engine/model/item~Item model item}.
   * @param stickiness Position stickiness. Used only when the first parameter is a {@link module:engine/model/item~Item model item}.
   */
  static _createAt(e, t, n = "toNone") {
    if (e instanceof y)
      return new y(e.root, e.path, e.stickiness);
    {
      const s = e;
      if (t == "end")
        t = s.maxOffset;
      else {
        if (t == "before")
          return this._createBefore(s, n);
        if (t == "after")
          return this._createAfter(s, n);
        if (t !== 0 && !t)
          throw new g("model-createpositionat-offset-required", [this, e]);
      }
      if (!s.is("element") && !s.is("documentFragment"))
        throw new g("model-position-parent-incorrect", [this, e]);
      const o = s.getPath();
      return o.push(t), new this(s.root, o, n);
    }
  }
  /**
   * Creates a new position, after given {@link module:engine/model/item~Item model item}.
   *
   * @internal
   * @param item Item after which the position should be placed.
   * @param stickiness Position stickiness.
   */
  static _createAfter(e, t) {
    if (!e.parent)
      throw new g("model-position-after-root", [this, e], { root: e });
    return this._createAt(e.parent, e.endOffset, t);
  }
  /**
   * Creates a new position, before the given {@link module:engine/model/item~Item model item}.
   *
   * @internal
   * @param item Item before which the position should be placed.
   * @param stickiness Position stickiness.
   */
  static _createBefore(e, t) {
    if (!e.parent)
      throw new g("model-position-before-root", e, { root: e });
    return this._createAt(e.parent, e.startOffset, t);
  }
  /**
   * Creates a `Position` instance from given plain object (i.e. parsed JSON string).
   *
   * @param json Plain object to be converted to `Position`.
   * @param doc Document object that will be position owner.
   * @returns `Position` instance created using given plain object.
   */
  static fromJSON(e, t) {
    if (e.root === "$graveyard") {
      const n = new y(t.graveyard, e.path);
      return n.stickiness = e.stickiness, n;
    }
    if (!t.getRoot(e.root))
      throw new g("model-position-fromjson-no-root", t, { rootName: e.root });
    return new y(t.getRoot(e.root), e.path, e.stickiness);
  }
}
y.prototype.is = function(i) {
  return i === "position" || i === "model:position";
};
function Ni(i, e) {
  const t = e.getChild(e.offsetToIndex(i.offset));
  return t && t.is("$text") && t.startOffset < i.offset ? t : null;
}
function Pm(i, e, t) {
  return t !== null ? null : e.getChild(e.offsetToIndex(i.offset));
}
function Rm(i, e, t) {
  return t !== null ? null : e.getChild(e.offsetToIndex(i.offset) - 1);
}
function uu(i, e, t) {
  return !(t + 1 === i.path.length || !fa(e.path, t + 1) || !Gk(i, t + 1));
}
function fa(i, e) {
  for (; e < i.length; ) {
    if (i[e] !== 0)
      return !1;
    e++;
  }
  return !0;
}
function Gk(i, e) {
  let t = i.parent, n = i.path.length - 1, s = 0;
  for (; n >= e; ) {
    if (i.path[n] + s !== t.maxOffset)
      return !1;
    s = 1, n--, t = t.parent;
  }
  return !0;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class _ extends jt {
  /**
   * Creates a range spanning from `start` position to `end` position.
   *
   * @param start The start position.
   * @param end The end position. If not set, the range will be collapsed at the `start` position.
   */
  constructor(e, t) {
    super(), this.start = y._createAt(e), this.end = t ? y._createAt(t) : y._createAt(e), this.start.stickiness = this.isCollapsed ? "toNone" : "toNext", this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious";
  }
  /**
   * Iterable interface.
   *
   * Iterates over all {@link module:engine/model/item~Item items} that are in this range and returns
   * them together with additional information like length or {@link module:engine/model/position~Position positions},
   * grouped as {@link module:engine/model/treewalker~TreeWalkerValue}.
   * It iterates over all {@link module:engine/model/textproxy~TextProxy text contents} that are inside the range
   * and all the {@link module:engine/model/element~Element}s that are entered into when iterating over this range.
   *
   * This iterator uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range
   * and `ignoreElementEnd` option set to `true`.
   */
  *[Symbol.iterator]() {
    yield* new At({ boundaries: this, ignoreElementEnd: !0 });
  }
  /**
   * Describes whether the range is collapsed, that is if {@link #start} and
   * {@link #end} positions are equal.
   */
  get isCollapsed() {
    return this.start.isEqual(this.end);
  }
  /**
   * Describes whether this range is flat, that is if {@link #start} position and
   * {@link #end} position are in the same {@link module:engine/model/position~Position#parent}.
   */
  get isFlat() {
    const e = this.start.getParentPath(), t = this.end.getParentPath();
    return Ee(e, t) == "same";
  }
  /**
   * Range root element.
   */
  get root() {
    return this.start.root;
  }
  /**
   * Checks whether this range contains given {@link module:engine/model/position~Position position}.
   *
   * @param position Position to check.
   * @returns `true` if given {@link module:engine/model/position~Position position} is contained
   * in this range,`false` otherwise.
   */
  containsPosition(e) {
    return e.isAfter(this.start) && e.isBefore(this.end);
  }
  /**
   * Checks whether this range contains given {@link ~Range range}.
   *
   * @param otherRange Range to check.
   * @param loose Whether the check is loose or strict. If the check is strict (`false`), compared range cannot
   * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or
   * even be equal to this range. Note that collapsed ranges are always compared in strict mode.
   * @returns {Boolean} `true` if given {@link ~Range range} boundaries are contained by this range, `false` otherwise.
   */
  containsRange(e, t = !1) {
    e.isCollapsed && (t = !1);
    const n = this.containsPosition(e.start) || t && this.start.isEqual(e.start), s = this.containsPosition(e.end) || t && this.end.isEqual(e.end);
    return n && s;
  }
  /**
   * Checks whether given {@link module:engine/model/item~Item} is inside this range.
   */
  containsItem(e) {
    const t = y._createBefore(e);
    return this.containsPosition(t) || this.start.isEqual(t);
  }
  /**
   * Two ranges are equal if their {@link #start} and {@link #end} positions are equal.
   *
   * @param otherRange Range to compare with.
   * @returns `true` if ranges are equal, `false` otherwise.
   */
  isEqual(e) {
    return this.start.isEqual(e.start) && this.end.isEqual(e.end);
  }
  /**
   * Checks and returns whether this range intersects with given range.
   *
   * @param otherRange Range to compare with.
   * @returns `true` if ranges intersect, `false` otherwise.
   */
  isIntersecting(e) {
    return this.start.isBefore(e.end) && this.end.isAfter(e.start);
  }
  /**
   * Computes which part(s) of this {@link ~Range range} is not a part of given {@link ~Range range}.
   * Returned array contains zero, one or two {@link ~Range ranges}.
   *
   * Examples:
   *
   * ```ts
   * let range = model.createRange(
   * 	model.createPositionFromPath( root, [ 2, 7 ] ),
   * 	model.createPositionFromPath( root, [ 4, 0, 1 ] )
   * );
   * let otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 5 ] ) );
   * let transformed = range.getDifference( otherRange );
   * // transformed array has no ranges because `otherRange` contains `range`
   *
   * otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 3 ] ) );
   * transformed = range.getDifference( otherRange );
   * // transformed array has one range: from [ 3 ] to [ 4, 0, 1 ]
   *
   * otherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 4 ] ) );
   * transformed = range.getDifference( otherRange );
   * // transformed array has two ranges: from [ 2, 7 ] to [ 3 ] and from [ 4 ] to [ 4, 0, 1 ]
   * ```
   *
   * @param otherRange Range to differentiate against.
   * @returns The difference between ranges.
   */
  getDifference(e) {
    const t = [];
    return this.isIntersecting(e) ? (this.containsPosition(e.start) && t.push(new _(this.start, e.start)), this.containsPosition(e.end) && t.push(new _(e.end, this.end))) : t.push(new _(this.start, this.end)), t;
  }
  /**
   * Returns an intersection of this {@link ~Range range} and given {@link ~Range range}.
   * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.
   *
   * Examples:
   *
   * ```ts
   * let range = model.createRange(
   * 	model.createPositionFromPath( root, [ 2, 7 ] ),
   * 	model.createPositionFromPath( root, [ 4, 0, 1 ] )
   * );
   * let otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 2 ] ) );
   * let transformed = range.getIntersection( otherRange ); // null - ranges have no common part
   *
   * otherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 5 ] ) );
   * transformed = range.getIntersection( otherRange ); // range from [ 3 ] to [ 4, 0, 1 ]
   * ```
   *
   * @param otherRange Range to check for intersection.
   * @returns A common part of given ranges or `null` if ranges have no common part.
   */
  getIntersection(e) {
    if (this.isIntersecting(e)) {
      let t = this.start, n = this.end;
      return this.containsPosition(e.start) && (t = e.start), this.containsPosition(e.end) && (n = e.end), new _(t, n);
    }
    return null;
  }
  /**
   * Returns a range created by joining this {@link ~Range range} with the given {@link ~Range range}.
   * If ranges have no common part, returns `null`.
   *
   * Examples:
   *
   * ```ts
   * let range = model.createRange(
   * 	model.createPositionFromPath( root, [ 2, 7 ] ),
   * 	model.createPositionFromPath( root, [ 4, 0, 1 ] )
   * );
   * let otherRange = model.createRange(
   * 	model.createPositionFromPath( root, [ 1 ] ),
   * 	model.createPositionFromPath( root, [ 2 ] )
   * );
   * let transformed = range.getJoined( otherRange ); // null - ranges have no common part
   *
   * otherRange = model.createRange(
   * 	model.createPositionFromPath( root, [ 3 ] ),
   * 	model.createPositionFromPath( root, [ 5 ] )
   * );
   * transformed = range.getJoined( otherRange ); // range from [ 2, 7 ] to [ 5 ]
   * ```
   *
   * @param otherRange Range to be joined.
   * @param loose Whether the intersection check is loose or strict. If the check is strict (`false`),
   * ranges are tested for intersection or whether start/end positions are equal. If the check is loose (`true`),
   * compared range is also checked if it's {@link module:engine/model/position~Position#isTouching touching} current range.
   * @returns A sum of given ranges or `null` if ranges have no common part.
   */
  getJoined(e, t = !1) {
    let n = this.isIntersecting(e);
    if (n || (this.start.isBefore(e.start) ? n = t ? this.end.isTouching(e.start) : this.end.isEqual(e.start) : n = t ? e.end.isTouching(this.start) : e.end.isEqual(this.start)), !n)
      return null;
    let s = this.start, o = this.end;
    return e.start.isBefore(s) && (s = e.start), e.end.isAfter(o) && (o = e.end), new _(s, o);
  }
  /**
   * Computes and returns the smallest set of {@link #isFlat flat} ranges, that covers this range in whole.
   *
   * See an example of a model structure (`[` and `]` are range boundaries):
   *
   * ```
   * root                                                            root
   *  |- element DIV                         DIV             P2              P3             DIV
   *  |   |- element H                   H        P1        f o o           b a r       H         P4
   *  |   |   |- "fir[st"             fir[st     lorem                               se]cond     ipsum
   *  |   |- element P1
   *  |   |   |- "lorem"                                              ||
   *  |- element P2                                                   ||
   *  |   |- "foo"                                                    VV
   *  |- element P3
   *  |   |- "bar"                                                   root
   *  |- element DIV                         DIV             [P2             P3]             DIV
   *  |   |- element H                   H       [P1]       f o o           b a r        H         P4
   *  |   |   |- "se]cond"            fir[st]    lorem                               [se]cond     ipsum
   *  |   |- element P4
   *  |   |   |- "ipsum"
   * ```
   *
   * As it can be seen, letters contained in the range are: `stloremfoobarse`, spread across different parents.
   * We are looking for minimal set of flat ranges that contains the same nodes.
   *
   * Minimal flat ranges for above range `( [ 0, 0, 3 ], [ 3, 0, 2 ] )` will be:
   *
   * ```
   * ( [ 0, 0, 3 ], [ 0, 0, 5 ] ) = "st"
   * ( [ 0, 1 ], [ 0, 2 ] ) = element P1 ("lorem")
   * ( [ 1 ], [ 3 ] ) = element P2, element P3 ("foobar")
   * ( [ 3, 0, 0 ], [ 3, 0, 2 ] ) = "se"
   * ```
   *
   * **Note:** if an {@link module:engine/model/element~Element element} is not wholly contained in this range, it won't be returned
   * in any of the returned flat ranges. See in the example how `H` elements at the beginning and at the end of the range
   * were omitted. Only their parts that were wholly in the range were returned.
   *
   * **Note:** this method is not returning flat ranges that contain no nodes.
   *
   * @returns Array of flat ranges covering this range.
   */
  getMinimalFlatRanges() {
    const e = [], t = this.start.getCommonPath(this.end).length, n = y._createAt(this.start);
    let s = n.parent;
    for (; n.path.length > t + 1; ) {
      const o = s.maxOffset - n.offset;
      o !== 0 && e.push(new _(n, n.getShiftedBy(o))), n.path = n.path.slice(0, -1), n.offset++, s = s.parent;
    }
    for (; n.path.length <= this.end.path.length; ) {
      const o = this.end.path[n.path.length - 1], r = o - n.offset;
      r !== 0 && e.push(new _(n, n.getShiftedBy(r))), n.offset = o, n.path.push(0);
    }
    return e;
  }
  /**
   * Creates a {@link module:engine/model/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.
   *
   * For example, to iterate over all items in the entire document root:
   *
   * ```ts
   * // Create a range spanning over the entire root content:
   * const range = editor.model.createRangeIn( editor.model.document.getRoot() );
   *
   * // Iterate over all items in this range:
   * for ( const value of range.getWalker() ) {
   * 	console.log( value.item );
   * }
   * ```
   *
   * @param options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
   */
  getWalker(e = {}) {
    return e.boundaries = this, new At(e);
  }
  /**
   * Returns an iterator that iterates over all {@link module:engine/model/item~Item items} that are in this range and returns
   * them.
   *
   * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option
   * set to `true`. However it returns only {@link module:engine/model/item~Item model items},
   * not {@link module:engine/model/treewalker~TreeWalkerValue}.
   *
   * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for
   * a full list of available options.
   *
   * @param options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
   */
  *getItems(e = {}) {
    e.boundaries = this, e.ignoreElementEnd = !0;
    const t = new At(e);
    for (const n of t)
      yield n.item;
  }
  /**
   * Returns an iterator that iterates over all {@link module:engine/model/position~Position positions} that are boundaries or
   * contained in this range.
   *
   * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only
   * {@link module:engine/model/position~Position positions}, not {@link module:engine/model/treewalker~TreeWalkerValue}.
   *
   * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for
   * a full list of available options.
   *
   * @param options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
   */
  *getPositions(e = {}) {
    e.boundaries = this;
    const t = new At(e);
    yield t.position;
    for (const n of t)
      yield n.nextPosition;
  }
  /**
   * Returns a range that is a result of transforming this range by given `operation`.
   *
   * **Note:** transformation may break one range into multiple ranges (for example, when a part of the range is
   * moved to a different part of document tree). For this reason, an array is returned by this method and it
   * may contain one or more `Range` instances.
   *
   * @param operation Operation to transform range by.
   * @returns Range which is the result of transformation.
   */
  getTransformedByOperation(e) {
    switch (e.type) {
      case "insert":
        return this._getTransformedByInsertOperation(e);
      case "move":
      case "remove":
      case "reinsert":
        return this._getTransformedByMoveOperation(e);
      case "split":
        return [this._getTransformedBySplitOperation(e)];
      case "merge":
        return [this._getTransformedByMergeOperation(e)];
    }
    return [new _(this.start, this.end)];
  }
  /**
   * Returns a range that is a result of transforming this range by multiple `operations`.
   *
   * @see ~Range#getTransformedByOperation
   * @param operations Operations to transform the range by.
   * @returns Range which is the result of transformation.
   */
  getTransformedByOperations(e) {
    const t = [new _(this.start, this.end)];
    for (const n of e)
      for (let s = 0; s < t.length; s++) {
        const o = t[s].getTransformedByOperation(n);
        t.splice(s, 1, ...o), s += o.length - 1;
      }
    for (let n = 0; n < t.length; n++) {
      const s = t[n];
      for (let o = n + 1; o < t.length; o++) {
        const r = t[o];
        (s.containsRange(r) || r.containsRange(s) || s.isEqual(r)) && t.splice(o, 1);
      }
    }
    return t;
  }
  /**
   * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}
   * which is a common ancestor of the range's both ends (in which the entire range is contained).
   */
  getCommonAncestor() {
    return this.start.getCommonAncestor(this.end);
  }
  /**
   * Returns an {@link module:engine/model/element~Element Element} contained by the range.
   * The element will be returned when it is the **only** node within the range and **fully–contained**
   * at the same time.
   */
  getContainedElement() {
    if (this.isCollapsed)
      return null;
    const e = this.start.nodeAfter, t = this.end.nodeBefore;
    return e && e.is("element") && e === t ? e : null;
  }
  /**
   * Converts `Range` to plain object and returns it.
   *
   * @returns `Node` converted to plain object.
   */
  toJSON() {
    return {
      start: this.start.toJSON(),
      end: this.end.toJSON()
    };
  }
  /**
   * Returns a new range that is equal to current range.
   */
  clone() {
    return new this.constructor(this.start, this.end);
  }
  /**
   * Returns a result of transforming a copy of this range by insert operation.
   *
   * One or more ranges may be returned as a result of this transformation.
   *
   * @internal
   */
  _getTransformedByInsertOperation(e, t = !1) {
    return this._getTransformedByInsertion(e.position, e.howMany, t);
  }
  /**
   * Returns a result of transforming a copy of this range by move operation.
   *
   * One or more ranges may be returned as a result of this transformation.
   *
   * @internal
   */
  _getTransformedByMoveOperation(e, t = !1) {
    const n = e.sourcePosition, s = e.howMany, o = e.targetPosition;
    return this._getTransformedByMove(n, o, s, t);
  }
  /**
   * Returns a result of transforming a copy of this range by split operation.
   *
   * Always one range is returned. The transformation is done in a way to not break the range.
   *
   * @internal
   */
  _getTransformedBySplitOperation(e) {
    const t = this.start._getTransformedBySplitOperation(e);
    let n = this.end._getTransformedBySplitOperation(e);
    return this.end.isEqual(e.insertionPosition) && (n = this.end.getShiftedBy(1)), t.root != n.root && (n = this.end.getShiftedBy(-1)), new _(t, n);
  }
  /**
   * Returns a result of transforming a copy of this range by merge operation.
   *
   * Always one range is returned. The transformation is done in a way to not break the range.
   *
   * @internal
   */
  _getTransformedByMergeOperation(e) {
    if (this.start.isEqual(e.targetPosition) && this.end.isEqual(e.deletionPosition))
      return new _(this.start);
    let t = this.start._getTransformedByMergeOperation(e), n = this.end._getTransformedByMergeOperation(e);
    return t.root != n.root && (n = this.end.getShiftedBy(-1)), t.isAfter(n) ? (e.sourcePosition.isBefore(e.targetPosition) ? (t = y._createAt(n), t.offset = 0) : (e.deletionPosition.isEqual(t) || (n = e.deletionPosition), t = e.targetPosition), new _(t, n)) : new _(t, n);
  }
  /**
   * Returns an array containing one or two {@link ~Range ranges} that are a result of transforming this
   * {@link ~Range range} by inserting `howMany` nodes at `insertPosition`. Two {@link ~Range ranges} are
   * returned if the insertion was inside this {@link ~Range range} and `spread` is set to `true`.
   *
   * Examples:
   *
   * ```ts
   * let range = model.createRange(
   * 	model.createPositionFromPath( root, [ 2, 7 ] ),
   * 	model.createPositionFromPath( root, [ 4, 0, 1 ] )
   * );
   * let transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 1 ] ), 2 );
   * // transformed array has one range from [ 4, 7 ] to [ 6, 0, 1 ]
   *
   * transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 4, 0, 0 ] ), 4 );
   * // transformed array has one range from [ 2, 7 ] to [ 4, 0, 5 ]
   *
   * transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4 );
   * // transformed array has one range, which is equal to original range
   *
   * transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4, true );
   * // transformed array has two ranges: from [ 2, 7 ] to [ 3, 2 ] and from [ 3, 6 ] to [ 4, 0, 1 ]
   * ```
   *
   * @internal
   * @param insertPosition Position where nodes are inserted.
   * @param howMany How many nodes are inserted.
   * @param spread Flag indicating whether this range should be spread if insertion
   * was inside the range. Defaults to `false`.
   * @returns Result of the transformation.
   */
  _getTransformedByInsertion(e, t, n = !1) {
    if (n && this.containsPosition(e))
      return [
        new _(this.start, e),
        new _(e.getShiftedBy(t), this.end._getTransformedByInsertion(e, t))
      ];
    {
      const s = new _(this.start, this.end);
      return s.start = s.start._getTransformedByInsertion(e, t), s.end = s.end._getTransformedByInsertion(e, t), [s];
    }
  }
  /**
   * Returns an array containing {@link ~Range ranges} that are a result of transforming this
   * {@link ~Range range} by moving `howMany` nodes from `sourcePosition` to `targetPosition`.
   *
   * @internal
   * @param sourcePosition Position from which nodes are moved.
   * @param targetPosition Position to where nodes are moved.
   * @param howMany How many nodes are moved.
   * @param spread Whether the range should be spread if the move points inside the range.
   * @returns  Result of the transformation.
   */
  _getTransformedByMove(e, t, n, s = !1) {
    if (this.isCollapsed) {
      const d = this.start._getTransformedByMove(e, t, n);
      return [new _(d)];
    }
    const o = _._createFromPositionAndShift(e, n), r = t._getTransformedByDeletion(e, n);
    if (this.containsPosition(t) && !s && (o.containsPosition(this.start) || o.containsPosition(this.end))) {
      const d = this.start._getTransformedByMove(e, t, n), h = this.end._getTransformedByMove(e, t, n);
      return [new _(d, h)];
    }
    let a;
    const l = this.getDifference(o);
    let c = null;
    const u = this.getIntersection(o);
    if (l.length == 1 ? c = new _(l[0].start._getTransformedByDeletion(e, n), l[0].end._getTransformedByDeletion(e, n)) : l.length == 2 && (c = new _(this.start, this.end._getTransformedByDeletion(e, n))), c ? a = c._getTransformedByInsertion(r, n, u !== null || s) : a = [], u) {
      const d = new _(u.start._getCombined(o.start, r), u.end._getCombined(o.start, r));
      a.length == 2 ? a.splice(1, 0, d) : a.push(d);
    }
    return a;
  }
  /**
   * Returns a copy of this range that is transformed by deletion of `howMany` nodes from `deletePosition`.
   *
   * If the deleted range is intersecting with the transformed range, the transformed range will be shrank.
   *
   * If the deleted range contains transformed range, `null` will be returned.
   *
   * @internal
   * @param deletionPosition Position from which nodes are removed.
   * @param howMany How many nodes are removed.
   * @returns Result of the transformation.
   */
  _getTransformedByDeletion(e, t) {
    let n = this.start._getTransformedByDeletion(e, t), s = this.end._getTransformedByDeletion(e, t);
    return n == null && s == null ? null : (n == null && (n = e), s == null && (s = e), new _(n, s));
  }
  /**
   * Creates a new range, spreading from specified {@link module:engine/model/position~Position position} to a position moved by
   * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.
   *
   * @internal
   * @param position Beginning of the range.
   * @param shift How long the range should be.
   */
  static _createFromPositionAndShift(e, t) {
    const n = e, s = e.getShiftedBy(t);
    return t > 0 ? new this(n, s) : new this(s, n);
  }
  /**
   * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * @internal
   * @param element Element which is a parent for the range.
   */
  static _createIn(e) {
    return new this(y._createAt(e, 0), y._createAt(e, e.maxOffset));
  }
  /**
   * Creates a range that starts before given {@link module:engine/model/item~Item model item} and ends after it.
   *
   * @internal
   */
  static _createOn(e) {
    return this._createFromPositionAndShift(y._createBefore(e), e.offsetSize);
  }
  /**
   * Combines all ranges from the passed array into a one range. At least one range has to be passed.
   * Passed ranges must not have common parts.
   *
   * The first range from the array is a reference range. If other ranges start or end on the exactly same position where
   * the reference range, they get combined into one range.
   *
   * ```
   * [  ][]  [    ][ ][             ][ ][]  [  ]  // Passed ranges, shown sorted
   * [    ]                                       // The result of the function if the first range was a reference range.
   *         [                           ]        // The result of the function if the third-to-seventh range was a reference range.
   *                                        [  ]  // The result of the function if the last range was a reference range.
   * ```
   *
   * @internal
   * @param ranges Ranges to combine.
   * @returns Combined range.
   */
  static _createFromRanges(e) {
    if (e.length === 0)
      throw new g("range-create-from-ranges-empty-array", null);
    if (e.length == 1)
      return e[0].clone();
    const t = e[0];
    e.sort((o, r) => o.start.isAfter(r.start) ? 1 : -1);
    const n = e.indexOf(t), s = new this(t.start, t.end);
    if (n > 0)
      for (let o = n - 1; e[o].end.isEqual(s.start); o++)
        s.start = y._createAt(e[o].start);
    for (let o = n + 1; o < e.length && e[o].start.isEqual(s.end); o++)
      s.end = y._createAt(e[o].end);
    return s;
  }
  /**
   * Creates a `Range` instance from given plain object (i.e. parsed JSON string).
   *
   * @param json Plain object to be converted to `Range`.
   * @param doc Document object that will be range owner.
   * @returns `Range` instance created using given plain object.
   */
  static fromJSON(e, t) {
    return new this(y.fromJSON(e.start, t), y.fromJSON(e.end, t));
  }
}
_.prototype.is = function(i) {
  return i === "range" || i === "model:range";
};
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Vm extends G() {
  /**
   * Creates an instance of the mapper.
   */
  constructor() {
    super(), this._modelToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelLengthCallbacks = /* @__PURE__ */ new Map(), this._markerNameToElements = /* @__PURE__ */ new Map(), this._elementToMarkerNames = /* @__PURE__ */ new Map(), this._deferredBindingRemovals = /* @__PURE__ */ new Map(), this._unboundMarkerNames = /* @__PURE__ */ new Set(), this.on("modelToViewPosition", (e, t) => {
      if (t.viewPosition)
        return;
      const n = this._modelToViewMapping.get(t.modelPosition.parent);
      if (!n)
        throw new g("mapping-model-position-view-parent-not-found", this, { modelPosition: t.modelPosition });
      t.viewPosition = this.findPositionIn(n, t.modelPosition.offset);
    }, { priority: "low" }), this.on("viewToModelPosition", (e, t) => {
      if (t.modelPosition)
        return;
      const n = this.findMappedViewAncestor(t.viewPosition), s = this._viewToModelMapping.get(n), o = this._toModelOffset(t.viewPosition.parent, t.viewPosition.offset, n);
      t.modelPosition = y._createAt(s, o);
    }, { priority: "low" });
  }
  /**
   * Marks model and view elements as corresponding. Corresponding elements can be retrieved by using
   * the {@link module:engine/conversion/mapper~Mapper#toModelElement toModelElement} and
   * {@link module:engine/conversion/mapper~Mapper#toViewElement toViewElement} methods.
   * The information that elements are bound is also used to translate positions.
   *
   * @param modelElement Model element.
   * @param viewElement View element.
   */
  bindElements(e, t) {
    this._modelToViewMapping.set(e, t), this._viewToModelMapping.set(t, e);
  }
  /**
   * Unbinds the given {@link module:engine/view/element~Element view element} from the map.
   *
   * **Note:** view-to-model binding will be removed, if it existed. However, corresponding model-to-view binding
   * will be removed only if model element is still bound to the passed `viewElement`.
   *
   * This behavior allows for re-binding model element to another view element without fear of losing the new binding
   * when the previously bound view element is unbound.
   *
   * @param viewElement View element to unbind.
   * @param options The options object.
   * @param options.defer Controls whether the binding should be removed immediately or deferred until a
   * {@link #flushDeferredBindings `flushDeferredBindings()`} call.
   */
  unbindViewElement(e, t = {}) {
    const n = this.toModelElement(e);
    if (this._elementToMarkerNames.has(e))
      for (const s of this._elementToMarkerNames.get(e))
        this._unboundMarkerNames.add(s);
    t.defer ? this._deferredBindingRemovals.set(e, e.root) : (this._viewToModelMapping.delete(e), this._modelToViewMapping.get(n) == e && this._modelToViewMapping.delete(n));
  }
  /**
   * Unbinds the given {@link module:engine/model/element~Element model element} from the map.
   *
   * **Note:** the model-to-view binding will be removed, if it existed. However, the corresponding view-to-model binding
   * will be removed only if the view element is still bound to the passed `modelElement`.
   *
   * This behavior lets for re-binding view element to another model element without fear of losing the new binding
   * when the previously bound model element is unbound.
   *
   * @param modelElement Model element to unbind.
   */
  unbindModelElement(e) {
    const t = this.toViewElement(e);
    this._modelToViewMapping.delete(e), this._viewToModelMapping.get(t) == e && this._viewToModelMapping.delete(t);
  }
  /**
   * Binds the given marker name with the given {@link module:engine/view/element~Element view element}. The element
   * will be added to the current set of elements bound with the given marker name.
   *
   * @param element Element to bind.
   * @param name Marker name.
   */
  bindElementToMarker(e, t) {
    const n = this._markerNameToElements.get(t) || /* @__PURE__ */ new Set();
    n.add(e);
    const s = this._elementToMarkerNames.get(e) || /* @__PURE__ */ new Set();
    s.add(t), this._markerNameToElements.set(t, n), this._elementToMarkerNames.set(e, s);
  }
  /**
   * Unbinds an element from given marker name.
   *
   * @param element Element to unbind.
   * @param name Marker name.
   */
  unbindElementFromMarkerName(e, t) {
    const n = this._markerNameToElements.get(t);
    n && (n.delete(e), n.size == 0 && this._markerNameToElements.delete(t));
    const s = this._elementToMarkerNames.get(e);
    s && (s.delete(t), s.size == 0 && this._elementToMarkerNames.delete(e));
  }
  /**
   * Returns all marker names of markers which have changed due to unbinding a view element (so it is assumed that the view element
   * has been removed, moved or renamed) since the last flush. After returning, the marker names list is cleared.
   */
  flushUnboundMarkerNames() {
    const e = Array.from(this._unboundMarkerNames);
    return this._unboundMarkerNames.clear(), e;
  }
  /**
   * Unbinds all deferred binding removals of view elements that in the meantime were not re-attached to some root or document fragment.
   *
   * See: {@link #unbindViewElement `unbindViewElement()`}.
   */
  flushDeferredBindings() {
    for (const [e, t] of this._deferredBindingRemovals)
      e.root == t && this.unbindViewElement(e);
    this._deferredBindingRemovals = /* @__PURE__ */ new Map();
  }
  /**
   * Removes all model to view and view to model bindings.
   */
  clearBindings() {
    this._modelToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelMapping = /* @__PURE__ */ new WeakMap(), this._markerNameToElements = /* @__PURE__ */ new Map(), this._elementToMarkerNames = /* @__PURE__ */ new Map(), this._unboundMarkerNames = /* @__PURE__ */ new Set(), this._deferredBindingRemovals = /* @__PURE__ */ new Map();
  }
  toModelElement(e) {
    return this._viewToModelMapping.get(e);
  }
  toViewElement(e) {
    return this._modelToViewMapping.get(e);
  }
  /**
   * Gets the corresponding model range.
   *
   * @param viewRange View range.
   * @returns Corresponding model range.
   */
  toModelRange(e) {
    return new _(this.toModelPosition(e.start), this.toModelPosition(e.end));
  }
  /**
   * Gets the corresponding view range.
   *
   * @param modelRange Model range.
   * @returns Corresponding view range.
   */
  toViewRange(e) {
    return new O(this.toViewPosition(e.start), this.toViewPosition(e.end));
  }
  /**
   * Gets the corresponding model position.
   *
   * @fires viewToModelPosition
   * @param viewPosition View position.
   * @returns Corresponding model position.
   */
  toModelPosition(e) {
    const t = {
      viewPosition: e,
      mapper: this
    };
    return this.fire("viewToModelPosition", t), t.modelPosition;
  }
  /**
   * Gets the corresponding view position.
   *
   * @fires modelToViewPosition
   * @param modelPosition Model position.
   * @param options Additional options for position mapping process.
   * @param options.isPhantom Should be set to `true` if the model position to map is pointing to a place
   * in model tree which no longer exists. For example, it could be an end of a removed model range.
   * @returns Corresponding view position.
   */
  toViewPosition(e, t = {}) {
    const n = {
      modelPosition: e,
      mapper: this,
      isPhantom: t.isPhantom
    };
    return this.fire("modelToViewPosition", n), n.viewPosition;
  }
  /**
   * Gets all view elements bound to the given marker name.
   *
   * @param name Marker name.
   * @returns View elements bound with the given marker name or `null`
   * if no elements are bound to the given marker name.
   */
  markerNameToElements(e) {
    const t = this._markerNameToElements.get(e);
    if (!t)
      return null;
    const n = /* @__PURE__ */ new Set();
    for (const s of t)
      if (s.is("attributeElement"))
        for (const o of s.getElementsWithSameId())
          n.add(o);
      else
        n.add(s);
    return n;
  }
  /**
   * Registers a callback that evaluates the length in the model of a view element with the given name.
   *
   * The callback is fired with one argument, which is a view element instance. The callback is expected to return
   * a number representing the length of the view element in the model.
   *
   * ```ts
   * // List item in view may contain nested list, which have other list items. In model though,
   * // the lists are represented by flat structure. Because of those differences, length of list view element
   * // may be greater than one. In the callback it's checked how many nested list items are in evaluated list item.
   *
   * function getViewListItemLength( element ) {
   * 	let length = 1;
   *
   * 	for ( let child of element.getChildren() ) {
   * 		if ( child.name == 'ul' || child.name == 'ol' ) {
   * 			for ( let item of child.getChildren() ) {
   * 				length += getViewListItemLength( item );
   * 			}
   * 		}
   * 	}
   *
   * 	return length;
   * }
   *
   * mapper.registerViewToModelLength( 'li', getViewListItemLength );
   * ```
   *
   * @param viewElementName Name of view element for which callback is registered.
   * @param lengthCallback Function return a length of view element instance in model.
   */
  registerViewToModelLength(e, t) {
    this._viewToModelLengthCallbacks.set(e, t);
  }
  /**
   * For the given `viewPosition`, finds and returns the closest ancestor of this position that has a mapping to
   * the model.
   *
   * @param viewPosition Position for which a mapped ancestor should be found.
   */
  findMappedViewAncestor(e) {
    let t = e.parent;
    for (; !this._viewToModelMapping.has(t); )
      t = t.parent;
    return t;
  }
  /**
   * Calculates model offset based on the view position and the block element.
   *
   * Example:
   *
   * ```html
   * <p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, p ) -> 5
   * ```
   *
   * Is a sum of:
   *
   * ```html
   * <p>foo|<b>bar</b></p> // _toModelOffset( p, 3, p ) -> 3
   * <p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, b ) -> 2
   * ```
   *
   * @param viewParent Position parent.
   * @param viewOffset Position offset.
   * @param viewBlock Block used as a base to calculate offset.
   * @returns Offset in the model.
   */
  _toModelOffset(e, t, n) {
    if (n != e) {
      const o = this._toModelOffset(e.parent, e.index, n), r = this._toModelOffset(e, t, e);
      return o + r;
    }
    if (e.is("$text"))
      return t;
    let s = 0;
    for (let o = 0; o < t; o++)
      s += this.getModelLength(e.getChild(o));
    return s;
  }
  /**
   * Gets the length of the view element in the model.
   *
   * The length is calculated as follows:
   * * if a {@link #registerViewToModelLength length mapping callback} is provided for the given `viewNode`, it is used to
   * evaluate the model length (`viewNode` is used as first and only parameter passed to the callback),
   * * length of a {@link module:engine/view/text~Text text node} is equal to the length of its
   * {@link module:engine/view/text~Text#data data},
   * * length of a {@link module:engine/view/uielement~UIElement ui element} is equal to 0,
   * * length of a mapped {@link module:engine/view/element~Element element} is equal to 1,
   * * length of a non-mapped {@link module:engine/view/element~Element element} is equal to the length of its children.
   *
   * Examples:
   *
   * ```
   * foo                          -> 3 // Text length is equal to its data length.
   * <p>foo</p>                   -> 1 // Length of an element which is mapped is by default equal to 1.
   * <b>foo</b>                   -> 3 // Length of an element which is not mapped is a length of its children.
   * <div><p>x</p><p>y</p></div>  -> 2 // Assuming that <div> is not mapped and <p> are mapped.
   * ```
   *
   * @param viewNode View node.
   * @returns Length of the node in the tree model.
   */
  getModelLength(e) {
    if (this._viewToModelLengthCallbacks.get(e.name))
      return this._viewToModelLengthCallbacks.get(e.name)(e);
    if (this._viewToModelMapping.has(e))
      return 1;
    if (e.is("$text"))
      return e.data.length;
    if (e.is("uiElement"))
      return 0;
    {
      let t = 0;
      for (const n of e.getChildren())
        t += this.getModelLength(n);
      return t;
    }
  }
  /**
   * Finds the position in the view node (or in its children) with the expected model offset.
   *
   * Example:
   *
   * ```
   * <p>fo<b>bar</b>bom</p> -> expected offset: 4
   *
   * findPositionIn( p, 4 ):
   * <p>|fo<b>bar</b>bom</p> -> expected offset: 4, actual offset: 0
   * <p>fo|<b>bar</b>bom</p> -> expected offset: 4, actual offset: 2
   * <p>fo<b>bar</b>|bom</p> -> expected offset: 4, actual offset: 5 -> we are too far
   *
   * findPositionIn( b, 4 - ( 5 - 3 ) ):
   * <p>fo<b>|bar</b>bom</p> -> expected offset: 2, actual offset: 0
   * <p>fo<b>bar|</b>bom</p> -> expected offset: 2, actual offset: 3 -> we are too far
   *
   * findPositionIn( bar, 2 - ( 3 - 3 ) ):
   * We are in the text node so we can simple find the offset.
   * <p>fo<b>ba|r</b>bom</p> -> expected offset: 2, actual offset: 2 -> position found
   * ```
   *
   * @param viewParent Tree view element in which we are looking for the position.
   * @param expectedOffset Expected offset.
   * @returns Found position.
   */
  findPositionIn(e, t) {
    let n, s = 0, o = 0, r = 0;
    if (e.is("$text"))
      return new k(e, t);
    for (; o < t; )
      n = e.getChild(r), s = this.getModelLength(n), o += s, r++;
    return o == t ? this._moveViewPositionToTextNode(new k(e, r)) : this.findPositionIn(n, t - (o - s));
  }
  /**
   * Because we prefer positions in the text nodes over positions next to text nodes, if the view position was next to a text node,
   * it moves it into the text node instead.
   *
   * ```
   * <p>[]<b>foo</b></p> -> <p>[]<b>foo</b></p> // do not touch if position is not directly next to text
   * <p>foo[]<b>foo</b></p> -> <p>foo{}<b>foo</b></p> // move to text node
   * <p><b>[]foo</b></p> -> <p><b>{}foo</b></p> // move to text node
   * ```
   *
   * @param viewPosition Position potentially next to the text node.
   * @returns Position in the text node if possible.
   */
  _moveViewPositionToTextNode(e) {
    const t = e.nodeBefore, n = e.nodeAfter;
    return t instanceof ne ? new k(t, t.data.length) : n instanceof ne ? new k(n, 0) : e;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class jk {
  constructor() {
    this._consumable = /* @__PURE__ */ new Map(), this._textProxyRegistry = /* @__PURE__ */ new Map();
  }
  /**
   * Adds a consumable value to the consumables list and links it with a given model item.
   *
   * ```ts
   * modelConsumable.add( modelElement, 'insert' ); // Add `modelElement` insertion change to consumable values.
   * modelConsumable.add( modelElement, 'addAttribute:bold' ); // Add `bold` attribute insertion on `modelElement` change.
   * modelConsumable.add( modelElement, 'removeAttribute:bold' ); // Add `bold` attribute removal on `modelElement` change.
   * modelConsumable.add( modelSelection, 'selection' ); // Add `modelSelection` to consumable values.
   * modelConsumable.add( modelRange, 'range' ); // Add `modelRange` to consumable values.
   * ```
   *
   * @param item Model item, range or selection that has the consumable.
   * @param type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.
   * Second colon and everything after will be cut. Passing event name is a safe and good practice.
   */
  add(e, t) {
    t = Rs(t), e instanceof it && (e = this._getSymbolForTextProxy(e)), this._consumable.has(e) || this._consumable.set(e, /* @__PURE__ */ new Map()), this._consumable.get(e).set(t, !0);
  }
  /**
   * Removes a given consumable value from a given model item.
   *
   * ```ts
   * modelConsumable.consume( modelElement, 'insert' ); // Remove `modelElement` insertion change from consumable values.
   * modelConsumable.consume( modelElement, 'addAttribute:bold' ); // Remove `bold` attribute insertion on `modelElement` change.
   * modelConsumable.consume( modelElement, 'removeAttribute:bold' ); // Remove `bold` attribute removal on `modelElement` change.
   * modelConsumable.consume( modelSelection, 'selection' ); // Remove `modelSelection` from consumable values.
   * modelConsumable.consume( modelRange, 'range' ); // Remove 'modelRange' from consumable values.
   * ```
   *
   * @param item Model item, range or selection from which consumable will be consumed.
   * @param type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.
   * Second colon and everything after will be cut. Passing event name is a safe and good practice.
   * @returns `true` if consumable value was available and was consumed, `false` otherwise.
   */
  consume(e, t) {
    return t = Rs(t), e instanceof it && (e = this._getSymbolForTextProxy(e)), this.test(e, t) ? (this._consumable.get(e).set(t, !1), !0) : !1;
  }
  /**
   * Tests whether there is a consumable value of a given type connected with a given model item.
   *
   * ```ts
   * modelConsumable.test( modelElement, 'insert' ); // Check for `modelElement` insertion change.
   * modelConsumable.test( modelElement, 'addAttribute:bold' ); // Check for `bold` attribute insertion on `modelElement` change.
   * modelConsumable.test( modelElement, 'removeAttribute:bold' ); // Check for `bold` attribute removal on `modelElement` change.
   * modelConsumable.test( modelSelection, 'selection' ); // Check if `modelSelection` is consumable.
   * modelConsumable.test( modelRange, 'range' ); // Check if `modelRange` is consumable.
   * ```
   *
   * @param item Model item, range or selection to be tested.
   * @param type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.
   * Second colon and everything after will be cut. Passing event name is a safe and good practice.
   * @returns `null` if such consumable was never added, `false` if the consumable values was
   * already consumed or `true` if it was added and not consumed yet.
   */
  test(e, t) {
    t = Rs(t), e instanceof it && (e = this._getSymbolForTextProxy(e));
    const n = this._consumable.get(e);
    if (n === void 0)
      return null;
    const s = n.get(t);
    return s === void 0 ? null : s;
  }
  /**
   * Reverts consuming of a consumable value.
   *
   * ```ts
   * modelConsumable.revert( modelElement, 'insert' ); // Revert consuming `modelElement` insertion change.
   * modelConsumable.revert( modelElement, 'addAttribute:bold' ); // Revert consuming `bold` attribute insert from `modelElement`.
   * modelConsumable.revert( modelElement, 'removeAttribute:bold' ); // Revert consuming `bold` attribute remove from `modelElement`.
   * modelConsumable.revert( modelSelection, 'selection' ); // Revert consuming `modelSelection`.
   * modelConsumable.revert( modelRange, 'range' ); // Revert consuming `modelRange`.
   * ```
   *
   * @param item Model item, range or selection to be reverted.
   * @param type Consumable type.
   * @returns `true` if consumable has been reversed, `false` otherwise. `null` if the consumable has
   * never been added.
   */
  revert(e, t) {
    t = Rs(t), e instanceof it && (e = this._getSymbolForTextProxy(e));
    const n = this.test(e, t);
    return n === !1 ? (this._consumable.get(e).set(t, !0), !0) : n === !0 ? !1 : null;
  }
  /**
   * Verifies if all events from the specified group were consumed.
   *
   * @param eventGroup The events group to verify.
   */
  verifyAllConsumed(e) {
    const t = [];
    for (const [n, s] of this._consumable)
      for (const [o, r] of s) {
        const a = o.split(":")[0];
        r && e == a && t.push({
          event: o,
          item: n.name || n.description
        });
      }
    if (t.length)
      throw new g("conversion-model-consumable-not-consumed", null, { items: t });
  }
  /**
   * Gets a unique symbol for the passed {@link module:engine/model/textproxy~TextProxy} instance. All `TextProxy` instances that
   * have same parent, same start index and same end index will get the same symbol.
   *
   * Used internally to correctly consume `TextProxy` instances.
   *
   * @internal
   * @param textProxy `TextProxy` instance to get a symbol for.
   * @returns Symbol representing all equal instances of `TextProxy`.
   */
  _getSymbolForTextProxy(e) {
    let t = null;
    const n = this._textProxyRegistry.get(e.startOffset);
    if (n) {
      const s = n.get(e.endOffset);
      s && (t = s.get(e.parent));
    }
    return t || (t = this._addSymbolForTextProxy(e)), t;
  }
  /**
   * Adds a symbol for the given {@link module:engine/model/textproxy~TextProxy} instance.
   *
   * Used internally to correctly consume `TextProxy` instances.
   *
   * @param textProxy Text proxy instance.
   * @returns Symbol generated for given `TextProxy`.
   */
  _addSymbolForTextProxy(e) {
    const t = e.startOffset, n = e.endOffset, s = e.parent, o = Symbol("$textProxy:" + e.data);
    let r, a;
    return r = this._textProxyRegistry.get(t), r || (r = /* @__PURE__ */ new Map(), this._textProxyRegistry.set(t, r)), a = r.get(n), a || (a = /* @__PURE__ */ new Map(), r.set(n, a)), a.set(s, o), o;
  }
}
function Rs(i) {
  const e = i.split(":");
  return e[0] == "insert" ? e[0] : e[0] == "addMarker" || e[0] == "removeMarker" ? i : e.length > 1 ? e[0] + ":" + e[1] : e[0];
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Mm extends G() {
  /**
   * Creates a downcast dispatcher instance.
   *
   * @see module:engine/conversion/downcastdispatcher~DowncastConversionApi
   *
   * @param conversionApi Additional properties for an interface that will be passed to events fired
   * by the downcast dispatcher.
   */
  constructor(e) {
    super(), this._conversionApi = { dispatcher: this, ...e }, this._firedEventsMap = /* @__PURE__ */ new WeakMap();
  }
  /**
   * Converts changes buffered in the given {@link module:engine/model/differ~Differ model differ}
   * and fires conversion events based on it.
   *
   * @fires insert
   * @fires remove
   * @fires attribute
   * @fires addMarker
   * @fires removeMarker
   * @fires reduceChanges
   * @param differ The differ object with buffered changes.
   * @param markers Markers related to the model fragment to convert.
   * @param writer The view writer that should be used to modify the view document.
   */
  convertChanges(e, t, n) {
    const s = this._createConversionApi(n, e.getRefreshedItems());
    for (const r of e.getMarkersToRemove())
      this._convertMarkerRemove(r.name, r.range, s);
    const o = this._reduceChanges(e.getChanges());
    for (const r of o)
      r.type === "insert" ? this._convertInsert(_._createFromPositionAndShift(r.position, r.length), s) : r.type === "reinsert" ? this._convertReinsert(_._createFromPositionAndShift(r.position, r.length), s) : r.type === "remove" ? this._convertRemove(r.position, r.length, r.name, s) : this._convertAttribute(r.range, r.attributeKey, r.attributeOldValue, r.attributeNewValue, s);
    s.mapper.flushDeferredBindings();
    for (const r of s.mapper.flushUnboundMarkerNames()) {
      const a = t.get(r).getRange();
      this._convertMarkerRemove(r, a, s), this._convertMarkerAdd(r, a, s);
    }
    for (const r of e.getMarkersToAdd())
      this._convertMarkerAdd(r.name, r.range, s);
    s.consumable.verifyAllConsumed("insert");
  }
  /**
   * Starts a conversion of a model range and the provided markers.
   *
   * @fires insert
   * @fires attribute
   * @fires addMarker
   * @param range The inserted range.
   * @param markers The map of markers that should be down-casted.
   * @param writer The view writer that should be used to modify the view document.
   * @param options Optional options object passed to `convertionApi.options`.
   */
  convert(e, t, n, s = {}) {
    const o = this._createConversionApi(n, void 0, s);
    this._convertInsert(e, o);
    for (const [r, a] of t)
      this._convertMarkerAdd(r, a, o);
    o.consumable.verifyAllConsumed("insert");
  }
  /**
   * Starts the model selection conversion.
   *
   * Fires events for a given {@link module:engine/model/selection~Selection selection} to start the selection conversion.
   *
   * @fires selection
   * @fires addMarker
   * @fires attribute
   * @param selection The selection to convert.
   * @param markers Markers connected with the converted model.
   * @param writer View writer that should be used to modify the view document.
   */
  convertSelection(e, t, n) {
    const s = this._createConversionApi(n);
    this.fire("cleanSelection", { selection: e }, s);
    const o = e.getFirstPosition().root;
    if (!s.mapper.toViewElement(o))
      return;
    const r = Array.from(t.getMarkersAtPosition(e.getFirstPosition()));
    if (this._addConsumablesForSelection(s.consumable, e, r), this.fire("selection", { selection: e }, s), !!e.isCollapsed) {
      for (const a of r)
        if (s.consumable.test(e, "addMarker:" + a.name)) {
          const l = a.getRange();
          if (!Kk(e.getFirstPosition(), a, s.mapper))
            continue;
          const c = {
            item: e,
            markerName: a.name,
            markerRange: l
          };
          this.fire(`addMarker:${a.name}`, c, s);
        }
      for (const a of e.getAttributeKeys())
        if (s.consumable.test(e, "attribute:" + a)) {
          const l = {
            item: e,
            range: e.getFirstRange(),
            attributeKey: a,
            attributeOldValue: null,
            attributeNewValue: e.getAttribute(a)
          };
          this.fire(`attribute:${a}:$text`, l, s);
        }
    }
  }
  /**
   * Fires insertion conversion of a range of nodes.
   *
   * For each node in the range, {@link #event:insert `insert` event is fired}. For each attribute on each node,
   * {@link #event:attribute `attribute` event is fired}.
   *
   * @fires insert
   * @fires attribute
   * @param range The inserted range.
   * @param conversionApi The conversion API object.
   * @param options.doNotAddConsumables Whether the ModelConsumable should not get populated
   * for items in the provided range.
   */
  _convertInsert(e, t, n = {}) {
    n.doNotAddConsumables || this._addConsumablesForInsert(t.consumable, e);
    for (const s of Array.from(e.getWalker({ shallow: !0 })).map(du))
      this._testAndFire("insert", s, t);
  }
  /**
   * Fires conversion of a single node removal. Fires {@link #event:remove remove event} with provided data.
   *
   * @param position Position from which node was removed.
   * @param length Offset size of removed node.
   * @param name Name of removed node.
   * @param conversionApi The conversion API object.
   */
  _convertRemove(e, t, n, s) {
    this.fire(`remove:${n}`, { position: e, length: t }, s);
  }
  /**
   * Starts a conversion of an attribute change on a given `range`.
   *
   * For each node in the given `range`, {@link #event:attribute attribute event} is fired with the passed data.
   *
   * @fires attribute
   * @param range Changed range.
   * @param key Key of the attribute that has changed.
   * @param oldValue Attribute value before the change or `null` if the attribute has not been set before.
   * @param newValue New attribute value or `null` if the attribute has been removed.
   * @param conversionApi The conversion API object.
   */
  _convertAttribute(e, t, n, s, o) {
    this._addConsumablesForRange(o.consumable, e, `attribute:${t}`);
    for (const r of e) {
      const a = {
        item: r.item,
        range: _._createFromPositionAndShift(r.previousPosition, r.length),
        attributeKey: t,
        attributeOldValue: n,
        attributeNewValue: s
      };
      this._testAndFire(`attribute:${t}`, a, o);
    }
  }
  /**
   * Fires re-insertion conversion (with a `reconversion` flag passed to `insert` events)
   * of a range of elements (only elements on the range depth, without children).
   *
   * For each node in the range on its depth (without children), {@link #event:insert `insert` event} is fired.
   * For each attribute on each node, {@link #event:attribute `attribute` event} is fired.
   *
   * @fires insert
   * @fires attribute
   * @param range The range to reinsert.
   * @param conversionApi The conversion API object.
   */
  _convertReinsert(e, t) {
    const n = Array.from(e.getWalker({ shallow: !0 }));
    this._addConsumablesForInsert(t.consumable, n);
    for (const s of n.map(du))
      this._testAndFire("insert", { ...s, reconversion: !0 }, t);
  }
  /**
   * Converts the added marker. Fires the {@link #event:addMarker `addMarker`} event for each item
   * in the marker's range. If the range is collapsed, a single event is dispatched. See the event description for more details.
   *
   * @fires addMarker
   * @param markerName Marker name.
   * @param markerRange The marker range.
   * @param conversionApi The conversion API object.
   */
  _convertMarkerAdd(e, t, n) {
    if (t.root.rootName == "$graveyard")
      return;
    const s = `addMarker:${e}`;
    if (n.consumable.add(t, s), this.fire(s, { markerName: e, markerRange: t }, n), !!n.consumable.consume(t, s)) {
      this._addConsumablesForRange(n.consumable, t, s);
      for (const o of t.getItems()) {
        if (!n.consumable.test(o, s))
          continue;
        const r = { item: o, range: _._createOn(o), markerName: e, markerRange: t };
        this.fire(s, r, n);
      }
    }
  }
  /**
   * Fires the conversion of the marker removal. Fires the {@link #event:removeMarker `removeMarker`} event with the provided data.
   *
   * @fires removeMarker
   * @param markerName Marker name.
   * @param markerRange The marker range.
   * @param conversionApi The conversion API object.
   */
  _convertMarkerRemove(e, t, n) {
    t.root.rootName != "$graveyard" && this.fire(`removeMarker:${e}`, { markerName: e, markerRange: t }, n);
  }
  /**
   * Fires the reduction of changes buffered in the {@link module:engine/model/differ~Differ `Differ`}.
   *
   * Features can replace selected {@link module:engine/model/differ~DiffItem `DiffItem`}s with `reinsert` entries to trigger
   * reconversion. The {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure
   * `DowncastHelpers.elementToStructure()`} is using this event to trigger reconversion.
   *
   * @fires reduceChanges
   */
  _reduceChanges(e) {
    const t = { changes: e };
    return this.fire("reduceChanges", t), t.changes;
  }
  /**
   * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume from a given range,
   * assuming that the range has just been inserted to the model.
   *
   * @param consumable The consumable.
   * @param walkerValues The walker values for the inserted range.
   * @returns The values to consume.
   */
  _addConsumablesForInsert(e, t) {
    for (const n of t) {
      const s = n.item;
      if (e.test(s, "insert") === null) {
        e.add(s, "insert");
        for (const o of s.getAttributeKeys())
          e.add(s, "attribute:" + o);
      }
    }
    return e;
  }
  /**
   * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume for a given range.
   *
   * @param consumable The consumable.
   * @param range The affected range.
   * @param type Consumable type.
   * @returns The values to consume.
   */
  _addConsumablesForRange(e, t, n) {
    for (const s of t.getItems())
      e.add(s, n);
    return e;
  }
  /**
   * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with selection consumable values.
   *
   * @param consumable The consumable.
   * @param selection The selection to create the consumable from.
   * @param markers Markers that contain the selection.
   * @returns The values to consume.
   */
  _addConsumablesForSelection(e, t, n) {
    e.add(t, "selection");
    for (const s of n)
      e.add(t, "addMarker:" + s.name);
    for (const s of t.getAttributeKeys())
      e.add(t, "attribute:" + s);
    return e;
  }
  /**
   * Tests whether given event wasn't already fired and if so, fires it.
   *
   * @fires insert
   * @fires attribute
   * @param type Event type.
   * @param data Event data.
   * @param conversionApi The conversion API object.
   */
  _testAndFire(e, t, n) {
    const s = Zk(e, t), o = t.item.is("$textProxy") ? n.consumable._getSymbolForTextProxy(t.item) : t.item, r = this._firedEventsMap.get(n), a = r.get(o);
    if (!a)
      r.set(o, /* @__PURE__ */ new Set([s]));
    else if (!a.has(s))
      a.add(s);
    else
      return;
    this.fire(s, t, n);
  }
  /**
   * Fires not already fired events for setting attributes on just inserted item.
   *
   * @param item The model item to convert attributes for.
   * @param conversionApi The conversion API object.
   */
  _testAndFireAddAttributes(e, t) {
    const n = {
      item: e,
      range: _._createOn(e)
    };
    for (const s of n.item.getAttributeKeys())
      n.attributeKey = s, n.attributeOldValue = null, n.attributeNewValue = n.item.getAttribute(s), this._testAndFire(`attribute:${s}`, n, t);
  }
  /**
   * Builds an instance of the {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi} from a template and a given
   * {@link module:engine/view/downcastwriter~DowncastWriter `DowncastWriter`} and options object.
   *
   * @param writer View writer that should be used to modify the view document.
   * @param refreshedItems A set of model elements that should not reuse their
   * previous view representations.
   * @param options Optional options passed to `convertionApi.options`.
   * @return The conversion API object.
   */
  _createConversionApi(e, t = /* @__PURE__ */ new Set(), n = {}) {
    const s = {
      ...this._conversionApi,
      consumable: new jk(),
      writer: e,
      options: n,
      convertItem: (o) => this._convertInsert(_._createOn(o), s),
      convertChildren: (o) => this._convertInsert(_._createIn(o), s, { doNotAddConsumables: !0 }),
      convertAttributes: (o) => this._testAndFireAddAttributes(o, s),
      canReuseView: (o) => !t.has(s.mapper.toModelElement(o))
    };
    return this._firedEventsMap.set(s, /* @__PURE__ */ new Map()), s;
  }
}
function Kk(i, e, t) {
  const n = e.getRange(), s = Array.from(i.getAncestors());
  return s.shift(), s.reverse(), !s.some((r) => {
    if (n.containsItem(r))
      return !!t.toViewElement(r).getCustomProperty("addHighlight");
  });
}
function Zk(i, e) {
  const t = e.item.is("element") ? e.item.name : "$text";
  return `${i}:${t}`;
}
function du(i) {
  const e = i.item, t = _._createFromPositionAndShift(i.previousPosition, i.length);
  return {
    item: e,
    range: t
  };
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class De extends G(jt) {
  /**
   * Creates a new selection instance based on the given {@link module:engine/model/selection~Selectable selectable}
   * or creates an empty selection if no arguments were passed.
   *
   * ```ts
   * // Creates empty selection without ranges.
   * const selection = writer.createSelection();
   *
   * // Creates selection at the given range.
   * const range = writer.createRange( start, end );
   * const selection = writer.createSelection( range );
   *
   * // Creates selection at the given ranges
   * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
   * const selection = writer.createSelection( ranges );
   *
   * // Creates selection from the other selection.
   * // Note: It doesn't copy selection attributes.
   * const otherSelection = writer.createSelection();
   * const selection = writer.createSelection( otherSelection );
   *
   * // Creates selection from the given document selection.
   * // Note: It doesn't copy selection attributes.
   * const documentSelection = model.document.selection;
   * const selection = writer.createSelection( documentSelection );
   *
   * // Creates selection at the given position.
   * const position = writer.createPositionFromPath( root, path );
   * const selection = writer.createSelection( position );
   *
   * // Creates selection at the given offset in the given element.
   * const paragraph = writer.createElement( 'paragraph' );
   * const selection = writer.createSelection( paragraph, offset );
   *
   * // Creates a range inside an {@link module:engine/model/element~Element element} which starts before the
   * // first child of that element and ends after the last child of that element.
   * const selection = writer.createSelection( paragraph, 'in' );
   *
   * // Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends
   * // just after the item.
   * const selection = writer.createSelection( paragraph, 'on' );
   * ```
   *
   * Selection's constructor allow passing additional options (`'backward'`) as the last argument.
   *
   * ```ts
   * // Creates backward selection.
   * const selection = writer.createSelection( range, { backward: true } );
   * ```
   *
   * @internal
   */
  constructor(...e) {
    super(), this._lastRangeBackward = !1, this._attrs = /* @__PURE__ */ new Map(), this._ranges = [], e.length && this.setTo(...e);
  }
  /**
   * Selection anchor. Anchor is the position from which the selection was started. If a user is making a selection
   * by dragging the mouse, the anchor is where the user pressed the mouse button (the beginning of the selection).
   *
   * Anchor and {@link #focus} define the direction of the selection, which is important
   * when expanding/shrinking selection. The focus moves, while the anchor should remain in the same place.
   *
   * Anchor is always set to the {@link module:engine/model/range~Range#start start} or
   * {@link module:engine/model/range~Range#end end} position of the last of selection's ranges. Whether it is
   * the `start` or `end` depends on the specified `options.backward`. See the {@link #setTo `setTo()`} method.
   *
   * May be set to `null` if there are no ranges in the selection.
   *
   * @see #focus
   */
  get anchor() {
    if (this._ranges.length > 0) {
      const e = this._ranges[this._ranges.length - 1];
      return this._lastRangeBackward ? e.end : e.start;
    }
    return null;
  }
  /**
   * Selection focus. Focus is the position where the selection ends. If a user is making a selection
   * by dragging the mouse, the focus is where the mouse cursor is.
   *
   * May be set to `null` if there are no ranges in the selection.
   *
   * @see #anchor
   */
  get focus() {
    if (this._ranges.length > 0) {
      const e = this._ranges[this._ranges.length - 1];
      return this._lastRangeBackward ? e.start : e.end;
    }
    return null;
  }
  /**
   * Whether the selection is collapsed. Selection is collapsed when there is exactly one range in it
   * and it is collapsed.
   */
  get isCollapsed() {
    return this._ranges.length === 1 ? this._ranges[0].isCollapsed : !1;
  }
  /**
   * Returns the number of ranges in the selection.
   */
  get rangeCount() {
    return this._ranges.length;
  }
  /**
   * Specifies whether the selection's {@link #focus} precedes the selection's {@link #anchor}.
   */
  get isBackward() {
    return !this.isCollapsed && this._lastRangeBackward;
  }
  /**
   * Checks whether this selection is equal to the given selection. Selections are equal if they have the same directions,
   * the same number of ranges and all ranges from one selection equal to ranges from the another selection.
   *
   * @param otherSelection Selection to compare with.
   * @returns `true` if selections are equal, `false` otherwise.
   */
  isEqual(e) {
    if (this.rangeCount != e.rangeCount)
      return !1;
    if (this.rangeCount === 0)
      return !0;
    if (!this.anchor.isEqual(e.anchor) || !this.focus.isEqual(e.focus))
      return !1;
    for (const t of this._ranges) {
      let n = !1;
      for (const s of e._ranges)
        if (t.isEqual(s)) {
          n = !0;
          break;
        }
      if (!n)
        return !1;
    }
    return !0;
  }
  /**
   * Returns an iterable object that iterates over copies of selection ranges.
   */
  *getRanges() {
    for (const e of this._ranges)
      yield new _(e.start, e.end);
  }
  /**
   * Returns a copy of the first range in the selection.
   * First range is the one which {@link module:engine/model/range~Range#start start} position
   * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges
   * (not to confuse with the first range added to the selection).
   *
   * Returns `null` if there are no ranges in selection.
   */
  getFirstRange() {
    let e = null;
    for (const t of this._ranges)
      (!e || t.start.isBefore(e.start)) && (e = t);
    return e ? new _(e.start, e.end) : null;
  }
  /**
   * Returns a copy of the last range in the selection.
   * Last range is the one which {@link module:engine/model/range~Range#end end} position
   * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most
   * recently added to the selection).
   *
   * Returns `null` if there are no ranges in selection.
   */
  getLastRange() {
    let e = null;
    for (const t of this._ranges)
      (!e || t.end.isAfter(e.end)) && (e = t);
    return e ? new _(e.start, e.end) : null;
  }
  /**
   * Returns the first position in the selection.
   * First position is the position that {@link module:engine/model/position~Position#isBefore is before}
   * any other position in the selection.
   *
   * Returns `null` if there are no ranges in selection.
   */
  getFirstPosition() {
    const e = this.getFirstRange();
    return e ? e.start.clone() : null;
  }
  /**
   * Returns the last position in the selection.
   * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}
   * any other position in the selection.
   *
   * Returns `null` if there are no ranges in selection.
   */
  getLastPosition() {
    const e = this.getLastRange();
    return e ? e.end.clone() : null;
  }
  /**
   * Sets this selection's ranges and direction to the specified location based on the given
   * {@link module:engine/model/selection~Selectable selectable}.
   *
   * ```ts
   * // Removes all selection's ranges.
   * selection.setTo( null );
   *
   * // Sets selection to the given range.
   * const range = writer.createRange( start, end );
   * selection.setTo( range );
   *
   * // Sets selection to given ranges.
   * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
   * selection.setTo( ranges );
   *
   * // Sets selection to other selection.
   * // Note: It doesn't copy selection attributes.
   * const otherSelection = writer.createSelection();
   * selection.setTo( otherSelection );
   *
   * // Sets selection to the given document selection.
   * // Note: It doesn't copy selection attributes.
   * const documentSelection = new DocumentSelection( doc );
   * selection.setTo( documentSelection );
   *
   * // Sets collapsed selection at the given position.
   * const position = writer.createPositionFromPath( root, path );
   * selection.setTo( position );
   *
   * // Sets collapsed selection at the position of the given node and an offset.
   * selection.setTo( paragraph, offset );
   * ```
   *
   * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * ```ts
   * selection.setTo( paragraph, 'in' );
   * ```
   *
   * Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends just after the item.
   *
   * ```ts
   * selection.setTo( paragraph, 'on' );
   * ```
   *
   * `Selection#setTo()`' method allow passing additional options (`backward`) as the last argument.
   *
   * ```ts
   * // Sets backward selection.
   * const selection = writer.createSelection( range, { backward: true } );
   * ```
   */
  setTo(...e) {
    let [t, n, s] = e;
    if (typeof n == "object" && (s = n, n = void 0), t === null)
      this._setRanges([]);
    else if (t instanceof De)
      this._setRanges(t.getRanges(), t.isBackward);
    else if (t && typeof t.getRanges == "function")
      this._setRanges(t.getRanges(), t.isBackward);
    else if (t instanceof _)
      this._setRanges([t], !!s && !!s.backward);
    else if (t instanceof y)
      this._setRanges([new _(t)]);
    else if (t instanceof vn) {
      const o = !!s && !!s.backward;
      let r;
      if (n == "in")
        r = _._createIn(t);
      else if (n == "on")
        r = _._createOn(t);
      else if (n !== void 0)
        r = new _(y._createAt(t, n));
      else
        throw new g("model-selection-setto-required-second-parameter", [this, t]);
      this._setRanges([r], o);
    } else if (Ue(t))
      this._setRanges(t, s && !!s.backward);
    else
      throw new g("model-selection-setto-not-selectable", [this, t]);
  }
  /**
   * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array
   * is treated like the last added range and is used to set {@link module:engine/model/selection~Selection#anchor} and
   * {@link module:engine/model/selection~Selection#focus}. Accepts a flag describing in which direction the selection is made.
   *
   * @fires change:range
   * @param newRanges Ranges to set.
   * @param isLastBackward Flag describing if last added range was selected forward - from start to end (`false`)
   * or backward - from end to start (`true`).
   */
  _setRanges(e, t = !1) {
    const n = Array.from(e), s = n.some((o) => {
      if (!(o instanceof _))
        throw new g("model-selection-set-ranges-not-range", [this, e]);
      return this._ranges.every((r) => !r.isEqual(o));
    });
    n.length === this._ranges.length && !s || (this._replaceAllRanges(n), this._lastRangeBackward = !!t, this.fire("change:range", { directChange: !0 }));
  }
  /**
   * Moves {@link module:engine/model/selection~Selection#focus} to the specified location.
   *
   * The location can be specified in the same form as
   * {@link module:engine/model/writer~Writer#createPositionAt writer.createPositionAt()} parameters.
   *
   * @fires change:range
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/model/item~Item model item}.
   */
  setFocus(e, t) {
    if (this.anchor === null)
      throw new g("model-selection-setfocus-no-ranges", [this, e]);
    const n = y._createAt(e, t);
    if (n.compareWith(this.focus) == "same")
      return;
    const s = this.anchor;
    this._ranges.length && this._popRange(), n.compareWith(s) == "before" ? (this._pushRange(new _(n, s)), this._lastRangeBackward = !0) : (this._pushRange(new _(s, n)), this._lastRangeBackward = !1), this.fire("change:range", { directChange: !0 });
  }
  /**
   * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.
   *
   * @param key Key of attribute to look for.
   * @returns Attribute value or `undefined`.
   */
  getAttribute(e) {
    return this._attrs.get(e);
  }
  /**
   * Returns iterable that iterates over this selection's attributes.
   *
   * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
   */
  getAttributes() {
    return this._attrs.entries();
  }
  /**
   * Returns iterable that iterates over this selection's attribute keys.
   */
  getAttributeKeys() {
    return this._attrs.keys();
  }
  /**
   * Checks if the selection has an attribute for given key.
   *
   * @param key Key of attribute to check.
   * @returns `true` if attribute with given key is set on selection, `false` otherwise.
   */
  hasAttribute(e) {
    return this._attrs.has(e);
  }
  /**
   * Removes an attribute with given key from the selection.
   *
   * If given attribute was set on the selection, fires the {@link #event:change:range} event with
   * removed attribute key.
   *
   * @fires change:attribute
   * @param key Key of attribute to remove.
   */
  removeAttribute(e) {
    this.hasAttribute(e) && (this._attrs.delete(e), this.fire("change:attribute", { attributeKeys: [e], directChange: !0 }));
  }
  /**
   * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.
   *
   * If the attribute value has changed, fires the {@link #event:change:range} event with
   * the attribute key.
   *
   * @fires change:attribute
   * @param key Key of attribute to set.
   * @param value Attribute value.
   */
  setAttribute(e, t) {
    this.getAttribute(e) !== t && (this._attrs.set(e, t), this.fire("change:attribute", { attributeKeys: [e], directChange: !0 }));
  }
  /**
   * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only
   * one range in the selection, and that range contains exactly one element.
   * Returns `null` if there is no selected element.
   */
  getSelectedElement() {
    return this.rangeCount !== 1 ? null : this.getFirstRange().getContainedElement();
  }
  /**
   * Gets elements of type {@link module:engine/model/schema~Schema#isBlock "block"} touched by the selection.
   *
   * This method's result can be used for example to apply block styling to all blocks covered by this selection.
   *
   * **Note:** `getSelectedBlocks()` returns blocks that are nested in other non-block elements
   * but will not return blocks nested in other blocks.
   *
   * In this case the function will return exactly all 3 paragraphs (note: `<blockQuote>` is not a block itself):
   *
   * ```xml
   * <paragraph>[a</paragraph>
   * <blockQuote>
   * 	<paragraph>b</paragraph>
   * </blockQuote>
   * <paragraph>c]d</paragraph>
   * ```
   *
   * In this case the paragraph will also be returned, despite the collapsed selection:
   *
   * ```xml
   * <paragraph>[]a</paragraph>
   * ```
   *
   * In such a scenario, however, only blocks A, B & E will be returned as blocks C & D are nested in block B:
   *
   * ```xml
   * [<blockA></blockA>
   * <blockB>
   * 	<blockC></blockC>
   * 	<blockD></blockD>
   * </blockB>
   * <blockE></blockE>]
   * ```
   *
   * If the selection is inside a block all the inner blocks (A & B) are returned:
   *
   * ```xml
   * <block>
   * 	<blockA>[a</blockA>
   * 	<blockB>b]</blockB>
   * </block>
   * ```
   *
   * **Special case**: Selection ignores first and/or last blocks if nothing (from user perspective) is selected in them.
   *
   * ```xml
   * // Selection ends and the beginning of the last block.
   * <paragraph>[a</paragraph>
   * <paragraph>b</paragraph>
   * <paragraph>]c</paragraph> // This block will not be returned
   *
   * // Selection begins at the end of the first block.
   * <paragraph>a[</paragraph> // This block will not be returned
   * <paragraph>b</paragraph>
   * <paragraph>c]</paragraph>
   *
   * // Selection begings at the end of the first block and ends at the beginning of the last block.
   * <paragraph>a[</paragraph> // This block will not be returned
   * <paragraph>b</paragraph>
   * <paragraph>]c</paragraph> // This block will not be returned
   * ```
   */
  *getSelectedBlocks() {
    const e = /* @__PURE__ */ new WeakSet();
    for (const t of this.getRanges()) {
      const n = hu(t.start, e);
      Xk(n, t) && (yield n);
      for (const o of t.getWalker()) {
        const r = o.item;
        o.type == "elementEnd" && Jk(r, e, t) && (yield r);
      }
      const s = hu(t.end, e);
      Qk(s, t) && (yield s);
    }
  }
  /**
   * Checks whether the selection contains the entire content of the given element. This means that selection must start
   * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position
   * touching the element's end.
   *
   * By default, this method will check whether the entire content of the selection's current root is selected.
   * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.
   */
  containsEntireContent(e = this.anchor.root) {
    const t = y._createAt(e, 0), n = y._createAt(e, "end");
    return t.isTouching(this.getFirstPosition()) && n.isTouching(this.getLastPosition());
  }
  /**
   * Adds given range to internal {@link #_ranges ranges array}. Throws an error
   * if given range is intersecting with any range that is already stored in this selection.
   */
  _pushRange(e) {
    this._checkRange(e), this._ranges.push(new _(e.start, e.end));
  }
  /**
   * Checks if given range intersects with ranges that are already in the selection. Throws an error if it does.
   */
  _checkRange(e) {
    for (let t = 0; t < this._ranges.length; t++)
      if (e.isIntersecting(this._ranges[t]))
        throw new g("model-selection-range-intersects", [this, e], { addedRange: e, intersectingRange: this._ranges[t] });
  }
  /**
   * Replaces all the ranges by the given ones.
   * Uses {@link #_popRange _popRange} and {@link #_pushRange _pushRange} to ensure proper ranges removal and addition.
   */
  _replaceAllRanges(e) {
    this._removeAllRanges();
    for (const t of e)
      this._pushRange(t);
  }
  /**
   * Deletes ranges from internal range array. Uses {@link #_popRange _popRange} to
   * ensure proper ranges removal.
   */
  _removeAllRanges() {
    for (; this._ranges.length > 0; )
      this._popRange();
  }
  /**
   * Removes most recently added range from the selection.
   */
  _popRange() {
    this._ranges.pop();
  }
}
De.prototype.is = function(i) {
  return i === "selection" || i === "model:selection";
};
function Bm(i, e) {
  return e.has(i) ? !1 : (e.add(i), i.root.document.model.schema.isBlock(i) && !!i.parent);
}
function Jk(i, e, t) {
  return Bm(i, e) && bl(i, t);
}
function hu(i, e) {
  const n = i.parent.root.document.model.schema, s = i.parent.getAncestors({ parentFirst: !0, includeSelf: !0 });
  let o = !1;
  const r = s.find((a) => o ? !1 : (o = n.isLimit(a), !o && Bm(a, e)));
  return s.forEach((a) => e.add(a)), r;
}
function bl(i, e) {
  const t = Yk(i);
  return t ? !e.containsRange(_._createOn(t), !0) : !0;
}
function Xk(i, e) {
  return i ? e.isCollapsed || i.isEmpty ? !0 : e.start.isTouching(y._createAt(i, i.maxOffset)) ? !1 : bl(i, e) : !1;
}
function Qk(i, e) {
  return i ? e.isCollapsed || i.isEmpty ? !0 : e.end.isTouching(y._createAt(i, 0)) ? !1 : bl(i, e) : !1;
}
function Yk(i) {
  const e = i.root.document.model.schema;
  let t = i.parent;
  for (; t; ) {
    if (e.isBlock(t))
      return t;
    t = t.parent;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Pe extends G(_) {
  /**
   * Creates a live range.
   *
   * @see module:engine/model/range~Range
   */
  constructor(e, t) {
    super(e, t), eT.call(this);
  }
  /**
   * Unbinds all events previously bound by `LiveRange`. Use it whenever you don't need `LiveRange` instance
   * anymore (i.e. when leaving scope in which it was declared or before re-assigning variable that was
   * referring to it).
   */
  detach() {
    this.stopListening();
  }
  /**
   * Creates a {@link module:engine/model/range~Range range instance} that is equal to this live range.
   */
  toRange() {
    return new _(this.start, this.end);
  }
  /**
   * Creates a `LiveRange` instance that is equal to the given range.
   */
  static fromRange(e) {
    return new Pe(e.start, e.end);
  }
}
Pe.prototype.is = function(i) {
  return i === "liveRange" || i === "model:liveRange" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i == "range" || i === "model:range";
};
function eT() {
  this.listenTo(this.root.document.model, "applyOperation", (i, e) => {
    const t = e[0];
    t.isDocumentOperation && tT.call(this, t);
  }, { priority: "low" });
}
function tT(i) {
  const e = this.getTransformedByOperation(i), t = _._createFromRanges(e), n = !t.isEqual(this), s = nT(this, i);
  let o = null;
  if (n) {
    t.root.rootName == "$graveyard" && (i.type == "remove" ? o = i.sourcePosition : o = i.deletionPosition);
    const r = this.toRange();
    this.start = t.start, this.end = t.end, this.fire("change:range", r, { deletionPosition: o });
  } else s && this.fire("change:content", this.toRange(), { deletionPosition: o });
}
function nT(i, e) {
  switch (e.type) {
    case "insert":
      return i.containsPosition(e.position);
    case "move":
    case "remove":
    case "reinsert":
    case "merge":
      return i.containsPosition(e.sourcePosition) || i.start.isEqual(e.sourcePosition) || i.containsPosition(e.targetPosition);
    case "split":
      return i.containsPosition(e.splitPosition) || i.containsPosition(e.insertionPosition);
  }
  return !1;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Qi = "selection:";
class at extends G(jt) {
  /**
   * Creates an empty live selection for given {@link module:engine/model/document~Document}.
   *
   * @param doc Document which owns this selection.
   */
  constructor(e) {
    super(), this._selection = new iT(e), this._selection.delegate("change:range").to(this), this._selection.delegate("change:attribute").to(this), this._selection.delegate("change:marker").to(this);
  }
  /**
   * Describes whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
   * collapsed.
   */
  get isCollapsed() {
    return this._selection.isCollapsed;
  }
  /**
   * Selection anchor. Anchor may be described as a position where the most recent part of the selection starts.
   * Together with {@link #focus} they define the direction of selection, which is important
   * when expanding/shrinking selection. Anchor is always {@link module:engine/model/range~Range#start start} or
   * {@link module:engine/model/range~Range#end end} position of the most recently added range.
   *
   * Is set to `null` if there are no ranges in selection.
   *
   * @see #focus
   */
  get anchor() {
    return this._selection.anchor;
  }
  /**
   * Selection focus. Focus is a position where the selection ends.
   *
   * Is set to `null` if there are no ranges in selection.
   *
   * @see #anchor
   */
  get focus() {
    return this._selection.focus;
  }
  /**
   * Number of ranges in selection.
   */
  get rangeCount() {
    return this._selection.rangeCount;
  }
  /**
   * Describes whether `Documentselection` has own range(s) set, or if it is defaulted to
   * {@link module:engine/model/document~Document#_getDefaultRange document's default range}.
   */
  get hasOwnRange() {
    return this._selection.hasOwnRange;
  }
  /**
   * Specifies whether the {@link #focus}
   * precedes {@link #anchor}.
   *
   * @readonly
   * @type {Boolean}
   */
  get isBackward() {
    return this._selection.isBackward;
  }
  /**
   * Describes whether the gravity is overridden (using {@link module:engine/model/writer~Writer#overrideSelectionGravity}) or not.
   *
   * Note that the gravity remains overridden as long as will not be restored the same number of times as it was overridden.
   */
  get isGravityOverridden() {
    return this._selection.isGravityOverridden;
  }
  /**
   * A collection of selection {@link module:engine/model/markercollection~Marker markers}.
   * Marker is a selection marker when selection range is inside the marker range.
   *
   * **Note**: Only markers from {@link ~DocumentSelection#observeMarkers observed markers groups} are collected.
   */
  get markers() {
    return this._selection.markers;
  }
  /**
   * Used for the compatibility with the {@link module:engine/model/selection~Selection#isEqual} method.
   *
   * @internal
   */
  get _ranges() {
    return this._selection._ranges;
  }
  /**
   * Returns an iterable that iterates over copies of selection ranges.
   */
  getRanges() {
    return this._selection.getRanges();
  }
  /**
   * Returns the first position in the selection.
   * First position is the position that {@link module:engine/model/position~Position#isBefore is before}
   * any other position in the selection.
   *
   * Returns `null` if there are no ranges in selection.
   */
  getFirstPosition() {
    return this._selection.getFirstPosition();
  }
  /**
   * Returns the last position in the selection.
   * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}
   * any other position in the selection.
   *
   * Returns `null` if there are no ranges in selection.
   */
  getLastPosition() {
    return this._selection.getLastPosition();
  }
  /**
   * Returns a copy of the first range in the selection.
   * First range is the one which {@link module:engine/model/range~Range#start start} position
   * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges
   * (not to confuse with the first range added to the selection).
   *
   * Returns `null` if there are no ranges in selection.
   */
  getFirstRange() {
    return this._selection.getFirstRange();
  }
  /**
   * Returns a copy of the last range in the selection.
   * Last range is the one which {@link module:engine/model/range~Range#end end} position
   * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most
   * recently added to the selection).
   *
   * Returns `null` if there are no ranges in selection.
   */
  getLastRange() {
    return this._selection.getLastRange();
  }
  /**
   * Gets elements of type {@link module:engine/model/schema~Schema#isBlock "block"} touched by the selection.
   *
   * This method's result can be used for example to apply block styling to all blocks covered by this selection.
   *
   * **Note:** `getSelectedBlocks()` returns blocks that are nested in other non-block elements
   * but will not return blocks nested in other blocks.
   *
   * In this case the function will return exactly all 3 paragraphs (note: `<blockQuote>` is not a block itself):
   *
   * ```
   * <paragraph>[a</paragraph>
   * <blockQuote>
   * 	<paragraph>b</paragraph>
   * </blockQuote>
   * <paragraph>c]d</paragraph>
   * ```
   *
   * In this case the paragraph will also be returned, despite the collapsed selection:
   *
   * ```
   * <paragraph>[]a</paragraph>
   * ```
   *
   * In such a scenario, however, only blocks A, B & E will be returned as blocks C & D are nested in block B:
   *
   * ```
   * [<blockA></blockA>
   * <blockB>
   * 	<blockC></blockC>
   * 	<blockD></blockD>
   * </blockB>
   * <blockE></blockE>]
   * ```
   *
   * If the selection is inside a block all the inner blocks (A & B) are returned:
   *
   * ```
   * <block>
   * 	<blockA>[a</blockA>
   * 	<blockB>b]</blockB>
   * </block>
   * ```
   *
   * **Special case**: If a selection ends at the beginning of a block, that block is not returned as from user perspective
   * this block wasn't selected. See [#984](https://github.com/ckeditor/ckeditor5-engine/issues/984) for more details.
   *
   * ```
   * <paragraph>[a</paragraph>
   * <paragraph>b</paragraph>
   * <paragraph>]c</paragraph> // this block will not be returned
   * ```
   */
  getSelectedBlocks() {
    return this._selection.getSelectedBlocks();
  }
  /**
   * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only
   * one range in the selection, and that range contains exactly one element.
   * Returns `null` if there is no selected element.
   */
  getSelectedElement() {
    return this._selection.getSelectedElement();
  }
  /**
   * Checks whether the selection contains the entire content of the given element. This means that selection must start
   * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position
   * touching the element's end.
   *
   * By default, this method will check whether the entire content of the selection's current root is selected.
   * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.
   */
  containsEntireContent(e) {
    return this._selection.containsEntireContent(e);
  }
  /**
   * Unbinds all events previously bound by document selection.
   */
  destroy() {
    this._selection.destroy();
  }
  /**
   * Returns iterable that iterates over this selection's attribute keys.
   */
  getAttributeKeys() {
    return this._selection.getAttributeKeys();
  }
  /**
   * Returns iterable that iterates over this selection's attributes.
   *
   * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
   */
  getAttributes() {
    return this._selection.getAttributes();
  }
  /**
   * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.
   *
   * @param key Key of attribute to look for.
   * @returns Attribute value or `undefined`.
   */
  getAttribute(e) {
    return this._selection.getAttribute(e);
  }
  /**
   * Checks if the selection has an attribute for given key.
   *
   * @param key Key of attribute to check.
   * @returns `true` if attribute with given key is set on selection, `false` otherwise.
   */
  hasAttribute(e) {
    return this._selection.hasAttribute(e);
  }
  /**
   * Refreshes selection attributes and markers according to the current position in the model.
   */
  refresh() {
    this._selection.updateMarkers(), this._selection._updateAttributes(!1);
  }
  /**
   * Registers a marker group prefix or a marker name to be collected in the
   * {@link ~DocumentSelection#markers selection markers collection}.
   *
   * See also {@link module:engine/model/markercollection~MarkerCollection#getMarkersGroup `MarkerCollection#getMarkersGroup()`}.
   *
   * @param prefixOrName The marker group prefix or marker name.
   */
  observeMarkers(e) {
    this._selection.observeMarkers(e);
  }
  /**
   * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.
   * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionFocus} method.
   *
   * The location can be specified in the same form as
   * {@link module:engine/model/writer~Writer#createPositionAt writer.createPositionAt()} parameters.
   *
   * @see module:engine/model/writer~Writer#setSelectionFocus
   * @internal
   * @param offset Offset or one of the flags. Used only when
   * first parameter is a {@link module:engine/model/item~Item model item}.
   */
  _setFocus(e, t) {
    this._selection.setFocus(e, t);
  }
  /**
   * Sets this selection's ranges and direction to the specified location based on the given
   * {@link module:engine/model/selection~Selectable selectable}.
   * Should be used only within the {@link module:engine/model/writer~Writer#setSelection} method.
   *
   * @see module:engine/model/writer~Writer#setSelection
   * @internal
   */
  _setTo(...e) {
    this._selection.setTo(...e);
  }
  /**
   * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.
   * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionAttribute} method.
   *
   * @see module:engine/model/writer~Writer#setSelectionAttribute
   * @internal
   * @param key Key of the attribute to set.
   * @param value Attribute value.
   */
  _setAttribute(e, t) {
    this._selection.setAttribute(e, t);
  }
  /**
   * Removes an attribute with given key from the selection.
   * If the given attribute was set on the selection, fires the {@link module:engine/model/selection~Selection#event:change:range}
   * event with removed attribute key.
   * Should be used only within the {@link module:engine/model/writer~Writer#removeSelectionAttribute} method.
   *
   * @see module:engine/model/writer~Writer#removeSelectionAttribute
   * @internal
   * @param key Key of the attribute to remove.
   */
  _removeAttribute(e) {
    this._selection.removeAttribute(e);
  }
  /**
   * Returns an iterable that iterates through all selection attributes stored in current selection's parent.
   *
   * @internal
   */
  _getStoredAttributes() {
    return this._selection.getStoredAttributes();
  }
  /**
   * Temporarily changes the gravity of the selection from the left to the right.
   *
   * The gravity defines from which direction the selection inherits its attributes. If it's the default left
   * gravity, the selection (after being moved by the the user) inherits attributes from its left hand side.
   * This method allows to temporarily override this behavior by forcing the gravity to the right.
   *
   * It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry
   * of the process.
   *
   * @see module:engine/model/writer~Writer#overrideSelectionGravity
   * @internal
   * @returns The unique id which allows restoring the gravity.
   */
  _overrideGravity() {
    return this._selection.overrideGravity();
  }
  /**
   * Restores the {@link ~DocumentSelection#_overrideGravity overridden gravity}.
   *
   * Restoring the gravity is only possible using the unique identifier returned by
   * {@link ~DocumentSelection#_overrideGravity}. Note that the gravity remains overridden as long as won't be restored
   * the same number of times it was overridden.
   *
   * @see module:engine/model/writer~Writer#restoreSelectionGravity
   * @internal
   * @param uid The unique id returned by {@link #_overrideGravity}.
   */
  _restoreGravity(e) {
    this._selection.restoreGravity(e);
  }
  /**
   * Generates and returns an attribute key for selection attributes store, basing on original attribute key.
   *
   * @internal
   * @param key Attribute key to convert.
   * @returns Converted attribute key, applicable for selection store.
   */
  static _getStoreAttributeKey(e) {
    return Qi + e;
  }
  /**
   * Checks whether the given attribute key is an attribute stored on an element.
   *
   * @internal
   */
  static _isStoreAttributeKey(e) {
    return e.startsWith(Qi);
  }
}
at.prototype.is = function(i) {
  return i === "selection" || i == "model:selection" || i == "documentSelection" || i == "model:documentSelection";
};
class iT extends De {
  /**
   * Creates an empty live selection for given {@link module:engine/model/document~Document}.
   *
   * @param doc Document which owns this selection.
   */
  constructor(e) {
    super(), this.markers = new ke({ idProperty: "name" }), this._attributePriority = /* @__PURE__ */ new Map(), this._selectionRestorePosition = null, this._hasChangedRange = !1, this._overriddenGravityRegister = /* @__PURE__ */ new Set(), this._observedMarkers = /* @__PURE__ */ new Set(), this._model = e.model, this._document = e, this.listenTo(this._model, "applyOperation", (t, n) => {
      const s = n[0];
      !s.isDocumentOperation || s.type == "marker" || s.type == "rename" || s.type == "noop" || (this._ranges.length == 0 && this._selectionRestorePosition && this._fixGraveyardSelection(this._selectionRestorePosition), this._selectionRestorePosition = null, this._hasChangedRange && (this._hasChangedRange = !1, this.fire("change:range", { directChange: !1 })));
    }, { priority: "lowest" }), this.on("change:range", () => {
      this._validateSelectionRanges(this.getRanges());
    }), this.listenTo(this._model.markers, "update", (t, n, s, o) => {
      this._updateMarker(n, o);
    }), this.listenTo(this._document, "change", (t, n) => {
      sT(this._model, n);
    });
  }
  get isCollapsed() {
    return this._ranges.length === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;
  }
  get anchor() {
    return super.anchor || this._document._getDefaultRange().start;
  }
  get focus() {
    return super.focus || this._document._getDefaultRange().end;
  }
  get rangeCount() {
    return this._ranges.length ? this._ranges.length : 1;
  }
  /**
   * Describes whether `LiveSelection` has own range(s) set, or if it is defaulted to
   * {@link module:engine/model/document~Document#_getDefaultRange document's default range}.
   */
  get hasOwnRange() {
    return this._ranges.length > 0;
  }
  /**
   * When set to `true` then selection attributes on node before the caret won't be taken
   * into consideration while updating selection attributes.
   */
  get isGravityOverridden() {
    return !!this._overriddenGravityRegister.size;
  }
  /**
   * Unbinds all events previously bound by live selection.
   */
  destroy() {
    for (let e = 0; e < this._ranges.length; e++)
      this._ranges[e].detach();
    this.stopListening();
  }
  *getRanges() {
    this._ranges.length ? yield* super.getRanges() : yield this._document._getDefaultRange();
  }
  getFirstRange() {
    return super.getFirstRange() || this._document._getDefaultRange();
  }
  getLastRange() {
    return super.getLastRange() || this._document._getDefaultRange();
  }
  setTo(...e) {
    super.setTo(...e), this._updateAttributes(!0), this.updateMarkers();
  }
  setFocus(e, t) {
    super.setFocus(e, t), this._updateAttributes(!0), this.updateMarkers();
  }
  setAttribute(e, t) {
    if (this._setAttribute(e, t)) {
      const n = [e];
      this.fire("change:attribute", { attributeKeys: n, directChange: !0 });
    }
  }
  removeAttribute(e) {
    if (this._removeAttribute(e)) {
      const t = [e];
      this.fire("change:attribute", { attributeKeys: t, directChange: !0 });
    }
  }
  overrideGravity() {
    const e = je();
    return this._overriddenGravityRegister.add(e), this._overriddenGravityRegister.size === 1 && this._updateAttributes(!0), e;
  }
  restoreGravity(e) {
    if (!this._overriddenGravityRegister.has(e))
      throw new g("document-selection-gravity-wrong-restore", this, { uid: e });
    this._overriddenGravityRegister.delete(e), this.isGravityOverridden || this._updateAttributes(!0);
  }
  observeMarkers(e) {
    this._observedMarkers.add(e), this.updateMarkers();
  }
  _replaceAllRanges(e) {
    this._validateSelectionRanges(e), super._replaceAllRanges(e);
  }
  _popRange() {
    this._ranges.pop().detach();
  }
  _pushRange(e) {
    const t = this._prepareRange(e);
    t && this._ranges.push(t);
  }
  _validateSelectionRanges(e) {
    for (const t of e)
      if (!this._document._validateSelectionRange(t))
        throw new g("document-selection-wrong-position", this, { range: t });
  }
  /**
   * Prepares given range to be added to selection. Checks if it is correct,
   * converts it to {@link module:engine/model/liverange~LiveRange LiveRange}
   * and sets listeners listening to the range's change event.
   */
  _prepareRange(e) {
    if (this._checkRange(e), e.root == this._document.graveyard)
      return;
    const t = Pe.fromRange(e);
    return t.on("change:range", (n, s, o) => {
      if (this._hasChangedRange = !0, t.root == this._document.graveyard) {
        this._selectionRestorePosition = o.deletionPosition;
        const r = this._ranges.indexOf(t);
        this._ranges.splice(r, 1), t.detach();
      }
    }), t;
  }
  updateMarkers() {
    if (!this._observedMarkers.size)
      return;
    const e = [];
    let t = !1;
    for (const s of this._model.markers) {
      const o = s.name.split(":", 1)[0];
      if (!this._observedMarkers.has(o))
        continue;
      const r = s.getRange();
      for (const a of this.getRanges())
        r.containsRange(a, !a.isCollapsed) && e.push(s);
    }
    const n = Array.from(this.markers);
    for (const s of e)
      this.markers.has(s) || (this.markers.add(s), t = !0);
    for (const s of Array.from(this.markers))
      e.includes(s) || (this.markers.remove(s), t = !0);
    t && this.fire("change:marker", { oldMarkers: n, directChange: !1 });
  }
  _updateMarker(e, t) {
    const n = e.name.split(":", 1)[0];
    if (!this._observedMarkers.has(n))
      return;
    let s = !1;
    const o = Array.from(this.markers), r = this.markers.has(e);
    if (!t)
      r && (this.markers.remove(e), s = !0);
    else {
      let a = !1;
      for (const l of this.getRanges())
        if (t.containsRange(l, !l.isCollapsed)) {
          a = !0;
          break;
        }
      a && !r ? (this.markers.add(e), s = !0) : !a && r && (this.markers.remove(e), s = !0);
    }
    s && this.fire("change:marker", { oldMarkers: o, directChange: !1 });
  }
  /**
   * Updates this selection attributes according to its ranges and the {@link module:engine/model/document~Document model document}.
   */
  _updateAttributes(e) {
    const t = pt(this._getSurroundingAttributes()), n = pt(this.getAttributes());
    if (e)
      this._attributePriority = /* @__PURE__ */ new Map(), this._attrs = /* @__PURE__ */ new Map();
    else
      for (const [o, r] of this._attributePriority)
        r == "low" && (this._attrs.delete(o), this._attributePriority.delete(o));
    this._setAttributesTo(t);
    const s = [];
    for (const [o, r] of this.getAttributes())
      (!n.has(o) || n.get(o) !== r) && s.push(o);
    for (const [o] of n)
      this.hasAttribute(o) || s.push(o);
    s.length > 0 && this.fire("change:attribute", { attributeKeys: s, directChange: !1 });
  }
  /**
   * Internal method for setting `LiveSelection` attribute. Supports attribute priorities (through `directChange`
   * parameter).
   */
  _setAttribute(e, t, n = !0) {
    const s = n ? "normal" : "low";
    return s == "low" && this._attributePriority.get(e) == "normal" || super.getAttribute(e) === t ? !1 : (this._attrs.set(e, t), this._attributePriority.set(e, s), !0);
  }
  /**
   * Internal method for removing `LiveSelection` attribute. Supports attribute priorities (through `directChange`
   * parameter).
   *
   * NOTE: Even if attribute is not present in the selection but is provided to this method, it's priority will
   * be changed according to `directChange` parameter.
   */
  _removeAttribute(e, t = !0) {
    const n = t ? "normal" : "low";
    return n == "low" && this._attributePriority.get(e) == "normal" || (this._attributePriority.set(e, n), !super.hasAttribute(e)) ? !1 : (this._attrs.delete(e), !0);
  }
  /**
   * Internal method for setting multiple `LiveSelection` attributes. Supports attribute priorities (through
   * `directChange` parameter).
   */
  _setAttributesTo(e) {
    const t = /* @__PURE__ */ new Set();
    for (const [n, s] of this.getAttributes())
      e.get(n) !== s && this._removeAttribute(n, !1);
    for (const [n, s] of e)
      this._setAttribute(n, s, !1) && t.add(n);
    return t;
  }
  /**
   * Returns an iterable that iterates through all selection attributes stored in current selection's parent.
   */
  *getStoredAttributes() {
    const e = this.getFirstPosition().parent;
    if (this.isCollapsed && e.isEmpty)
      for (const t of e.getAttributeKeys())
        t.startsWith(Qi) && (yield [t.substr(Qi.length), e.getAttribute(t)]);
  }
  /**
   * Checks model text nodes that are closest to the selection's first position and returns attributes of first
   * found element. If there are no text nodes in selection's first position parent, it returns selection
   * attributes stored in that parent.
   */
  _getSurroundingAttributes() {
    const e = this.getFirstPosition(), t = this._model.schema;
    if (e.root.rootName == "$graveyard")
      return null;
    let n = null;
    if (this.isCollapsed) {
      const s = e.textNode ? e.textNode : e.nodeBefore, o = e.textNode ? e.textNode : e.nodeAfter;
      if (this.isGravityOverridden || (n = _i(s, t)), n || (n = _i(o, t)), !this.isGravityOverridden && !n) {
        let r = s;
        for (; r && !n; )
          r = r.previousSibling, n = _i(r, t);
      }
      if (!n) {
        let r = o;
        for (; r && !n; )
          r = r.nextSibling, n = _i(r, t);
      }
      n || (n = this.getStoredAttributes());
    } else {
      const s = this.getFirstRange();
      for (const o of s) {
        if (o.item.is("element") && t.isObject(o.item)) {
          n = _i(o.item, t);
          break;
        }
        if (o.type == "text") {
          n = o.item.getAttributes();
          break;
        }
      }
    }
    return n;
  }
  /**
   * Fixes the selection after all its ranges got removed.
   * @param deletionPosition Position where the deletion happened.
   */
  _fixGraveyardSelection(e) {
    const t = this._model.schema.getNearestSelectionRange(e);
    t && this._pushRange(t);
  }
}
function _i(i, e) {
  if (!i)
    return null;
  if (i instanceof it || i instanceof j)
    return i.getAttributes();
  if (!e.isInline(i))
    return null;
  if (!e.isObject(i))
    return [];
  const t = [];
  for (const [n, s] of i.getAttributes())
    e.checkAttribute("$text", n) && e.getAttributeProperties(n).copyFromObject !== !1 && t.push([n, s]);
  return t;
}
function sT(i, e) {
  const t = i.document.differ;
  for (const n of t.getChanges()) {
    if (n.type != "insert")
      continue;
    const s = n.position.parent;
    n.length === s.maxOffset && i.enqueueChange(e, (r) => {
      const a = Array.from(s.getAttributeKeys()).filter((l) => l.startsWith(Qi));
      for (const l of a)
        r.removeAttribute(l, s);
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Lm {
  /**
   * Creates a conversion helpers instance.
   */
  constructor(e) {
    this._dispatchers = e;
  }
  /**
   * Registers a conversion helper.
   *
   * **Note**: See full usage example in the `{@link module:engine/conversion/conversion~Conversion#for conversion.for()}`
   * method description.
   *
   * @param conversionHelper The function to be called on event.
   */
  add(e) {
    for (const t of this._dispatchers)
      e(t);
    return this;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class oT extends Lm {
  /**
   * Model element to view element conversion helper.
   *
   * This conversion results in creating a view element. For example, model `<paragraph>Foo</paragraph>` becomes `<p>Foo</p>` in the view.
   *
   * ```ts
   * editor.conversion.for( 'downcast' ).elementToElement( {
   * 	model: 'paragraph',
   * 	view: 'p'
   * } );
   *
   * editor.conversion.for( 'downcast' ).elementToElement( {
   * 	model: 'paragraph',
   * 	view: 'div',
   * 	converterPriority: 'high'
   * } );
   *
   * editor.conversion.for( 'downcast' ).elementToElement( {
   * 	model: 'fancyParagraph',
   * 	view: {
   * 		name: 'p',
   * 		classes: 'fancy'
   * 	}
   * } );
   *
   * editor.conversion.for( 'downcast' ).elementToElement( {
   * 	model: 'heading',
   * 	view: ( modelElement, conversionApi ) => {
   * 		const { writer } = conversionApi;
   *
   * 		return writer.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) );
   * 	}
   * } );
   * ```
   *
   * The element-to-element conversion supports the reconversion mechanism. It can be enabled by using either the `attributes` or
   * the `children` props on a model description. You will find a couple examples below.
   *
   * In order to reconvert an element if any of its direct children have been added or removed, use the `children` property on a `model`
   * description. For example, this model:
   *
   * ```xml
   * <box>
   * 	<paragraph>Some text.</paragraph>
   * </box>
   * ```
   *
   * will be converted into this structure in the view:
   *
   * ```html
   * <div class="box" data-type="single">
   * 	<p>Some text.</p>
   * </div>
   * ```
   *
   * But if more items were inserted in the model:
   *
   * ```xml
   * <box>
   * 	<paragraph>Some text.</paragraph>
   * 	<paragraph>Other item.</paragraph>
   * </box>
   * ```
   *
   * it will be converted into this structure in the view (note the element `data-type` change):
   *
   * ```html
   * <div class="box" data-type="multiple">
   * 	<p>Some text.</p>
   * 	<p>Other item.</p>
   * </div>
   * ```
   *
   * Such a converter would look like this (note that the `paragraph` elements are converted separately):
   *
   * ```ts
   * editor.conversion.for( 'downcast' ).elementToElement( {
   * 	model: {
   * 		name: 'box',
   * 		children: true
   * 	},
   * 	view: ( modelElement, conversionApi ) => {
   * 		const { writer } = conversionApi;
   *
   * 		return writer.createContainerElement( 'div', {
   * 			class: 'box',
   * 			'data-type': modelElement.childCount == 1 ? 'single' : 'multiple'
   * 		} );
   * 	}
   * } );
   * ```
   *
   * In order to reconvert element if any of its attributes have been updated, use the `attributes` property on a `model`
   * description. For example, this model:
   *
   * ```xml
   * <heading level="2">Some text.</heading>
   * ```
   *
   * will be converted into this structure in the view:
   *
   * ```html
   * <h2>Some text.</h2>
   * ```
   *
   * But if the `heading` element's `level` attribute has been updated to `3` for example, then
   * it will be converted into this structure in the view:
   *
   * ```html
   * <h3>Some text.</h3>
   * ```
   *
   * Such a converter would look as follows:
   *
   * ```ts
   * editor.conversion.for( 'downcast' ).elementToElement( {
   * 	model: {
   * 		name: 'heading',
   * 		attributes: 'level'
   * 	},
   * 	view: ( modelElement, conversionApi ) => {
   * 		const { writer } = conversionApi;
   *
   * 		return writer.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) );
   * 	}
   * } );
   * ```
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * You can read more about the element-to-element conversion in the
   * {@glink framework/deep-dive/conversion/downcast downcast conversion} guide.
   *
   * @param config Conversion configuration.
   * @param config.model The description or a name of the model element to convert.
   * @param config.model.attributes The list of attribute names that should be consumed while creating
   * the view element. Note that the view will be reconverted if any of the listed attributes changes.
   * @param config.model.children Specifies whether the view element requires reconversion if the list
   * of the model child nodes changed.
   * @param config.view A view element definition or a function that takes the model element and
   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}
   * as parameters and returns a view container element.
   */
  elementToElement(e) {
    return this.add(kT(e));
  }
  /**
   * The model element to view structure (several elements) conversion helper.
   *
   * This conversion results in creating a view structure with one or more slots defined for the child nodes.
   * For example, a model `<table>` may become this structure in the view:
   *
   * ```html
   * <figure class="table">
   * 	<table>
   * 		<tbody>${ slot for table rows }</tbody>
   * 	</table>
   * </figure>
   * ```
   *
   * The children of the model's `<table>` element will be inserted into the `<tbody>` element.
   * If the `elementToElement()` helper was used, the children would be inserted into the `<figure>`.
   *
   * Imagine a table feature where for this model structure:
   *
   * ```xml
   * <table headingRows="1">
   * 	<tableRow> ... table cells 1 ... </tableRow>
   * 	<tableRow> ... table cells 2 ... </tableRow>
   * 	<tableRow> ... table cells 3 ... </tableRow>
   * 	<caption>Caption text</caption>
   * </table>
   * ```
   *
   * we want to generate this view structure:
   *
   * ```html
   * <figure class="table">
   * 	<table>
   * 		<thead>
   * 			<tr> ... table cells 1 ... </tr>
   * 		</thead>
   * 		<tbody>
   * 			<tr> ... table cells 2 ... </tr>
   * 			<tr> ... table cells 3 ... </tr>
   * 		</tbody>
   * 	</table>
   * 	<figcaption>Caption text</figcaption>
   * </figure>
   * ```
   *
   * The converter has to take the `headingRows` attribute into consideration when allocating the `<tableRow>` elements
   * into the `<tbody>` and `<thead>` elements. Hence, we need two slots and need to define proper filter callbacks for them.
   *
   * Additionally, all elements other than `<tableRow>` should be placed outside the `<table>` tag.
   * In the example above, this will handle the table caption.
   *
   * Such a converter would look like this:
   *
   * ```ts
   * editor.conversion.for( 'downcast' ).elementToStructure( {
   * 	model: {
   * 		name: 'table',
   * 		attributes: [ 'headingRows' ]
   * 	},
   * 	view: ( modelElement, conversionApi ) => {
   * 		const { writer } = conversionApi;
   *
   * 		const figureElement = writer.createContainerElement( 'figure', { class: 'table' } );
   * 		const tableElement = writer.createContainerElement( 'table' );
   *
   * 		writer.insert( writer.createPositionAt( figureElement, 0 ), tableElement );
   *
   * 		const headingRows = modelElement.getAttribute( 'headingRows' ) || 0;
   *
   * 		if ( headingRows > 0 ) {
   * 			const tableHead = writer.createContainerElement( 'thead' );
   *
   * 			const headSlot = writer.createSlot( node => node.is( 'element', 'tableRow' ) && node.index < headingRows );
   *
   * 			writer.insert( writer.createPositionAt( tableElement, 'end' ), tableHead );
   * 			writer.insert( writer.createPositionAt( tableHead, 0 ), headSlot );
   * 		}
   *
   * 		if ( headingRows < tableUtils.getRows( table ) ) {
   * 			const tableBody = writer.createContainerElement( 'tbody' );
   *
   * 			const bodySlot = writer.createSlot( node => node.is( 'element', 'tableRow' ) && node.index >= headingRows );
   *
   * 			writer.insert( writer.createPositionAt( tableElement, 'end' ), tableBody );
   * 			writer.insert( writer.createPositionAt( tableBody, 0 ), bodySlot );
   * 		}
   *
   * 		const restSlot = writer.createSlot( node => !node.is( 'element', 'tableRow' ) );
   *
   * 		writer.insert( writer.createPositionAt( figureElement, 'end' ), restSlot );
   *
   * 		return figureElement;
   * 	}
   * } );
   * ```
   *
   * Note: The children of a model element that's being converted must be allocated in the same order in the view
   * in which they are placed in the model.
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.model The description or a name of the model element to convert.
   * @param config.model.name The name of the model element to convert.
   * @param config.model.attributes The list of attribute names that should be consumed while creating
   * the view structure. Note that the view will be reconverted if any of the listed attributes will change.
   * @param config.view A function that takes the model element and
   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as parameters
   * and returns a view container element with slots for model child nodes to be converted into.
   */
  elementToStructure(e) {
    return this.add(TT(e));
  }
  /**
   * Model attribute to view element conversion helper.
   *
   * This conversion results in wrapping view nodes with a view attribute element. For example, a model text node with
   * `"Foo"` as data and the `bold` attribute becomes `<strong>Foo</strong>` in the view.
   *
   * ```ts
   * editor.conversion.for( 'downcast' ).attributeToElement( {
   * 	model: 'bold',
   * 	view: 'strong'
   * } );
   *
   * editor.conversion.for( 'downcast' ).attributeToElement( {
   * 	model: 'bold',
   * 	view: 'b',
   * 	converterPriority: 'high'
   * } );
   *
   * editor.conversion.for( 'downcast' ).attributeToElement( {
   * 	model: 'invert',
   * 	view: {
   * 		name: 'span',
   * 		classes: [ 'font-light', 'bg-dark' ]
   * 	}
   * } );
   *
   * editor.conversion.for( 'downcast' ).attributeToElement( {
   * 	model: {
   * 		key: 'fontSize',
   * 		values: [ 'big', 'small' ]
   * 	},
   * 	view: {
   * 		big: {
   * 			name: 'span',
   * 			styles: {
   * 				'font-size': '1.2em'
   * 			}
   * 		},
   * 		small: {
   * 			name: 'span',
   * 			styles: {
   * 				'font-size': '0.8em'
   * 			}
   * 		}
   * 	}
   * } );
   *
   * editor.conversion.for( 'downcast' ).attributeToElement( {
   * 	model: 'bold',
   * 	view: ( modelAttributeValue, conversionApi ) => {
   * 		const { writer } = conversionApi;
   *
   * 		return writer.createAttributeElement( 'span', {
   * 			style: 'font-weight:' + modelAttributeValue
   * 		} );
   * 	}
   * } );
   *
   * editor.conversion.for( 'downcast' ).attributeToElement( {
   * 	model: {
   * 		key: 'color',
   * 		name: '$text'
   * 	},
   * 	view: ( modelAttributeValue, conversionApi ) => {
   * 		const { writer } = conversionApi;
   *
   * 		return writer.createAttributeElement( 'span', {
   * 			style: 'color:' + modelAttributeValue
   * 		} );
   * 	}
   * } );
   * ```
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array
   * of `String`s with possible values if the model attribute is an enumerable.
   * @param config.view A view element definition or a function
   * that takes the model attribute value and
   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as parameters and returns a view
   * attribute element. If `config.model.values` is given, `config.view` should be an object assigning values from `config.model.values`
   * to view element definitions or functions.
   * @param config.converterPriority Converter priority.
   */
  attributeToElement(e) {
    return this.add(ET(e));
  }
  /**
   * Model attribute to view attribute conversion helper.
   *
   * This conversion results in adding an attribute to a view node, basing on an attribute from a model node. For example,
   * `<imageInline src='foo.jpg'></imageInline>` is converted to `<img src='foo.jpg'></img>`.
   *
   * ```ts
   * editor.conversion.for( 'downcast' ).attributeToAttribute( {
   * 	model: 'source',
   * 	view: 'src'
   * } );
   *
   * editor.conversion.for( 'downcast' ).attributeToAttribute( {
   * 	model: 'source',
   * 	view: 'href',
   * 	converterPriority: 'high'
   * } );
   *
   * editor.conversion.for( 'downcast' ).attributeToAttribute( {
   * 	model: {
   * 		name: 'imageInline',
   * 		key: 'source'
   * 	},
   * 	view: 'src'
   * } );
   *
   * editor.conversion.for( 'downcast' ).attributeToAttribute( {
   * 	model: {
   * 		name: 'styled',
   * 		values: [ 'dark', 'light' ]
   * 	},
   * 	view: {
   * 		dark: {
   * 			key: 'class',
   * 			value: [ 'styled', 'styled-dark' ]
   * 		},
   * 		light: {
   * 			key: 'class',
   * 			value: [ 'styled', 'styled-light' ]
   * 		}
   * 	}
   * } );
   *
   * editor.conversion.for( 'downcast' ).attributeToAttribute( {
   * 	model: 'styled',
   * 	view: modelAttributeValue => ( {
   * 		key: 'class',
   * 		value: 'styled-' + modelAttributeValue
   * 	} )
   * } );
   * ```
   *
   * **Note**: Downcasting to a style property requires providing `value` as an object:
   *
   * ```ts
   * editor.conversion.for( 'downcast' ).attributeToAttribute( {
   * 	model: 'lineHeight',
   * 	view: modelAttributeValue => ( {
   * 		key: 'style',
   * 		value: {
   * 			'line-height': modelAttributeValue,
   * 			'border-bottom': '1px dotted #ba2'
   * 		}
   * 	} )
   * } );
   * ```
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing
   * the attribute key, possible values and, optionally, an element name to convert from.
   * @param config.view A view attribute key, or a `{ key, value }` object or a function that takes the model attribute value and
   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}
   * as parameters and returns a `{ key, value }` object. If the `key` is `'class'`, the `value` can be a `String` or an
   * array of `String`s. If the `key` is `'style'`, the `value` is an object with key-value pairs. In other cases, `value` is a `String`.
   * If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to
   * `{ key, value }` objects or a functions.
   * @param config.converterPriority Converter priority.
   */
  attributeToAttribute(e) {
    return this.add(AT(e));
  }
  /**
   * Model marker to view element conversion helper.
   *
   * **Note**: This method should be used mainly for editing the downcast and it is recommended
   * to use the {@link #markerToData `#markerToData()`} helper instead.
   *
   * This helper may produce invalid HTML code (e.g. a span between table cells).
   * It should only be used when you are sure that the produced HTML will be semantically correct.
   *
   * This conversion results in creating a view element on the boundaries of the converted marker. If the converted marker
   * is collapsed, only one element is created. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>`
   * becomes `<p>F<span data-marker="search"></span>oo b<span data-marker="search"></span>ar</p>` in the view.
   *
   * ```ts
   * editor.conversion.for( 'editingDowncast' ).markerToElement( {
   * 	model: 'search',
   * 	view: 'marker-search'
   * } );
   *
   * editor.conversion.for( 'editingDowncast' ).markerToElement( {
   * 	model: 'search',
   * 	view: 'search-result',
   * 	converterPriority: 'high'
   * } );
   *
   * editor.conversion.for( 'editingDowncast' ).markerToElement( {
   * 	model: 'search',
   * 	view: {
   * 		name: 'span',
   * 		attributes: {
   * 			'data-marker': 'search'
   * 		}
   * 	}
   * } );
   *
   * editor.conversion.for( 'editingDowncast' ).markerToElement( {
   * 	model: 'search',
   * 	view: ( markerData, conversionApi ) => {
   * 		const { writer } = conversionApi;
   *
   * 		return writer.createUIElement( 'span', {
   * 			'data-marker': 'search',
   * 			'data-start': markerData.isOpening
   * 		} );
   * 	}
   * } );
   * ```
   *
   * If a function is passed as the `config.view` parameter, it will be used to generate both boundary elements. The function
   * receives the `data` object and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}
   * as a parameters and should return an instance of the
   * {@link module:engine/view/uielement~UIElement view UI element}. The `data` object and
   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi `conversionApi`} are passed from
   * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}. Additionally,
   * the `data.isOpening` parameter is passed, which is set to `true` for the marker start boundary element, and `false` for
   * the marker end boundary element.
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.model The name of the model marker (or model marker group) to convert.
   * @param config.view A view element definition or a function that takes the model marker data and
   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as a parameters
   * and returns a view UI element.
   * @param config.converterPriority Converter priority.
   */
  markerToElement(e) {
    return this.add(xT(e));
  }
  /**
   * Model marker to highlight conversion helper.
   *
   * This conversion results in creating a highlight on view nodes. For this kind of conversion,
   * the {@link module:engine/conversion/downcasthelpers~HighlightDescriptor} should be provided.
   *
   * For text nodes, a `<span>` {@link module:engine/view/attributeelement~AttributeElement} is created and it wraps all text nodes
   * in the converted marker range. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>` becomes
   * `<p>F<span class="comment">oo b</span>ar</p>` in the view.
   *
   * {@link module:engine/view/containerelement~ContainerElement} may provide a custom way of handling highlight. Most often,
   * the element itself is given classes and attributes described in the highlight descriptor (instead of being wrapped in `<span>`).
   * For example, a model marker set like this:
   * `[<imageInline src="foo.jpg"></imageInline>]` becomes `<img src="foo.jpg" class="comment"></img>` in the view.
   *
   * For container elements, the conversion is two-step. While the converter processes the highlight descriptor and passes it
   * to a container element, it is the container element instance itself that applies values from the highlight descriptor.
   * So, in a sense, the converter takes care of stating what should be applied on what, while the element decides how to apply that.
   *
   * ```ts
   * editor.conversion.for( 'downcast' ).markerToHighlight( { model: 'comment', view: { classes: 'comment' } } );
   *
   * editor.conversion.for( 'downcast' ).markerToHighlight( {
   * 	model: 'comment',
   * 	view: { classes: 'comment' },
   * 	converterPriority: 'high'
   * } );
   *
   * editor.conversion.for( 'downcast' ).markerToHighlight( {
   * 	model: 'comment',
   * 	view: ( data, conversionApi ) => {
   * 		// Assuming that the marker name is in a form of comment:commentType:commentId.
   * 		const [ , commentType, commentId ] = data.markerName.split( ':' );
   *
   * 		return {
   * 			classes: [ 'comment', 'comment-' + commentType ],
   * 			attributes: { 'data-comment-id': commentId }
   * 		};
   * 	}
   * } );
   * ```
   *
   * If a function is passed as the `config.view` parameter, it will be used to generate the highlight descriptor. The function
   * receives the `data` object and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}
   * as the parameters and should return a
   * {@link module:engine/conversion/downcasthelpers~HighlightDescriptor highlight descriptor}.
   * The `data` object properties are passed from {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}.
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.model The name of the model marker (or model marker group) to convert.
   * @param config.view A highlight descriptor that will be used for highlighting or a function that takes the model marker data and
   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as a parameters
   * and returns a highlight descriptor.
   * @param config.converterPriority Converter priority.
   */
  markerToHighlight(e) {
    return this.add(ST(e));
  }
  /**
   * Model marker converter for data downcast.
   *
   * This conversion creates a representation for model marker boundaries in the view:
   *
   * * If the marker boundary is before or after a model element, a view attribute is set on a corresponding view element.
   * * In other cases, a view element with the specified tag name is inserted at the corresponding view position.
   *
   * Typically, the marker names use the `group:uniqueId:otherData` convention. For example: `comment:e34zfk9k2n459df53sjl34:zx32c`.
   * The default configuration for this conversion is that the first part is the `group` part and the rest of
   * the marker name becomes the `name` part.
   *
   * Tag and attribute names and values are generated from the marker name:
   *
   * * The templates for attributes are `data-[group]-start-before="[name]"`, `data-[group]-start-after="[name]"`,
   * `data-[group]-end-before="[name]"` and `data-[group]-end-after="[name]"`.
   * * The templates for view elements are `<[group]-start name="[name]">` and `<[group]-end name="[name]">`.
   *
   * Attributes mark whether the given marker's start or end boundary is before or after the given element.
   * The `data-[group]-start-before` and `data-[group]-end-after` attributes are favored.
   * The other two are used when the former two cannot be used.
   *
   * The conversion configuration can take a function that will generate different group and name parts.
   * If such a function is set as the `config.view` parameter, it is passed a marker name and it is expected to return an object with two
   * properties: `group` and `name`. If the function returns a falsy value, the conversion will not take place.
   *
   * Basic usage:
   *
   * ```ts
   * // Using the default conversion.
   * // In this case, all markers with names starting with 'comment:' will be converted.
   * // The `group` parameter will be set to `comment`.
   * // The `name` parameter will be the rest of the marker name (without the `:`).
   * editor.conversion.for( 'dataDowncast' ).markerToData( {
   * 	model: 'comment'
   * } );
   * ```
   *
   * An example of a view that may be generated by this conversion (assuming a marker with the name `comment:commentId:uid` marked
   * by `[]`):
   *
   * ```
   * // Model:
   * <paragraph>Foo[bar</paragraph>
   * <imageBlock src="abc.jpg"></imageBlock>]
   *
   * // View:
   * <p>Foo<comment-start name="commentId:uid"></comment-start>bar</p>
   * <figure data-comment-end-after="commentId:uid" class="image"><img src="abc.jpg" /></figure>
   * ```
   *
   * In the example above, the comment starts before "bar" and ends after the image.
   *
   * If the `name` part is empty, the following view may be generated:
   *
   * ```html
   * <p>Foo <myMarker-start></myMarker-start>bar</p>
   * <figure data-myMarker-end-after="" class="image"><img src="abc.jpg" /></figure>
   * ```
   *
   * **Note:** A situation where some markers have the `name` part and some do not, is incorrect and should be avoided.
   *
   * Examples where `data-group-start-after` and `data-group-end-before` are used:
   *
   * ```
   * // Model:
   * <blockQuote>[]<paragraph>Foo</paragraph></blockQuote>
   *
   * // View:
   * <blockquote><p data-group-end-before="name" data-group-start-before="name">Foo</p></blockquote>
   * ```
   *
   * Similarly, when a marker is collapsed after the last element:
   *
   * ```
   * // Model:
   * <blockQuote><paragraph>Foo</paragraph>[]</blockQuote>
   *
   * // View:
   * <blockquote><p data-group-end-after="name" data-group-start-after="name">Foo</p></blockquote>
   * ```
   *
   * When there are multiple markers from the same group stored in the same attribute of the same element, their
   * name parts are put together in the attribute value, for example: `data-group-start-before="name1,name2,name3"`.
   *
   * Other examples of usage:
   *
   * ```ts
   * // Using a custom function which is the same as the default conversion:
   * editor.conversion.for( 'dataDowncast' ).markerToData( {
   * 	model: 'comment',
   * 	view: markerName => ( {
   * 		group: 'comment',
   * 		name: markerName.substr( 8 ) // Removes 'comment:' part.
   * 	} )
   * } );
   *
   * // Using the converter priority:
   * editor.conversion.for( 'dataDowncast' ).markerToData( {
   * 	model: 'comment',
   * 	view: markerName => ( {
   * 		group: 'comment',
   * 		name: markerName.substr( 8 ) // Removes 'comment:' part.
   * 	} ),
   * 	converterPriority: 'high'
   * } );
   * ```
   *
   * This kind of conversion is useful for saving data into the database, so it should be used in the data conversion pipeline.
   *
   * See the {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} API guide to learn how to
   * add a converter to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.model The name of the model marker (or the model marker group) to convert.
   * @param config.view A function that takes the model marker name and
   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as the parameters
   * and returns an object with the `group` and `name` properties.
   * @param config.converterPriority Converter priority.
   */
  markerToData(e) {
    return this.add(IT(e));
  }
}
function Om() {
  return (i, e, t) => {
    if (!t.consumable.consume(e.item, i.name))
      return;
    const n = t.writer, s = t.mapper.toViewPosition(e.range.start), o = n.createText(e.item.data);
    n.insert(s, o);
  };
}
function Fm() {
  return (i, e, t) => {
    t.convertAttributes(e.item), !e.reconversion && e.item.is("element") && !e.item.isEmpty && t.convertChildren(e.item);
  };
}
function rT() {
  return (i, e, t) => {
    const n = t.mapper.toViewPosition(e.position), s = e.position.getShiftedBy(e.length), o = t.mapper.toViewPosition(s, { isPhantom: !0 }), r = t.writer.createRange(n, o), a = t.writer.remove(r.getTrimmed());
    for (const l of t.writer.createRangeIn(a).getItems())
      t.mapper.unbindViewElement(l, { defer: !0 });
  };
}
function Nm(i, e) {
  const t = i.createAttributeElement("span", e.attributes);
  return e.classes && t._addClass(e.classes), typeof e.priority == "number" && (t._priority = e.priority), t._id = e.id, t;
}
function aT() {
  return (i, e, t) => {
    const n = e.selection;
    if (n.isCollapsed || !t.consumable.consume(n, "selection"))
      return;
    const s = [];
    for (const o of n.getRanges())
      s.push(t.mapper.toViewRange(o));
    t.writer.setSelection(s, { backward: n.isBackward });
  };
}
function lT() {
  return (i, e, t) => {
    const n = e.selection;
    if (!n.isCollapsed || !t.consumable.consume(n, "selection"))
      return;
    const s = t.writer, o = n.getFirstPosition(), r = t.mapper.toViewPosition(o), a = s.breakAttributes(r);
    s.setSelection(a);
  };
}
function cT() {
  return (i, e, t) => {
    const n = t.writer, s = n.document.selection;
    for (const o of s.getRanges())
      o.isCollapsed && o.end.parent.isAttached() && t.writer.mergeAttributes(o.start);
    n.setSelection(null);
  };
}
function uT(i) {
  return (e, t, n) => {
    if (!n.consumable.test(t.item, e.name))
      return;
    const s = i(t.attributeOldValue, n, t), o = i(t.attributeNewValue, n, t);
    if (!s && !o)
      return;
    n.consumable.consume(t.item, e.name);
    const r = n.writer, a = r.document.selection;
    if (t.item instanceof De || t.item instanceof at)
      r.wrap(a.getFirstRange(), o);
    else {
      let l = n.mapper.toViewRange(t.range);
      t.attributeOldValue !== null && s && (l = r.unwrap(l, s)), t.attributeNewValue !== null && o && r.wrap(l, o);
    }
  };
}
function dT(i, e = OT) {
  return (t, n, s) => {
    if (!e(n.item, s.consumable, { preflight: !0 }))
      return;
    const o = i(n.item, s, n);
    if (!o)
      return;
    e(n.item, s.consumable);
    const r = s.mapper.toViewPosition(n.range.start);
    s.mapper.bindElements(n.item, o), s.writer.insert(r, o), s.convertAttributes(n.item), $m(o, n.item.getChildren(), s, { reconversion: n.reconversion });
  };
}
function hT(i, e) {
  return (t, n, s) => {
    if (!e(n.item, s.consumable, { preflight: !0 }))
      return;
    const o = /* @__PURE__ */ new Map();
    s.writer._registerSlotFactory(VT(n.item, o, s));
    const r = i(n.item, s, n);
    if (s.writer._clearSlotFactory(), !r)
      return;
    MT(n.item, o, s), e(n.item, s.consumable);
    const a = s.mapper.toViewPosition(n.range.start);
    s.mapper.bindElements(n.item, r), s.writer.insert(a, r), s.convertAttributes(n.item), BT(r, o, s, { reconversion: n.reconversion });
  };
}
function fT(i) {
  return (e, t, n) => {
    t.isOpening = !0;
    const s = i(t, n);
    t.isOpening = !1;
    const o = i(t, n);
    if (!s || !o)
      return;
    const r = t.markerRange;
    if (r.isCollapsed && !n.consumable.consume(r, e.name))
      return;
    for (const c of r)
      if (!n.consumable.consume(c.item, e.name))
        return;
    const a = n.mapper, l = n.writer;
    l.insert(a.toViewPosition(r.start), s), n.mapper.bindElementToMarker(s, t.markerName), r.isCollapsed || (l.insert(a.toViewPosition(r.end), o), n.mapper.bindElementToMarker(o, t.markerName)), e.stop();
  };
}
function mT() {
  return (i, e, t) => {
    const n = t.mapper.markerNameToElements(e.markerName);
    if (n) {
      for (const s of n)
        t.mapper.unbindElementFromMarkerName(s, e.markerName), t.writer.clear(t.writer.createRangeOn(s), s);
      t.writer.clearClonedElementsGroup(e.markerName), i.stop();
    }
  };
}
function gT(i) {
  return (e, t, n) => {
    const s = i(t.markerName, n);
    if (!s)
      return;
    const o = t.markerRange;
    n.consumable.consume(o, e.name) && (fu(o, !1, n, t, s), fu(o, !0, n, t, s), e.stop());
  };
}
function fu(i, e, t, n, s) {
  const o = e ? i.start : i.end, r = o.nodeAfter && o.nodeAfter.is("element") ? o.nodeAfter : null, a = o.nodeBefore && o.nodeBefore.is("element") ? o.nodeBefore : null;
  if (r || a) {
    let c, u;
    e && r || !e && !a ? (c = r, u = !0) : (c = a, u = !1);
    const d = t.mapper.toViewElement(c);
    if (d) {
      pT(d, e, u, t, n, s);
      return;
    }
  }
  const l = t.mapper.toViewPosition(o);
  bT(l, e, t, n, s);
}
function pT(i, e, t, n, s, o) {
  const r = `data-${o.group}-${e ? "start" : "end"}-${t ? "before" : "after"}`, a = i.hasAttribute(r) ? i.getAttribute(r).split(",") : [];
  a.unshift(o.name), n.writer.setAttribute(r, a.join(","), i), n.mapper.bindElementToMarker(i, s.markerName);
}
function bT(i, e, t, n, s) {
  const o = `${s.group}-${e ? "start" : "end"}`, r = s.name ? { name: s.name } : null, a = t.writer.createUIElement(o, r);
  t.writer.insert(i, a), t.mapper.bindElementToMarker(a, n.markerName);
}
function wT(i) {
  return (e, t, n) => {
    const s = i(t.markerName, n);
    if (!s)
      return;
    const o = n.mapper.markerNameToElements(t.markerName);
    if (!o)
      return;
    for (const a of o)
      n.mapper.unbindElementFromMarkerName(a, t.markerName), a.is("containerElement") ? (r(`data-${s.group}-start-before`, a), r(`data-${s.group}-start-after`, a), r(`data-${s.group}-end-before`, a), r(`data-${s.group}-end-after`, a)) : n.writer.clear(n.writer.createRangeOn(a), a);
    n.writer.clearClonedElementsGroup(t.markerName), e.stop();
    function r(a, l) {
      if (l.hasAttribute(a)) {
        const c = new Set(l.getAttribute(a).split(","));
        c.delete(s.name), c.size == 0 ? n.writer.removeAttribute(a, l) : n.writer.setAttribute(a, Array.from(c).join(","), l);
      }
    }
  };
}
function _T(i) {
  return (e, t, n) => {
    if (!n.consumable.test(t.item, e.name))
      return;
    const s = i(t.attributeOldValue, n, t), o = i(t.attributeNewValue, n, t);
    if (!s && !o)
      return;
    n.consumable.consume(t.item, e.name);
    const r = n.mapper.toViewElement(t.item), a = n.writer;
    if (!r)
      throw new g("conversion-attribute-to-attribute-on-text", n.dispatcher, t);
    if (t.attributeOldValue !== null && s)
      if (s.key == "class") {
        const l = typeof s.value == "string" ? s.value.split(/\s+/) : s.value;
        for (const c of l)
          a.removeClass(c, r);
      } else if (s.key == "style")
        if (typeof s.value == "string") {
          const l = new la(a.document.stylesProcessor);
          l.setTo(s.value);
          for (const [c] of l.getStylesEntries())
            a.removeStyle(c, r);
        } else {
          const l = Object.keys(s.value);
          for (const c of l)
            a.removeStyle(c, r);
        }
      else
        a.removeAttribute(s.key, r);
    if (t.attributeNewValue !== null && o)
      if (o.key == "class") {
        const l = typeof o.value == "string" ? o.value.split(/\s+/) : o.value;
        for (const c of l)
          a.addClass(c, r);
      } else if (o.key == "style")
        if (typeof o.value == "string") {
          const l = new la(a.document.stylesProcessor);
          l.setTo(o.value);
          for (const [c, u] of l.getStylesEntries())
            a.setStyle(c, u, r);
        } else {
          const l = Object.keys(o.value);
          for (const c of l)
            a.setStyle(c, o.value[c], r);
        }
      else
        a.setAttribute(o.key, o.value, r);
  };
}
function vT(i) {
  return (e, t, n) => {
    if (!t.item || !(t.item instanceof De || t.item instanceof at) && !t.item.is("$textProxy"))
      return;
    const s = wl(i, t, n);
    if (!s || !n.consumable.consume(t.item, e.name))
      return;
    const o = n.writer, r = Nm(o, s), a = o.document.selection;
    if (t.item instanceof De || t.item instanceof at)
      o.wrap(a.getFirstRange(), r);
    else {
      const l = n.mapper.toViewRange(t.range), c = o.wrap(l, r);
      for (const u of c.getItems())
        if (u.is("attributeElement") && u.isSimilar(r)) {
          n.mapper.bindElementToMarker(u, t.markerName);
          break;
        }
    }
  };
}
function yT(i) {
  return (e, t, n) => {
    if (!t.item || !(t.item instanceof $))
      return;
    const s = wl(i, t, n);
    if (!s || !n.consumable.test(t.item, e.name))
      return;
    const o = n.mapper.toViewElement(t.item);
    if (o && o.getCustomProperty("addHighlight")) {
      n.consumable.consume(t.item, e.name);
      for (const a of _._createIn(t.item))
        n.consumable.consume(a.item, e.name);
      o.getCustomProperty("addHighlight")(o, s, n.writer), n.mapper.bindElementToMarker(o, t.markerName);
    }
  };
}
function CT(i) {
  return (e, t, n) => {
    if (t.markerRange.isCollapsed)
      return;
    const s = wl(i, t, n);
    if (!s)
      return;
    const o = Nm(n.writer, s), r = n.mapper.markerNameToElements(t.markerName);
    if (r) {
      for (const a of r)
        n.mapper.unbindElementFromMarkerName(a, t.markerName), a.is("attributeElement") ? n.writer.unwrap(n.writer.createRangeOn(a), o) : a.getCustomProperty("removeHighlight")(a, s.id, n.writer);
      n.writer.clearClonedElementsGroup(t.markerName), e.stop();
    }
  };
}
function kT(i) {
  const e = Dm(i.model), t = Yi(i.view, "container");
  return e.attributes.length && (e.children = !0), (n) => {
    n.on(`insert:${e.name}`, dT(t, Um(e)), { priority: i.converterPriority || "normal" }), (e.children || e.attributes.length) && n.on("reduceChanges", Hm(e), { priority: "low" });
  };
}
function TT(i) {
  const e = Dm(i.model), t = Yi(i.view, "container");
  return e.children = !0, (n) => {
    if (n._conversionApi.schema.checkChild(e.name, "$text"))
      throw new g("conversion-element-to-structure-disallowed-text", n, { elementName: e.name });
    n.on(`insert:${e.name}`, hT(t, Um(e)), { priority: i.converterPriority || "normal" }), n.on("reduceChanges", Hm(e), { priority: "low" });
  };
}
function ET(i) {
  i = ct(i);
  let e = i.model;
  typeof e == "string" && (e = { key: e });
  let t = `attribute:${e.key}`;
  if (e.name && (t += ":" + e.name), e.values)
    for (const s of e.values)
      i.view[s] = Yi(i.view[s], "attribute");
  else
    i.view = Yi(i.view, "attribute");
  const n = zm(i);
  return (s) => {
    s.on(t, uT(n), { priority: i.converterPriority || "normal" });
  };
}
function AT(i) {
  i = ct(i);
  let e = i.model;
  typeof e == "string" && (e = { key: e });
  let t = `attribute:${e.key}`;
  if (e.name && (t += ":" + e.name), e.values)
    for (const s of e.values)
      i.view[s] = mu(i.view[s]);
  else
    i.view = mu(i.view);
  const n = zm(i);
  return (s) => {
    s.on(t, _T(n), { priority: i.converterPriority || "normal" });
  };
}
function xT(i) {
  const e = Yi(i.view, "ui");
  return (t) => {
    t.on(`addMarker:${i.model}`, fT(e), { priority: i.converterPriority || "normal" }), t.on(`removeMarker:${i.model}`, mT(), { priority: i.converterPriority || "normal" });
  };
}
function IT(i) {
  i = ct(i);
  const e = i.model;
  let t = i.view;
  return t || (t = (n) => ({
    group: e,
    name: n.substr(i.model.length + 1)
  })), (n) => {
    n.on(`addMarker:${e}`, gT(t), { priority: i.converterPriority || "normal" }), n.on(`removeMarker:${e}`, wT(t), { priority: i.converterPriority || "normal" });
  };
}
function ST(i) {
  return (e) => {
    e.on(`addMarker:${i.model}`, vT(i.view), { priority: i.converterPriority || "normal" }), e.on(`addMarker:${i.model}`, yT(i.view), { priority: i.converterPriority || "normal" }), e.on(`removeMarker:${i.model}`, CT(i.view), { priority: i.converterPriority || "normal" });
  };
}
function Dm(i) {
  return typeof i == "string" && (i = { name: i }), {
    name: i.name,
    attributes: i.attributes ? Z(i.attributes) : [],
    children: !!i.children
  };
}
function Yi(i, e) {
  return typeof i == "function" ? i : (t, n) => PT(i, n, e);
}
function PT(i, e, t) {
  typeof i == "string" && (i = { name: i });
  let n;
  const s = e.writer, o = Object.assign({}, i.attributes);
  if (t == "container")
    n = s.createContainerElement(i.name, o);
  else if (t == "attribute") {
    const r = {
      priority: i.priority || on.DEFAULT_PRIORITY
    };
    n = s.createAttributeElement(i.name, o, r);
  } else
    n = s.createUIElement(i.name, o);
  if (i.styles) {
    const r = Object.keys(i.styles);
    for (const a of r)
      s.setStyle(a, i.styles[a], n);
  }
  if (i.classes) {
    const r = i.classes;
    if (typeof r == "string")
      s.addClass(r, n);
    else
      for (const a of r)
        s.addClass(a, n);
  }
  return n;
}
function zm(i) {
  return i.model.values ? (e, t, n) => {
    const s = i.view[e];
    return s ? s(e, t, n) : null;
  } : i.view;
}
function mu(i) {
  return typeof i == "string" ? (e) => ({ key: i, value: e }) : typeof i == "object" ? i.value ? () => i : (e) => ({ key: i.key, value: e }) : i;
}
function wl(i, e, t) {
  const n = typeof i == "function" ? i(e, t) : i;
  return n ? (n.priority || (n.priority = 10), n.id || (n.id = e.markerName), n) : null;
}
function RT(i) {
  return (e, t) => {
    if (!e.is("element", i.name))
      return !1;
    if (t.type == "attribute") {
      if (i.attributes.includes(t.attributeKey))
        return !0;
    } else {
      /* istanbul ignore else: This is always true because otherwise it would not register a reducer callback. -- @preserve */
      if (i.children)
        return !0;
    }
    return !1;
  };
}
function Hm(i) {
  const e = RT(i);
  return (t, n) => {
    const s = [];
    n.reconvertedElements || (n.reconvertedElements = /* @__PURE__ */ new Set());
    for (const o of n.changes) {
      const r = o.type == "attribute" ? o.range.start.nodeAfter : o.position.parent;
      if (!r || !e(r, o)) {
        s.push(o);
        continue;
      }
      if (!n.reconvertedElements.has(r)) {
        n.reconvertedElements.add(r);
        const a = y._createBefore(r);
        let l = s.length;
        for (let c = s.length - 1; c >= 0; c--) {
          const u = s[c], h = (u.type == "attribute" ? u.range.start : u.position).compareWith(a);
          if (h == "before" || u.type == "remove" && h == "same")
            break;
          l = c;
        }
        s.splice(l, 0, {
          type: "remove",
          name: r.name,
          position: a,
          length: 1
        }, {
          type: "reinsert",
          name: r.name,
          position: a,
          length: 1
        });
      }
    }
    n.changes = s;
  };
}
function Um(i) {
  return (e, t, n = {}) => {
    const s = ["insert"];
    for (const o of i.attributes)
      e.hasAttribute(o) && s.push(`attribute:${o}`);
    return s.every((o) => t.test(e, o)) ? (n.preflight || s.forEach((o) => t.consume(e, o)), !0) : !1;
  };
}
function VT(i, e, t) {
  return (n, s) => {
    const o = n.createContainerElement("$slot");
    let r = null;
    if (s === "children")
      r = Array.from(i.getChildren());
    else if (typeof s == "function")
      r = Array.from(i.getChildren()).filter((a) => s(a));
    else
      throw new g("conversion-slot-mode-unknown", t.dispatcher, { modeOrFilter: s });
    return e.set(o, r), o;
  };
}
function MT(i, e, t) {
  const n = Array.from(e.values()).flat(), s = new Set(n);
  if (s.size != n.length)
    throw new g("conversion-slot-filter-overlap", t.dispatcher, { element: i });
  if (s.size != i.childCount)
    throw new g("conversion-slot-filter-incomplete", t.dispatcher, { element: i });
}
function BT(i, e, t, n) {
  t.mapper.on("modelToViewPosition", r, { priority: "highest" });
  let s = null, o = null;
  for ([s, o] of e)
    $m(i, o, t, n), t.writer.move(t.writer.createRangeIn(s), t.writer.createPositionBefore(s)), t.writer.remove(s);
  t.mapper.off("modelToViewPosition", r);
  function r(a, l) {
    const c = l.modelPosition.nodeAfter, u = o.indexOf(c);
    u < 0 || (l.viewPosition = l.mapper.findPositionIn(s, u));
  }
}
function $m(i, e, t, n) {
  for (const s of e)
    LT(i.root, s, t, n) || t.convertItem(s);
}
function LT(i, e, t, n) {
  const { writer: s, mapper: o } = t;
  if (!n.reconversion)
    return !1;
  const r = o.toViewElement(e);
  return !r || r.root == i || !t.canReuseView(r) ? !1 : (s.move(s.createRangeOn(r), o.toViewPosition(y._createBefore(e))), !0);
}
function OT(i, e, { preflight: t } = {}) {
  return t ? e.test(i, "insert") : e.consume(i, "insert");
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Wm(i) {
  const { schema: e, document: t } = i.model;
  for (const n of t.getRoots())
    if (n.isEmpty && !e.checkChild(n, "$text") && e.checkChild(n, "paragraph"))
      return i.insertElement("paragraph", n), !0;
  return !1;
}
function qm(i, e, t) {
  const n = t.createContext(i);
  return !(!t.checkChild(n, "paragraph") || !t.checkChild(n.push("paragraph"), e));
}
function Gm(i, e) {
  const t = e.createElement("paragraph");
  return e.insert(t, i), e.createPositionAt(t, 0);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class FT extends Lm {
  /**
   * View element to model element conversion helper.
   *
   * This conversion results in creating a model element. For example,
   * view `<p>Foo</p>` becomes `<paragraph>Foo</paragraph>` in the model.
   *
   * Keep in mind that the element will be inserted only if it is allowed
   * by {@link module:engine/model/schema~Schema schema} configuration.
   *
   * ```ts
   * editor.conversion.for( 'upcast' ).elementToElement( {
   * 	view: 'p',
   * 	model: 'paragraph'
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToElement( {
   * 	view: 'p',
   * 	model: 'paragraph',
   * 	converterPriority: 'high'
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToElement( {
   * 	view: {
   * 		name: 'p',
   * 		classes: 'fancy'
   * 	},
   * 	model: 'fancyParagraph'
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToElement( {
   * 	view: {
   * 		name: 'p',
   * 		classes: 'heading'
   * 	},
   * 	model: ( viewElement, conversionApi ) => {
   * 		const modelWriter = conversionApi.writer;
   *
   * 		return modelWriter.createElement( 'heading', { level: viewElement.getAttribute( 'data-level' ) } );
   * 	}
   * } );
   * ```
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.view Pattern matching all view elements which should be converted. If not set, the converter
   * will fire for every view element.
   * @param config.model Name of the model element, a model element instance or a function that takes a view element
   * and {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API}
   * and returns a model element. The model element will be inserted in the model.
   * @param config.converterPriority Converter priority.
   */
  elementToElement(e) {
    return this.add(jm(e));
  }
  /**
   * View element to model attribute conversion helper.
   *
   * This conversion results in setting an attribute on a model node. For example, view `<strong>Foo</strong>` becomes
   * `Foo` {@link module:engine/model/text~Text model text node} with `bold` attribute set to `true`.
   *
   * This helper is meant to set a model attribute on all the elements that are inside the converted element:
   *
   * ```
   * <strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold="true">Foo</$text></paragraph>
   * ```
   *
   * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).
   * Even though `<strong>` is over `<p>` element, `bold="true"` was added to the text. See
   * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute} for comparison.
   *
   * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.
   *
   * ```ts
   * editor.conversion.for( 'upcast' ).elementToAttribute( {
   * 	view: 'strong',
   * 	model: 'bold'
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToAttribute( {
   * 	view: 'strong',
   * 	model: 'bold',
   * 	converterPriority: 'high'
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToAttribute( {
   * 	view: {
   * 		name: 'span',
   * 		classes: 'bold'
   * 	},
   * 	model: 'bold'
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToAttribute( {
   * 	view: {
   * 		name: 'span',
   * 		classes: [ 'styled', 'styled-dark' ]
   * 	},
   * 	model: {
   * 		key: 'styled',
   * 		value: 'dark'
   * 	}
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToAttribute( {
   * 	view: {
   * 		name: 'span',
   * 		styles: {
   * 			'font-size': /[\s\S]+/
   * 		}
   * 	},
   * 	model: {
   * 		key: 'fontSize',
   * 		value: ( viewElement, conversionApi ) => {
   * 			const fontSize = viewElement.getStyle( 'font-size' );
   * 			const value = fontSize.substr( 0, fontSize.length - 2 );
   *
   * 			if ( value <= 10 ) {
   * 				return 'small';
   * 			} else if ( value > 12 ) {
   * 				return 'big';
   * 			}
   *
   * 			return null;
   * 		}
   * 	}
   * } );
   * ```
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.view Pattern matching all view elements which should be converted.
   * @param config.model Model attribute key or an object with `key` and `value` properties, describing
   * the model attribute. `value` property may be set as a function that takes a view element and
   * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the value.
   * If `String` is given, the model attribute value will be set to `true`.
   * @param config.converterPriority Converter priority. Defaults to `low`.
   */
  elementToAttribute(e) {
    return this.add(zT(e));
  }
  /**
   * View attribute to model attribute conversion helper.
   *
   * This conversion results in setting an attribute on a model node. For example, view `<img src="foo.jpg"></img>` becomes
   * `<imageBlock source="foo.jpg"></imageBlock>` in the model.
   *
   * This helper is meant to convert view attributes from view elements which got converted to the model, so the view attribute
   * is set only on the corresponding model node:
   *
   * ```
   * <div class="dark"><div>foo</div></div>    -->    <div dark="true"><div>foo</div></div>
   * ```
   *
   * Above, `class="dark"` attribute is added only to the `<div>` elements that has it. This is in contrast to
   * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute} which sets attributes for
   * all the children in the model:
   *
   * ```
   * <strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold="true">Foo</$text></paragraph>
   * ```
   *
   * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).
   * Even though `<strong>` is over `<p>` element, `bold="true"` was added to the text.
   *
   * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.
   *
   * ```ts
   * editor.conversion.for( 'upcast' ).attributeToAttribute( {
   * 	view: 'src',
   * 	model: 'source'
   * } );
   *
   * editor.conversion.for( 'upcast' ).attributeToAttribute( {
   * 	view: { key: 'src' },
   * 	model: 'source'
   * } );
   *
   * editor.conversion.for( 'upcast' ).attributeToAttribute( {
   * 	view: { key: 'src' },
   * 	model: 'source',
   * 	converterPriority: 'normal'
   * } );
   *
   * editor.conversion.for( 'upcast' ).attributeToAttribute( {
   * 	view: {
   * 		key: 'data-style',
   * 		value: /[\s\S]+/
   * 	},
   * 	model: 'styled'
   * } );
   *
   * editor.conversion.for( 'upcast' ).attributeToAttribute( {
   * 	view: {
   * 		name: 'img',
   * 		key: 'class',
   * 		value: 'styled-dark'
   * 	},
   * 	model: {
   * 		key: 'styled',
   * 		value: 'dark'
   * 	}
   * } );
   *
   * editor.conversion.for( 'upcast' ).attributeToAttribute( {
   * 	view: {
   * 		key: 'class',
   * 		value: /styled-[\S]+/
   * 	},
   * 	model: {
   * 		key: 'styled'
   * 		value: ( viewElement, conversionApi ) => {
   * 			const regexp = /styled-([\S]+)/;
   * 			const match = viewElement.getAttribute( 'class' ).match( regexp );
   *
   * 			return match[ 1 ];
   * 		}
   * 	}
   * } );
   * ```
   *
   * Converting styles works a bit differently as it requires `view.styles` to be an object and by default
   * a model attribute will be set to `true` by such a converter. You can set the model attribute to any value by providing the `value`
   * callback that returns the desired value.
   *
   * ```ts
   * // Default conversion of font-weight style will result in setting bold attribute to true.
   * editor.conversion.for( 'upcast' ).attributeToAttribute( {
   * 	view: {
   * 		styles: {
   * 			'font-weight': 'bold'
   * 		}
   * 	},
   * 	model: 'bold'
   * } );
   *
   * // This converter will pass any style value to the `lineHeight` model attribute.
   * editor.conversion.for( 'upcast' ).attributeToAttribute( {
   * 	view: {
   * 		styles: {
   * 			'line-height': /[\s\S]+/
   * 		}
   * 	},
   * 	model: {
   * 		key: 'lineHeight',
   * 		value: ( viewElement, conversionApi ) => viewElement.getStyle( 'line-height' )
   * 	}
   * } );
   * ```
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.view Specifies which view attribute will be converted. If a `String` is passed,
   * attributes with given key will be converted. If an `Object` is passed, it must have a required `key` property,
   * specifying view attribute key, and may have an optional `value` property, specifying view attribute value and optional `name`
   * property specifying a view element name from/on which the attribute should be converted. `value` can be given as a `String`,
   * a `RegExp` or a function callback, that takes view attribute value as the only parameter and returns `Boolean`.
   * @param config.model Model attribute key or an object with `key` and `value` properties, describing
   * the model attribute. `value` property may be set as a function that takes a view element and
   * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the value.
   * If `String` is given, the model attribute value will be same as view attribute value.
   * @param config.converterPriority Converter priority. Defaults to `low`.
   */
  attributeToAttribute(e) {
    return this.add(HT(e));
  }
  /**
   * View element to model marker conversion helper.
   *
   * This conversion results in creating a model marker. For example, if the marker was stored in a view as an element:
   * `<p>Fo<span data-marker="comment" data-comment-id="7"></span>o</p><p>B<span data-marker="comment" data-comment-id="7"></span>ar</p>`,
   * after the conversion is done, the marker will be available in
   * {@link module:engine/model/model~Model#markers model document markers}.
   *
   * **Note**: When this helper is used in the data upcast in combination with
   * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`} in the data downcast,
   * then invalid HTML code (e.g. a span between table cells) may be produced by the latter converter.
   *
   * In most of the cases, the {@link #dataToMarker} should be used instead.
   *
   * ```ts
   * editor.conversion.for( 'upcast' ).elementToMarker( {
   * 	view: 'marker-search',
   * 	model: 'search'
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToMarker( {
   * 	view: 'marker-search',
   * 	model: 'search',
   * 	converterPriority: 'high'
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToMarker( {
   * 	view: 'marker-search',
   * 	model: ( viewElement, conversionApi ) => 'comment:' + viewElement.getAttribute( 'data-comment-id' )
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToMarker( {
   * 	view: {
   * 		name: 'span',
   * 		attributes: {
   * 			'data-marker': 'search'
   * 		}
   * 	},
   * 	model: 'search'
   * } );
   * ```
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.view Pattern matching all view elements which should be converted.
   * @param config.model Name of the model marker, or a function that takes a view element and returns
   * a model marker name.
   * @param config.converterPriority Converter priority.
   */
  elementToMarker(e) {
    return this.add(UT(e));
  }
  /**
   * View-to-model marker conversion helper.
   *
   * Converts view data created by {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`}
   * back to a model marker.
   *
   * This converter looks for specific view elements and view attributes that mark marker boundaries. See
   * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`} to learn what view data
   * is expected by this converter.
   *
   * The `config.view` property is equal to the marker group name to convert.
   *
   * By default, this converter creates markers with the `group:name` name convention (to match the default `markerToData` conversion).
   *
   * The conversion configuration can take a function that will generate a marker name.
   * If such function is set as the `config.model` parameter, it is passed the `name` part from the view element or attribute and it is
   * expected to return a string with the marker name.
   *
   * Basic usage:
   *
   * ```ts
   * // Using the default conversion.
   * // In this case, all markers from the `comment` group will be converted.
   * // The conversion will look for `<comment-start>` and `<comment-end>` tags and
   * // `data-comment-start-before`, `data-comment-start-after`,
   * // `data-comment-end-before` and `data-comment-end-after` attributes.
   * editor.conversion.for( 'upcast' ).dataToMarker( {
   * 	view: 'comment'
   * } );
   * ```
   *
   * An example of a model that may be generated by this conversion:
   *
   * ```
   * // View:
   * <p>Foo<comment-start name="commentId:uid"></comment-start>bar</p>
   * <figure data-comment-end-after="commentId:uid" class="image"><img src="abc.jpg" /></figure>
   *
   * // Model:
   * <paragraph>Foo[bar</paragraph>
   * <imageBlock src="abc.jpg"></imageBlock>]
   * ```
   *
   * Where `[]` are boundaries of a marker that will receive the `comment:commentId:uid` name.
   *
   * Other examples of usage:
   *
   * ```ts
   * // Using a custom function which is the same as the default conversion:
   * editor.conversion.for( 'upcast' ).dataToMarker( {
   * 	view: 'comment',
   * 	model: ( name, conversionApi ) => 'comment:' + name,
   * } );
   *
   * // Using the converter priority:
   * editor.conversion.for( 'upcast' ).dataToMarker( {
   * 	view: 'comment',
   * 	model: ( name, conversionApi ) => 'comment:' + name,
   * 	converterPriority: 'high'
   * } );
   * ```
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.view The marker group name to convert.
   * @param config.model A function that takes the `name` part from the view element or attribute and
   * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the marker name.
   * @param config.converterPriority Converter priority.
   */
  dataToMarker(e) {
    return this.add($T(e));
  }
}
function gu() {
  return (i, e, t) => {
    if (!e.modelRange && t.consumable.consume(e.viewItem, { name: !0 })) {
      const { modelRange: n, modelCursor: s } = t.convertChildren(e.viewItem, e.modelCursor);
      e.modelRange = n, e.modelCursor = s;
    }
  };
}
function NT() {
  return (i, e, { schema: t, consumable: n, writer: s }) => {
    let o = e.modelCursor;
    if (!n.test(e.viewItem))
      return;
    if (!t.checkChild(o, "$text")) {
      if (!qm(o, "$text", t) || e.viewItem.data.trim().length == 0)
        return;
      const a = o.nodeBefore;
      o = Gm(o, s), a && a.is("element", "$marker") && (s.move(s.createRangeOn(a), o), o = s.createPositionAfter(a));
    }
    n.consume(e.viewItem);
    const r = s.createText(e.viewItem.data);
    s.insert(r, o), e.modelRange = s.createRange(o, o.getShiftedBy(r.offsetSize)), e.modelCursor = e.modelRange.end;
  };
}
function DT(i, e) {
  return (t, n) => {
    const s = n.newSelection, o = [];
    for (const a of s.getRanges())
      o.push(e.toModelRange(a));
    const r = i.createSelection(o, { backward: s.isBackward });
    r.isEqual(i.document.selection) || i.change((a) => {
      a.setSelection(r);
    });
  };
}
function jm(i) {
  i = ct(i);
  const e = ma(i), t = _l(i.view), n = t ? `element:${t}` : "element";
  return (s) => {
    s.on(n, e, { priority: i.converterPriority || "normal" });
  };
}
function zT(i) {
  i = ct(i), Km(i);
  const e = Zm(i, !1), t = _l(i.view), n = t ? `element:${t}` : "element";
  return (s) => {
    s.on(n, e, { priority: i.converterPriority || "low" });
  };
}
function HT(i) {
  i = ct(i);
  let e = null;
  (typeof i.view == "string" || i.view.key) && (e = GT(i)), Km(i, e);
  const t = Zm(i, !0);
  return (n) => {
    n.on("element", t, { priority: i.converterPriority || "low" });
  };
}
function UT(i) {
  const e = ZT(i.model);
  return jm({ ...i, model: e });
}
function $T(i) {
  i = ct(i), i.model || (i.model = (s) => s ? i.view + ":" + s : i.view);
  const e = {
    view: i.view,
    model: i.model
  }, t = ma(pu(e, "start")), n = ma(pu(e, "end"));
  return (s) => {
    s.on(`element:${i.view}-start`, t, { priority: i.converterPriority || "normal" }), s.on(`element:${i.view}-end`, n, { priority: i.converterPriority || "normal" });
    const o = Ht.low, r = Ht.highest, a = Ht.get(i.converterPriority) / r;
    s.on("element", WT(e), { priority: o + a });
  };
}
function WT(i) {
  return (e, t, n) => {
    const s = `data-${i.view}`;
    if (!n.consumable.test(t.viewItem, { attributes: s + "-end-after" }) && !n.consumable.test(t.viewItem, { attributes: s + "-start-after" }) && !n.consumable.test(t.viewItem, { attributes: s + "-end-before" }) && !n.consumable.test(t.viewItem, { attributes: s + "-start-before" }))
      return;
    t.modelRange || Object.assign(t, n.convertChildren(t.viewItem, t.modelCursor)), n.consumable.consume(t.viewItem, { attributes: s + "-end-after" }) && o(t.modelRange.end, t.viewItem.getAttribute(s + "-end-after").split(",")), n.consumable.consume(t.viewItem, { attributes: s + "-start-after" }) && o(t.modelRange.end, t.viewItem.getAttribute(s + "-start-after").split(",")), n.consumable.consume(t.viewItem, { attributes: s + "-end-before" }) && o(t.modelRange.start, t.viewItem.getAttribute(s + "-end-before").split(",")), n.consumable.consume(t.viewItem, { attributes: s + "-start-before" }) && o(t.modelRange.start, t.viewItem.getAttribute(s + "-start-before").split(","));
    function o(r, a) {
      for (const l of a) {
        const c = i.model(l, n), u = n.writer.createElement("$marker", { "data-name": c });
        n.writer.insert(u, r), t.modelCursor.isEqual(r) ? t.modelCursor = t.modelCursor.getShiftedBy(1) : t.modelCursor = t.modelCursor._getTransformedByInsertion(r, 1), t.modelRange = t.modelRange._getTransformedByInsertion(r, 1)[0];
      }
    }
  };
}
function _l(i) {
  return typeof i == "string" ? i : typeof i == "object" && typeof i.name == "string" ? i.name : null;
}
function ma(i) {
  const e = new ot(i.view);
  return (t, n, s) => {
    const o = e.match(n.viewItem);
    if (!o)
      return;
    const r = o.match;
    if (r.name = !0, !s.consumable.test(n.viewItem, r))
      return;
    const a = qT(i.model, n.viewItem, s);
    a && s.safeInsert(a, n.modelCursor) && (s.consumable.consume(n.viewItem, r), s.convertChildren(n.viewItem, a), s.updateConversionResult(a, n));
  };
}
function qT(i, e, t) {
  return i instanceof Function ? i(e, t) : t.writer.createElement(i);
}
function GT(i) {
  typeof i.view == "string" && (i.view = { key: i.view });
  const e = i.view.key, t = typeof i.view.value == "undefined" ? /[\s\S]*/ : i.view.value;
  let n;
  return e == "class" || e == "style" ? n = {
    [e == "class" ? "classes" : "styles"]: t
  } : n = {
    attributes: {
      [e]: t
    }
  }, i.view.name && (n.name = i.view.name), i.view = n, e;
}
function Km(i, e = null) {
  const t = e === null ? !0 : (o) => o.getAttribute(e), n = typeof i.model != "object" ? i.model : i.model.key, s = typeof i.model != "object" || typeof i.model.value == "undefined" ? t : i.model.value;
  i.model = { key: n, value: s };
}
function Zm(i, e) {
  const t = new ot(i.view);
  return (n, s, o) => {
    if (!s.modelRange && e)
      return;
    const r = t.match(s.viewItem);
    if (!r || (jT(i.view, s.viewItem) ? r.match.name = !0 : delete r.match.name, !o.consumable.test(s.viewItem, r.match)))
      return;
    const a = i.model.key, l = typeof i.model.value == "function" ? i.model.value(s.viewItem, o) : i.model.value;
    if (l === null)
      return;
    s.modelRange || Object.assign(s, o.convertChildren(s.viewItem, s.modelCursor)), KT(s.modelRange, { key: a, value: l }, e, o) && (o.consumable.test(s.viewItem, { name: !0 }) && (r.match.name = !0), o.consumable.consume(s.viewItem, r.match));
  };
}
function jT(i, e) {
  const t = typeof i == "function" ? i(e) : i;
  return typeof t == "object" && !_l(t) ? !1 : !t.classes && !t.attributes && !t.styles;
}
function KT(i, e, t, n) {
  let s = !1;
  for (const o of Array.from(i.getItems({ shallow: t })))
    n.schema.checkAttribute(o, e.key) && (s = !0, !o.hasAttribute(e.key) && n.writer.setAttribute(e.key, e.value, o));
  return s;
}
function ZT(i) {
  return (e, t) => {
    const n = typeof i == "string" ? i : i(e, t);
    return t.writer.createElement("$marker", { "data-name": n });
  };
}
function pu(i, e) {
  const t = (n, s) => {
    const o = n.getAttribute("name"), r = i.model(o, s);
    return s.writer.createElement("$marker", { "data-name": r });
  };
  return {
    // Upcast <markerGroup-start> and <markerGroup-end> elements.
    view: `${i.view}-${e}`,
    model: t
  };
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function JT(i) {
  i.document.registerPostFixer((e) => XT(e, i));
}
function XT(i, e) {
  const t = e.document.selection, n = e.schema, s = [];
  let o = !1;
  for (const r of t.getRanges()) {
    const a = Jm(r, n);
    a && !a.isEqual(r) ? (s.push(a), o = !0) : s.push(r);
  }
  return o && i.setSelection(t2(s), { backward: t.isBackward }), !1;
}
function Jm(i, e) {
  return i.isCollapsed ? QT(i, e) : YT(i, e);
}
function QT(i, e) {
  const t = i.start, n = e.getNearestSelectionRange(t);
  if (!n) {
    const o = t.getAncestors().reverse().find((r) => e.isObject(r));
    return o ? _._createOn(o) : null;
  }
  if (!n.isCollapsed)
    return n;
  const s = n.start;
  return t.isEqual(s) ? null : new _(s);
}
function YT(i, e) {
  const { start: t, end: n } = i, s = e.checkChild(t, "$text"), o = e.checkChild(n, "$text"), r = e.getLimitElement(t), a = e.getLimitElement(n);
  if (r === a) {
    if (s && o)
      return null;
    if (e2(t, n, e)) {
      const d = t.nodeAfter && e.isSelectable(t.nodeAfter) ? null : e.getNearestSelectionRange(t, "forward"), f = n.nodeBefore && e.isSelectable(n.nodeBefore) ? null : e.getNearestSelectionRange(n, "backward"), m = d ? d.start : t, p = f ? f.end : n;
      return new _(m, p);
    }
  }
  const l = r && !r.is("rootElement"), c = a && !a.is("rootElement");
  if (l || c) {
    const u = t.nodeAfter && n.nodeBefore && t.nodeAfter.parent === n.nodeBefore.parent, d = l && (!u || !wu(t.nodeAfter, e)), h = c && (!u || !wu(n.nodeBefore, e));
    let f = t, m = n;
    return d && (f = y._createBefore(bu(r, e))), h && (m = y._createAfter(bu(a, e))), new _(f, m);
  }
  return null;
}
function bu(i, e) {
  let t = i, n = t;
  for (; e.isLimit(n) && n.parent; )
    t = n, n = n.parent;
  return t;
}
function e2(i, e, t) {
  const n = i.nodeAfter && !t.isLimit(i.nodeAfter) || t.checkChild(i, "$text"), s = e.nodeBefore && !t.isLimit(e.nodeBefore) || t.checkChild(e, "$text");
  return n || s;
}
function t2(i) {
  const e = [...i], t = /* @__PURE__ */ new Set();
  let n = 1;
  for (; n < e.length; ) {
    const o = e[n], r = e.slice(0, n);
    for (const [a, l] of r.entries())
      if (!t.has(a)) {
        if (o.isEqual(l))
          t.add(a);
        else if (o.isIntersecting(l)) {
          t.add(a), t.add(n);
          const c = o.getJoined(l);
          e.push(c);
        }
      }
    n++;
  }
  return e.filter((o, r) => !t.has(r));
}
function wu(i, e) {
  return i && e.isSelectable(i);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class n2 extends U() {
  /**
   * Creates an editing controller instance.
   *
   * @param model Editing model.
   * @param stylesProcessor The styles processor instance.
   */
  constructor(e, t) {
    super(), this.model = e, this.view = new Wk(t), this.mapper = new Vm(), this.downcastDispatcher = new Mm({
      mapper: this.mapper,
      schema: e.schema
    });
    const n = this.model.document, s = n.selection, o = this.model.markers;
    this.listenTo(this.model, "_beforeChanges", () => {
      this.view._disableRendering(!0);
    }, { priority: "highest" }), this.listenTo(this.model, "_afterChanges", () => {
      this.view._disableRendering(!1);
    }, { priority: "lowest" }), this.listenTo(n, "change", () => {
      this.view.change((r) => {
        this.downcastDispatcher.convertChanges(n.differ, o, r), this.downcastDispatcher.convertSelection(s, o, r);
      });
    }, { priority: "low" }), this.listenTo(this.view.document, "selectionChange", DT(this.model, this.mapper)), this.listenTo(this.view.document, "beforeinput", i2(this.mapper, this.model.schema, this.view), { priority: "high" }), this.downcastDispatcher.on("insert:$text", Om(), { priority: "lowest" }), this.downcastDispatcher.on("insert", Fm(), { priority: "lowest" }), this.downcastDispatcher.on("remove", rT(), { priority: "low" }), this.downcastDispatcher.on("cleanSelection", cT()), this.downcastDispatcher.on("selection", aT(), { priority: "low" }), this.downcastDispatcher.on("selection", lT(), { priority: "low" }), this.view.document.roots.bindTo(this.model.document.roots).using((r) => {
      if (r.rootName == "$graveyard")
        return null;
      const a = new wm(this.view.document, r.name);
      return a.rootName = r.rootName, this.mapper.bindElements(r, a), a;
    });
  }
  /**
   * Removes all event listeners attached to the `EditingController`. Destroys all objects created
   * by `EditingController` that need to be destroyed.
   */
  destroy() {
    this.view.destroy(), this.stopListening();
  }
  /**
   * Calling this method will refresh the marker by triggering the downcast conversion for it.
   *
   * Reconverting the marker is useful when you want to change its {@link module:engine/view/element~Element view element}
   * without changing any marker data. For instance:
   *
   * ```ts
   * let isCommentActive = false;
   *
   * model.conversion.markerToHighlight( {
   * 	model: 'comment',
   * 	view: data => {
   * 		const classes = [ 'comment-marker' ];
   *
   * 		if ( isCommentActive ) {
   * 			classes.push( 'comment-marker--active' );
   * 		}
   *
   * 		return { classes };
   * 	}
   * } );
   *
   * // ...
   *
   * // Change the property that indicates if marker is displayed as active or not.
   * isCommentActive = true;
   *
   * // Reconverting will downcast and synchronize the marker with the new isCommentActive state value.
   * editor.editing.reconvertMarker( 'comment' );
   * ```
   *
   * **Note**: If you want to reconvert a model item, use {@link #reconvertItem} instead.
   *
   * @param markerOrName Name of a marker to update, or a marker instance.
   */
  reconvertMarker(e) {
    const t = typeof e == "string" ? e : e.name, n = this.model.markers.get(t);
    if (!n)
      throw new g("editingcontroller-reconvertmarker-marker-not-exist", this, { markerName: t });
    this.model.change(() => {
      this.model.markers._refresh(n);
    });
  }
  /**
   * Calling this method will downcast a model item on demand (by requesting a refresh in the {@link module:engine/model/differ~Differ}).
   *
   * You can use it if you want the view representation of a specific item updated as a response to external modifications. For instance,
   * when the view structure depends not only on the associated model data but also on some external state.
   *
   * **Note**: If you want to reconvert a model marker, use {@link #reconvertMarker} instead.
   *
   * @param item Item to refresh.
   */
  reconvertItem(e) {
    this.model.change(() => {
      this.model.document.differ._refreshItem(e);
    });
  }
}
function i2(i, e, t) {
  return (n, s) => {
    if (!(t.document.isComposing && !M.isAndroid))
      for (let o = 0; o < s.targetRanges.length; o++) {
        const r = s.targetRanges[o], a = i.toModelRange(r), l = Jm(a, e);
        !l || l.isEqual(a) || (s.targetRanges[o] = i.toViewRange(l));
      }
  };
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Di {
  constructor() {
    this._consumables = /* @__PURE__ */ new Map();
  }
  add(e, t) {
    let n;
    if (e.is("$text") || e.is("documentFragment")) {
      this._consumables.set(e, !0);
      return;
    }
    this._consumables.has(e) ? n = this._consumables.get(e) : (n = new s2(e), this._consumables.set(e, n)), n.add(t);
  }
  /**
   * Tests if {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or
   * {@link module:engine/view/documentfragment~DocumentFragment document fragment} can be consumed.
   * It returns `true` when all items included in method's call can be consumed. Returns `false` when
   * first already consumed item is found and `null` when first non-consumable item is found.
   *
   * ```ts
   * viewConsumable.test( p, { name: true } ); // Tests element's name.
   * viewConsumable.test( p, { attributes: 'name' } ); // Tests attribute.
   * viewConsumable.test( p, { classes: 'foobar' } ); // Tests class.
   * viewConsumable.test( p, { styles: 'color' } ); // Tests style.
   * viewConsumable.test( p, { attributes: 'name', styles: 'color' } ); // Tests attribute and style.
   * viewConsumable.test( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be tested.
   * viewConsumable.test( textNode ); // Tests text node.
   * viewConsumable.test( docFragment ); // Tests document fragment.
   * ```
   *
   * Testing classes and styles as attribute will test if all added classes/styles can be consumed.
   *
   * ```ts
   * viewConsumable.test( p, { attributes: 'class' } ); // Tests if all added classes can be consumed.
   * viewConsumable.test( p, { attributes: 'style' } ); // Tests if all added styles can be consumed.
   * ```
   *
   * @param consumables Used only if first parameter is {@link module:engine/view/element~Element view element} instance.
   * @param consumables.name If set to true element's name will be included.
   * @param consumables.attributes Attribute name or array of attribute names.
   * @param consumables.classes Class name or array of class names.
   * @param consumables.styles Style name or array of style names.
   * @returns Returns `true` when all items included in method's call can be consumed. Returns `false`
   * when first already consumed item is found and `null` when first non-consumable item is found.
   */
  test(e, t) {
    const n = this._consumables.get(e);
    return n === void 0 ? null : e.is("$text") || e.is("documentFragment") ? n : n.test(t);
  }
  /**
   * Consumes {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or
   * {@link module:engine/view/documentfragment~DocumentFragment document fragment}.
   * It returns `true` when all items included in method's call can be consumed, otherwise returns `false`.
   *
   * ```ts
   * viewConsumable.consume( p, { name: true } ); // Consumes element's name.
   * viewConsumable.consume( p, { attributes: 'name' } ); // Consumes element's attribute.
   * viewConsumable.consume( p, { classes: 'foobar' } ); // Consumes element's class.
   * viewConsumable.consume( p, { styles: 'color' } ); // Consumes element's style.
   * viewConsumable.consume( p, { attributes: 'name', styles: 'color' } ); // Consumes attribute and style.
   * viewConsumable.consume( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be consumed.
   * viewConsumable.consume( textNode ); // Consumes text node.
   * viewConsumable.consume( docFragment ); // Consumes document fragment.
   * ```
   *
   * Consuming classes and styles as attribute will test if all added classes/styles can be consumed.
   *
   * ```ts
   * viewConsumable.consume( p, { attributes: 'class' } ); // Consume only if all added classes can be consumed.
   * viewConsumable.consume( p, { attributes: 'style' } ); // Consume only if all added styles can be consumed.
   * ```
   *
   * @param consumables Used only if first parameter is {@link module:engine/view/element~Element view element} instance.
   * @param consumables.name If set to true element's name will be included.
   * @param consumables.attributes Attribute name or array of attribute names.
   * @param consumables.classes Class name or array of class names.
   * @param consumables.styles Style name or array of style names.
   * @returns Returns `true` when all items included in method's call can be consumed,
   * otherwise returns `false`.
   */
  consume(e, t) {
    return this.test(e, t) ? (e.is("$text") || e.is("documentFragment") ? this._consumables.set(e, !1) : this._consumables.get(e).consume(t), !0) : !1;
  }
  /**
   * Reverts {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or
   * {@link module:engine/view/documentfragment~DocumentFragment document fragment} so they can be consumed once again.
   * Method does not revert items that were never previously added for consumption, even if they are included in
   * method's call.
   *
   * ```ts
   * viewConsumable.revert( p, { name: true } ); // Reverts element's name.
   * viewConsumable.revert( p, { attributes: 'name' } ); // Reverts element's attribute.
   * viewConsumable.revert( p, { classes: 'foobar' } ); // Reverts element's class.
   * viewConsumable.revert( p, { styles: 'color' } ); // Reverts element's style.
   * viewConsumable.revert( p, { attributes: 'name', styles: 'color' } ); // Reverts attribute and style.
   * viewConsumable.revert( p, { classes: [ 'baz', 'bar' ] } ); // Multiple names can be reverted.
   * viewConsumable.revert( textNode ); // Reverts text node.
   * viewConsumable.revert( docFragment ); // Reverts document fragment.
   * ```
   *
   * Reverting classes and styles as attribute will revert all classes/styles that were previously added for
   * consumption.
   *
   * ```ts
   * viewConsumable.revert( p, { attributes: 'class' } ); // Reverts all classes added for consumption.
   * viewConsumable.revert( p, { attributes: 'style' } ); // Reverts all styles added for consumption.
   * ```
   *
   * @param consumables Used only if first parameter is {@link module:engine/view/element~Element view element} instance.
   * @param consumables.name If set to true element's name will be included.
   * @param consumables.attributes Attribute name or array of attribute names.
   * @param consumables.classes Class name or array of class names.
   * @param consumables.styles Style name or array of style names.
   */
  revert(e, t) {
    const n = this._consumables.get(e);
    n !== void 0 && (e.is("$text") || e.is("documentFragment") ? this._consumables.set(e, !0) : n.revert(t));
  }
  /**
   * Creates consumable object from {@link module:engine/view/element~Element view element}. Consumable object will include
   * element's name and all its attributes, classes and styles.
   */
  static consumablesFromElement(e) {
    const t = {
      element: e,
      name: !0,
      attributes: [],
      classes: [],
      styles: []
    }, n = e.getAttributeKeys();
    for (const r of n)
      r == "style" || r == "class" || t.attributes.push(r);
    const s = e.getClassNames();
    for (const r of s)
      t.classes.push(r);
    const o = e.getStyleNames();
    for (const r of o)
      t.styles.push(r);
    return t;
  }
  /**
   * Creates {@link module:engine/conversion/viewconsumable~ViewConsumable ViewConsumable} instance from
   * {@link module:engine/view/node~Node node} or {@link module:engine/view/documentfragment~DocumentFragment document fragment}.
   * Instance will contain all elements, child nodes, attributes, styles and classes added for consumption.
   *
   * @param from View node or document fragment from which `ViewConsumable` will be created.
   * @param instance If provided, given `ViewConsumable` instance will be used
   * to add all consumables. It will be returned instead of a new instance.
   */
  static createFrom(e, t) {
    if (t || (t = new Di()), e.is("$text"))
      return t.add(e), t;
    e.is("element") && t.add(e, Di.consumablesFromElement(e)), e.is("documentFragment") && t.add(e);
    for (const n of e.getChildren())
      t = Di.createFrom(n, t);
    return t;
  }
}
const Vs = ["attributes", "classes", "styles"];
class s2 {
  /**
   * Creates ViewElementConsumables instance.
   *
   * @param from View node or document fragment from which `ViewElementConsumables` is being created.
   */
  constructor(e) {
    this.element = e, this._canConsumeName = null, this._consumables = {
      attributes: /* @__PURE__ */ new Map(),
      styles: /* @__PURE__ */ new Map(),
      classes: /* @__PURE__ */ new Map()
    };
  }
  /**
   * Adds consumable parts of the {@link module:engine/view/element~Element view element}.
   * Element's name itself can be marked to be consumed (when element's name is consumed its attributes, classes and
   * styles still could be consumed):
   *
   * ```ts
   * consumables.add( { name: true } );
   * ```
   *
   * Attributes classes and styles:
   *
   * ```ts
   * consumables.add( { attributes: 'title', classes: 'foo', styles: 'color' } );
   * consumables.add( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );
   * ```
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`
   * attribute is provided - it should be handled separately by providing `style` and `class` in consumables object.
   *
   * @param consumables Object describing which parts of the element can be consumed.
   * @param consumables.name If set to `true` element's name will be added as consumable.
   * @param consumables.attributes Attribute name or array of attribute names to add as consumable.
   * @param consumables.classes Class name or array of class names to add as consumable.
   * @param consumables.styles Style name or array of style names to add as consumable.
   */
  add(e) {
    e.name && (this._canConsumeName = !0);
    for (const t of Vs)
      t in e && this._add(t, e[t]);
  }
  /**
   * Tests if parts of the {@link module:engine/view/node~Node view node} can be consumed.
   *
   * Element's name can be tested:
   *
   * ```ts
   * consumables.test( { name: true } );
   * ```
   *
   * Attributes classes and styles:
   *
   * ```ts
   * consumables.test( { attributes: 'title', classes: 'foo', styles: 'color' } );
   * consumables.test( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );
   * ```
   *
   * @param consumables Object describing which parts of the element should be tested.
   * @param consumables.name If set to `true` element's name will be tested.
   * @param consumables.attributes Attribute name or array of attribute names to test.
   * @param consumables.classes Class name or array of class names to test.
   * @param consumables.styles Style name or array of style names to test.
   * @returns `true` when all tested items can be consumed, `null` when even one of the items
   * was never marked for consumption and `false` when even one of the items was already consumed.
   */
  test(e) {
    if (e.name && !this._canConsumeName)
      return this._canConsumeName;
    for (const t of Vs)
      if (t in e) {
        const n = this._test(t, e[t]);
        if (n !== !0)
          return n;
      }
    return !0;
  }
  /**
   * Consumes parts of {@link module:engine/view/element~Element view element}. This function does not check if consumable item
   * is already consumed - it consumes all consumable items provided.
   * Element's name can be consumed:
   *
   * ```ts
   * consumables.consume( { name: true } );
   * ```
   *
   * Attributes classes and styles:
   *
   * ```ts
   * consumables.consume( { attributes: 'title', classes: 'foo', styles: 'color' } );
   * consumables.consume( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );
   * ```
   *
   * @param consumables Object describing which parts of the element should be consumed.
   * @param consumables.name If set to `true` element's name will be consumed.
   * @param consumables.attributes Attribute name or array of attribute names to consume.
   * @param consumables.classes Class name or array of class names to consume.
   * @param consumables.styles Style name or array of style names to consume.
   */
  consume(e) {
    e.name && (this._canConsumeName = !1);
    for (const t of Vs)
      t in e && this._consume(t, e[t]);
  }
  /**
   * Revert already consumed parts of {@link module:engine/view/element~Element view Element}, so they can be consumed once again.
   * Element's name can be reverted:
   *
   * ```ts
   * consumables.revert( { name: true } );
   * ```
   *
   * Attributes classes and styles:
   *
   * ```ts
   * consumables.revert( { attributes: 'title', classes: 'foo', styles: 'color' } );
   * consumables.revert( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );
   * ```
   *
   * @param consumables Object describing which parts of the element should be reverted.
   * @param consumables.name If set to `true` element's name will be reverted.
   * @param consumables.attributes Attribute name or array of attribute names to revert.
   * @param consumables.classes Class name or array of class names to revert.
   * @param consumables.styles Style name or array of style names to revert.
   */
  revert(e) {
    e.name && (this._canConsumeName = !0);
    for (const t of Vs)
      t in e && this._revert(t, e[t]);
  }
  /**
   * Helper method that adds consumables of a given type: attribute, class or style.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`
   * type is provided - it should be handled separately by providing actual style/class type.
   *
   * @param type Type of the consumable item: `attributes`, `classes` or `styles`.
   * @param item Consumable item or array of items.
   */
  _add(e, t) {
    const n = Z(t), s = this._consumables[e];
    for (const o of n) {
      if (e === "attributes" && (o === "class" || o === "style"))
        throw new g("viewconsumable-invalid-attribute", this);
      if (s.set(o, !0), e === "styles")
        for (const r of this.element.document.stylesProcessor.getRelatedStyles(o))
          s.set(r, !0);
    }
  }
  /**
   * Helper method that tests consumables of a given type: attribute, class or style.
   *
   * @param type Type of the consumable item: `attributes`, `classes` or `styles`.
   * @param item Consumable item or array of items.
   * @returns Returns `true` if all items can be consumed, `null` when one of the items cannot be
   * consumed and `false` when one of the items is already consumed.
   */
  _test(e, t) {
    const n = Z(t), s = this._consumables[e];
    for (const o of n)
      if (e === "attributes" && (o === "class" || o === "style")) {
        const r = o == "class" ? "classes" : "styles", a = this._test(r, [...this._consumables[r].keys()]);
        if (a !== !0)
          return a;
      } else {
        const r = s.get(o);
        if (r === void 0)
          return null;
        if (!r)
          return !1;
      }
    return !0;
  }
  /**
   * Helper method that consumes items of a given type: attribute, class or style.
   *
   * @param type Type of the consumable item: `attributes`, `classes` or `styles`.
   * @param item Consumable item or array of items.
   */
  _consume(e, t) {
    const n = Z(t), s = this._consumables[e];
    for (const o of n)
      if (e === "attributes" && (o === "class" || o === "style")) {
        const r = o == "class" ? "classes" : "styles";
        this._consume(r, [...this._consumables[r].keys()]);
      } else if (s.set(o, !1), e == "styles")
        for (const r of this.element.document.stylesProcessor.getRelatedStyles(o))
          s.set(r, !1);
  }
  /**
   * Helper method that reverts items of a given type: attribute, class or style.
   *
   * @param type Type of the consumable item: `attributes`, `classes` or , `styles`.
   * @param item Consumable item or array of items.
   */
  _revert(e, t) {
    const n = Z(t), s = this._consumables[e];
    for (const o of n)
      if (e === "attributes" && (o === "class" || o === "style")) {
        const r = o == "class" ? "classes" : "styles";
        this._revert(r, [...this._consumables[r].keys()]);
      } else
        s.get(o) === !1 && s.set(o, !0);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class o2 extends U() {
  /**
   * Creates a schema instance.
   */
  constructor() {
    super(), this._sourceDefinitions = {}, this._attributeProperties = {}, this.decorate("checkChild"), this.decorate("checkAttribute"), this.on("checkAttribute", (e, t) => {
      t[0] = new an(t[0]);
    }, { priority: "highest" }), this.on("checkChild", (e, t) => {
      t[0] = new an(t[0]), t[1] = this.getDefinition(t[1]);
    }, { priority: "highest" });
  }
  /**
   * Registers a schema item. Can only be called once for every item name.
   *
   * ```ts
   * schema.register( 'paragraph', {
   * 	inheritAllFrom: '$block'
   * } );
   * ```
   */
  register(e, t) {
    if (this._sourceDefinitions[e])
      throw new g("schema-cannot-register-item-twice", this, {
        itemName: e
      });
    this._sourceDefinitions[e] = [
      Object.assign({}, t)
    ], this._clearCache();
  }
  /**
   * Extends a {@link #register registered} item's definition.
   *
   * Extending properties such as `allowIn` will add more items to the existing properties,
   * while redefining properties such as `isBlock` will override the previously defined ones.
   *
   * ```ts
   * schema.register( 'foo', {
   * 	allowIn: '$root',
   * 	isBlock: true;
   * } );
   * schema.extend( 'foo', {
   * 	allowIn: 'blockQuote',
   * 	isBlock: false
   * } );
   *
   * schema.getDefinition( 'foo' );
   * //	{
   * //		allowIn: [ '$root', 'blockQuote' ],
   * // 		isBlock: false
   * //	}
   * ```
   */
  extend(e, t) {
    if (!this._sourceDefinitions[e])
      throw new g("schema-cannot-extend-missing-item", this, {
        itemName: e
      });
    this._sourceDefinitions[e].push(Object.assign({}, t)), this._clearCache();
  }
  /**
   * Returns data of all registered items.
   *
   * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,
   * checking a list of all block elements, etc).
   * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})
   * in other cases.
   */
  getDefinitions() {
    return this._compiledDefinitions || this._compile(), this._compiledDefinitions;
  }
  /**
   * Returns a definition of the given item or `undefined` if an item is not registered.
   *
   * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,
   * checking a list of all block elements, etc).
   * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})
   * in other cases.
   */
  getDefinition(e) {
    let t;
    return typeof e == "string" ? t = e : "is" in e && (e.is("$text") || e.is("$textProxy")) ? t = "$text" : t = e.name, this.getDefinitions()[t];
  }
  /**
   * Returns `true` if the given item is registered in the schema.
   *
   * ```ts
   * schema.isRegistered( 'paragraph' ); // -> true
   * schema.isRegistered( editor.model.document.getRoot() ); // -> true
   * schema.isRegistered( 'foo' ); // -> false
   * ```
   */
  isRegistered(e) {
    return !!this.getDefinition(e);
  }
  /**
   * Returns `true` if the given item is defined to be
   * a block by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isBlock` property.
   *
   * ```ts
   * schema.isBlock( 'paragraph' ); // -> true
   * schema.isBlock( '$root' ); // -> false
   *
   * const paragraphElement = writer.createElement( 'paragraph' );
   * schema.isBlock( paragraphElement ); // -> true
   * ```
   *
   * See the {@glink framework/deep-dive/schema#block-elements Block elements} section of
   * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
   */
  isBlock(e) {
    const t = this.getDefinition(e);
    return !!(t && t.isBlock);
  }
  /**
   * Returns `true` if the given item should be treated as a limit element.
   *
   * It considers an item to be a limit element if its
   * {@link module:engine/model/schema~SchemaItemDefinition}'s
   * {@link module:engine/model/schema~SchemaItemDefinition#isLimit `isLimit`} or
   * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property
   * was set to `true`.
   *
   * ```ts
   * schema.isLimit( 'paragraph' ); // -> false
   * schema.isLimit( '$root' ); // -> true
   * schema.isLimit( editor.model.document.getRoot() ); // -> true
   * schema.isLimit( 'imageBlock' ); // -> true
   * ```
   *
   * See the {@glink framework/deep-dive/schema#limit-elements Limit elements} section of
   * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
   */
  isLimit(e) {
    const t = this.getDefinition(e);
    return t ? !!(t.isLimit || t.isObject) : !1;
  }
  /**
   * Returns `true` if the given item should be treated as an object element.
   *
   * It considers an item to be an object element if its
   * {@link module:engine/model/schema~SchemaItemDefinition}'s
   * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property
   * was set to `true`.
   *
   * ```ts
   * schema.isObject( 'paragraph' ); // -> false
   * schema.isObject( 'imageBlock' ); // -> true
   *
   * const imageElement = writer.createElement( 'imageBlock' );
   * schema.isObject( imageElement ); // -> true
   * ```
   *
   * See the {@glink framework/deep-dive/schema#object-elements Object elements} section of
   * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
   */
  isObject(e) {
    const t = this.getDefinition(e);
    return t ? !!(t.isObject || t.isLimit && t.isSelectable && t.isContent) : !1;
  }
  /**
   * Returns `true` if the given item is defined to be
   * an inline element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isInline` property.
   *
   * ```ts
   * schema.isInline( 'paragraph' ); // -> false
   * schema.isInline( 'softBreak' ); // -> true
   *
   * const text = writer.createText( 'foo' );
   * schema.isInline( text ); // -> true
   * ```
   *
   * See the {@glink framework/deep-dive/schema#inline-elements Inline elements} section of
   * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
   */
  isInline(e) {
    const t = this.getDefinition(e);
    return !!(t && t.isInline);
  }
  /**
   * Returns `true` if the given item is defined to be
   * a selectable element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isSelectable` property.
   *
   * ```ts
   * schema.isSelectable( 'paragraph' ); // -> false
   * schema.isSelectable( 'heading1' ); // -> false
   * schema.isSelectable( 'imageBlock' ); // -> true
   * schema.isSelectable( 'tableCell' ); // -> true
   *
   * const text = writer.createText( 'foo' );
   * schema.isSelectable( text ); // -> false
   * ```
   *
   * See the {@glink framework/deep-dive/schema#selectable-elements Selectable elements section} of
   * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
   */
  isSelectable(e) {
    const t = this.getDefinition(e);
    return t ? !!(t.isSelectable || t.isObject) : !1;
  }
  /**
   * Returns `true` if the given item is defined to be
   * a content by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isContent` property.
   *
   * ```ts
   * schema.isContent( 'paragraph' ); // -> false
   * schema.isContent( 'heading1' ); // -> false
   * schema.isContent( 'imageBlock' ); // -> true
   * schema.isContent( 'horizontalLine' ); // -> true
   *
   * const text = writer.createText( 'foo' );
   * schema.isContent( text ); // -> true
   * ```
   *
   * See the {@glink framework/deep-dive/schema#content-elements Content elements section} of
   * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
   */
  isContent(e) {
    const t = this.getDefinition(e);
    return t ? !!(t.isContent || t.isObject) : !1;
  }
  /**
   * Checks whether the given node (`child`) can be a child of the given context.
   *
   * ```ts
   * schema.checkChild( model.document.getRoot(), paragraph ); // -> false
   *
   * schema.register( 'paragraph', {
   * 	allowIn: '$root'
   * } );
   * schema.checkChild( model.document.getRoot(), paragraph ); // -> true
   * ```
   *
   * Note: When verifying whether the given node can be a child of the given context, the
   * schema also verifies the entire context &ndash; from its root to its last element. Therefore, it is possible
   * for `checkChild()` to return `false` even though the context's last element can contain the checked child.
   * It happens if one of the context's elements does not allow its child.
   *
   * @fires checkChild
   * @param context The context in which the child will be checked.
   * @param def The child to check.
   */
  checkChild(e, t) {
    return t ? this._checkContextMatch(t, e) : !1;
  }
  /**
   * Checks whether the given attribute can be applied in the given context (on the last
   * item of the context).
   *
   * ```ts
   * schema.checkAttribute( textNode, 'bold' ); // -> false
   *
   * schema.extend( '$text', {
   * 	allowAttributes: 'bold'
   * } );
   * schema.checkAttribute( textNode, 'bold' ); // -> true
   * ```
   *
   * @fires checkAttribute
   * @param context The context in which the attribute will be checked.
   */
  checkAttribute(e, t) {
    const n = this.getDefinition(e.last);
    return n ? n.allowAttributes.includes(t) : !1;
  }
  /**
   * Checks whether the given element (`elementToMerge`) can be merged with the specified base element (`positionOrBaseElement`).
   *
   * In other words &ndash; whether `elementToMerge`'s children {@link #checkChild are allowed} in the `positionOrBaseElement`.
   *
   * This check ensures that elements merged with {@link module:engine/model/writer~Writer#merge `Writer#merge()`}
   * will be valid.
   *
   * Instead of elements, you can pass the instance of the {@link module:engine/model/position~Position} class as the
   * `positionOrBaseElement`. It means that the elements before and after the position will be checked whether they can be merged.
   *
   * @param positionOrBaseElement The position or base element to which the `elementToMerge` will be merged.
   * @param elementToMerge The element to merge. Required if `positionOrBaseElement` is an element.
   */
  checkMerge(e, t) {
    if (e instanceof y) {
      const n = e.nodeBefore, s = e.nodeAfter;
      if (!(n instanceof $))
        throw new g("schema-check-merge-no-element-before", this);
      if (!(s instanceof $))
        throw new g("schema-check-merge-no-element-after", this);
      return this.checkMerge(n, s);
    }
    for (const n of t.getChildren())
      if (!this.checkChild(e, n))
        return !1;
    return !0;
  }
  /**
   * Allows registering a callback to the {@link #checkChild} method calls.
   *
   * Callbacks allow you to implement rules which are not otherwise possible to achieve
   * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.
   * For example, by using this method you can disallow elements in specific contexts.
   *
   * This method is a shorthand for using the {@link #event:checkChild} event. For even better control,
   * you can use that event instead.
   *
   * Example:
   *
   * ```ts
   * // Disallow heading1 directly inside a blockQuote.
   * schema.addChildCheck( ( context, childDefinition ) => {
   * 	if ( context.endsWith( 'blockQuote' ) && childDefinition.name == 'heading1' ) {
   * 		return false;
   * 	}
   * } );
   * ```
   *
   * Which translates to:
   *
   * ```ts
   * schema.on( 'checkChild', ( evt, args ) => {
   * 	const context = args[ 0 ];
   * 	const childDefinition = args[ 1 ];
   *
   * 	if ( context.endsWith( 'blockQuote' ) && childDefinition && childDefinition.name == 'heading1' ) {
   * 		// Prevent next listeners from being called.
   * 		evt.stop();
   * 		// Set the checkChild()'s return value.
   * 		evt.return = false;
   * 	}
   * }, { priority: 'high' } );
   * ```
   *
   * @param callback The callback to be called. It is called with two parameters:
   * {@link module:engine/model/schema~SchemaContext} (context) instance and
   * {@link module:engine/model/schema~SchemaCompiledItemDefinition} (child-to-check definition).
   * The callback may return `true/false` to override `checkChild()`'s return value. If it does not return
   * a boolean value, the default algorithm (or other callbacks) will define `checkChild()`'s return value.
   */
  addChildCheck(e) {
    this.on("checkChild", (t, [n, s]) => {
      if (!s)
        return;
      const o = e(n, s);
      typeof o == "boolean" && (t.stop(), t.return = o);
    }, { priority: "high" });
  }
  /**
   * Allows registering a callback to the {@link #checkAttribute} method calls.
   *
   * Callbacks allow you to implement rules which are not otherwise possible to achieve
   * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.
   * For example, by using this method you can disallow attribute if node to which it is applied
   * is contained within some other element (e.g. you want to disallow `bold` on `$text` within `heading1`).
   *
   * This method is a shorthand for using the {@link #event:checkAttribute} event. For even better control,
   * you can use that event instead.
   *
   * Example:
   *
   * ```ts
   * // Disallow bold on $text inside heading1.
   * schema.addAttributeCheck( ( context, attributeName ) => {
   * 	if ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {
   * 		return false;
   * 	}
   * } );
   * ```
   *
   * Which translates to:
   *
   * ```ts
   * schema.on( 'checkAttribute', ( evt, args ) => {
   * 	const context = args[ 0 ];
   * 	const attributeName = args[ 1 ];
   *
   * 	if ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {
   * 		// Prevent next listeners from being called.
   * 		evt.stop();
   * 		// Set the checkAttribute()'s return value.
   * 		evt.return = false;
   * 	}
   * }, { priority: 'high' } );
   * ```
   *
   * @param callback The callback to be called. It is called with two parameters:
   * {@link module:engine/model/schema~SchemaContext} (context) instance and attribute name.
   * The callback may return `true/false` to override `checkAttribute()`'s return value. If it does not return
   * a boolean value, the default algorithm (or other callbacks) will define `checkAttribute()`'s return value.
   */
  addAttributeCheck(e) {
    this.on("checkAttribute", (t, [n, s]) => {
      const o = e(n, s);
      typeof o == "boolean" && (t.stop(), t.return = o);
    }, { priority: "high" });
  }
  /**
   * This method allows assigning additional metadata to the model attributes. For example,
   * {@link module:engine/model/schema~AttributeProperties `AttributeProperties#isFormatting` property} is
   * used to mark formatting attributes (like `bold` or `italic`).
   *
   * ```ts
   * // Mark bold as a formatting attribute.
   * schema.setAttributeProperties( 'bold', {
   * 	isFormatting: true
   * } );
   *
   * // Override code not to be considered a formatting markup.
   * schema.setAttributeProperties( 'code', {
   * 	isFormatting: false
   * } );
   * ```
   *
   * Properties are not limited to members defined in the
   * {@link module:engine/model/schema~AttributeProperties `AttributeProperties` type} and you can also use custom properties:
   *
   * ```ts
   * schema.setAttributeProperties( 'blockQuote', {
   * 	customProperty: 'value'
   * } );
   * ```
   *
   * Subsequent calls with the same attribute will extend its custom properties:
   *
   * ```ts
   * schema.setAttributeProperties( 'blockQuote', {
   * 	one: 1
   * } );
   *
   * schema.setAttributeProperties( 'blockQuote', {
   * 	two: 2
   * } );
   *
   * console.log( schema.getAttributeProperties( 'blockQuote' ) );
   * // Logs: { one: 1, two: 2 }
   * ```
   *
   * @param attributeName A name of the attribute to receive the properties.
   * @param properties A dictionary of properties.
   */
  setAttributeProperties(e, t) {
    this._attributeProperties[e] = Object.assign(this.getAttributeProperties(e), t);
  }
  /**
   * Returns properties associated with a given model attribute. See {@link #setAttributeProperties `setAttributeProperties()`}.
   *
   * @param attributeName A name of the attribute.
   */
  getAttributeProperties(e) {
    return this._attributeProperties[e] || {};
  }
  /**
   * Returns the lowest {@link module:engine/model/schema~Schema#isLimit limit element} containing the entire
   * selection/range/position or the root otherwise.
   *
   * @param selectionOrRangeOrPosition The selection/range/position to check.
   * @returns The lowest limit element containing the entire `selectionOrRangeOrPosition`.
   */
  getLimitElement(e) {
    let t;
    for (e instanceof y ? t = e.parent : t = (e instanceof _ ? [e] : Array.from(e.getRanges())).reduce((s, o) => {
      const r = o.getCommonAncestor();
      return s ? s.getCommonAncestor(r, { includeSelf: !0 }) : r;
    }, null); !this.isLimit(t) && t.parent; )
      t = t.parent;
    return t;
  }
  /**
   * Checks whether the attribute is allowed in selection:
   *
   * * if the selection is not collapsed, then checks if the attribute is allowed on any of nodes in that range,
   * * if the selection is collapsed, then checks if on the selection position there's a text with the
   * specified attribute allowed.
   *
   * @param selection Selection which will be checked.
   * @param attribute The name of the attribute to check.
   */
  checkAttributeInSelection(e, t) {
    if (e.isCollapsed) {
      const s = [
        ...e.getFirstPosition().getAncestors(),
        new j("", e.getAttributes())
      ];
      return this.checkAttribute(s, t);
    } else {
      const n = e.getRanges();
      for (const s of n)
        for (const o of s)
          if (this.checkAttribute(o.item, t))
            return !0;
    }
    return !1;
  }
  /**
   * Transforms the given set of ranges into a set of ranges where the given attribute is allowed (and can be applied).
   *
   * @param ranges Ranges to be validated.
   * @param attribute The name of the attribute to check.
   * @returns Ranges in which the attribute is allowed.
   */
  *getValidRanges(e, t) {
    e = y2(e);
    for (const n of e)
      yield* this._getValidRangesForRange(n, t);
  }
  /**
   * Basing on given `position`, finds and returns a {@link module:engine/model/range~Range range} which is
   * nearest to that `position` and is a correct range for selection.
   *
   * The correct selection range might be collapsed when it is located in a position where the text node can be placed.
   * Non-collapsed range is returned when selection can be placed around element marked as an "object" in
   * the {@link module:engine/model/schema~Schema schema}.
   *
   * Direction of searching for the nearest correct selection range can be specified as:
   *
   * * `both` - searching will be performed in both ways,
   * * `forward` - searching will be performed only forward,
   * * `backward` - searching will be performed only backward.
   *
   * When valid selection range cannot be found, `null` is returned.
   *
   * @param position Reference position where new selection range should be looked for.
   * @param direction Search direction.
   * @returns Nearest selection range or `null` if one cannot be found.
   */
  getNearestSelectionRange(e, t = "both") {
    if (e.root.rootName == "$graveyard")
      return null;
    if (this.checkChild(e, "$text"))
      return new _(e);
    let n, s;
    const o = e.getAncestors().reverse().find((r) => this.isLimit(r)) || e.root;
    (t == "both" || t == "backward") && (n = new At({
      boundaries: _._createIn(o),
      startPosition: e,
      direction: "backward"
    })), (t == "both" || t == "forward") && (s = new At({
      boundaries: _._createIn(o),
      startPosition: e
    }));
    for (const r of v2(n, s)) {
      const a = r.walker == n ? "elementEnd" : "elementStart", l = r.value;
      if (l.type == a && this.isObject(l.item))
        return _._createOn(l.item);
      if (this.checkChild(l.nextPosition, "$text"))
        return new _(l.nextPosition);
    }
    return null;
  }
  /**
   * Tries to find position ancestors that allow to insert a given node.
   * It starts searching from the given position and goes node by node to the top of the model tree
   * as long as a {@link module:engine/model/schema~Schema#isLimit limit element}, an
   * {@link module:engine/model/schema~Schema#isObject object element} or a topmost ancestor is not reached.
   *
   * @param position The position that the search will start from.
   * @param node The node for which an allowed parent should be found or its name.
   * @returns Allowed parent or null if nothing was found.
   */
  findAllowedParent(e, t) {
    let n = e.parent;
    for (; n; ) {
      if (this.checkChild(n, t))
        return n;
      if (this.isLimit(n))
        return null;
      n = n.parent;
    }
    return null;
  }
  /**
   * Sets attributes allowed by the schema on a given node.
   *
   * @param node A node to set attributes on.
   * @param attributes Attributes keys and values.
   * @param writer An instance of the model writer.
   */
  setAllowedAttributes(e, t, n) {
    const s = n.model;
    for (const [o, r] of Object.entries(t))
      s.schema.checkAttribute(e, o) && n.setAttribute(o, r, e);
  }
  /**
   * Removes attributes disallowed by the schema.
   *
   * @param nodes Nodes that will be filtered.
   */
  removeDisallowedAttributes(e, t) {
    for (const n of e)
      if (n.is("$text"))
        _u(this, n, t);
      else {
        const o = _._createIn(n).getPositions();
        for (const r of o) {
          const a = r.nodeBefore || r.parent;
          _u(this, a, t);
        }
      }
  }
  /**
   * Gets attributes of a node that have a given property.
   *
   * @param node Node to get attributes from.
   * @param propertyName Name of the property that attribute must have to return it.
   * @param propertyValue Desired value of the property that we want to check.
   * When `undefined` attributes will be returned if they have set a given property no matter what the value is. If specified it will
   * return attributes which given property's value is equal to this parameter.
   * @returns Object with attributes' names as key and attributes' values as value.
   */
  getAttributesWithProperty(e, t, n) {
    const s = {};
    for (const [o, r] of e.getAttributes()) {
      const a = this.getAttributeProperties(o);
      a[t] !== void 0 && (n === void 0 || n === a[t]) && (s[o] = r);
    }
    return s;
  }
  /**
   * Creates an instance of the schema context.
   */
  createContext(e) {
    return new an(e);
  }
  _clearCache() {
    this._compiledDefinitions = null;
  }
  _compile() {
    const e = {}, t = this._sourceDefinitions, n = Object.keys(t);
    for (const s of n)
      e[s] = r2(t[s], s);
    for (const s of n)
      a2(e, s);
    for (const s of n)
      l2(e, s);
    for (const s of n)
      c2(e, s);
    for (const s of n)
      u2(e, s), d2(e, s);
    for (const s of n)
      h2(e, s), f2(e, s), m2(e, s);
    this._compiledDefinitions = e;
  }
  _checkContextMatch(e, t, n = t.length - 1) {
    const s = t.getItem(n);
    if (e.allowIn.includes(s.name)) {
      if (n == 0)
        return !0;
      {
        const o = this.getDefinition(s);
        return this._checkContextMatch(o, t, n - 1);
      }
    } else
      return !1;
  }
  /**
   * Takes a flat range and an attribute name. Traverses the range recursively and deeply to find and return all ranges
   * inside the given range on which the attribute can be applied.
   *
   * This is a helper function for {@link ~Schema#getValidRanges}.
   *
   * @param range The range to process.
   * @param attribute The name of the attribute to check.
   * @returns Ranges in which the attribute is allowed.
   */
  *_getValidRangesForRange(e, t) {
    let n = e.start, s = e.start;
    for (const o of e.getItems({ shallow: !0 }))
      o.is("element") && (yield* this._getValidRangesForRange(_._createIn(o), t)), this.checkAttribute(o, t) || (n.isEqual(s) || (yield new _(n, s)), n = y._createAfter(o)), s = y._createAfter(o);
    n.isEqual(s) || (yield new _(n, s));
  }
  /**
   * Returns a model range which is optimal (in terms of UX) for inserting a widget block.
   *
   * For instance, if a selection is in the middle of a paragraph, the collapsed range before this paragraph
   * will be returned so that it is not split. If the selection is at the end of a paragraph,
   * the collapsed range after this paragraph will be returned.
   *
   * Note: If the selection is placed in an empty block, the range in that block will be returned. If that range
   * is then passed to {@link module:engine/model/model~Model#insertContent}, the block will be fully replaced
   * by the inserted widget block.
   *
   * @internal
   * @param selection The selection based on which the insertion position should be calculated.
   * @param place The place where to look for optimal insertion range.
   * The `auto` value will determine itself the best position for insertion.
   * The `before` value will try to find a position before selection.
   * The `after` value will try to find a position after selection.
   * @returns The optimal range.
   */
  findOptimalInsertionRange(e, t) {
    const n = e.getSelectedElement();
    if (n && this.isObject(n) && !this.isInline(n))
      return t == "before" || t == "after" ? new _(y._createAt(n, t)) : _._createOn(n);
    const s = me(e.getSelectedBlocks());
    if (!s)
      return new _(e.focus);
    if (s.isEmpty)
      return new _(y._createAt(s, 0));
    const o = y._createAfter(s);
    return e.focus.isTouching(o) ? new _(o) : new _(y._createBefore(s));
  }
}
class an {
  /**
   * Creates an instance of the context.
   */
  constructor(e) {
    if (e instanceof an)
      return e;
    let t;
    typeof e == "string" ? t = [e] : Array.isArray(e) ? t = e : t = e.getAncestors({ includeSelf: !0 }), this._items = t.map(_2);
  }
  /**
   * The number of items.
   */
  get length() {
    return this._items.length;
  }
  /**
   * The last item (the lowest node).
   */
  get last() {
    return this._items[this._items.length - 1];
  }
  /**
   * Iterable interface.
   *
   * Iterates over all context items.
   */
  [Symbol.iterator]() {
    return this._items[Symbol.iterator]();
  }
  /**
   * Returns a new schema context instance with an additional item.
   *
   * Item can be added as:
   *
   * ```ts
   * const context = new SchemaContext( [ '$root' ] );
   *
   * // An element.
   * const fooElement = writer.createElement( 'fooElement' );
   * const newContext = context.push( fooElement ); // [ '$root', 'fooElement' ]
   *
   * // A text node.
   * const text = writer.createText( 'foobar' );
   * const newContext = context.push( text ); // [ '$root', '$text' ]
   *
   * // A string (element name).
   * const newContext = context.push( 'barElement' ); // [ '$root', 'barElement' ]
   * ```
   *
   * **Note** {@link module:engine/model/node~Node} that is already in the model tree will be added as the only item
   * (without ancestors).
   *
   * @param item An item that will be added to the current context.
   * @returns A new schema context instance with an additional item.
   */
  push(e) {
    const t = new an([e]);
    return t._items = [...this._items, ...t._items], t;
  }
  /**
   * Gets an item on the given index.
   */
  getItem(e) {
    return this._items[e];
  }
  /**
   * Returns the names of items.
   */
  *getNames() {
    yield* this._items.map((e) => e.name);
  }
  /**
   * Checks whether the context ends with the given nodes.
   *
   * ```ts
   * const ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );
   *
   * ctx.endsWith( '$text' ); // -> true
   * ctx.endsWith( 'paragraph $text' ); // -> true
   * ctx.endsWith( '$root' ); // -> false
   * ctx.endsWith( 'paragraph' ); // -> false
   * ```
   */
  endsWith(e) {
    return Array.from(this.getNames()).join(" ").endsWith(e);
  }
  /**
   * Checks whether the context starts with the given nodes.
   *
   * ```ts
   * const ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );
   *
   * ctx.endsWith( '$root' ); // -> true
   * ctx.endsWith( '$root paragraph' ); // -> true
   * ctx.endsWith( '$text' ); // -> false
   * ctx.endsWith( 'paragraph' ); // -> false
   * ```
   */
  startsWith(e) {
    return Array.from(this.getNames()).join(" ").startsWith(e);
  }
}
function r2(i, e) {
  const t = {
    name: e,
    allowIn: [],
    allowContentOf: [],
    allowWhere: [],
    allowAttributes: [],
    allowAttributesOf: [],
    allowChildren: [],
    inheritTypesFrom: []
  };
  return g2(i, t), Qt(i, t, "allowIn"), Qt(i, t, "allowContentOf"), Qt(i, t, "allowWhere"), Qt(i, t, "allowAttributes"), Qt(i, t, "allowAttributesOf"), Qt(i, t, "allowChildren"), Qt(i, t, "inheritTypesFrom"), p2(i, t), t;
}
function a2(i, e) {
  const t = i[e];
  for (const n of t.allowChildren) {
    const s = i[n];
    s && s.allowIn.push(e);
  }
  t.allowChildren.length = 0;
}
function l2(i, e) {
  for (const t of i[e].allowContentOf)
    i[t] && b2(i, t).forEach((s) => {
      s.allowIn.push(e);
    });
  delete i[e].allowContentOf;
}
function c2(i, e) {
  for (const t of i[e].allowWhere) {
    const n = i[t];
    if (n) {
      const s = n.allowIn;
      i[e].allowIn.push(...s);
    }
  }
  delete i[e].allowWhere;
}
function u2(i, e) {
  for (const t of i[e].allowAttributesOf) {
    const n = i[t];
    if (n) {
      const s = n.allowAttributes;
      i[e].allowAttributes.push(...s);
    }
  }
  delete i[e].allowAttributesOf;
}
function d2(i, e) {
  const t = i[e];
  for (const n of t.inheritTypesFrom) {
    const s = i[n];
    if (s) {
      const o = Object.keys(s).filter((r) => r.startsWith("is"));
      for (const r of o)
        r in t || (t[r] = s[r]);
    }
  }
  delete t.inheritTypesFrom;
}
function h2(i, e) {
  const t = i[e], n = t.allowIn.filter((s) => i[s]);
  t.allowIn = Array.from(new Set(n));
}
function f2(i, e) {
  const t = i[e];
  for (const n of t.allowIn)
    i[n].allowChildren.push(e);
}
function m2(i, e) {
  const t = i[e];
  t.allowAttributes = Array.from(new Set(t.allowAttributes));
}
function g2(i, e) {
  for (const t of i) {
    const n = Object.keys(t).filter((s) => s.startsWith("is"));
    for (const s of n)
      e[s] = !!t[s];
  }
}
function Qt(i, e, t) {
  for (const n of i) {
    const s = n[t];
    typeof s == "string" ? e[t].push(s) : Array.isArray(s) && e[t].push(...s);
  }
}
function p2(i, e) {
  for (const t of i) {
    const n = t.inheritAllFrom;
    n && (e.allowContentOf.push(n), e.allowWhere.push(n), e.allowAttributesOf.push(n), e.inheritTypesFrom.push(n));
  }
}
function b2(i, e) {
  const t = i[e];
  return w2(i).filter((n) => n.allowIn.includes(t.name));
}
function w2(i) {
  return Object.keys(i).map((e) => i[e]);
}
function _2(i) {
  return typeof i == "string" || i.is("documentFragment") ? {
    name: typeof i == "string" ? i : "$documentFragment",
    *getAttributeKeys() {
    },
    getAttribute() {
    }
  } : {
    // '$text' means text nodes and text proxies.
    name: i.is("element") ? i.name : "$text",
    *getAttributeKeys() {
      yield* i.getAttributeKeys();
    },
    getAttribute(e) {
      return i.getAttribute(e);
    }
  };
}
function* v2(i, e) {
  let t = !1;
  for (; !t; ) {
    if (t = !0, i) {
      const n = i.next();
      n.done || (t = !1, yield {
        walker: i,
        value: n.value
      });
    }
    if (e) {
      const n = e.next();
      n.done || (t = !1, yield {
        walker: e,
        value: n.value
      });
    }
  }
}
function* y2(i) {
  for (const e of i)
    yield* e.getMinimalFlatRanges();
}
function _u(i, e, t) {
  for (const n of e.getAttributeKeys())
    i.checkAttribute(e, n) || t.removeAttribute(n, e);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class C2 extends G() {
  /**
   * Creates an upcast dispatcher that operates using the passed API.
   *
   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi
   * @param conversionApi Additional properties for an interface that will be passed to events fired
   * by the upcast dispatcher.
   */
  constructor(e) {
    super(), this._splitParts = /* @__PURE__ */ new Map(), this._cursorParents = /* @__PURE__ */ new Map(), this._modelCursor = null, this._emptyElementsToKeep = /* @__PURE__ */ new Set(), this.conversionApi = {
      ...e,
      consumable: null,
      writer: null,
      store: null,
      convertItem: (t, n) => this._convertItem(t, n),
      convertChildren: (t, n) => this._convertChildren(t, n),
      safeInsert: (t, n) => this._safeInsert(t, n),
      updateConversionResult: (t, n) => this._updateConversionResult(t, n),
      // Advanced API - use only if custom position handling is needed.
      splitToAllowedParent: (t, n) => this._splitToAllowedParent(t, n),
      getSplitParts: (t) => this._getSplitParts(t),
      keepEmptyElement: (t) => this._keepEmptyElement(t)
    };
  }
  /**
   * Starts the conversion process. The entry point for the conversion.
   *
   * @fires element
   * @fires text
   * @fires documentFragment
   * @param viewElement The part of the view to be converted.
   * @param writer An instance of the model writer.
   * @param context Elements will be converted according to this context.
   * @returns Model data that is the result of the conversion process
   * wrapped in `DocumentFragment`. Converted marker elements will be set as the document fragment's
   * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.
   */
  convert(e, t, n = ["$root"]) {
    this.fire("viewCleanup", e), this._modelCursor = T2(n, t), this.conversionApi.writer = t, this.conversionApi.consumable = Di.createFrom(e), this.conversionApi.store = {};
    const { modelRange: s } = this._convertItem(e, this._modelCursor), o = t.createDocumentFragment();
    if (s) {
      this._removeEmptyElements();
      for (const r of Array.from(this._modelCursor.parent.getChildren()))
        t.append(r, o);
      o.markers = k2(o, t);
    }
    return this._modelCursor = null, this._splitParts.clear(), this._cursorParents.clear(), this._emptyElementsToKeep.clear(), this.conversionApi.writer = null, this.conversionApi.store = null, o;
  }
  /**
   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertItem
   */
  _convertItem(e, t) {
    const n = { viewItem: e, modelCursor: t, modelRange: null };
    if (e.is("element") ? this.fire(`element:${e.name}`, n, this.conversionApi) : e.is("$text") ? this.fire("text", n, this.conversionApi) : this.fire("documentFragment", n, this.conversionApi), n.modelRange && !(n.modelRange instanceof _))
      throw new g("view-conversion-dispatcher-incorrect-result", this);
    return { modelRange: n.modelRange, modelCursor: n.modelCursor };
  }
  /**
   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertChildren
   */
  _convertChildren(e, t) {
    let n = t.is("position") ? t : y._createAt(t, 0);
    const s = new _(n);
    for (const o of Array.from(e.getChildren())) {
      const r = this._convertItem(o, n);
      r.modelRange instanceof _ && (s.end = r.modelRange.end, n = r.modelCursor);
    }
    return { modelRange: s, modelCursor: n };
  }
  /**
   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#safeInsert
   */
  _safeInsert(e, t) {
    const n = this._splitToAllowedParent(e, t);
    return n ? (this.conversionApi.writer.insert(e, n.position), !0) : !1;
  }
  /**
   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#updateConversionResult
   */
  _updateConversionResult(e, t) {
    const n = this._getSplitParts(e), s = this.conversionApi.writer;
    t.modelRange || (t.modelRange = s.createRange(s.createPositionBefore(e), s.createPositionAfter(n[n.length - 1])));
    const o = this._cursorParents.get(e);
    o ? t.modelCursor = s.createPositionAt(o, 0) : t.modelCursor = t.modelRange.end;
  }
  /**
   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#splitToAllowedParent
   */
  _splitToAllowedParent(e, t) {
    const { schema: n, writer: s } = this.conversionApi;
    let o = n.findAllowedParent(t, e);
    if (o) {
      if (o === t.parent)
        return { position: t };
      this._modelCursor.parent.getAncestors().includes(o) && (o = null);
    }
    if (!o)
      return qm(t, e, n) ? {
        position: Gm(t, s)
      } : null;
    const r = this.conversionApi.writer.split(t, o), a = [];
    for (const c of r.range.getWalker())
      if (c.type == "elementEnd")
        a.push(c.item);
      else {
        const u = a.pop(), d = c.item;
        this._registerSplitPair(u, d);
      }
    const l = r.range.end.parent;
    return this._cursorParents.set(e, l), {
      position: r.position,
      cursorParent: l
    };
  }
  /**
   * Registers that a `splitPart` element is a split part of the `originalPart` element.
   *
   * The data set by this method is used by {@link #_getSplitParts} and {@link #_removeEmptyElements}.
   */
  _registerSplitPair(e, t) {
    this._splitParts.has(e) || this._splitParts.set(e, [e]);
    const n = this._splitParts.get(e);
    this._splitParts.set(t, n), n.push(t);
  }
  /**
   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#getSplitParts
   */
  _getSplitParts(e) {
    let t;
    return this._splitParts.has(e) ? t = this._splitParts.get(e) : t = [e], t;
  }
  /**
   * Mark an element that were created during the splitting to not get removed on conversion end even if it is empty.
   */
  _keepEmptyElement(e) {
    this._emptyElementsToKeep.add(e);
  }
  /**
   * Checks if there are any empty elements created while splitting and removes them.
   *
   * This method works recursively to re-check empty elements again after at least one element was removed in the initial call,
   * as some elements might have become empty after other empty elements were removed from them.
   */
  _removeEmptyElements() {
    let e = !1;
    for (const t of this._splitParts.keys())
      t.isEmpty && !this._emptyElementsToKeep.has(t) && (this.conversionApi.writer.remove(t), this._splitParts.delete(t), e = !0);
    e && this._removeEmptyElements();
  }
}
function k2(i, e) {
  const t = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Map(), s = _._createIn(i).getItems();
  for (const o of s)
    o.is("element", "$marker") && t.add(o);
  for (const o of t) {
    const r = o.getAttribute("data-name"), a = e.createPositionBefore(o);
    n.has(r) ? n.get(r).end = a.clone() : n.set(r, new _(a.clone())), e.remove(o);
  }
  return n;
}
function T2(i, e) {
  let t;
  for (const n of new an(i)) {
    const s = {};
    for (const r of n.getAttributeKeys())
      s[r] = n.getAttribute(r);
    const o = e.createElement(n.name, s);
    t && e.insert(o, t), t = y._createAt(o, 0);
  }
  return t;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class E2 {
  /**
   * Returns an HTML string created from the document fragment.
   */
  getHtml(e) {
    const n = E.document.implementation.createHTMLDocument("").createElement("div");
    return n.appendChild(e), n.innerHTML;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class A2 {
  /**
   * Creates a new instance of the HTML data processor class.
   *
   * @param document The view document instance.
   */
  constructor(e) {
    this.skipComments = !0, this.domParser = new DOMParser(), this.domConverter = new Xo(e, { renderingMode: "data" }), this.htmlWriter = new E2();
  }
  /**
   * Converts a provided {@link module:engine/view/documentfragment~DocumentFragment document fragment}
   * to data format &ndash; in this case to an HTML string.
   *
   * @returns HTML string.
   */
  toData(e) {
    const t = this.domConverter.viewToDom(e);
    return this.htmlWriter.getHtml(t);
  }
  /**
   * Converts the provided HTML string to a view tree.
   *
   * @param data An HTML string.
   * @returns A converted view element.
   */
  toView(e) {
    const t = this._toDom(e);
    return this.domConverter.domToView(t, { skipComments: this.skipComments });
  }
  /**
   * Registers a {@link module:engine/view/matcher~MatcherPattern} for view elements whose content should be treated as raw data
   * and not processed during the conversion from the DOM to the view elements.
   *
   * The raw data can be later accessed by a
   * {@link module:engine/view/element~Element#getCustomProperty custom property of a view element} called `"$rawContent"`.
   *
   * @param pattern Pattern matching all view elements whose content should be treated as raw data.
   */
  registerRawContentMatcher(e) {
    this.domConverter.registerRawContentMatcher(e);
  }
  /**
   * If the processor is set to use marked fillers, it will insert `&nbsp;` fillers wrapped in `<span>` elements
   * (`<span data-cke-filler="true">&nbsp;</span>`) instead of regular `&nbsp;` characters.
   *
   * This mode allows for a more precise handling of the block fillers (so they do not leak into the editor content) but
   * bloats the editor data with additional markup.
   *
   * This mode may be required by some features and will be turned on by them automatically.
   *
   * @param type Whether to use the default or the marked `&nbsp;` block fillers.
   */
  useFillerType(e) {
    this.domConverter.blockFillerMode = e == "marked" ? "markedNbsp" : "nbsp";
  }
  /**
   * Converts an HTML string to its DOM representation. Returns a document fragment containing nodes parsed from
   * the provided data.
   */
  _toDom(e) {
    e.match(/<(?:html|body|head|meta)(?:\s[^>]*)?>/i) || (e = `<body>${e}</body>`);
    const t = this.domParser.parseFromString(e, "text/html"), n = t.createDocumentFragment(), s = t.body.childNodes;
    for (; s.length > 0; )
      n.appendChild(s[0]);
    return n;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class x2 extends G() {
  /**
   * Creates a data controller instance.
   *
   * @param model Data model.
   * @param stylesProcessor The styles processor instance.
   */
  constructor(e, t) {
    super(), this.model = e, this.mapper = new Vm(), this.downcastDispatcher = new Mm({
      mapper: this.mapper,
      schema: e.schema
    }), this.downcastDispatcher.on("insert:$text", Om(), { priority: "lowest" }), this.downcastDispatcher.on("insert", Fm(), { priority: "lowest" }), this.upcastDispatcher = new C2({
      schema: e.schema
    }), this.viewDocument = new Zo(t), this.stylesProcessor = t, this.htmlProcessor = new A2(this.viewDocument), this.processor = this.htmlProcessor, this._viewWriter = new Cm(this.viewDocument), this.upcastDispatcher.on("text", NT(), { priority: "lowest" }), this.upcastDispatcher.on("element", gu(), { priority: "lowest" }), this.upcastDispatcher.on("documentFragment", gu(), { priority: "lowest" }), U().prototype.decorate.call(this, "init"), U().prototype.decorate.call(this, "set"), U().prototype.decorate.call(this, "get"), U().prototype.decorate.call(this, "toView"), U().prototype.decorate.call(this, "toModel"), this.on("init", () => {
      this.fire("ready");
    }, { priority: "lowest" }), this.on("ready", () => {
      this.model.enqueueChange({ isUndoable: !1 }, Wm);
    }, { priority: "lowest" });
  }
  /**
   * Returns the model's data converted by downcast dispatchers attached to {@link #downcastDispatcher} and
   * formatted by the {@link #processor data processor}.
   *
   * A warning is logged when you try to retrieve data for a detached root, as most probably this is a mistake. A detached root should
   * be treated like it is removed, and you should not save its data. Note, that the detached root data is always an empty string.
   *
   * @fires get
   * @param options Additional configuration for the retrieved data. `DataController` provides two optional
   * properties: `rootName` and `trim`. Other properties of this object are specified by various editor features.
   * @param options.rootName Root name. Default 'main'.
   * @param options.trim Whether returned data should be trimmed. This option is set to `empty` by default,
   * which means whenever editor content is considered empty, an empty string will be returned. To turn off trimming completely
   * use `'none'`. In such cases the exact content will be returned (for example a `<p>&nbsp;</p>` for an empty editor).
   * @returns Output data.
   */
  get(e = {}) {
    const { rootName: t = "main", trim: n = "empty" } = e;
    if (!this._checkIfRootsExists([t]))
      throw new g("datacontroller-get-non-existent-root", this);
    const s = this.model.document.getRoot(t);
    return s.isAttached() || D("datacontroller-get-detached-root", this), n === "empty" && !this.model.hasContent(s, { ignoreWhitespaces: !0 }) ? "" : this.stringify(s, e);
  }
  /**
   * Returns the content of the given {@link module:engine/model/element~Element model's element} or
   * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast converters
   * attached to the {@link #downcastDispatcher} and formatted by the {@link #processor data processor}.
   *
   * @param modelElementOrFragment The element whose content will be stringified.
   * @param options Additional configuration passed to the conversion process.
   * @returns Output data.
   */
  stringify(e, t = {}) {
    const n = this.toView(e, t);
    return this.processor.toData(n);
  }
  /**
   * Returns the content of the given {@link module:engine/model/element~Element model element} or
   * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast
   * converters attached to {@link #downcastDispatcher} into a
   * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}.
   *
   * @fires toView
   * @param modelElementOrFragment Element or document fragment whose content will be converted.
   * @param options Additional configuration that will be available through the
   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi#options} during the conversion process.
   * @returns Output view DocumentFragment.
   */
  toView(e, t = {}) {
    const n = this.viewDocument, s = this._viewWriter;
    this.mapper.clearBindings();
    const o = _._createIn(e), r = new rn(n);
    this.mapper.bindElements(e, r);
    const a = e.is("documentFragment") ? e.markers : I2(e);
    return this.downcastDispatcher.convert(o, a, s, t), r;
  }
  /**
   * Sets the initial input data parsed by the {@link #processor data processor} and
   * converted by the {@link #upcastDispatcher view-to-model converters}.
   * Initial data can be only set to a document whose {@link module:engine/model/document~Document#version} is equal 0.
   *
   * **Note** This method is {@link module:utils/observablemixin~Observable#decorate decorated} which is
   * used by e.g. collaborative editing plugin that syncs remote data on init.
   *
   * When data is passed as a string, it is initialized on the default `main` root:
   *
   * ```ts
   * dataController.init( '<p>Foo</p>' ); // Initializes data on the `main` root only, as no other is specified.
   * ```
   *
   * To initialize data on a different root or multiple roots at once, an object containing `rootName` - `data` pairs should be passed:
   *
   * ```ts
   * dataController.init( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Initializes data on both the `main` and `title` roots.
   * ```
   *
   * @fires init
   * @param data Input data as a string or an object containing the `rootName` - `data`
   * pairs to initialize data on multiple roots at once.
   * @returns Promise that is resolved after the data is set on the editor.
   */
  init(e) {
    if (this.model.document.version)
      throw new g("datacontroller-init-document-not-empty", this);
    let t = {};
    if (typeof e == "string" ? t.main = e : t = e, !this._checkIfRootsExists(Object.keys(t)))
      throw new g("datacontroller-init-non-existent-root", this);
    return this.model.enqueueChange({ isUndoable: !1 }, (n) => {
      for (const s of Object.keys(t)) {
        const o = this.model.document.getRoot(s);
        n.insert(this.parse(t[s], o), o, 0);
      }
    }), Promise.resolve();
  }
  /**
   * Sets the input data parsed by the {@link #processor data processor} and
   * converted by the {@link #upcastDispatcher view-to-model converters}.
   * This method can be used any time to replace existing editor data with the new one without clearing the
   * {@link module:engine/model/document~Document#history document history}.
   *
   * This method also creates a batch with all the changes applied. If all you need is to parse data, use
   * the {@link #parse} method.
   *
   * When data is passed as a string it is set on the default `main` root:
   *
   * ```ts
   * dataController.set( '<p>Foo</p>' ); // Sets data on the `main` root, as no other is specified.
   * ```
   *
   * To set data on a different root or multiple roots at once, an object containing `rootName` - `data` pairs should be passed:
   *
   * ```ts
   * dataController.set( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Sets data on the `main` and `title` roots as specified.
   * ```
   *
   * To set the data with a preserved undo stack and add the change to the undo stack, set `{ isUndoable: true }` as a `batchType` option.
   *
   * ```ts
   * dataController.set( '<p>Foo</p>', { batchType: { isUndoable: true } } );
   * ```
   *
   * @fires set
   * @param data Input data as a string or an object containing the `rootName` - `data`
   * pairs to set data on multiple roots at once.
   * @param options Options for setting data.
   * @param options.batchType The batch type that will be used to create a batch for the changes applied by this method.
   * By default, the batch will be set as {@link module:engine/model/batch~Batch#isUndoable not undoable} and the undo stack will be
   * cleared after the new data is applied (all undo steps will be removed). If the batch type `isUndoable` flag is be set to `true`,
   * the undo stack will be preserved instead and not cleared when new data is applied.
   */
  set(e, t = {}) {
    let n = {};
    if (typeof e == "string" ? n.main = e : n = e, !this._checkIfRootsExists(Object.keys(n)))
      throw new g("datacontroller-set-non-existent-root", this);
    this.model.enqueueChange(t.batchType || {}, (s) => {
      s.setSelection(null), s.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
      for (const o of Object.keys(n)) {
        const r = this.model.document.getRoot(o);
        s.remove(s.createRangeIn(r)), s.insert(this.parse(n[o], r), r, 0);
      }
    });
  }
  /**
   * Returns the data parsed by the {@link #processor data processor} and then converted by upcast converters
   * attached to the {@link #upcastDispatcher}.
   *
   * @see #set
   * @param data Data to parse.
   * @param context Base context in which the view will be converted to the model.
   * See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.
   * @returns Parsed data.
   */
  parse(e, t = "$root") {
    const n = this.processor.toView(e);
    return this.toModel(n, t);
  }
  /**
   * Returns the result of the given {@link module:engine/view/element~Element view element} or
   * {@link module:engine/view/documentfragment~DocumentFragment view document fragment} converted by the
   * {@link #upcastDispatcher view-to-model converters}, wrapped by {@link module:engine/model/documentfragment~DocumentFragment}.
   *
   * When marker elements were converted during the conversion process, it will be set as a document fragment's
   * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.
   *
   * @fires toModel
   * @param viewElementOrFragment The element or document fragment whose content will be converted.
   * @param context Base context in which the view will be converted to the model.
   * See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.
   * @returns Output document fragment.
   */
  toModel(e, t = "$root") {
    return this.model.change((n) => this.upcastDispatcher.convert(e, n, t));
  }
  /**
   * Adds the style processor normalization rules.
   *
   * You can implement your own rules as well as use one of the available processor rules:
   *
   * * background: {@link module:engine/view/styles/background~addBackgroundRules}
   * * border: {@link module:engine/view/styles/border~addBorderRules}
   * * margin: {@link module:engine/view/styles/margin~addMarginRules}
   * * padding: {@link module:engine/view/styles/padding~addPaddingRules}
   */
  addStyleProcessorRules(e) {
    e(this.stylesProcessor);
  }
  /**
   * Registers a {@link module:engine/view/matcher~MatcherPattern} on an {@link #htmlProcessor htmlProcessor}
   * and a {@link #processor processor} for view elements whose content should be treated as raw data
   * and not processed during the conversion from DOM to view elements.
   *
   * The raw data can be later accessed by the {@link module:engine/view/element~Element#getCustomProperty view element custom property}
   * `"$rawContent"`.
   *
   * @param pattern Pattern matching all view elements whose content should be treated as a raw data.
   */
  registerRawContentMatcher(e) {
    this.processor && this.processor !== this.htmlProcessor && this.processor.registerRawContentMatcher(e), this.htmlProcessor.registerRawContentMatcher(e);
  }
  /**
   * Removes all event listeners set by the DataController.
   */
  destroy() {
    this.stopListening();
  }
  /**
   * Checks whether all provided root names are actually existing editor roots.
   *
   * @param rootNames Root names to check.
   * @returns Whether all provided root names are existing editor roots.
   */
  _checkIfRootsExists(e) {
    for (const t of e)
      if (!this.model.document.getRoot(t))
        return !1;
    return !0;
  }
}
function I2(i) {
  const e = [], t = i.root.document;
  if (!t)
    return /* @__PURE__ */ new Map();
  const n = _._createIn(i);
  for (const s of t.model.markers) {
    const o = s.getRange(), r = o.isCollapsed, a = o.start.isEqual(n.start) || o.end.isEqual(n.end);
    if (r && a)
      e.push([s.name, o]);
    else {
      const l = n.getIntersection(o);
      l && e.push([s.name, l]);
    }
  }
  return e.sort(([s, o], [r, a]) => {
    if (o.end.compareWith(a.start) !== "after")
      return 1;
    if (o.start.compareWith(a.end) !== "before")
      return -1;
    switch (o.start.compareWith(a.start)) {
      case "before":
        return 1;
      case "after":
        return -1;
      default:
        switch (o.end.compareWith(a.end)) {
          case "before":
            return 1;
          case "after":
            return -1;
          default:
            return r.localeCompare(s);
        }
    }
  }), new Map(e);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class S2 {
  /**
   * Creates a new conversion instance.
   */
  constructor(e, t) {
    this._helpers = /* @__PURE__ */ new Map(), this._downcast = Z(e), this._createConversionHelpers({ name: "downcast", dispatchers: this._downcast, isDowncast: !0 }), this._upcast = Z(t), this._createConversionHelpers({ name: "upcast", dispatchers: this._upcast, isDowncast: !1 });
  }
  /**
   * Define an alias for registered dispatcher.
   *
   * ```ts
   * const conversion = new Conversion(
   * 	[ dataDowncastDispatcher, editingDowncastDispatcher ],
   * 	upcastDispatcher
   * );
   *
   * conversion.addAlias( 'dataDowncast', dataDowncastDispatcher );
   * ```
   *
   * @param alias An alias of a dispatcher.
   * @param dispatcher Dispatcher which should have an alias.
   */
  addAlias(e, t) {
    const n = this._downcast.includes(t);
    if (!this._upcast.includes(t) && !n)
      throw new g("conversion-add-alias-dispatcher-not-registered", this);
    this._createConversionHelpers({ name: e, dispatchers: [t], isDowncast: n });
  }
  /**
   * Provides a chainable API to assign converters to a conversion dispatchers group.
   *
   * If the given group name has not been registered, the
   * {@link module:utils/ckeditorerror~CKEditorError `conversion-for-unknown-group` error} is thrown.
   *
   * You can use conversion helpers available directly in the `for()` chain or your custom ones via
   * the {@link module:engine/conversion/conversionhelpers~ConversionHelpers#add `add()`} method.
   *
   * # Using built-in conversion helpers
   *
   * The `for()` chain comes with a set of conversion helpers which you can use like this:
   *
   * ```ts
   * editor.conversion.for( 'downcast' )
   * 	.elementToElement( config1 )        // Adds an element-to-element downcast converter.
   * 	.attributeToElement( config2 );     // Adds an attribute-to-element downcast converter.
   *
   * editor.conversion.for( 'upcast' )
   * 	.elementToAttribute( config3 );     // Adds an element-to-attribute upcast converter.
   * ```
   *
   * Refer to the documentation of built-in conversion helpers to learn about their configuration options.
   *
   * * downcast (model-to-view) conversion helpers:
   *
   *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`},
   *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement `attributeToElement()`},
   *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToAttribute `attributeToAttribute()`}.
   *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToElement `markerToElement()`}.
   *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToHighlight `markerToHighlight()`}.
   *
   * * upcast (view-to-model) conversion helpers:
   *
   *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToElement `elementToElement()`},
   *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute `elementToAttribute()`},
   *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute `attributeToAttribute()`}.
   *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToMarker `elementToMarker()`}.
   *
   * # Using custom conversion helpers
   *
   * If you need to implement an atypical converter, you can do so by calling:
   *
   * ```ts
   * editor.conversion.for( direction ).add( customHelper );
   * ```
   *
   * The `.add()` method takes exactly one parameter, which is a function. This function should accept one parameter that
   * is a dispatcher instance. The function should add an actual converter to the passed dispatcher instance.
   *
   * Example:
   *
   * ```ts
   * editor.conversion.for( 'upcast' ).add( dispatcher => {
   * 	dispatcher.on( 'element:a',  ( evt, data, conversionApi ) => {
   * 		// Do something with a view <a> element.
   * 	} );
   * } );
   * ```
   *
   * Refer to the documentation of {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}
   * and {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} to learn how to write
   * custom converters.
   *
   * @param groupName The name of dispatchers group to add the converters to.
   */
  for(e) {
    if (!this._helpers.has(e))
      throw new g("conversion-for-unknown-group", this);
    return this._helpers.get(e);
  }
  /**
   * Sets up converters between the model and the view that convert a model element to a view element (and vice versa).
   * For example, the model `<paragraph>Foo</paragraph>` is turned into `<p>Foo</p>` in the view.
   *
   * ```ts
   * // A simple conversion from the `paragraph` model element to the `<p>` view element (and vice versa).
   * editor.conversion.elementToElement( { model: 'paragraph', view: 'p' } );
   *
   * // Override other converters by specifying a converter definition with a higher priority.
   * editor.conversion.elementToElement( { model: 'paragraph', view: 'div', converterPriority: 'high' } );
   *
   * // View specified as an object instead of a string.
   * editor.conversion.elementToElement( {
   * 	model: 'fancyParagraph',
   * 	view: {
   * 		name: 'p',
   * 		classes: 'fancy'
   * 	}
   * } );
   *
   * // Use `upcastAlso` to define other view elements that should also be converted to a `paragraph` element.
   * editor.conversion.elementToElement( {
   * 	model: 'paragraph',
   * 	view: 'p',
   * 	upcastAlso: [
   * 		'div',
   * 		{
   * 			// Any element with the `display: block` style.
   * 			styles: {
   * 				display: 'block'
   * 			}
   * 		}
   * 	]
   * } );
   *
   * // `upcastAlso` set as callback enables a conversion of a wide range of different view elements.
   * editor.conversion.elementToElement( {
   * 	model: 'heading',
   * 	view: 'h2',
   * 	// Convert "heading-like" paragraphs to headings.
   * 	upcastAlso: viewElement => {
   * 		const fontSize = viewElement.getStyle( 'font-size' );
   *
   * 		if ( !fontSize ) {
   * 			return null;
   * 		}
   *
   * 		const match = fontSize.match( /(\d+)\s*px/ );
   *
   * 		if ( !match ) {
   * 			return null;
   * 		}
   *
   * 		const size = Number( match[ 1 ] );
   *
   * 		if ( size > 26 ) {
   * 			// Returned value can be an object with the matched properties.
   * 			// These properties will be "consumed" during the conversion.
   * 			// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
   *
   * 			return { name: true, styles: [ 'font-size' ] };
   * 		}
   *
   * 		return null;
   * 	}
   * } );
   * ```
   *
   * `definition.model` is a `String` with a model element name to convert from or to.
   *
   * @param definition The converter definition.
   */
  elementToElement(e) {
    this.for("downcast").elementToElement(e);
    for (const { model: t, view: n } of Ar(e))
      this.for("upcast").elementToElement({
        model: t,
        view: n,
        converterPriority: e.converterPriority
      });
  }
  /**
   * Sets up converters between the model and the view that convert a model attribute to a view element (and vice versa).
   * For example, a model text node with `"Foo"` as data and the `bold` attribute will be turned to `<strong>Foo</strong>` in the view.
   *
   * ```ts
   * // A simple conversion from the `bold=true` attribute to the `<strong>` view element (and vice versa).
   * editor.conversion.attributeToElement( { model: 'bold', view: 'strong' } );
   *
   * // Override other converters by specifying a converter definition with a higher priority.
   * editor.conversion.attributeToElement( { model: 'bold', view: 'b', converterPriority: 'high' } );
   *
   * // View specified as an object instead of a string.
   * editor.conversion.attributeToElement( {
   * 	model: 'bold',
   * 	view: {
   * 		name: 'span',
   * 		classes: 'bold'
   * 	}
   * } );
   *
   * // Use `config.model.name` to define the conversion only from a given node type, `$text` in this case.
   * // The same attribute on different elements may then be handled by a different converter.
   * editor.conversion.attributeToElement( {
   * 	model: {
   * 		key: 'textDecoration',
   * 		values: [ 'underline', 'lineThrough' ],
   * 		name: '$text'
   * 	},
   * 	view: {
   * 		underline: {
   * 			name: 'span',
   * 			styles: {
   * 				'text-decoration': 'underline'
   * 			}
   * 		},
   * 		lineThrough: {
   * 			name: 'span',
   * 			styles: {
   * 				'text-decoration': 'line-through'
   * 			}
   * 		}
   * 	}
   * } );
   *
   * // Use `upcastAlso` to define other view elements that should also be converted to the `bold` attribute.
   * editor.conversion.attributeToElement( {
   * 	model: 'bold',
   * 	view: 'strong',
   * 	upcastAlso: [
   * 		'b',
   * 		{
   * 			name: 'span',
   * 			classes: 'bold'
   * 		},
   * 		{
   * 			name: 'span',
   * 			styles: {
   * 				'font-weight': 'bold'
   * 			}
   * 		},
   * 		viewElement => {
   * 			const fontWeight = viewElement.getStyle( 'font-weight' );
   *
   * 			if ( viewElement.is( 'element', 'span' ) && fontWeight && /\d+/.test() && Number( fontWeight ) > 500 ) {
   * 				// Returned value can be an object with the matched properties.
   * 				// These properties will be "consumed" during the conversion.
   * 				// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
   *
   * 				return {
   * 					name: true,
   * 					styles: [ 'font-weight' ]
   * 				};
   * 			}
   * 		}
   * 	]
   * } );
   *
   * // Conversion from and to a model attribute key whose value is an enum (`fontSize=big|small`).
   * // `upcastAlso` set as callback enables a conversion of a wide range of different view elements.
   * editor.conversion.attributeToElement( {
   * 	model: {
   * 		key: 'fontSize',
   * 		values: [ 'big', 'small' ]
   * 	},
   * 	view: {
   * 		big: {
   * 			name: 'span',
   * 			styles: {
   * 				'font-size': '1.2em'
   * 			}
   * 		},
   * 		small: {
   * 			name: 'span',
   * 			styles: {
   * 				'font-size': '0.8em'
   * 			}
   * 		}
   * 	},
   * 	upcastAlso: {
   * 		big: viewElement => {
   * 			const fontSize = viewElement.getStyle( 'font-size' );
   *
   * 			if ( !fontSize ) {
   * 				return null;
   * 			}
   *
   * 			const match = fontSize.match( /(\d+)\s*px/ );
   *
   * 			if ( !match ) {
   * 				return null;
   * 			}
   *
   * 			const size = Number( match[ 1 ] );
   *
   * 			if ( viewElement.is( 'element', 'span' ) && size > 10 ) {
   * 				// Returned value can be an object with the matched properties.
   * 				// These properties will be "consumed" during the conversion.
   * 				// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
   *
   * 				return { name: true, styles: [ 'font-size' ] };
   * 			}
   *
   * 			return null;
   * 		},
   * 		small: viewElement => {
   * 			const fontSize = viewElement.getStyle( 'font-size' );
   *
   * 			if ( !fontSize ) {
   * 				return null;
   * 			}
   *
   * 			const match = fontSize.match( /(\d+)\s*px/ );
   *
   * 			if ( !match ) {
   * 				return null;
   * 			}
   *
   * 			const size = Number( match[ 1 ] );
   *
   * 			if ( viewElement.is( 'element', 'span' ) && size < 10 ) {
   * 				// Returned value can be an object with the matched properties.
   * 				// These properties will be "consumed" during the conversion.
   * 				// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
   *
   * 				return { name: true, styles: [ 'font-size' ] };
   * 			}
   *
   * 			return null;
   * 		}
   * 	}
   * } );
   * ```
   *
   * The `definition.model` parameter specifies which model attribute should be converted from or to. It can be a `{ key, value }` object
   * describing the attribute key and value to convert or a `String` specifying just the attribute key (in such a case
   * `value` is set to `true`).
   *
   * @param definition The converter definition.
   */
  attributeToElement(e) {
    this.for("downcast").attributeToElement(e);
    for (const { model: t, view: n } of Ar(e))
      this.for("upcast").elementToAttribute({
        view: n,
        model: t,
        converterPriority: e.converterPriority
      });
  }
  /**
   * Sets up converters between the model and the view that convert a model attribute to a view attribute (and vice versa). For example,
   * `<imageBlock src='foo.jpg'></imageBlock>` is converted to `<img src='foo.jpg'></img>` (the same attribute key and value).
   * This type of converters is intended to be used with {@link module:engine/model/element~Element model element} nodes.
   * To convert the text attributes,
   * the {@link module:engine/conversion/conversion~Conversion#attributeToElement `attributeToElement converter`}should be set up.
   *
   * ```ts
   * // A simple conversion from the `source` model attribute to the `src` view attribute (and vice versa).
   * editor.conversion.attributeToAttribute( { model: 'source', view: 'src' } );
   *
   * // Attribute values are strictly specified.
   * editor.conversion.attributeToAttribute( {
   * 	model: {
   * 		name: 'imageInline',
   * 		key: 'aside',
   * 		values: [ 'aside' ]
   * 	},
   * 	view: {
   * 		aside: {
   * 			name: 'img',
   * 			key: 'class',
   * 			value: [ 'aside', 'half-size' ]
   * 		}
   * 	}
   * } );
   *
   * // Set the style attribute.
   * editor.conversion.attributeToAttribute( {
   * 	model: {
   * 		name: 'imageInline',
   * 		key: 'aside',
   * 		values: [ 'aside' ]
   * 	},
   * 	view: {
   * 		aside: {
   * 			name: 'img',
   * 			key: 'style',
   * 			value: {
   * 				float: 'right',
   * 				width: '50%',
   * 				margin: '5px'
   * 			}
   * 		}
   * 	}
   * } );
   *
   * // Conversion from and to a model attribute key whose value is an enum (`align=right|center`).
   * // Use `upcastAlso` to define other view elements that should also be converted to the `align=right` attribute.
   * editor.conversion.attributeToAttribute( {
   * 	model: {
   * 		key: 'align',
   * 		values: [ 'right', 'center' ]
   * 	},
   * 	view: {
   * 		right: {
   * 			key: 'class',
   * 			value: 'align-right'
   * 		},
   * 		center: {
   * 			key: 'class',
   * 			value: 'align-center'
   * 		}
   * 	},
   * 	upcastAlso: {
   * 		right: {
   * 			styles: {
   * 				'text-align': 'right'
   * 			}
   * 		},
   * 		center: {
   * 			styles: {
   * 				'text-align': 'center'
   * 			}
   * 		}
   * 	}
   * } );
   * ```
   *
   * The `definition.model` parameter specifies which model attribute should be converted from and to.
   * It can be a `{ key, [ values ], [ name ] }` object or a `String`, which will be treated like `{ key: definition.model }`.
   * The `key` property is the model attribute key to convert from and to.
   * The `values` are the possible model attribute values. If the `values` parameter is not set, the model attribute value
   * will be the same as the view attribute value.
   * If `name` is set, the conversion will be set up only for model elements with the given name.
   *
   * The `definition.view` parameter specifies which view attribute should be converted from and to.
   * It can be a `{ key, value, [ name ] }` object or a `String`, which will be treated like `{ key: definition.view }`.
   * The `key` property is the view attribute key to convert from and to.
   * The `value` is the view attribute value to convert from and to. If `definition.value` is not set, the view attribute value will be
   * the same as the model attribute value.
   * If `key` is `'class'`, `value` can be a `String` or an array of `String`s.
   * If `key` is `'style'`, `value` is an object with key-value pairs.
   * In other cases, `value` is a `String`.
   * If `name` is set, the conversion will be set up only for model elements with the given name.
   * If `definition.model.values` is set, `definition.view` is an object that assigns values from `definition.model.values`
   * to `{ key, value, [ name ] }` objects.
   *
   * `definition.upcastAlso` specifies which other matching view elements should also be upcast to the given model configuration.
   * If `definition.model.values` is set, `definition.upcastAlso` should be an object assigning values from `definition.model.values`
   * to {@link module:engine/view/matcher~MatcherPattern}s or arrays of {@link module:engine/view/matcher~MatcherPattern}s.
   *
   * **Note:** `definition.model` and `definition.view` form should be mirrored, so the same types of parameters should
   * be given in both parameters.
   *
   * @param definition The converter definition.
   * @param definition.model The model attribute to convert from and to.
   * @param definition.view The view attribute to convert from and to.
   * @param definition.upcastAlso Any view element matching `definition.upcastAlso` will also be converted to the given model attribute.
   * `definition.upcastAlso` is used only if `config.model.values` is specified.
   */
  attributeToAttribute(e) {
    this.for("downcast").attributeToAttribute(e);
    for (const { model: t, view: n } of Ar(e))
      this.for("upcast").attributeToAttribute({
        view: n,
        model: t
      });
  }
  /**
   * Creates and caches conversion helpers for given dispatchers group.
   *
   * @param options.name Group name.
   */
  _createConversionHelpers({ name: e, dispatchers: t, isDowncast: n }) {
    if (this._helpers.has(e))
      throw new g("conversion-group-exists", this);
    const s = n ? new oT(t) : new FT(t);
    this._helpers.set(e, s);
  }
}
function* Ar(i) {
  if (i.model.values)
    for (const e of i.model.values) {
      const t = { key: i.model.key, value: e }, n = i.view[e], s = i.upcastAlso ? i.upcastAlso[e] : void 0;
      yield* vu(t, n, s);
    }
  else
    yield* vu(i.model, i.view, i.upcastAlso);
}
function* vu(i, e, t) {
  if (yield { model: i, view: e }, t)
    for (const n of Z(t))
      yield { model: i, view: n };
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class $e {
  /**
   * Base operation constructor.
   *
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  constructor(e) {
    this.baseVersion = e, this.isDocumentOperation = this.baseVersion !== null, this.batch = null;
  }
  /**
   * Checks whether the operation's parameters are correct and the operation can be correctly executed. Throws
   * an error if operation is not valid.
   *
   * @internal
   */
  _validate() {
  }
  /**
   * Custom toJSON method to solve child-parent circular dependencies.
   *
   * @returns Clone of this object with the operation property replaced with string.
   */
  toJSON() {
    const e = Object.assign({}, this);
    return e.__className = this.constructor.className, delete e.batch, delete e.isDocumentOperation, e;
  }
  /**
   * Name of the operation class used for serialization.
   */
  static get className() {
    return "Operation";
  }
  /**
   * Creates `Operation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param doc Document on which this operation will be applied.
   */
  static fromJSON(e, t) {
    return new this(e.baseVersion);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function vl(i, e) {
  const t = Qm(e), n = t.reduce((r, a) => r + a.offsetSize, 0), s = i.parent;
  ns(i);
  const o = i.index;
  return s._insertChild(o, t), ts(s, o + t.length), ts(s, o), new _(i, i.getShiftedBy(n));
}
function Xm(i) {
  if (!i.isFlat)
    throw new g("operation-utils-remove-range-not-flat", this);
  const e = i.start.parent;
  ns(i.start), ns(i.end);
  const t = e._removeChildren(i.start.index, i.end.index - i.start.index);
  return ts(e, i.start.index), t;
}
function es(i, e) {
  if (!i.isFlat)
    throw new g("operation-utils-move-range-not-flat", this);
  const t = Xm(i);
  return e = e._getTransformedByDeletion(i.start, i.end.offset - i.start.offset), vl(e, t);
}
function P2(i, e, t) {
  ns(i.start), ns(i.end);
  for (const n of i.getItems({ shallow: !0 })) {
    const s = n.is("$textProxy") ? n.textNode : n;
    t !== null ? s._setAttribute(e, t) : s._removeAttribute(e), ts(s.parent, s.index);
  }
  ts(i.end.parent, i.end.index);
}
function Qm(i) {
  const e = [];
  function t(n) {
    if (typeof n == "string")
      e.push(new j(n));
    else if (n instanceof it)
      e.push(new j(n.data, n.getAttributes()));
    else if (n instanceof vn)
      e.push(n);
    else if (Ue(n))
      for (const s of n)
        t(s);
  }
  t(i);
  for (let n = 1; n < e.length; n++) {
    const s = e[n], o = e[n - 1];
    s instanceof j && o instanceof j && Ym(s, o) && (e.splice(n - 1, 2, new j(o.data + s.data, o.getAttributes())), n--);
  }
  return e;
}
function ts(i, e) {
  const t = i.getChild(e - 1), n = i.getChild(e);
  if (t && n && t.is("$text") && n.is("$text") && Ym(t, n)) {
    const s = new j(t.data + n.data, t.getAttributes());
    i._removeChildren(e - 1, 2), i._insertChild(e - 1, s);
  }
}
function ns(i) {
  const e = i.textNode, t = i.parent;
  if (e) {
    const n = i.offset - e.startOffset, s = e.index;
    t._removeChildren(s, 1);
    const o = new j(e.data.substr(0, n), e.getAttributes()), r = new j(e.data.substr(n), e.getAttributes());
    t._insertChild(s, [o, r]);
  }
}
function Ym(i, e) {
  const t = i.getAttributes(), n = e.getAttributes();
  for (const s of t) {
    if (s[1] !== e.getAttribute(s[0]))
      return !1;
    n.next();
  }
  return n.next().done;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class H extends $e {
  /**
   * Creates a move operation.
   *
   * @param sourcePosition Position before the first {@link module:engine/model/item~Item model item} to move.
   * @param howMany Offset size of moved range. Moved range will start from `sourcePosition` and end at
   * `sourcePosition` with offset shifted by `howMany`.
   * @param targetPosition Position at which moved nodes will be inserted.
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  constructor(e, t, n, s) {
    super(s), this.sourcePosition = e.clone(), this.sourcePosition.stickiness = "toNext", this.howMany = t, this.targetPosition = n.clone(), this.targetPosition.stickiness = "toNone";
  }
  /**
   * @inheritDoc
   */
  get type() {
    return this.targetPosition.root.rootName == "$graveyard" ? "remove" : this.sourcePosition.root.rootName == "$graveyard" ? "reinsert" : "move";
  }
  /**
   * @inheritDoc
   */
  get affectedSelectable() {
    return [
      _._createFromPositionAndShift(this.sourcePosition, this.howMany),
      _._createFromPositionAndShift(this.targetPosition, 0)
    ];
  }
  /**
   * Creates and returns an operation that has the same parameters as this operation.
   */
  clone() {
    return new H(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion);
  }
  /**
   * Returns the start position of the moved range after it got moved. This may be different than
   * {@link module:engine/model/operation/moveoperation~MoveOperation#targetPosition} in some cases, i.e. when a range is moved
   * inside the same parent but {@link module:engine/model/operation/moveoperation~MoveOperation#targetPosition targetPosition}
   * is after {@link module:engine/model/operation/moveoperation~MoveOperation#sourcePosition sourcePosition}.
   *
   * ```
   *  vv              vv
   * abcdefg ===> adefbcg
   *      ^          ^
   *      targetPos  movedRangeStart
   *      offset 6   offset 4
   *```
   */
  getMovedRangeStart() {
    return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany);
  }
  /**
   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
   */
  getReversed() {
    const e = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
    return new H(this.getMovedRangeStart(), this.howMany, e, this.baseVersion + 1);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _validate() {
    const e = this.sourcePosition.parent, t = this.targetPosition.parent, n = this.sourcePosition.offset, s = this.targetPosition.offset;
    if (n + this.howMany > e.maxOffset)
      throw new g("move-operation-nodes-do-not-exist", this);
    if (e === t && n < s && s < n + this.howMany)
      throw new g("move-operation-range-into-itself", this);
    if (this.sourcePosition.root == this.targetPosition.root && Ee(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) == "prefix") {
      const o = this.sourcePosition.path.length - 1;
      if (this.targetPosition.path[o] >= n && this.targetPosition.path[o] < n + this.howMany)
        throw new g("move-operation-node-into-itself", this);
    }
  }
  /**
   * @inheritDoc
   * @internal
   */
  _execute() {
    es(_._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition);
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    const e = super.toJSON();
    return e.sourcePosition = this.sourcePosition.toJSON(), e.targetPosition = this.targetPosition.toJSON(), e;
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "MoveOperation";
  }
  /**
   * Creates `MoveOperation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(e, t) {
    const n = y.fromJSON(e.sourcePosition, t), s = y.fromJSON(e.targetPosition, t);
    return new this(n, e.howMany, s, e.baseVersion);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class _e extends $e {
  /**
   * Creates an insert operation.
   *
   * @param position Position of insertion.
   * @param nodes The list of nodes to be inserted.
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  constructor(e, t, n) {
    super(n), this.position = e.clone(), this.position.stickiness = "toNone", this.nodes = new Fi(Qm(t)), this.shouldReceiveAttributes = !1;
  }
  /**
   * @inheritDoc
   */
  get type() {
    return "insert";
  }
  /**
   * Total offset size of inserted nodes.
   */
  get howMany() {
    return this.nodes.maxOffset;
  }
  /**
   * @inheritDoc
   */
  get affectedSelectable() {
    return this.position.clone();
  }
  /**
   * Creates and returns an operation that has the same parameters as this operation.
   */
  clone() {
    const e = new Fi([...this.nodes].map((n) => n._clone(!0))), t = new _e(this.position, e, this.baseVersion);
    return t.shouldReceiveAttributes = this.shouldReceiveAttributes, t;
  }
  /**
   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
   */
  getReversed() {
    const e = this.position.root.document.graveyard, t = new y(e, [0]);
    return new H(this.position, this.nodes.maxOffset, t, this.baseVersion + 1);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _validate() {
    const e = this.position.parent;
    if (!e || e.maxOffset < this.position.offset)
      throw new g("insert-operation-position-invalid", this);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _execute() {
    const e = this.nodes;
    this.nodes = new Fi([...e].map((t) => t._clone(!0))), vl(this.position, e);
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    const e = super.toJSON();
    return e.position = this.position.toJSON(), e.nodes = this.nodes.toJSON(), e;
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "InsertOperation";
  }
  /**
   * Creates `InsertOperation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(e, t) {
    const n = [];
    for (const o of e.nodes)
      o.name ? n.push($.fromJSON(o)) : n.push(j.fromJSON(o));
    const s = new _e(y.fromJSON(e.position, t), n, e.baseVersion);
    return s.shouldReceiveAttributes = e.shouldReceiveAttributes, s;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class K extends $e {
  /**
   * Creates a split operation.
   *
   * @param splitPosition Position at which an element should be split.
   * @param howMany Total offset size of elements that are in the split element after `position`.
   * @param insertionPosition Position at which the clone of split element (or element from graveyard) will be inserted.
   * @param graveyardPosition Position in the graveyard root before the element which
   * should be used as a parent of the nodes after `position`. If it is not set, a copy of the the `position` parent will be used.
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  constructor(e, t, n, s, o) {
    super(o), this.splitPosition = e.clone(), this.splitPosition.stickiness = "toNext", this.howMany = t, this.insertionPosition = n, this.graveyardPosition = s ? s.clone() : null, this.graveyardPosition && (this.graveyardPosition.stickiness = "toNext");
  }
  /**
   * @inheritDoc
   */
  get type() {
    return "split";
  }
  /**
   * Position inside the new clone of a split element.
   *
   * This is a position where nodes that are after the split position will be moved to.
   */
  get moveTargetPosition() {
    const e = this.insertionPosition.path.slice();
    return e.push(0), new y(this.insertionPosition.root, e);
  }
  /**
   * Artificial range that contains all the nodes from the split element that will be moved to the new element.
   * The range starts at {@link #splitPosition} and ends in the same parent, at `POSITIVE_INFINITY` offset.
   */
  get movedRange() {
    const e = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
    return new _(this.splitPosition, e);
  }
  /**
   * @inheritDoc
   */
  get affectedSelectable() {
    const e = [
      _._createFromPositionAndShift(this.splitPosition, 0),
      _._createFromPositionAndShift(this.insertionPosition, 0)
    ];
    return this.graveyardPosition && e.push(_._createFromPositionAndShift(this.graveyardPosition, 0)), e;
  }
  /**
   * Creates and returns an operation that has the same parameters as this operation.
   *
   * @returns Clone of this operation.
   */
  clone() {
    return new K(this.splitPosition, this.howMany, this.insertionPosition, this.graveyardPosition, this.baseVersion);
  }
  /**
   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
   */
  getReversed() {
    const e = this.splitPosition.root.document.graveyard, t = new y(e, [0]);
    return new oe(this.moveTargetPosition, this.howMany, this.splitPosition, t, this.baseVersion + 1);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _validate() {
    const e = this.splitPosition.parent, t = this.splitPosition.offset;
    if (!e || e.maxOffset < t)
      throw new g("split-operation-position-invalid", this);
    if (e.parent) {
      if (this.howMany != e.maxOffset - this.splitPosition.offset)
        throw new g("split-operation-how-many-invalid", this);
      if (this.graveyardPosition && !this.graveyardPosition.nodeAfter)
        throw new g("split-operation-graveyard-position-invalid", this);
    } else throw new g("split-operation-split-in-root", this);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _execute() {
    const e = this.splitPosition.parent;
    if (this.graveyardPosition)
      es(_._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);
    else {
      const n = e._clone();
      vl(this.insertionPosition, n);
    }
    const t = new _(y._createAt(e, this.splitPosition.offset), y._createAt(e, e.maxOffset));
    es(t, this.moveTargetPosition);
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    const e = super.toJSON();
    return e.splitPosition = this.splitPosition.toJSON(), e.insertionPosition = this.insertionPosition.toJSON(), this.graveyardPosition && (e.graveyardPosition = this.graveyardPosition.toJSON()), e;
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "SplitOperation";
  }
  /**
   * Helper function that returns a default insertion position basing on given `splitPosition`. The default insertion
   * position is after the split element.
   */
  static getInsertionPosition(e) {
    const t = e.path.slice(0, -1);
    return t[t.length - 1]++, new y(e.root, t, "toPrevious");
  }
  /**
   * Creates `SplitOperation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(e, t) {
    const n = y.fromJSON(e.splitPosition, t), s = y.fromJSON(e.insertionPosition, t), o = e.graveyardPosition ? y.fromJSON(e.graveyardPosition, t) : null;
    return new this(n, e.howMany, s, o, e.baseVersion);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class oe extends $e {
  /**
   * Creates a merge operation.
   *
   * @param sourcePosition Position inside the merged element. All nodes from that
   * element after that position will be moved to {@link #targetPosition}.
   * @param howMany Summary offset size of nodes which will be moved from the merged element to the new parent.
   * @param targetPosition Position which the nodes from the merged elements will be moved to.
   * @param graveyardPosition Position in graveyard to which the merged element will be moved.
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  constructor(e, t, n, s, o) {
    super(o), this.sourcePosition = e.clone(), this.sourcePosition.stickiness = "toPrevious", this.howMany = t, this.targetPosition = n.clone(), this.targetPosition.stickiness = "toNext", this.graveyardPosition = s.clone();
  }
  /**
   * @inheritDoc
   */
  get type() {
    return "merge";
  }
  /**
   * Position before the merged element (which will be deleted).
   */
  get deletionPosition() {
    return new y(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1));
  }
  /**
   * Artificial range that contains all the nodes from the merged element that will be moved to {@link ~MergeOperation#sourcePosition}.
   * The range starts at {@link ~MergeOperation#sourcePosition} and ends in the same parent, at `POSITIVE_INFINITY` offset.
   */
  get movedRange() {
    const e = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
    return new _(this.sourcePosition, e);
  }
  /**
   * @inheritDoc
   */
  get affectedSelectable() {
    const e = this.sourcePosition.parent;
    return [
      _._createOn(e),
      // These could be positions but `Selectable` type only supports `Iterable<Range>`.
      _._createFromPositionAndShift(this.targetPosition, 0),
      _._createFromPositionAndShift(this.graveyardPosition, 0)
    ];
  }
  /**
   * Creates and returns an operation that has the same parameters as this operation.
   */
  clone() {
    return new oe(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion);
  }
  /**
   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
   */
  getReversed() {
    const e = this.targetPosition._getTransformedByMergeOperation(this), t = this.sourcePosition.path.slice(0, -1), n = new y(this.sourcePosition.root, t)._getTransformedByMergeOperation(this);
    return new K(e, this.howMany, n, this.graveyardPosition, this.baseVersion + 1);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _validate() {
    const e = this.sourcePosition.parent, t = this.targetPosition.parent;
    if (e.parent)
      if (t.parent) {
        if (this.howMany != e.maxOffset)
          throw new g("merge-operation-how-many-invalid", this);
      } else throw new g("merge-operation-target-position-invalid", this);
    else throw new g("merge-operation-source-position-invalid", this);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _execute() {
    const e = this.sourcePosition.parent, t = _._createIn(e);
    es(t, this.targetPosition), es(_._createOn(e), this.graveyardPosition);
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    const e = super.toJSON();
    return e.sourcePosition = e.sourcePosition.toJSON(), e.targetPosition = e.targetPosition.toJSON(), e.graveyardPosition = e.graveyardPosition.toJSON(), e;
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "MergeOperation";
  }
  /**
   * Creates `MergeOperation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(e, t) {
    const n = y.fromJSON(e.sourcePosition, t), s = y.fromJSON(e.targetPosition, t), o = y.fromJSON(e.graveyardPosition, t);
    return new this(n, e.howMany, s, o, e.baseVersion);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Re extends $e {
  /**
   * @param name Marker name.
   * @param oldRange Marker range before the change.
   * @param newRange Marker range after the change.
   * @param markers Marker collection on which change should be executed.
   * @param affectsData Specifies whether the marker operation affects the data produced by the data pipeline
   * (is persisted in the editor's data).
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  constructor(e, t, n, s, o, r) {
    super(r), this.name = e, this.oldRange = t ? t.clone() : null, this.newRange = n ? n.clone() : null, this.affectsData = o, this._markers = s;
  }
  /**
   * @inheritDoc
   */
  get type() {
    return "marker";
  }
  /**
   * @inheritDoc
   */
  get affectedSelectable() {
    const e = [];
    return this.oldRange && e.push(this.oldRange.clone()), this.newRange && (this.oldRange ? e.push(...this.newRange.getDifference(this.oldRange)) : e.push(this.newRange.clone())), e;
  }
  /**
   * Creates and returns an operation that has the same parameters as this operation.
   */
  clone() {
    return new Re(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion);
  }
  /**
   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
   */
  getReversed() {
    return new Re(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _execute() {
    this.newRange ? this._markers._set(this.name, this.newRange, !0, this.affectsData) : this._markers._remove(this.name);
  }
  /**
   * @inheritDoc
   * @internal
   */
  toJSON() {
    const e = super.toJSON();
    return this.oldRange && (e.oldRange = this.oldRange.toJSON()), this.newRange && (e.newRange = this.newRange.toJSON()), delete e._markers, e;
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "MarkerOperation";
  }
  /**
   * Creates `MarkerOperation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(e, t) {
    return new Re(e.name, e.oldRange ? _.fromJSON(e.oldRange, t) : null, e.newRange ? _.fromJSON(e.newRange, t) : null, t.model.markers, e.affectsData, e.baseVersion);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class le extends $e {
  /**
   * Creates an operation that changes, removes or adds attributes.
   *
   * If only `newValue` is set, attribute will be added on a node. Note that all nodes in operation's range must not
   * have an attribute with the same key as the added attribute.
   *
   * If only `oldValue` is set, then attribute with given key will be removed. Note that all nodes in operation's range
   * must have an attribute with that key added.
   *
   * If both `newValue` and `oldValue` are set, then the operation will change the attribute value. Note that all nodes in
   * operation's ranges must already have an attribute with given key and `oldValue` as value
   *
   * @param range Range on which the operation should be applied. Must be a flat range.
   * @param key Key of an attribute to change or remove.
   * @param oldValue Old value of the attribute with given key or `null`, if attribute was not set before.
   * @param newValue New value of the attribute with given key or `null`, if operation should remove attribute.
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  constructor(e, t, n, s, o) {
    super(o), this.range = e.clone(), this.key = t, this.oldValue = n === void 0 ? null : n, this.newValue = s === void 0 ? null : s;
  }
  /**
   * @inheritDoc
   */
  get type() {
    return this.oldValue === null ? "addAttribute" : this.newValue === null ? "removeAttribute" : "changeAttribute";
  }
  /**
   * @inheritDoc
   */
  get affectedSelectable() {
    return this.range.clone();
  }
  /**
   * Creates and returns an operation that has the same parameters as this operation.
   */
  clone() {
    return new le(this.range, this.key, this.oldValue, this.newValue, this.baseVersion);
  }
  /**
   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
   */
  getReversed() {
    return new le(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    const e = super.toJSON();
    return e.range = this.range.toJSON(), e;
  }
  /**
   * @inheritDoc
   * @internal
   */
  _validate() {
    if (!this.range.isFlat)
      throw new g("attribute-operation-range-not-flat", this);
    for (const e of this.range.getItems({ shallow: !0 })) {
      if (this.oldValue !== null && !wo(e.getAttribute(this.key), this.oldValue))
        throw new g("attribute-operation-wrong-old-value", this, { item: e, key: this.key, value: this.oldValue });
      if (this.oldValue === null && this.newValue !== null && e.hasAttribute(this.key))
        throw new g("attribute-operation-attribute-exists", this, { node: e, key: this.key });
    }
  }
  /**
   * @inheritDoc
   * @internal
   */
  _execute() {
    wo(this.oldValue, this.newValue) || P2(this.range, this.key, this.newValue);
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "AttributeOperation";
  }
  /**
   * Creates `AttributeOperation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(e, t) {
    return new le(_.fromJSON(e.range, t), e.key, e.oldValue, e.newValue, e.baseVersion);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class he extends $e {
  get type() {
    return "noop";
  }
  /**
   * @inheritDoc
   */
  get affectedSelectable() {
    return null;
  }
  /**
   * Creates and returns an operation that has the same parameters as this operation.
   */
  clone() {
    return new he(this.baseVersion);
  }
  /**
   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
   */
  getReversed() {
    return new he(this.baseVersion + 1);
  }
  /** @internal */
  _execute() {
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "NoOperation";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Ve extends $e {
  /**
   * Creates an operation that changes element's name.
   *
   * @param position Position before an element to change.
   * @param oldName Current name of the element.
   * @param newName New name for the element.
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  constructor(e, t, n, s) {
    super(s), this.position = e, this.position.stickiness = "toNext", this.oldName = t, this.newName = n;
  }
  /**
   * @inheritDoc
   */
  get type() {
    return "rename";
  }
  /**
   * @inheritDoc
   */
  get affectedSelectable() {
    return this.position.nodeAfter;
  }
  /**
   * Creates and returns an operation that has the same parameters as this operation.
   *
   * @returns Clone of this operation.
   */
  clone() {
    return new Ve(this.position.clone(), this.oldName, this.newName, this.baseVersion);
  }
  /**
   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
   */
  getReversed() {
    return new Ve(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _validate() {
    const e = this.position.nodeAfter;
    if (e instanceof $) {
      if (e.name !== this.oldName)
        throw new g("rename-operation-wrong-name", this);
    } else throw new g("rename-operation-wrong-position", this);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _execute() {
    const e = this.position.nodeAfter;
    e.name = this.newName;
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    const e = super.toJSON();
    return e.position = this.position.toJSON(), e;
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "RenameOperation";
  }
  /**
   * Creates `RenameOperation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(e, t) {
    return new Ve(y.fromJSON(e.position, t), e.oldName, e.newName, e.baseVersion);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class It extends $e {
  /**
   * Creates an operation that changes, removes or adds attributes on root element.
   *
   * @see module:engine/model/operation/attributeoperation~AttributeOperation
   * @param root Root element to change.
   * @param key Key of an attribute to change or remove.
   * @param oldValue Old value of the attribute with given key or `null`, if attribute was not set before.
   * @param newValue New value of the attribute with given key or `null`, if operation should remove attribute.
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  constructor(e, t, n, s, o) {
    super(o), this.root = e, this.key = t, this.oldValue = n === void 0 ? null : n, this.newValue = s === void 0 ? null : s;
  }
  /**
   * @inheritDoc
   */
  get type() {
    return this.oldValue === null ? "addRootAttribute" : this.newValue === null ? "removeRootAttribute" : "changeRootAttribute";
  }
  /**
   * @inheritDoc
   */
  get affectedSelectable() {
    return this.root;
  }
  /**
   * Creates and returns an operation that has the same parameters as this operation.
   *
   * @returns Clone of this operation.
   */
  clone() {
    return new It(this.root, this.key, this.oldValue, this.newValue, this.baseVersion);
  }
  /**
   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
   */
  getReversed() {
    return new It(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _validate() {
    if (this.root != this.root.root || this.root.is("documentFragment"))
      throw new g("rootattribute-operation-not-a-root", this, { root: this.root, key: this.key });
    if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue)
      throw new g("rootattribute-operation-wrong-old-value", this, { root: this.root, key: this.key });
    if (this.oldValue === null && this.newValue !== null && this.root.hasAttribute(this.key))
      throw new g("rootattribute-operation-attribute-exists", this, { root: this.root, key: this.key });
  }
  /**
   * @inheritDoc
   * @internal
   */
  _execute() {
    this.newValue !== null ? this.root._setAttribute(this.key, this.newValue) : this.root._removeAttribute(this.key);
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    const e = super.toJSON();
    return e.root = this.root.toJSON(), e;
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "RootAttributeOperation";
  }
  /**
   * Creates `RootAttributeOperation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(e, t) {
    if (!t.getRoot(e.root))
      throw new g("rootattribute-operation-fromjson-no-root", this, { rootName: e.root });
    return new It(t.getRoot(e.root), e.key, e.oldValue, e.newValue, e.baseVersion);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class mt extends $e {
  /**
   * Creates an operation that creates or removes a root element.
   *
   * @param rootName Root name to create or detach.
   * @param elementName Root element name.
   * @param isAdd Specifies whether the operation adds (`true`) or detaches the root (`false`).
   * @param document Document which owns the root.
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation can be applied.
   */
  constructor(e, t, n, s, o) {
    if (super(o), this.rootName = e, this.elementName = t, this.isAdd = n, this._document = s, !this._document.getRoot(this.rootName)) {
      const r = this._document.createRoot(this.elementName, this.rootName);
      r._isAttached = !1;
    }
  }
  /**
   * @inheritDoc
   */
  get type() {
    return this.isAdd ? "addRoot" : "detachRoot";
  }
  /**
   * @inheritDoc
   */
  get affectedSelectable() {
    return this._document.getRoot(this.rootName);
  }
  /**
   * @inheritDoc
   */
  clone() {
    return new mt(this.rootName, this.elementName, this.isAdd, this._document, this.baseVersion);
  }
  /**
   * @inheritDoc
   */
  getReversed() {
    return new mt(this.rootName, this.elementName, !this.isAdd, this._document, this.baseVersion + 1);
  }
  /**
   * @inheritDoc
   */
  _execute() {
    this._document.getRoot(this.rootName)._isAttached = this.isAdd;
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    const e = super.toJSON();
    return delete e._document, e;
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "RootOperation";
  }
  /**
   * Creates `RootOperation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(e, t) {
    return new mt(e.rootName, e.elementName, e.isAdd, t, e.baseVersion);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Xe = {};
Xe[le.className] = le;
Xe[_e.className] = _e;
Xe[Re.className] = Re;
Xe[H.className] = H;
Xe[he.className] = he;
Xe[$e.className] = $e;
Xe[Ve.className] = Ve;
Xe[It.className] = It;
Xe[mt.className] = mt;
Xe[K.className] = K;
Xe[oe.className] = oe;
class R2 {
  /**
   * Creates an operation instance from a JSON object (parsed JSON string).
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(e, t) {
    return Xe[e.__className].fromJSON(e, t);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const ga = /* @__PURE__ */ new Map();
function z(i, e, t) {
  let n = ga.get(i);
  n || (n = /* @__PURE__ */ new Map(), ga.set(i, n)), n.set(e, t);
}
function V2(i, e) {
  const t = ga.get(i);
  return t && t.has(e) ? t.get(e) : M2;
}
function M2(i) {
  return [i];
}
function yu(i, e, t = {}) {
  const n = V2(i.constructor, e.constructor);
  try {
    return i = i.clone(), n(i, e, t);
  } catch (s) {
    throw s;
  }
}
function B2(i, e, t) {
  i = i.slice(), e = e.slice();
  const n = new L2(t.document, t.useRelations, t.forceWeakRemove);
  n.setOriginalOperations(i), n.setOriginalOperations(e);
  const s = n.originalOperations;
  if (i.length == 0 || e.length == 0)
    return { operationsA: i, operationsB: e, originalOperations: s };
  const o = /* @__PURE__ */ new WeakMap();
  for (const l of i)
    o.set(l, 0);
  const r = {
    nextBaseVersionA: i[i.length - 1].baseVersion + 1,
    nextBaseVersionB: e[e.length - 1].baseVersion + 1,
    originalOperationsACount: i.length,
    originalOperationsBCount: e.length
  };
  let a = 0;
  for (; a < i.length; ) {
    const l = i[a], c = o.get(l);
    if (c == e.length) {
      a++;
      continue;
    }
    const u = e[c], d = yu(l, u, n.getContext(l, u, !0)), h = yu(u, l, n.getContext(u, l, !1));
    n.updateRelation(l, u), n.setOriginalOperations(d, l), n.setOriginalOperations(h, u);
    for (const f of d)
      o.set(f, c + h.length);
    i.splice(a, 1, ...d), e.splice(c, 1, ...h);
  }
  return Cu(i, r.nextBaseVersionB), Cu(e, r.nextBaseVersionA), { operationsA: i, operationsB: e, originalOperations: s };
}
class L2 {
  /**
   * Creates `ContextFactory` instance.
   *
   * @param document Document which the operations change.
   * @param useRelations Whether during transformation relations should be used (used during undo for
   * better conflict resolution).
   * @param forceWeakRemove If set to `false`, remove operation will be always stronger than move operation,
   * so the removed nodes won't end up back in the document root. When set to `true`, context data will be used.
   */
  constructor(e, t, n = !1) {
    this.originalOperations = /* @__PURE__ */ new Map(), this._history = e.history, this._useRelations = t, this._forceWeakRemove = !!n, this._relations = /* @__PURE__ */ new Map();
  }
  /**
   * Sets "original operation" for given operations.
   *
   * During transformation process, operations are cloned, then changed, then processed again, sometimes broken into two
   * or multiple operations. When gathering additional data it is important that all operations can be somehow linked
   * so a cloned and transformed "version" still kept track of the data assigned earlier to it.
   *
   * The original operation object will be used as such an universal linking id. Throughout the transformation process
   * all cloned operations will refer to "the original operation" when storing and reading additional data.
   *
   * If `takeFrom` is not set, each operation from `operations` array will be assigned itself as "the original operation".
   * This should be used as an initialization step.
   *
   * If `takeFrom` is set, each operation from `operations` will be assigned the same original operation as assigned
   * for `takeFrom` operation. This should be used to update original operations. It should be used in a way that
   * `operations` are the result of `takeFrom` transformation to ensure proper "original operation propagation".
   */
  setOriginalOperations(e, t = null) {
    const n = t ? this.originalOperations.get(t) : null;
    for (const s of e)
      this.originalOperations.set(s, n || s);
  }
  /**
   * Saves a relation between operations `opA` and `opB`.
   *
   * Relations are then later used to help solve conflicts when operations are transformed.
   */
  updateRelation(e, t) {
    if (e instanceof H)
      t instanceof oe ? e.targetPosition.isEqual(t.sourcePosition) || t.movedRange.containsPosition(e.targetPosition) ? this._setRelation(e, t, "insertAtSource") : e.targetPosition.isEqual(t.deletionPosition) ? this._setRelation(e, t, "insertBetween") : e.targetPosition.isAfter(t.sourcePosition) && this._setRelation(e, t, "moveTargetAfter") : t instanceof H && (e.targetPosition.isEqual(t.sourcePosition) || e.targetPosition.isBefore(t.sourcePosition) ? this._setRelation(e, t, "insertBefore") : this._setRelation(e, t, "insertAfter"));
    else if (e instanceof K) {
      if (t instanceof oe)
        e.splitPosition.isBefore(t.sourcePosition) && this._setRelation(e, t, "splitBefore");
      else if (t instanceof H)
        if (e.splitPosition.isEqual(t.sourcePosition) || e.splitPosition.isBefore(t.sourcePosition))
          this._setRelation(e, t, "splitBefore");
        else {
          const n = _._createFromPositionAndShift(t.sourcePosition, t.howMany);
          if (e.splitPosition.hasSameParentAs(t.sourcePosition) && n.containsPosition(e.splitPosition)) {
            const s = n.end.offset - e.splitPosition.offset, o = e.splitPosition.offset - n.start.offset;
            this._setRelation(e, t, { howMany: s, offset: o });
          }
        }
    } else if (e instanceof oe)
      t instanceof oe ? (e.targetPosition.isEqual(t.sourcePosition) || this._setRelation(e, t, "mergeTargetNotMoved"), e.sourcePosition.isEqual(t.targetPosition) && this._setRelation(e, t, "mergeSourceNotMoved"), e.sourcePosition.isEqual(t.sourcePosition) && this._setRelation(e, t, "mergeSameElement")) : t instanceof K ? e.sourcePosition.isEqual(t.splitPosition) && this._setRelation(e, t, "splitAtSource") : t instanceof H && t.howMany > 0 && (e.sourcePosition.isEqual(t.sourcePosition.getShiftedBy(t.howMany)) && this._setRelation(e, t, "mergeSourceAffected"), e.targetPosition.isEqual(t.sourcePosition) && this._setRelation(e, t, "mergeTargetWasBefore"));
    else if (e instanceof Re) {
      const n = e.newRange;
      if (!n)
        return;
      if (t instanceof H) {
        const s = _._createFromPositionAndShift(t.sourcePosition, t.howMany), o = s.containsPosition(n.start) || s.start.isEqual(n.start), r = s.containsPosition(n.end) || s.end.isEqual(n.end);
        (o || r) && !s.containsRange(n) && this._setRelation(e, t, {
          side: o ? "left" : "right",
          path: o ? n.start.path.slice() : n.end.path.slice()
        });
      } else if (t instanceof oe) {
        const s = n.start.isEqual(t.targetPosition), o = n.start.isEqual(t.deletionPosition), r = n.end.isEqual(t.deletionPosition), a = n.end.isEqual(t.sourcePosition);
        (s || o || r || a) && this._setRelation(e, t, {
          wasInLeftElement: s,
          wasStartBeforeMergedElement: o,
          wasEndBeforeMergedElement: r,
          wasInRightElement: a
        });
      }
    }
  }
  /**
   * Evaluates and returns contextual information about two given operations `opA` and `opB` which are about to be transformed.
   */
  getContext(e, t, n) {
    return {
      aIsStrong: n,
      aWasUndone: this._wasUndone(e),
      bWasUndone: this._wasUndone(t),
      abRelation: this._useRelations ? this._getRelation(e, t) : null,
      baRelation: this._useRelations ? this._getRelation(t, e) : null,
      forceWeakRemove: this._forceWeakRemove
    };
  }
  /**
   * Returns whether given operation `op` has already been undone.
   *
   * Information whether an operation was undone gives more context when making a decision when two operations are in conflict.
   */
  _wasUndone(e) {
    const t = this.originalOperations.get(e);
    return t.wasUndone || this._history.isUndoneOperation(t);
  }
  /**
   * Returns a relation between `opA` and an operation which is undone by `opB`. This can be `String` value if a relation
   * was set earlier or `null` if there was no relation between those operations.
   *
   * This is a little tricky to understand, so let's compare it to `ContextFactory#_wasUndone`.
   *
   * When `wasUndone( opB )` is used, we check if the `opB` has already been undone. It is obvious, that the
   * undoing operation must happen after the undone operation. So, essentially, we have `opB`, we take document history,
   * we look forward in the future and ask if in that future `opB` was undone.
   *
   * Relations is a backward process to `wasUndone()`.
   *
   * Long story short - using relations is asking what happened in the past. Looking back. This time we have an undoing
   * operation `opB` which has undone some other operation. When there is a transformation `opA` x `opB` and there is
   * a conflict to solve and `opB` is an undoing operation, we can look back in the history and see what was a relation
   * between `opA` and the operation which `opB` undone. Basing on that relation from the past, we can now make
   * a better decision when resolving a conflict between two operations, because we know more about the context of
   * those two operations.
   *
   * This is why this function does not return a relation directly between `opA` and `opB` because we need to look
   * back to search for a meaningful contextual information.
   */
  _getRelation(e, t) {
    const n = this.originalOperations.get(t), s = this._history.getUndoneOperation(n);
    if (!s)
      return null;
    const o = this.originalOperations.get(e), r = this._relations.get(o);
    return r && r.get(s) || null;
  }
  /**
   * Helper function for `ContextFactory#updateRelations`.
   */
  _setRelation(e, t, n) {
    const s = this.originalOperations.get(e), o = this.originalOperations.get(t);
    let r = this._relations.get(s);
    r || (r = /* @__PURE__ */ new Map(), this._relations.set(s, r)), r.set(o, n);
  }
}
function Cu(i, e) {
  for (const t of i)
    t.baseVersion = e++;
}
z(le, le, (i, e, t) => {
  if (i.key === e.key && i.range.start.hasSameParentAs(e.range.start)) {
    const n = i.range.getDifference(e.range).map((o) => new le(o, i.key, i.oldValue, i.newValue, 0)), s = i.range.getIntersection(e.range);
    return s && t.aIsStrong && n.push(new le(s, e.key, e.newValue, i.newValue, 0)), n.length == 0 ? [new he(0)] : n;
  } else
    return [i];
});
z(le, _e, (i, e) => {
  if (i.range.start.hasSameParentAs(e.position) && i.range.containsPosition(e.position)) {
    const n = i.range._getTransformedByInsertion(e.position, e.howMany, !e.shouldReceiveAttributes).map((s) => new le(s, i.key, i.oldValue, i.newValue, i.baseVersion));
    if (e.shouldReceiveAttributes) {
      const s = eg(e, i.key, i.oldValue);
      s && n.unshift(s);
    }
    return n;
  }
  return i.range = i.range._getTransformedByInsertion(e.position, e.howMany, !1)[0], [i];
});
function eg(i, e, t) {
  const s = i.nodes.getNode(0).getAttribute(e);
  if (s == t)
    return null;
  const o = new _(i.position, i.position.getShiftedBy(i.howMany));
  return new le(o, e, s, t, 0);
}
z(le, oe, (i, e) => {
  const t = [];
  i.range.start.hasSameParentAs(e.deletionPosition) && (i.range.containsPosition(e.deletionPosition) || i.range.start.isEqual(e.deletionPosition)) && t.push(_._createFromPositionAndShift(e.graveyardPosition, 1));
  const n = i.range._getTransformedByMergeOperation(e);
  return n.isCollapsed || t.push(n), t.map((s) => new le(s, i.key, i.oldValue, i.newValue, i.baseVersion));
});
z(le, H, (i, e) => O2(i.range, e).map((n) => new le(n, i.key, i.oldValue, i.newValue, i.baseVersion)));
function O2(i, e) {
  const t = _._createFromPositionAndShift(e.sourcePosition, e.howMany);
  let n = null, s = [];
  t.containsRange(i, !0) ? n = i : i.start.hasSameParentAs(t.start) ? (s = i.getDifference(t), n = i.getIntersection(t)) : s = [i];
  const o = [];
  for (let r of s) {
    r = r._getTransformedByDeletion(e.sourcePosition, e.howMany);
    const a = e.getMovedRangeStart(), l = r.start.hasSameParentAs(a), c = r._getTransformedByInsertion(a, e.howMany, l);
    o.push(...c);
  }
  return n && o.push(n._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany, !1)[0]), o;
}
z(le, K, (i, e) => {
  if (i.range.end.isEqual(e.insertionPosition))
    return e.graveyardPosition || i.range.end.offset++, [i];
  if (i.range.start.hasSameParentAs(e.splitPosition) && i.range.containsPosition(e.splitPosition)) {
    const t = i.clone();
    return t.range = new _(e.moveTargetPosition.clone(), i.range.end._getCombined(e.splitPosition, e.moveTargetPosition)), i.range.end = e.splitPosition.clone(), i.range.end.stickiness = "toPrevious", [i, t];
  }
  return i.range = i.range._getTransformedBySplitOperation(e), [i];
});
z(_e, le, (i, e) => {
  const t = [i];
  if (i.shouldReceiveAttributes && i.position.hasSameParentAs(e.range.start) && e.range.containsPosition(i.position)) {
    const n = eg(i, e.key, e.newValue);
    n && t.push(n);
  }
  return t;
});
z(_e, _e, (i, e, t) => i.position.isEqual(e.position) && t.aIsStrong ? [i] : (i.position = i.position._getTransformedByInsertOperation(e), [i]));
z(_e, H, (i, e) => (i.position = i.position._getTransformedByMoveOperation(e), [i]));
z(_e, K, (i, e) => (i.position = i.position._getTransformedBySplitOperation(e), [i]));
z(_e, oe, (i, e) => (i.position = i.position._getTransformedByMergeOperation(e), [i]));
z(Re, _e, (i, e) => (i.oldRange && (i.oldRange = i.oldRange._getTransformedByInsertOperation(e)[0]), i.newRange && (i.newRange = i.newRange._getTransformedByInsertOperation(e)[0]), [i]));
z(Re, Re, (i, e, t) => {
  if (i.name == e.name)
    if (t.aIsStrong)
      i.oldRange = e.newRange ? e.newRange.clone() : null;
    else
      return [new he(0)];
  return [i];
});
z(Re, oe, (i, e) => (i.oldRange && (i.oldRange = i.oldRange._getTransformedByMergeOperation(e)), i.newRange && (i.newRange = i.newRange._getTransformedByMergeOperation(e)), [i]));
z(Re, H, (i, e, t) => {
  if (i.oldRange && (i.oldRange = _._createFromRanges(i.oldRange._getTransformedByMoveOperation(e))), i.newRange) {
    if (t.abRelation) {
      const n = _._createFromRanges(i.newRange._getTransformedByMoveOperation(e));
      if (t.abRelation.side == "left" && e.targetPosition.isEqual(i.newRange.start))
        return i.newRange.end = n.end, i.newRange.start.path = t.abRelation.path, [i];
      if (t.abRelation.side == "right" && e.targetPosition.isEqual(i.newRange.end))
        return i.newRange.start = n.start, i.newRange.end.path = t.abRelation.path, [i];
    }
    i.newRange = _._createFromRanges(i.newRange._getTransformedByMoveOperation(e));
  }
  return [i];
});
z(Re, K, (i, e, t) => {
  if (i.oldRange && (i.oldRange = i.oldRange._getTransformedBySplitOperation(e)), i.newRange) {
    if (t.abRelation) {
      const n = i.newRange._getTransformedBySplitOperation(e);
      return i.newRange.start.isEqual(e.splitPosition) && t.abRelation.wasStartBeforeMergedElement ? i.newRange.start = y._createAt(e.insertionPosition) : i.newRange.start.isEqual(e.splitPosition) && !t.abRelation.wasInLeftElement && (i.newRange.start = y._createAt(e.moveTargetPosition)), i.newRange.end.isEqual(e.splitPosition) && t.abRelation.wasInRightElement ? i.newRange.end = y._createAt(e.moveTargetPosition) : i.newRange.end.isEqual(e.splitPosition) && t.abRelation.wasEndBeforeMergedElement ? i.newRange.end = y._createAt(e.insertionPosition) : i.newRange.end = n.end, [i];
    }
    i.newRange = i.newRange._getTransformedBySplitOperation(e);
  }
  return [i];
});
z(oe, _e, (i, e) => (i.sourcePosition.hasSameParentAs(e.position) && (i.howMany += e.howMany), i.sourcePosition = i.sourcePosition._getTransformedByInsertOperation(e), i.targetPosition = i.targetPosition._getTransformedByInsertOperation(e), [i]));
z(oe, oe, (i, e, t) => {
  if (i.sourcePosition.isEqual(e.sourcePosition) && i.targetPosition.isEqual(e.targetPosition))
    if (t.bWasUndone) {
      const n = e.graveyardPosition.path.slice();
      return n.push(0), i.sourcePosition = new y(e.graveyardPosition.root, n), i.howMany = 0, [i];
    } else
      return [new he(0)];
  if (i.sourcePosition.isEqual(e.sourcePosition) && !i.targetPosition.isEqual(e.targetPosition) && !t.bWasUndone && t.abRelation != "splitAtSource") {
    const n = i.targetPosition.root.rootName == "$graveyard", s = e.targetPosition.root.rootName == "$graveyard";
    if (s && !n || !(n && !s) && t.aIsStrong) {
      const l = e.targetPosition._getTransformedByMergeOperation(e), c = i.targetPosition._getTransformedByMergeOperation(e);
      return [new H(l, i.howMany, c, 0)];
    } else
      return [new he(0)];
  }
  return i.sourcePosition.hasSameParentAs(e.targetPosition) && (i.howMany += e.howMany), i.sourcePosition = i.sourcePosition._getTransformedByMergeOperation(e), i.targetPosition = i.targetPosition._getTransformedByMergeOperation(e), (!i.graveyardPosition.isEqual(e.graveyardPosition) || !t.aIsStrong) && (i.graveyardPosition = i.graveyardPosition._getTransformedByMergeOperation(e)), [i];
});
z(oe, H, (i, e, t) => {
  const n = _._createFromPositionAndShift(e.sourcePosition, e.howMany);
  return e.type == "remove" && !t.bWasUndone && !t.forceWeakRemove && i.deletionPosition.hasSameParentAs(e.sourcePosition) && n.containsPosition(i.sourcePosition) ? [new he(0)] : (e.sourcePosition.getShiftedBy(e.howMany).isEqual(i.sourcePosition) ? i.sourcePosition.stickiness = "toNone" : e.targetPosition.isEqual(i.sourcePosition) && t.abRelation == "mergeSourceAffected" ? i.sourcePosition.stickiness = "toNext" : e.sourcePosition.isEqual(i.targetPosition) ? (i.targetPosition.stickiness = "toNone", i.howMany -= e.howMany) : e.targetPosition.isEqual(i.targetPosition) && t.abRelation == "mergeTargetWasBefore" ? (i.targetPosition.stickiness = "toPrevious", i.howMany += e.howMany) : (i.sourcePosition.hasSameParentAs(e.targetPosition) && (i.howMany += e.howMany), i.sourcePosition.hasSameParentAs(e.sourcePosition) && (i.howMany -= e.howMany)), i.sourcePosition = i.sourcePosition._getTransformedByMoveOperation(e), i.targetPosition = i.targetPosition._getTransformedByMoveOperation(e), i.sourcePosition.stickiness = "toPrevious", i.targetPosition.stickiness = "toNext", i.graveyardPosition.isEqual(e.targetPosition) || (i.graveyardPosition = i.graveyardPosition._getTransformedByMoveOperation(e)), [i]);
});
z(oe, K, (i, e, t) => {
  if (e.graveyardPosition && (i.graveyardPosition = i.graveyardPosition._getTransformedByDeletion(e.graveyardPosition, 1), i.deletionPosition.isEqual(e.graveyardPosition) && (i.howMany = e.howMany)), i.targetPosition.isEqual(e.splitPosition)) {
    const n = e.howMany != 0, s = e.graveyardPosition && i.deletionPosition.isEqual(e.graveyardPosition);
    if (n || s || t.abRelation == "mergeTargetNotMoved")
      return i.sourcePosition = i.sourcePosition._getTransformedBySplitOperation(e), [i];
  }
  if (i.sourcePosition.isEqual(e.splitPosition)) {
    if (t.abRelation == "mergeSourceNotMoved")
      return i.howMany = 0, i.targetPosition = i.targetPosition._getTransformedBySplitOperation(e), [i];
    if (t.abRelation == "mergeSameElement" || i.sourcePosition.offset > 0)
      return i.sourcePosition = e.moveTargetPosition.clone(), i.targetPosition = i.targetPosition._getTransformedBySplitOperation(e), [i];
  }
  return i.sourcePosition.hasSameParentAs(e.splitPosition) && (i.howMany = e.splitPosition.offset), i.sourcePosition = i.sourcePosition._getTransformedBySplitOperation(e), i.targetPosition = i.targetPosition._getTransformedBySplitOperation(e), [i];
});
z(H, _e, (i, e) => {
  const n = _._createFromPositionAndShift(i.sourcePosition, i.howMany)._getTransformedByInsertOperation(e, !1)[0];
  return i.sourcePosition = n.start, i.howMany = n.end.offset - n.start.offset, i.targetPosition.isEqual(e.position) || (i.targetPosition = i.targetPosition._getTransformedByInsertOperation(e)), [i];
});
z(H, H, (i, e, t) => {
  const n = _._createFromPositionAndShift(i.sourcePosition, i.howMany), s = _._createFromPositionAndShift(e.sourcePosition, e.howMany);
  let o = t.aIsStrong, r = !t.aIsStrong;
  t.abRelation == "insertBefore" || t.baRelation == "insertAfter" ? r = !0 : (t.abRelation == "insertAfter" || t.baRelation == "insertBefore") && (r = !1);
  let a;
  if (i.targetPosition.isEqual(e.targetPosition) && r ? a = i.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) : a = i.targetPosition._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), ku(i, e) && ku(e, i))
    return [e.getReversed()];
  if (n.containsPosition(e.targetPosition) && n.containsRange(s, !0))
    return n.start = n.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), n.end = n.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), jn([n], a);
  if (s.containsPosition(i.targetPosition) && s.containsRange(n, !0))
    return n.start = n.start._getCombined(e.sourcePosition, e.getMovedRangeStart()), n.end = n.end._getCombined(e.sourcePosition, e.getMovedRangeStart()), jn([n], a);
  const u = Ee(i.sourcePosition.getParentPath(), e.sourcePosition.getParentPath());
  if (u == "prefix" || u == "extension")
    return n.start = n.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), n.end = n.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), jn([n], a);
  i.type == "remove" && e.type != "remove" && !t.aWasUndone && !t.forceWeakRemove ? o = !0 : i.type != "remove" && e.type == "remove" && !t.bWasUndone && !t.forceWeakRemove && (o = !1);
  const d = [], h = n.getDifference(s);
  for (const m of h) {
    m.start = m.start._getTransformedByDeletion(e.sourcePosition, e.howMany), m.end = m.end._getTransformedByDeletion(e.sourcePosition, e.howMany);
    const p = Ee(m.start.getParentPath(), e.getMovedRangeStart().getParentPath()) == "same", w = m._getTransformedByInsertion(e.getMovedRangeStart(), e.howMany, p);
    d.push(...w);
  }
  const f = n.getIntersection(s);
  return f !== null && o && (f.start = f.start._getCombined(e.sourcePosition, e.getMovedRangeStart()), f.end = f.end._getCombined(e.sourcePosition, e.getMovedRangeStart()), d.length === 0 ? d.push(f) : d.length == 1 ? s.start.isBefore(n.start) || s.start.isEqual(n.start) ? d.unshift(f) : d.push(f) : d.splice(1, 0, f)), d.length === 0 ? [new he(i.baseVersion)] : jn(d, a);
});
z(H, K, (i, e, t) => {
  let n = i.targetPosition.clone();
  (!i.targetPosition.isEqual(e.insertionPosition) || !e.graveyardPosition || t.abRelation == "moveTargetAfter") && (n = i.targetPosition._getTransformedBySplitOperation(e));
  const s = _._createFromPositionAndShift(i.sourcePosition, i.howMany);
  if (s.end.isEqual(e.insertionPosition))
    return e.graveyardPosition || i.howMany++, i.targetPosition = n, [i];
  if (s.start.hasSameParentAs(e.splitPosition) && s.containsPosition(e.splitPosition)) {
    let a = new _(e.splitPosition, s.end);
    a = a._getTransformedBySplitOperation(e);
    const l = [
      new _(s.start, e.splitPosition),
      a
    ];
    return jn(l, n);
  }
  i.targetPosition.isEqual(e.splitPosition) && t.abRelation == "insertAtSource" && (n = e.moveTargetPosition), i.targetPosition.isEqual(e.insertionPosition) && t.abRelation == "insertBetween" && (n = i.targetPosition);
  const r = [s._getTransformedBySplitOperation(e)];
  if (e.graveyardPosition) {
    const a = s.start.isEqual(e.graveyardPosition) || s.containsPosition(e.graveyardPosition);
    i.howMany > 1 && a && !t.aWasUndone && r.push(_._createFromPositionAndShift(e.insertionPosition, 1));
  }
  return jn(r, n);
});
z(H, oe, (i, e, t) => {
  const n = _._createFromPositionAndShift(i.sourcePosition, i.howMany);
  if (e.deletionPosition.hasSameParentAs(i.sourcePosition) && n.containsPosition(e.sourcePosition)) {
    if (i.type == "remove" && !t.forceWeakRemove) {
      if (!t.aWasUndone) {
        const r = [];
        let a = e.graveyardPosition.clone(), l = e.targetPosition._getTransformedByMergeOperation(e);
        i.howMany > 1 && (r.push(new H(i.sourcePosition, i.howMany - 1, i.targetPosition, 0)), a = a._getTransformedByMove(i.sourcePosition, i.targetPosition, i.howMany - 1), l = l._getTransformedByMove(i.sourcePosition, i.targetPosition, i.howMany - 1));
        const c = e.deletionPosition._getCombined(i.sourcePosition, i.targetPosition), u = new H(a, 1, c, 0), d = u.getMovedRangeStart().path.slice();
        d.push(0);
        const h = new y(u.targetPosition.root, d);
        l = l._getTransformedByMove(a, c, 1);
        const f = new H(l, e.howMany, h, 0);
        return r.push(u), r.push(f), r;
      }
    } else if (i.howMany == 1)
      return t.bWasUndone ? (i.sourcePosition = e.graveyardPosition.clone(), i.targetPosition = i.targetPosition._getTransformedByMergeOperation(e), [i]) : [new he(0)];
  }
  const o = _._createFromPositionAndShift(i.sourcePosition, i.howMany)._getTransformedByMergeOperation(e);
  return i.sourcePosition = o.start, i.howMany = o.end.offset - o.start.offset, i.targetPosition = i.targetPosition._getTransformedByMergeOperation(e), [i];
});
z(Ve, _e, (i, e) => (i.position = i.position._getTransformedByInsertOperation(e), [i]));
z(Ve, oe, (i, e) => i.position.isEqual(e.deletionPosition) ? (i.position = e.graveyardPosition.clone(), i.position.stickiness = "toNext", [i]) : (i.position = i.position._getTransformedByMergeOperation(e), [i]));
z(Ve, H, (i, e) => (i.position = i.position._getTransformedByMoveOperation(e), [i]));
z(Ve, Ve, (i, e, t) => {
  if (i.position.isEqual(e.position))
    if (t.aIsStrong)
      i.oldName = e.newName;
    else
      return [new he(0)];
  return [i];
});
z(Ve, K, (i, e) => {
  const t = i.position.path, n = e.splitPosition.getParentPath();
  if (Ee(t, n) == "same" && !e.graveyardPosition) {
    const s = new Ve(i.position.getShiftedBy(1), i.oldName, i.newName, 0);
    return [i, s];
  }
  return i.position = i.position._getTransformedBySplitOperation(e), [i];
});
z(It, It, (i, e, t) => {
  if (i.root === e.root && i.key === e.key) {
    if (!t.aIsStrong || i.newValue === e.newValue)
      return [new he(0)];
    i.oldValue = e.newValue;
  }
  return [i];
});
z(mt, mt, (i, e) => i.rootName === e.rootName && i.isAdd === e.isAdd ? [new he(0)] : [i]);
z(K, _e, (i, e) => (i.splitPosition.hasSameParentAs(e.position) && i.splitPosition.offset < e.position.offset && (i.howMany += e.howMany), i.splitPosition = i.splitPosition._getTransformedByInsertOperation(e), i.insertionPosition = i.insertionPosition._getTransformedByInsertOperation(e), [i]));
z(K, oe, (i, e, t) => {
  if (!i.graveyardPosition && !t.bWasUndone && i.splitPosition.hasSameParentAs(e.sourcePosition)) {
    const n = e.graveyardPosition.path.slice();
    n.push(0);
    const s = new y(e.graveyardPosition.root, n), o = K.getInsertionPosition(new y(e.graveyardPosition.root, n)), r = new K(s, 0, o, null, 0);
    return i.splitPosition = i.splitPosition._getTransformedByMergeOperation(e), i.insertionPosition = K.getInsertionPosition(i.splitPosition), i.graveyardPosition = r.insertionPosition.clone(), i.graveyardPosition.stickiness = "toNext", [r, i];
  }
  return i.splitPosition.hasSameParentAs(e.deletionPosition) && !i.splitPosition.isAfter(e.deletionPosition) && i.howMany--, i.splitPosition.hasSameParentAs(e.targetPosition) && (i.howMany += e.howMany), i.splitPosition = i.splitPosition._getTransformedByMergeOperation(e), i.insertionPosition = K.getInsertionPosition(i.splitPosition), i.graveyardPosition && (i.graveyardPosition = i.graveyardPosition._getTransformedByMergeOperation(e)), [i];
});
z(K, H, (i, e, t) => {
  const n = _._createFromPositionAndShift(e.sourcePosition, e.howMany);
  if (i.graveyardPosition) {
    const o = n.start.isEqual(i.graveyardPosition) || n.containsPosition(i.graveyardPosition);
    if (!t.bWasUndone && o) {
      const r = i.splitPosition._getTransformedByMoveOperation(e), a = i.graveyardPosition._getTransformedByMoveOperation(e), l = a.path.slice();
      l.push(0);
      const c = new y(a.root, l);
      return [new H(r, i.howMany, c, 0)];
    }
    i.graveyardPosition = i.graveyardPosition._getTransformedByMoveOperation(e);
  }
  const s = i.splitPosition.isEqual(e.targetPosition);
  if (s && (t.baRelation == "insertAtSource" || t.abRelation == "splitBefore"))
    return i.howMany += e.howMany, i.splitPosition = i.splitPosition._getTransformedByDeletion(e.sourcePosition, e.howMany), i.insertionPosition = K.getInsertionPosition(i.splitPosition), [i];
  if (s && t.abRelation && t.abRelation.howMany) {
    const { howMany: o, offset: r } = t.abRelation;
    return i.howMany += o, i.splitPosition = i.splitPosition.getShiftedBy(r), [i];
  }
  if (i.splitPosition.hasSameParentAs(e.sourcePosition) && n.containsPosition(i.splitPosition)) {
    const o = e.howMany - (i.splitPosition.offset - e.sourcePosition.offset);
    return i.howMany -= o, i.splitPosition.hasSameParentAs(e.targetPosition) && i.splitPosition.offset < e.targetPosition.offset && (i.howMany += e.howMany), i.splitPosition = e.sourcePosition.clone(), i.insertionPosition = K.getInsertionPosition(i.splitPosition), [i];
  }
  return e.sourcePosition.isEqual(e.targetPosition) || (i.splitPosition.hasSameParentAs(e.sourcePosition) && i.splitPosition.offset <= e.sourcePosition.offset && (i.howMany -= e.howMany), i.splitPosition.hasSameParentAs(e.targetPosition) && i.splitPosition.offset < e.targetPosition.offset && (i.howMany += e.howMany)), i.splitPosition.stickiness = "toNone", i.splitPosition = i.splitPosition._getTransformedByMoveOperation(e), i.splitPosition.stickiness = "toNext", i.graveyardPosition ? i.insertionPosition = i.insertionPosition._getTransformedByMoveOperation(e) : i.insertionPosition = K.getInsertionPosition(i.splitPosition), [i];
});
z(K, K, (i, e, t) => {
  if (i.splitPosition.isEqual(e.splitPosition)) {
    if (!i.graveyardPosition && !e.graveyardPosition)
      return [new he(0)];
    if (i.graveyardPosition && e.graveyardPosition && i.graveyardPosition.isEqual(e.graveyardPosition))
      return [new he(0)];
    if (t.abRelation == "splitBefore")
      return i.howMany = 0, i.graveyardPosition = i.graveyardPosition._getTransformedBySplitOperation(e), [i];
  }
  if (i.graveyardPosition && e.graveyardPosition && i.graveyardPosition.isEqual(e.graveyardPosition)) {
    const n = i.splitPosition.root.rootName == "$graveyard", s = e.splitPosition.root.rootName == "$graveyard";
    if (s && !n || !(n && !s) && t.aIsStrong) {
      const l = [];
      return e.howMany && l.push(new H(e.moveTargetPosition, e.howMany, e.splitPosition, 0)), i.howMany && l.push(new H(i.splitPosition, i.howMany, i.moveTargetPosition, 0)), l;
    } else
      return [new he(0)];
  }
  if (i.graveyardPosition && (i.graveyardPosition = i.graveyardPosition._getTransformedBySplitOperation(e)), i.splitPosition.isEqual(e.insertionPosition) && t.abRelation == "splitBefore")
    return i.howMany++, [i];
  if (e.splitPosition.isEqual(i.insertionPosition) && t.baRelation == "splitBefore") {
    const n = e.insertionPosition.path.slice();
    n.push(0);
    const s = new y(e.insertionPosition.root, n), o = new H(i.insertionPosition, 1, s, 0);
    return [i, o];
  }
  return i.splitPosition.hasSameParentAs(e.splitPosition) && i.splitPosition.offset < e.splitPosition.offset && (i.howMany -= e.howMany), i.splitPosition = i.splitPosition._getTransformedBySplitOperation(e), i.insertionPosition = K.getInsertionPosition(i.splitPosition), [i];
});
function ku(i, e) {
  return i.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) === null;
}
function jn(i, e) {
  const t = [];
  for (let n = 0; n < i.length; n++) {
    const s = i[n], o = new H(s.start, s.end.offset - s.start.offset, e, 0);
    t.push(o);
    for (let r = n + 1; r < i.length; r++)
      i[r] = i[r]._getTransformedByMove(o.sourcePosition, o.targetPosition, o.howMany)[0];
    e = e._getTransformedByMove(o.sourcePosition, o.targetPosition, o.howMany);
  }
  return t;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ce extends G(y) {
  /**
   * Creates a live position.
   *
   * @see module:engine/model/position~Position
   */
  constructor(e, t, n = "toNone") {
    if (super(e, t, n), !this.root.is("rootElement"))
      throw new g("model-liveposition-root-not-rootelement", e);
    F2.call(this);
  }
  /**
   * Unbinds all events previously bound by `LivePosition`. Use it whenever you don't need `LivePosition` instance
   * anymore (i.e. when leaving scope in which it was declared or before re-assigning variable that was
   * referring to it).
   */
  detach() {
    this.stopListening();
  }
  /**
   * Creates a {@link module:engine/model/position~Position position instance}, which is equal to this live position.
   */
  toPosition() {
    return new y(this.root, this.path.slice(), this.stickiness);
  }
  /**
   * Creates a `LivePosition` instance that is equal to position.
   */
  static fromPosition(e, t) {
    return new this(e.root, e.path.slice(), t || e.stickiness);
  }
}
ce.prototype.is = function(i) {
  return i === "livePosition" || i === "model:livePosition" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i == "position" || i === "model:position";
};
function F2() {
  this.listenTo(this.root.document.model, "applyOperation", (i, e) => {
    const t = e[0];
    t.isDocumentOperation && N2.call(this, t);
  }, { priority: "low" });
}
function N2(i) {
  const e = this.getTransformedByOperation(i);
  if (!this.isEqual(e)) {
    const t = this.toPosition();
    this.path = e.path, this.root = e.root, this.fire("change", t);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Mn {
  /**
   * Creates a batch instance.
   *
   * @see module:engine/model/model~Model#enqueueChange
   * @see module:engine/model/model~Model#change
   * @param type A set of flags that specify the type of the batch. Batch type can alter how some of the features work
   * when encountering a given `Batch` instance (for example, when a feature listens to applied operations).
   */
  constructor(e = {}) {
    typeof e == "string" && (e = e === "transparent" ? { isUndoable: !1 } : {}, D("batch-constructor-deprecated-string-type"));
    const { isUndoable: t = !0, isLocal: n = !0, isUndo: s = !1, isTyping: o = !1 } = e;
    this.operations = [], this.isUndoable = t, this.isLocal = n, this.isUndo = s, this.isTyping = o;
  }
  /**
   * The type of the batch.
   *
   * **This property has been deprecated and is always set to the `'default'` value.**
   *
   * It can be one of the following values:
   * * `'default'` &ndash; All "normal" batches. This is the most commonly used type.
   * * `'transparent'` &ndash; A batch that should be ignored by other features, i.e. an initial batch or collaborative editing
   * changes.
   *
   * @deprecated
   */
  get type() {
    return D("batch-type-deprecated"), "default";
  }
  /**
   * Returns the base version of this batch, which is equal to the base version of the first operation in the batch.
   * If there are no operations in the batch or neither operation has the base version set, it returns `null`.
   */
  get baseVersion() {
    for (const e of this.operations)
      if (e.baseVersion !== null)
        return e.baseVersion;
    return null;
  }
  /**
   * Adds an operation to the batch instance.
   *
   * @param operation An operation to add.
   * @returns The added operation.
   */
  addOperation(e) {
    return e.batch = this, this.operations.push(e), e;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class D2 {
  /**
   * Creates a `Differ` instance.
   *
   * @param markerCollection Model's marker collection.
   */
  constructor(e) {
    this._changesInElement = /* @__PURE__ */ new Map(), this._elementSnapshots = /* @__PURE__ */ new Map(), this._changedMarkers = /* @__PURE__ */ new Map(), this._changedRoots = /* @__PURE__ */ new Map(), this._changeCount = 0, this._cachedChanges = null, this._cachedChangesWithGraveyard = null, this._refreshedItems = /* @__PURE__ */ new Set(), this._markerCollection = e;
  }
  /**
   * Informs whether there are any changes buffered in `Differ`.
   */
  get isEmpty() {
    return this._changesInElement.size == 0 && this._changedMarkers.size == 0 && this._changedRoots.size == 0;
  }
  /**
   * Buffers the given operation. An operation has to be buffered before it is executed.
   *
   * @param operationToBuffer An operation to buffer.
   */
  bufferOperation(e) {
    const t = e;
    switch (t.type) {
      case "insert": {
        if (this._isInInsertedElement(t.position.parent))
          return;
        this._markInsert(t.position.parent, t.position.offset, t.nodes.maxOffset);
        break;
      }
      case "addAttribute":
      case "removeAttribute":
      case "changeAttribute": {
        for (const n of t.range.getItems({ shallow: !0 }))
          this._isInInsertedElement(n.parent) || this._markAttribute(n);
        break;
      }
      case "remove":
      case "move":
      case "reinsert": {
        if (t.sourcePosition.isEqual(t.targetPosition) || t.sourcePosition.getShiftedBy(t.howMany).isEqual(t.targetPosition))
          return;
        const n = this._isInInsertedElement(t.sourcePosition.parent), s = this._isInInsertedElement(t.targetPosition.parent);
        n || this._markRemove(t.sourcePosition.parent, t.sourcePosition.offset, t.howMany), s || this._markInsert(t.targetPosition.parent, t.getMovedRangeStart().offset, t.howMany);
        break;
      }
      case "rename": {
        if (this._isInInsertedElement(t.position.parent))
          return;
        this._markRemove(t.position.parent, t.position.offset, 1), this._markInsert(t.position.parent, t.position.offset, 1);
        const n = _._createFromPositionAndShift(t.position, 1);
        for (const s of this._markerCollection.getMarkersIntersectingRange(n)) {
          const o = s.getData();
          this.bufferMarkerChange(s.name, o, o);
        }
        break;
      }
      case "split": {
        const n = t.splitPosition.parent;
        this._isInInsertedElement(n) || this._markRemove(n, t.splitPosition.offset, t.howMany), this._isInInsertedElement(t.insertionPosition.parent) || this._markInsert(t.insertionPosition.parent, t.insertionPosition.offset, 1), t.graveyardPosition && this._markRemove(t.graveyardPosition.parent, t.graveyardPosition.offset, 1);
        break;
      }
      case "merge": {
        const n = t.sourcePosition.parent;
        this._isInInsertedElement(n.parent) || this._markRemove(n.parent, n.startOffset, 1);
        const s = t.graveyardPosition.parent;
        this._markInsert(s, t.graveyardPosition.offset, 1);
        const o = t.targetPosition.parent;
        this._isInInsertedElement(o) || this._markInsert(o, t.targetPosition.offset, n.maxOffset);
        break;
      }
      case "detachRoot":
      case "addRoot": {
        const n = t.affectedSelectable;
        if (!n._isLoaded || n.isAttached() == t.isAdd)
          return;
        this._bufferRootStateChange(t.rootName, t.isAdd);
        break;
      }
      case "addRootAttribute":
      case "removeRootAttribute":
      case "changeRootAttribute": {
        if (!t.root._isLoaded)
          return;
        const n = t.root.rootName;
        this._bufferRootAttributeChange(n, t.key, t.oldValue, t.newValue);
        break;
      }
    }
    this._cachedChanges = null;
  }
  /**
   * Buffers a marker change.
   *
   * @param markerName The name of the marker that changed.
   * @param oldMarkerData Marker data before the change.
   * @param newMarkerData Marker data after the change.
   */
  bufferMarkerChange(e, t, n) {
    t.range && t.range.root.is("rootElement") && !t.range.root._isLoaded && (t.range = null), n.range && n.range.root.is("rootElement") && !n.range.root._isLoaded && (n.range = null);
    let s = this._changedMarkers.get(e);
    s ? s.newMarkerData = n : (s = { newMarkerData: n, oldMarkerData: t }, this._changedMarkers.set(e, s)), s.oldMarkerData.range == null && n.range == null && this._changedMarkers.delete(e);
  }
  /**
   * Returns all markers that should be removed as a result of buffered changes.
   *
   * @returns Markers to remove. Each array item is an object containing the `name` and `range` properties.
   */
  getMarkersToRemove() {
    const e = [];
    for (const [t, n] of this._changedMarkers)
      n.oldMarkerData.range != null && e.push({ name: t, range: n.oldMarkerData.range });
    return e;
  }
  /**
   * Returns all markers which should be added as a result of buffered changes.
   *
   * @returns Markers to add. Each array item is an object containing the `name` and `range` properties.
   */
  getMarkersToAdd() {
    const e = [];
    for (const [t, n] of this._changedMarkers)
      n.newMarkerData.range != null && e.push({ name: t, range: n.newMarkerData.range });
    return e;
  }
  /**
   * Returns all markers which changed.
   */
  getChangedMarkers() {
    return Array.from(this._changedMarkers).map(([e, t]) => ({
      name: e,
      data: {
        oldRange: t.oldMarkerData.range,
        newRange: t.newMarkerData.range
      }
    }));
  }
  /**
   * Checks whether some of the buffered changes affect the editor data.
   *
   * Types of changes which affect the editor data:
   *
   * * model structure changes,
   * * attribute changes,
   * * a root is added or detached,
   * * changes of markers which were defined as `affectsData`,
   * * changes of markers' `affectsData` property.
   */
  hasDataChanges() {
    if (this.getChanges().length || this._changedRoots.size > 0)
      return !0;
    for (const { newMarkerData: e, oldMarkerData: t } of this._changedMarkers.values()) {
      if (e.affectsData !== t.affectsData)
        return !0;
      if (e.affectsData) {
        const n = e.range && !t.range, s = !e.range && t.range, o = e.range && t.range && !e.range.isEqual(t.range);
        if (n || s || o)
          return !0;
      }
    }
    return !1;
  }
  /**
   * Calculates the diff between the old model tree state (the state before the first buffered operations since the last {@link #reset}
   * call) and the new model tree state (actual one). It should be called after all buffered operations are executed.
   *
   * The diff set is returned as an array of {@link module:engine/model/differ~DiffItem diff items}, each describing a change done
   * on the model. The items are sorted by the position on which the change happened. If a position
   * {@link module:engine/model/position~Position#isBefore is before} another one, it will be on an earlier index in the diff set.
   *
   * **Note**: Elements inside inserted element will not have a separate diff item, only the top most element change will be reported.
   *
   * Because calculating the diff is a costly operation, the result is cached. If no new operation was buffered since the
   * previous {@link #getChanges} call, the next call will return the cached value.
   *
   * @param options Additional options.
   * @param options.includeChangesInGraveyard If set to `true`, also changes that happened
   * in the graveyard root will be returned. By default, changes in the graveyard root are not returned.
   * @returns Diff between the old and the new model tree state.
   */
  getChanges(e = {}) {
    if (this._cachedChanges)
      return e.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice();
    let t = [];
    for (const n of this._changesInElement.keys()) {
      const s = this._changesInElement.get(n).sort((u, d) => u.offset === d.offset ? u.type != d.type ? u.type == "remove" ? -1 : 1 : 0 : u.offset < d.offset ? -1 : 1), o = this._elementSnapshots.get(n), r = Tu(n.getChildren()), a = z2(o.length, s);
      let l = 0, c = 0;
      for (const u of a)
        if (u === "i")
          t.push(this._getInsertDiff(n, l, r[l])), l++;
        else if (u === "r")
          t.push(this._getRemoveDiff(n, l, o[c])), c++;
        else if (u === "a") {
          const d = r[l].attributes, h = o[c].attributes;
          let f;
          if (r[l].name == "$text")
            f = new _(y._createAt(n, l), y._createAt(n, l + 1));
          else {
            const m = n.offsetToIndex(l);
            f = new _(y._createAt(n, l), y._createAt(n.getChild(m), 0));
          }
          t.push(...this._getAttributesDiff(f, h, d)), l++, c++;
        } else
          l++, c++;
    }
    t.sort((n, s) => n.position.root != s.position.root ? n.position.root.rootName < s.position.root.rootName ? -1 : 1 : n.position.isEqual(s.position) ? n.changeCount - s.changeCount : n.position.isBefore(s.position) ? -1 : 1);
    for (let n = 1, s = 0; n < t.length; n++) {
      const o = t[s], r = t[n], a = o.type == "remove" && r.type == "remove" && o.name == "$text" && r.name == "$text" && o.position.isEqual(r.position), l = o.type == "insert" && r.type == "insert" && o.name == "$text" && r.name == "$text" && o.position.parent == r.position.parent && o.position.offset + o.length == r.position.offset, c = o.type == "attribute" && r.type == "attribute" && o.position.parent == r.position.parent && o.range.isFlat && r.range.isFlat && o.position.offset + o.length == r.position.offset && o.attributeKey == r.attributeKey && o.attributeOldValue == r.attributeOldValue && o.attributeNewValue == r.attributeNewValue;
      a || l || c ? (o.length++, c && (o.range.end = o.range.end.getShiftedBy(1)), t[n] = null) : s = n;
    }
    t = t.filter((n) => n);
    for (const n of t)
      delete n.changeCount, n.type == "attribute" && (delete n.position, delete n.length);
    return this._changeCount = 0, this._cachedChangesWithGraveyard = t, this._cachedChanges = t.filter(H2), e.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice();
  }
  /**
   * Returns all roots that have changed (either were attached, or detached, or their attributes changed).
   *
   * @returns Diff between the old and the new roots state.
   */
  getChangedRoots() {
    return Array.from(this._changedRoots.values()).map((e) => {
      const t = { ...e };
      return t.state !== void 0 && delete t.attributes, t;
    });
  }
  /**
   * Returns a set of model items that were marked to get refreshed.
   */
  getRefreshedItems() {
    return new Set(this._refreshedItems);
  }
  /**
   * Resets `Differ`. Removes all buffered changes.
   */
  reset() {
    this._changesInElement.clear(), this._elementSnapshots.clear(), this._changedMarkers.clear(), this._changedRoots.clear(), this._refreshedItems = /* @__PURE__ */ new Set(), this._cachedChanges = null;
  }
  /**
   * Buffers the root state change after the root was attached or detached
   */
  _bufferRootStateChange(e, t) {
    if (!this._changedRoots.has(e)) {
      this._changedRoots.set(e, { name: e, state: t ? "attached" : "detached" });
      return;
    }
    const n = this._changedRoots.get(e);
    n.state !== void 0 ? (delete n.state, n.attributes === void 0 && this._changedRoots.delete(e)) : n.state = t ? "attached" : "detached";
  }
  /**
   * Buffers a root attribute change.
   */
  _bufferRootAttributeChange(e, t, n, s) {
    const o = this._changedRoots.get(e) || { name: e }, r = o.attributes || {};
    if (r[t]) {
      const a = r[t];
      s === a.oldValue ? delete r[t] : a.newValue = s;
    } else
      r[t] = { oldValue: n, newValue: s };
    Object.entries(r).length === 0 ? (delete o.attributes, o.state === void 0 && this._changedRoots.delete(e)) : (o.attributes = r, this._changedRoots.set(e, o));
  }
  /**
   * Marks the given `item` in differ to be "refreshed". It means that the item will be marked as removed and inserted
   * in the differ changes set, so it will be effectively re-converted when the differ changes are handled by a dispatcher.
   *
   * @internal
   * @param item Item to refresh.
   */
  _refreshItem(e) {
    if (this._isInInsertedElement(e.parent))
      return;
    this._markRemove(e.parent, e.startOffset, e.offsetSize), this._markInsert(e.parent, e.startOffset, e.offsetSize), this._refreshedItems.add(e);
    const t = _._createOn(e);
    for (const n of this._markerCollection.getMarkersIntersectingRange(t)) {
      const s = n.getData();
      this.bufferMarkerChange(n.name, s, s);
    }
    this._cachedChanges = null;
  }
  /**
   * Buffers all the data related to given root like it was all just added to the editor.
   *
   * Following changes are buffered:
   *
   * * root is attached,
   * * all root content is inserted,
   * * all root attributes are added,
   * * all markers inside the root are added.
   *
   * @internal
   */
  _bufferRootLoad(e) {
    if (e.isAttached()) {
      this._bufferRootStateChange(e.rootName, !0), this._markInsert(e, 0, e.maxOffset);
      for (const t of e.getAttributeKeys())
        this._bufferRootAttributeChange(e.rootName, t, null, e.getAttribute(t));
      for (const t of this._markerCollection)
        if (t.getRange().root == e) {
          const n = t.getData();
          this.bufferMarkerChange(t.name, { ...n, range: null }, n);
        }
    }
  }
  /**
   * Saves and handles an insert change.
   */
  _markInsert(e, t, n) {
    if (e.root.is("rootElement") && !e.root._isLoaded)
      return;
    const s = { type: "insert", offset: t, howMany: n, count: this._changeCount++ };
    this._markChange(e, s);
  }
  /**
   * Saves and handles a remove change.
   */
  _markRemove(e, t, n) {
    if (e.root.is("rootElement") && !e.root._isLoaded)
      return;
    const s = { type: "remove", offset: t, howMany: n, count: this._changeCount++ };
    this._markChange(e, s), this._removeAllNestedChanges(e, t, n);
  }
  /**
   * Saves and handles an attribute change.
   */
  _markAttribute(e) {
    if (e.root.is("rootElement") && !e.root._isLoaded)
      return;
    const t = { type: "attribute", offset: e.startOffset, howMany: e.offsetSize, count: this._changeCount++ };
    this._markChange(e.parent, t);
  }
  /**
   * Saves and handles a model change.
   */
  _markChange(e, t) {
    this._makeSnapshot(e);
    const n = this._getChangesForElement(e);
    this._handleChange(t, n), n.push(t);
    for (let s = 0; s < n.length; s++)
      n[s].howMany < 1 && (n.splice(s, 1), s--);
  }
  /**
   * Gets an array of changes that have already been saved for a given element.
   */
  _getChangesForElement(e) {
    let t;
    return this._changesInElement.has(e) ? t = this._changesInElement.get(e) : (t = [], this._changesInElement.set(e, t)), t;
  }
  /**
   * Saves a children snapshot for a given element.
   */
  _makeSnapshot(e) {
    this._elementSnapshots.has(e) || this._elementSnapshots.set(e, Tu(e.getChildren()));
  }
  /**
   * For a given newly saved change, compares it with a change already done on the element and modifies the incoming
   * change and/or the old change.
   *
   * @param inc Incoming (new) change.
   * @param changes An array containing all the changes done on that element.
   */
  _handleChange(e, t) {
    e.nodesToHandle = e.howMany;
    for (const n of t) {
      const s = e.offset + e.howMany, o = n.offset + n.howMany;
      if (e.type == "insert" && (n.type == "insert" && (e.offset <= n.offset ? n.offset += e.howMany : e.offset < o && (n.howMany += e.nodesToHandle, e.nodesToHandle = 0)), n.type == "remove" && e.offset < n.offset && (n.offset += e.howMany), n.type == "attribute")) {
        if (e.offset <= n.offset)
          n.offset += e.howMany;
        else if (e.offset < o) {
          const r = n.howMany;
          n.howMany = e.offset - n.offset, t.unshift({
            type: "attribute",
            offset: s,
            howMany: r - n.howMany,
            count: this._changeCount++
          });
        }
      }
      if (e.type == "remove") {
        if (n.type == "insert") {
          if (s <= n.offset)
            n.offset -= e.howMany;
          else if (s <= o)
            if (e.offset < n.offset) {
              const r = s - n.offset;
              n.offset = e.offset, n.howMany -= r, e.nodesToHandle -= r;
            } else
              n.howMany -= e.nodesToHandle, e.nodesToHandle = 0;
          else if (e.offset <= n.offset)
            e.nodesToHandle -= n.howMany, n.howMany = 0;
          else if (e.offset < o) {
            const r = o - e.offset;
            n.howMany -= r, e.nodesToHandle -= r;
          }
        }
        if (n.type == "remove" && (s <= n.offset ? n.offset -= e.howMany : e.offset < n.offset && (e.nodesToHandle += n.howMany, n.howMany = 0)), n.type == "attribute") {
          if (s <= n.offset)
            n.offset -= e.howMany;
          else if (e.offset < n.offset) {
            const r = s - n.offset;
            n.offset = e.offset, n.howMany -= r;
          } else if (e.offset < o)
            if (s <= o) {
              const r = n.howMany;
              n.howMany = e.offset - n.offset;
              const a = r - n.howMany - e.nodesToHandle;
              t.unshift({
                type: "attribute",
                offset: e.offset,
                howMany: a,
                count: this._changeCount++
              });
            } else
              n.howMany -= o - e.offset;
        }
      }
      if (e.type == "attribute") {
        if (n.type == "insert")
          if (e.offset < n.offset && s > n.offset) {
            if (s > o) {
              const r = {
                type: "attribute",
                offset: o,
                howMany: s - o,
                count: this._changeCount++
              };
              this._handleChange(r, t), t.push(r);
            }
            e.nodesToHandle = n.offset - e.offset, e.howMany = e.nodesToHandle;
          } else e.offset >= n.offset && e.offset < o && (s > o ? (e.nodesToHandle = s - o, e.offset = o) : e.nodesToHandle = 0);
        if (n.type == "remove" && e.offset < n.offset && s > n.offset) {
          const r = {
            type: "attribute",
            offset: n.offset,
            howMany: s - n.offset,
            count: this._changeCount++
          };
          this._handleChange(r, t), t.push(r), e.nodesToHandle = n.offset - e.offset, e.howMany = e.nodesToHandle;
        }
        n.type == "attribute" && (e.offset >= n.offset && s <= o ? (e.nodesToHandle = 0, e.howMany = 0, e.offset = 0) : e.offset <= n.offset && s >= o && (n.howMany = 0));
      }
    }
    e.howMany = e.nodesToHandle, delete e.nodesToHandle;
  }
  /**
   * Returns an object with a single insert change description.
   *
   * @param parent The element in which the change happened.
   * @param offset The offset at which change happened.
   * @param elementSnapshot The snapshot of the removed element a character.
   * @returns The diff item.
   */
  _getInsertDiff(e, t, n) {
    return {
      type: "insert",
      position: y._createAt(e, t),
      name: n.name,
      attributes: new Map(n.attributes),
      length: 1,
      changeCount: this._changeCount++,
      _element: n.element
    };
  }
  /**
   * Returns an object with a single remove change description.
   *
   * @param parent The element in which change happened.
   * @param offset The offset at which change happened.
   * @param elementSnapshot The snapshot of the removed element a character.
   * @returns The diff item.
   */
  _getRemoveDiff(e, t, n) {
    return {
      type: "remove",
      position: y._createAt(e, t),
      name: n.name,
      attributes: new Map(n.attributes),
      length: 1,
      changeCount: this._changeCount++,
      _element: n.element
    };
  }
  /**
   * Returns an array of objects where each one is a single attribute change description.
   *
   * @param range The range where the change happened.
   * @param oldAttributes A map, map iterator or compatible object that contains attributes before the change.
   * @param newAttributes A map, map iterator or compatible object that contains attributes after the change.
   * @returns An array containing one or more diff items.
   */
  _getAttributesDiff(e, t, n) {
    const s = [];
    n = new Map(n);
    for (const [o, r] of t) {
      const a = n.has(o) ? n.get(o) : null;
      a !== r && s.push({
        type: "attribute",
        position: e.start,
        range: e.clone(),
        length: 1,
        attributeKey: o,
        attributeOldValue: r,
        attributeNewValue: a,
        changeCount: this._changeCount++
      }), n.delete(o);
    }
    for (const [o, r] of n)
      s.push({
        type: "attribute",
        position: e.start,
        range: e.clone(),
        length: 1,
        attributeKey: o,
        attributeOldValue: null,
        attributeNewValue: r,
        changeCount: this._changeCount++
      });
    return s;
  }
  /**
   * Checks whether given element or any of its parents is an element that is buffered as an inserted element.
   */
  _isInInsertedElement(e) {
    const t = e.parent;
    if (!t)
      return !1;
    const n = this._changesInElement.get(t), s = e.startOffset;
    if (n) {
      for (const o of n)
        if (o.type == "insert" && s >= o.offset && s < o.offset + o.howMany)
          return !0;
    }
    return this._isInInsertedElement(t);
  }
  /**
   * Removes deeply all buffered changes that are registered in elements from range specified by `parent`, `offset`
   * and `howMany`.
   */
  _removeAllNestedChanges(e, t, n) {
    const s = new _(y._createAt(e, t), y._createAt(e, t + n));
    for (const o of s.getItems({ shallow: !0 }))
      o.is("element") && (this._elementSnapshots.delete(o), this._changesInElement.delete(o), this._removeAllNestedChanges(o, 0, o.maxOffset));
  }
}
function Tu(i) {
  const e = [];
  for (const t of i)
    if (t.is("$text"))
      for (let n = 0; n < t.data.length; n++)
        e.push({
          name: "$text",
          attributes: new Map(t.getAttributes())
        });
    else
      e.push({
        name: t.name,
        attributes: new Map(t.getAttributes()),
        element: t
      });
  return e;
}
function z2(i, e) {
  const t = [];
  let n = 0, s = 0;
  for (const o of e) {
    if (o.offset > n) {
      for (let r = 0; r < o.offset - n; r++)
        t.push("e");
      s += o.offset - n;
    }
    if (o.type == "insert") {
      for (let r = 0; r < o.howMany; r++)
        t.push("i");
      n = o.offset + o.howMany;
    } else if (o.type == "remove") {
      for (let r = 0; r < o.howMany; r++)
        t.push("r");
      n = o.offset, s += o.howMany;
    } else
      t.push(..."a".repeat(o.howMany).split("")), n = o.offset + o.howMany, s += o.howMany;
  }
  if (s < i)
    for (let o = 0; o < i - s - n; o++)
      t.push("e");
  return t;
}
function H2(i) {
  const e = "position" in i && i.position.root.rootName == "$graveyard", t = "range" in i && i.range.root.rootName == "$graveyard";
  return !e && !t;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class U2 {
  constructor() {
    this._operations = [], this._undoPairs = /* @__PURE__ */ new Map(), this._undoneOperations = /* @__PURE__ */ new Set(), this._baseVersionToOperationIndex = /* @__PURE__ */ new Map(), this._version = 0, this._gaps = /* @__PURE__ */ new Map();
  }
  /**
   * The version of the last operation in the history.
   *
   * The history version is incremented automatically when a new operation is added to the history.
   * Setting the version manually should be done only in rare circumstances when a gap is planned
   * between history versions. When doing so, a gap will be created and the history will accept adding
   * an operation with base version equal to the new history version.
   */
  get version() {
    return this._version;
  }
  set version(e) {
    this._operations.length && e > this._version + 1 && this._gaps.set(this._version, e), this._version = e;
  }
  /**
   * The last history operation.
   */
  get lastOperation() {
    return this._operations[this._operations.length - 1];
  }
  /**
   * Adds an operation to the history and increments the history version.
   *
   * The operation's base version should be equal to the history version. Otherwise an error is thrown.
   */
  addOperation(e) {
    if (e.baseVersion !== this.version)
      throw new g("model-document-history-addoperation-incorrect-version", this, {
        operation: e,
        historyVersion: this.version
      });
    this._operations.push(e), this._version++, this._baseVersionToOperationIndex.set(e.baseVersion, this._operations.length - 1);
  }
  /**
   * Returns operations from the given range of operation base versions that were added to the history.
   *
   * Note that there may be gaps in operations base versions.
   *
   * @param fromBaseVersion Base version from which operations should be returned (inclusive).
   * @param toBaseVersion Base version up to which operations should be returned (exclusive).
   * @returns History operations for the given range, in chronological order.
   */
  getOperations(e, t = this.version) {
    if (!this._operations.length)
      return [];
    const n = this._operations[0];
    e === void 0 && (e = n.baseVersion);
    let s = t - 1;
    for (const [a, l] of this._gaps)
      e > a && e < l && (e = l), s > a && s < l && (s = a - 1);
    if (s < n.baseVersion || e > this.lastOperation.baseVersion)
      return [];
    let o = this._baseVersionToOperationIndex.get(e);
    o === void 0 && (o = 0);
    let r = this._baseVersionToOperationIndex.get(s);
    return r === void 0 && (r = this._operations.length - 1), this._operations.slice(
      o,
      // The `toIndex` should be included in the returned operations, so add `1`.
      r + 1
    );
  }
  /**
   * Returns operation from the history that bases on given `baseVersion`.
   *
   * @param baseVersion Base version of the operation to get.
   * @returns Operation with given base version or `undefined` if there is no such operation in history.
   */
  getOperation(e) {
    const t = this._baseVersionToOperationIndex.get(e);
    if (t !== void 0)
      return this._operations[t];
  }
  /**
   * Marks in history that one operation is an operation that is undoing the other operation. By marking operation this way,
   * history is keeping more context information about operations, which helps in operational transformation.
   *
   * @param undoneOperation Operation which is undone by `undoingOperation`.
   * @param undoingOperation Operation which undoes `undoneOperation`.
   */
  setOperationAsUndone(e, t) {
    this._undoPairs.set(t, e), this._undoneOperations.add(e);
  }
  /**
   * Checks whether given `operation` is undoing any other operation.
   *
   * @param operation Operation to check.
   * @returns `true` if given `operation` is undoing any other operation, `false` otherwise.
   */
  isUndoingOperation(e) {
    return this._undoPairs.has(e);
  }
  /**
   * Checks whether given `operation` has been undone by any other operation.
   *
   * @param operation Operation to check.
   * @returns `true` if given `operation` has been undone any other operation, `false` otherwise.
   */
  isUndoneOperation(e) {
    return this._undoneOperations.has(e);
  }
  /**
   * For given `undoingOperation`, returns the operation which has been undone by it.
   *
   * @returns Operation that has been undone by given `undoingOperation` or `undefined`
   * if given `undoingOperation` is not undoing any other operation.
   */
  getUndoneOperation(e) {
    return this._undoPairs.get(e);
  }
  /**
   * Resets the history of operations.
   */
  reset() {
    this._version = 0, this._undoPairs = /* @__PURE__ */ new Map(), this._operations = [], this._undoneOperations = /* @__PURE__ */ new Set(), this._gaps = /* @__PURE__ */ new Map(), this._baseVersionToOperationIndex = /* @__PURE__ */ new Map();
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class To extends $ {
  /**
   * Creates root element.
   *
   * @param document Document that is an owner of this root.
   * @param name Node name.
   * @param rootName Unique root name used to identify this root element by {@link module:engine/model/document~Document}.
   */
  constructor(e, t, n = "main") {
    super(t), this._isAttached = !0, this._isLoaded = !0, this._document = e, this.rootName = n;
  }
  /**
   * {@link module:engine/model/document~Document Document} that owns this root element.
   */
  get document() {
    return this._document;
  }
  /**
   * Informs if the root element is currently attached to the document, or not.
   *
   * A detached root is equivalent to being removed and cannot contain any children or markers.
   *
   * By default, a newly added root is attached. It can be detached using
   * {@link module:engine/model/writer~Writer#detachRoot `Writer#detachRoot`}. A detached root can be re-attached again using
   * {@link module:engine/model/writer~Writer#addRoot `Writer#addRoot`}.
   */
  isAttached() {
    return this._isAttached;
  }
  /**
   * Converts `RootElement` instance to `string` containing its name.
   *
   * @returns `RootElement` instance converted to `string`.
   */
  toJSON() {
    return this.rootName;
  }
}
To.prototype.is = function(i, e) {
  return e ? e === this.name && (i === "rootElement" || i === "model:rootElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "element" || i === "model:element") : i === "rootElement" || i === "model:rootElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "element" || i === "model:element" || i === "node" || i === "model:node";
};
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Eu = "$graveyard";
class $2 extends G() {
  /**
   * Creates an empty document instance with no {@link #roots} (other than
   * the {@link #graveyard graveyard root}).
   */
  constructor(e) {
    super(), this.model = e, this.history = new U2(), this.selection = new at(this), this.roots = new ke({ idProperty: "rootName" }), this.differ = new D2(e.markers), this.isReadOnly = !1, this._postFixers = /* @__PURE__ */ new Set(), this._hasSelectionChangedFromTheLastChangeBlock = !1, this.createRoot("$root", Eu), this.listenTo(e, "applyOperation", (t, n) => {
      const s = n[0];
      s.isDocumentOperation && this.differ.bufferOperation(s);
    }, { priority: "high" }), this.listenTo(e, "applyOperation", (t, n) => {
      const s = n[0];
      s.isDocumentOperation && this.history.addOperation(s);
    }, { priority: "low" }), this.listenTo(this.selection, "change", () => {
      this._hasSelectionChangedFromTheLastChangeBlock = !0;
    }), this.listenTo(e.markers, "update", (t, n, s, o, r) => {
      const a = { ...n.getData(), range: o };
      this.differ.bufferMarkerChange(n.name, r, a), s === null && n.on("change", (l, c) => {
        const u = n.getData();
        this.differ.bufferMarkerChange(n.name, { ...u, range: c }, u);
      });
    }), this.registerPostFixer((t) => {
      let n = !1;
      for (const s of this.roots)
        !s.isAttached() && !s.isEmpty && (t.remove(t.createRangeIn(s)), n = !0);
      for (const s of this.model.markers)
        s.getRange().root.isAttached() || (t.removeMarker(s), n = !0);
      return n;
    });
  }
  /**
   * The document version. Every applied operation increases the version number. It is used to
   * ensure that operations are applied on a proper document version.
   *
   * This property is equal to {@link module:engine/model/history~History#version `model.Document#history#version`}.
   *
   * If the {@link module:engine/model/operation/operation~Operation#baseVersion base version} does not match the document version,
   * a {@link module:utils/ckeditorerror~CKEditorError model-document-applyoperation-wrong-version} error is thrown.
   */
  get version() {
    return this.history.version;
  }
  set version(e) {
    this.history.version = e;
  }
  /**
   * The graveyard tree root. A document always has a graveyard root that stores removed nodes.
   */
  get graveyard() {
    return this.getRoot(Eu);
  }
  /**
   * Creates a new root.
   *
   * **Note:** do not use this method after the editor has been initialized! If you want to dynamically add a root, use
   * {@link module:engine/model/writer~Writer#addRoot `model.Writer#addRoot`} instead.
   *
   * @param elementName The element name. Defaults to `'$root'` which also has some basic schema defined
   * (e.g. `$block` elements are allowed inside the `$root`). Make sure to define a proper schema if you use a different name.
   * @param rootName A unique root name.
   * @returns The created root.
   */
  createRoot(e = "$root", t = "main") {
    if (this.roots.get(t))
      throw new g("model-document-createroot-name-exists", this, { name: t });
    const n = new To(this, e, t);
    return this.roots.add(n), n;
  }
  /**
   * Removes all event listeners set by the document instance.
   */
  destroy() {
    this.selection.destroy(), this.stopListening();
  }
  /**
   * Returns a root by its name.
   *
   * Detached roots are returned by this method. This is to be able to operate on the detached root (for example, to be able to create
   * a position inside such a root for undo feature purposes).
   *
   * @param name The root name of the root to return.
   * @returns The root registered under a given name or `null` when there is no root with the given name.
   */
  getRoot(e = "main") {
    return this.roots.get(e);
  }
  /**
   * Returns an array with names of all roots added to the document (except the {@link #graveyard graveyard root}).
   *
   * Detached roots **are not** returned by this method by default. This is to make sure that all features or algorithms that operate
   * on the document data know which roots are still a part of the document and should be processed.
   *
   * @param includeDetached Specified whether detached roots should be returned as well.
   */
  getRootNames(e = !1) {
    return this.getRoots(e).map((t) => t.rootName);
  }
  /**
   * Returns an array with all roots added to the document (except the {@link #graveyard graveyard root}).
   *
   * Detached roots **are not** returned by this method by default. This is to make sure that all features or algorithms that operate
   * on the document data know which roots are still a part of the document and should be processed.
   *
   * @param includeDetached Specified whether detached roots should be returned as well.
   */
  getRoots(e = !1) {
    return this.roots.filter((t) => t != this.graveyard && (e || t.isAttached()) && t._isLoaded);
  }
  /**
   * Used to register a post-fixer callback. A post-fixer mechanism guarantees that the features
   * will operate on a correct model state.
   *
   * An execution of a feature may lead to an incorrect document tree state. The callbacks are used to fix the document tree after
   * it has changed. Post-fixers are fired just after all changes from the outermost change block were applied but
   * before the {@link module:engine/model/document~Document#event:change change event} is fired. If a post-fixer callback made
   * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should
   * not be fixed in the new document tree state.
   *
   * As a parameter, a post-fixer callback receives a {@link module:engine/model/writer~Writer writer} instance connected with the
   * executed changes block. Thanks to that, all changes done by the callback will be added to the same
   * {@link module:engine/model/batch~Batch batch} (and undo step) as the original changes. This makes post-fixer changes transparent
   * for the user.
   *
   * An example of a post-fixer is a callback that checks if all the data were removed from the editor. If so, the
   * callback should add an empty paragraph so that the editor is never empty:
   *
   * ```ts
   * document.registerPostFixer( writer => {
   * 	const changes = document.differ.getChanges();
   *
   * 	// Check if the changes lead to an empty root in the editor.
   * 	for ( const entry of changes ) {
   * 		if ( entry.type == 'remove' && entry.position.root.isEmpty ) {
   * 			writer.insertElement( 'paragraph', entry.position.root, 0 );
   *
   * 			// It is fine to return early, even if multiple roots would need to be fixed.
   * 			// All post-fixers will be fired again, so if there are more empty roots, those will be fixed, too.
   * 			return true;
   * 		}
   * 	}
   *
   * 	return false;
   * } );
   * ```
   */
  registerPostFixer(e) {
    this._postFixers.add(e);
  }
  /**
   * A custom `toJSON()` method to solve child-parent circular dependencies.
   *
   * @returns A clone of this object with the document property changed to a string.
   */
  toJSON() {
    const e = Wf(this);
    return e.selection = "[engine.model.DocumentSelection]", e.model = "[engine.model.Model]", e;
  }
  /**
   * Check if there were any changes done on document, and if so, call post-fixers,
   * fire `change` event for features and conversion and then reset the differ.
   * Fire `change:data` event when at least one operation or buffered marker changes the data.
   *
   * @internal
   * @fires change
   * @fires change:data
   * @param writer The writer on which post-fixers will be called.
   */
  _handleChangeBlock(e) {
    this._hasDocumentChangedFromTheLastChangeBlock() && (this._callPostFixers(e), this.selection.refresh(), this.differ.hasDataChanges() ? this.fire("change:data", e.batch) : this.fire("change", e.batch), this.selection.refresh(), this.differ.reset()), this._hasSelectionChangedFromTheLastChangeBlock = !1;
  }
  /**
   * Returns whether there is a buffered change or if the selection has changed from the last
   * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()` block}
   * or {@link module:engine/model/model~Model#change `change()` block}.
   *
   * @returns Returns `true` if document has changed from the last `change()` or `enqueueChange()` block.
   */
  _hasDocumentChangedFromTheLastChangeBlock() {
    return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;
  }
  /**
   * Returns the default root for this document which is either the first root that was added to the document using
   * {@link #createRoot} or the {@link #graveyard graveyard root} if no other roots were created.
   *
   * @returns The default root for this document.
   */
  _getDefaultRoot() {
    const e = this.getRoots();
    return e.length ? e[0] : this.graveyard;
  }
  /**
   * Returns the default range for this selection. The default range is a collapsed range that starts and ends
   * at the beginning of this selection's document {@link #_getDefaultRoot default root}.
   *
   * @internal
   */
  _getDefaultRange() {
    const e = this._getDefaultRoot(), t = this.model, n = t.schema, s = t.createPositionFromPath(e, [0]);
    return n.getNearestSelectionRange(s) || t.createRange(s);
  }
  /**
   * Checks whether a given {@link module:engine/model/range~Range range} is a valid range for
   * the {@link #selection document's selection}.
   *
   * @internal
   * @param range A range to check.
   * @returns `true` if `range` is valid, `false` otherwise.
   */
  _validateSelectionRange(e) {
    return Au(e.start) && Au(e.end);
  }
  /**
   * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.
   *
   * @param writer The writer on which post-fixer callbacks will be called.
   */
  _callPostFixers(e) {
    let t = !1;
    do
      for (const n of this._postFixers)
        if (this.selection.refresh(), t = n(e), t)
          break;
    while (t);
  }
}
function Au(i) {
  const e = i.textNode;
  if (e) {
    const t = e.data, n = i.offset - e.startOffset;
    return !ul(t, n) && !dl(t, n);
  }
  return !0;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class W2 extends G() {
  constructor() {
    super(...arguments), this._markers = /* @__PURE__ */ new Map();
  }
  /**
   * Iterable interface.
   *
   * Iterates over all {@link ~Marker markers} added to the collection.
   */
  [Symbol.iterator]() {
    return this._markers.values();
  }
  /**
   * Checks if given {@link ~Marker marker} or marker name is in the collection.
   *
   * @param markerOrName Name of marker or marker instance to check.
   * @returns `true` if marker is in the collection, `false` otherwise.
   */
  has(e) {
    const t = e instanceof zn ? e.name : e;
    return this._markers.has(t);
  }
  /**
   * Returns {@link ~Marker marker} with given `markerName`.
   *
   * @param markerName Name of marker to get.
   * @returns Marker with given name or `null` if such marker was
   * not added to the collection.
   */
  get(e) {
    return this._markers.get(e) || null;
  }
  /**
   * Creates and adds a {@link ~Marker marker} to the `MarkerCollection` with given name on given
   * {@link module:engine/model/range~Range range}.
   *
   * If `MarkerCollection` already had a marker with given name (or {@link ~Marker marker} was passed), the marker in
   * collection is updated and {@link module:engine/model/markercollection~MarkerCollection#event:update} event is fired
   * but only if there was a change (marker range or {@link module:engine/model/markercollection~Marker#managedUsingOperations}
   * flag has changed.
   *
   * @internal
   * @fires update
   * @param markerOrName Name of marker to set or marker instance to update.
   * @param range Marker range.
   * @param managedUsingOperations Specifies whether the marker is managed using operations.
   * @param affectsData Specifies whether the marker affects the data produced by the data pipeline
   * (is persisted in the editor's data).
   * @returns `Marker` instance which was added or updated.
   */
  _set(e, t, n = !1, s = !1) {
    const o = e instanceof zn ? e.name : e;
    if (o.includes(","))
      throw new g("markercollection-incorrect-marker-name", this);
    const r = this._markers.get(o);
    if (r) {
      const c = r.getData(), u = r.getRange();
      let d = !1;
      return u.isEqual(t) || (r._attachLiveRange(Pe.fromRange(t)), d = !0), n != r.managedUsingOperations && (r._managedUsingOperations = n, d = !0), typeof s == "boolean" && s != r.affectsData && (r._affectsData = s, d = !0), d && this.fire(`update:${o}`, r, u, t, c), r;
    }
    const a = Pe.fromRange(t), l = new zn(o, a, n, s);
    return this._markers.set(o, l), this.fire(`update:${o}`, l, null, t, { ...l.getData(), range: null }), l;
  }
  /**
   * Removes given {@link ~Marker marker} or a marker with given name from the `MarkerCollection`.
   *
   * @internal
   * @fires update
   * @param markerOrName Marker or name of a marker to remove.
   * @returns `true` if marker was found and removed, `false` otherwise.
   */
  _remove(e) {
    const t = e instanceof zn ? e.name : e, n = this._markers.get(t);
    return n ? (this._markers.delete(t), this.fire(`update:${t}`, n, n.getRange(), null, n.getData()), this._destroyMarker(n), !0) : !1;
  }
  /**
   * Fires an {@link module:engine/model/markercollection~MarkerCollection#event:update} event for the given {@link ~Marker marker}
   * but does not change the marker. Useful to force {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher downcast
   * conversion} for the marker.
   *
   * @internal
   * @fires update
   * @param markerOrName Marker or name of a marker to refresh.
   */
  _refresh(e) {
    const t = e instanceof zn ? e.name : e, n = this._markers.get(t);
    if (!n)
      throw new g("markercollection-refresh-marker-not-exists", this);
    const s = n.getRange();
    this.fire(`update:${t}`, n, s, s, n.getData());
  }
  /**
   * Returns iterator that iterates over all markers, which ranges contain given {@link module:engine/model/position~Position position}.
   */
  *getMarkersAtPosition(e) {
    for (const t of this)
      t.getRange().containsPosition(e) && (yield t);
  }
  /**
   * Returns iterator that iterates over all markers, which intersects with given {@link module:engine/model/range~Range range}.
   */
  *getMarkersIntersectingRange(e) {
    for (const t of this)
      t.getRange().getIntersection(e) !== null && (yield t);
  }
  /**
   * Destroys marker collection and all markers inside it.
   */
  destroy() {
    for (const e of this._markers.values())
      this._destroyMarker(e);
    this._markers = null, this.stopListening();
  }
  /**
   * Iterates over all markers that starts with given `prefix`.
   *
   * ```ts
   * const markerFooA = markersCollection._set( 'foo:a', rangeFooA );
   * const markerFooB = markersCollection._set( 'foo:b', rangeFooB );
   * const markerBarA = markersCollection._set( 'bar:a', rangeBarA );
   * const markerFooBarA = markersCollection._set( 'foobar:a', rangeFooBarA );
   * Array.from( markersCollection.getMarkersGroup( 'foo' ) ); // [ markerFooA, markerFooB ]
   * Array.from( markersCollection.getMarkersGroup( 'a' ) ); // []
   * ```
   */
  *getMarkersGroup(e) {
    for (const t of this._markers.values())
      t.name.startsWith(e + ":") && (yield t);
  }
  /**
   * Destroys the marker.
   */
  _destroyMarker(e) {
    e.stopListening(), e._detachLiveRange();
  }
}
class zn extends G(jt) {
  /**
   * Creates a marker instance.
   *
   * @param name Marker name.
   * @param liveRange Range marked by the marker.
   * @param managedUsingOperations Specifies whether the marker is managed using operations.
   * @param affectsData Specifies whether the marker affects the data produced by the data pipeline (is persisted in the editor's data).
   */
  constructor(e, t, n, s) {
    super(), this.name = e, this._liveRange = this._attachLiveRange(t), this._managedUsingOperations = n, this._affectsData = s;
  }
  /**
   * A value indicating if the marker is managed using operations.
   * See {@link ~Marker marker class description} to learn more about marker types.
   * See {@link module:engine/model/writer~Writer#addMarker}.
   */
  get managedUsingOperations() {
    if (!this._liveRange)
      throw new g("marker-destroyed", this);
    return this._managedUsingOperations;
  }
  /**
   * A value indicating if the marker changes the data.
   */
  get affectsData() {
    if (!this._liveRange)
      throw new g("marker-destroyed", this);
    return this._affectsData;
  }
  /**
   * Returns the marker data (properties defining the marker).
   */
  getData() {
    return {
      range: this.getRange(),
      affectsData: this.affectsData,
      managedUsingOperations: this.managedUsingOperations
    };
  }
  /**
   * Returns current marker start position.
   */
  getStart() {
    if (!this._liveRange)
      throw new g("marker-destroyed", this);
    return this._liveRange.start.clone();
  }
  /**
   * Returns current marker end position.
   */
  getEnd() {
    if (!this._liveRange)
      throw new g("marker-destroyed", this);
    return this._liveRange.end.clone();
  }
  /**
   * Returns a range that represents the current state of the marker.
   *
   * Keep in mind that returned value is a {@link module:engine/model/range~Range Range}, not a
   * {@link module:engine/model/liverange~LiveRange LiveRange}. This means that it is up-to-date and relevant only
   * until next model document change. Do not store values returned by this method. Instead, store {@link ~Marker#name}
   * and get `Marker` instance from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection} every
   * time there is a need to read marker properties. This will guarantee that the marker has not been removed and
   * that it's data is up-to-date.
   */
  getRange() {
    if (!this._liveRange)
      throw new g("marker-destroyed", this);
    return this._liveRange.toRange();
  }
  /**
   * Binds new live range to the marker and detach the old one if is attached.
   *
   * @internal
   * @param liveRange Live range to attach
   * @returns Attached live range.
   */
  _attachLiveRange(e) {
    return this._liveRange && this._detachLiveRange(), e.delegate("change:range").to(this), e.delegate("change:content").to(this), this._liveRange = e, e;
  }
  /**
   * Unbinds and destroys currently attached live range.
   *
   * @internal
   */
  _detachLiveRange() {
    this._liveRange.stopDelegating("change:range", this), this._liveRange.stopDelegating("change:content", this), this._liveRange.detach(), this._liveRange = null;
  }
}
zn.prototype.is = function(i) {
  return i === "marker" || i === "model:marker";
};
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class q2 extends $e {
  /**
   * Creates an insert operation.
   *
   * @param sourcePosition Position before the first {@link module:engine/model/item~Item model item} to move.
   * @param howMany Offset size of moved range. Moved range will start from `sourcePosition` and end at
   * `sourcePosition` with offset shifted by `howMany`.
   */
  constructor(e, t) {
    super(null), this.sourcePosition = e.clone(), this.howMany = t;
  }
  /**
   * @inheritDoc
   */
  get type() {
    return "detach";
  }
  /**
   * @inheritDoc
   */
  get affectedSelectable() {
    return null;
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    const e = super.toJSON();
    return e.sourcePosition = this.sourcePosition.toJSON(), e;
  }
  /**
   * @inheritDoc
   * @internal
   */
  _validate() {
    if (this.sourcePosition.root.document)
      throw new g("detach-operation-on-document-node", this);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _execute() {
    Xm(_._createFromPositionAndShift(this.sourcePosition, this.howMany));
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "DetachOperation";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Tt extends jt {
  /**
   * Creates an empty `DocumentFragment`.
   *
   * **Note:** Constructor of this class shouldn't be used directly in the code.
   * Use the {@link module:engine/model/writer~Writer#createDocumentFragment} method instead.
   *
   * @internal
   * @param children Nodes to be contained inside the `DocumentFragment`.
   */
  constructor(e) {
    super(), this.markers = /* @__PURE__ */ new Map(), this._children = new Fi(), e && this._insertChild(0, e);
  }
  /**
   * Returns an iterator that iterates over all nodes contained inside this document fragment.
   */
  [Symbol.iterator]() {
    return this.getChildren();
  }
  /**
   * Number of this document fragment's children.
   */
  get childCount() {
    return this._children.length;
  }
  /**
   * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this document fragment's children.
   */
  get maxOffset() {
    return this._children.maxOffset;
  }
  /**
   * Is `true` if there are no nodes inside this document fragment, `false` otherwise.
   */
  get isEmpty() {
    return this.childCount === 0;
  }
  /**
   * Artificial next sibling. Returns `null`. Added for compatibility reasons.
   */
  get nextSibling() {
    return null;
  }
  /**
   * Artificial previous sibling. Returns `null`. Added for compatibility reasons.
   */
  get previousSibling() {
    return null;
  }
  /**
   * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.
   */
  get root() {
    return this;
  }
  /**
   * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.
   */
  get parent() {
    return null;
  }
  /**
   * Artificial owner of `DocumentFragment`. Returns `null`. Added for compatibility reasons.
   */
  get document() {
    return null;
  }
  /**
   * Returns `false` as `DocumentFragment` by definition is not attached to a document. Added for compatibility reasons.
   */
  isAttached() {
    return !1;
  }
  /**
   * Returns empty array. Added for compatibility reasons.
   */
  getAncestors() {
    return [];
  }
  /**
   * Gets the child at the given index. Returns `null` if incorrect index was passed.
   *
   * @param index Index of child.
   * @returns Child node.
   */
  getChild(e) {
    return this._children.getNode(e);
  }
  /**
   * Returns an iterator that iterates over all of this document fragment's children.
   */
  getChildren() {
    return this._children[Symbol.iterator]();
  }
  /**
   * Returns an index of the given child node. Returns `null` if given node is not a child of this document fragment.
   *
   * @param node Child node to look for.
   * @returns Child node's index.
   */
  getChildIndex(e) {
    return this._children.getNodeIndex(e);
  }
  /**
   * Returns the starting offset of given child. Starting offset is equal to the sum of
   * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if
   * given node is not a child of this document fragment.
   *
   * @param node Child node to look for.
   * @returns Child node's starting offset.
   */
  getChildStartOffset(e) {
    return this._children.getNodeStartOffset(e);
  }
  /**
   * Returns path to a `DocumentFragment`, which is an empty array. Added for compatibility reasons.
   */
  getPath() {
    return [];
  }
  /**
   * Returns a descendant node by its path relative to this element.
   *
   * ```ts
   * // <this>a<b>c</b></this>
   * this.getNodeByPath( [ 0 ] );     // -> "a"
   * this.getNodeByPath( [ 1 ] );     // -> <b>
   * this.getNodeByPath( [ 1, 0 ] );  // -> "c"
   * ```
   *
   * @param relativePath Path of the node to find, relative to this element.
   */
  getNodeByPath(e) {
    let t = this;
    for (const n of e)
      t = t.getChild(t.offsetToIndex(n));
    return t;
  }
  /**
   * Converts offset "position" to index "position".
   *
   * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is
   * too high, returns index after last child.
   *
   * ```ts
   * const textNode = new Text( 'foo' );
   * const pElement = new Element( 'p' );
   * const docFrag = new DocumentFragment( [ textNode, pElement ] );
   * docFrag.offsetToIndex( -1 ); // Returns 0, because offset is too low.
   * docFrag.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.
   * docFrag.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.
   * docFrag.offsetToIndex( 2 ); // Returns 0.
   * docFrag.offsetToIndex( 3 ); // Returns 1.
   * docFrag.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.
   * ```
   *
   * @param offset Offset to look for.
   * @returns Index of a node that occupies given offset.
   */
  offsetToIndex(e) {
    return this._children.offsetToIndex(e);
  }
  /**
   * Converts `DocumentFragment` instance to plain object and returns it.
   * Takes care of converting all of this document fragment's children.
   *
   * @returns `DocumentFragment` instance converted to plain object.
   */
  toJSON() {
    const e = [];
    for (const t of this._children)
      e.push(t.toJSON());
    return e;
  }
  /**
   * Creates a `DocumentFragment` instance from given plain object (i.e. parsed JSON string).
   * Converts `DocumentFragment` children to proper nodes.
   *
   * @param json Plain object to be converted to `DocumentFragment`.
   * @returns `DocumentFragment` instance created using given plain object.
   */
  static fromJSON(e) {
    const t = [];
    for (const n of e)
      n.name ? t.push($.fromJSON(n)) : t.push(j.fromJSON(n));
    return new Tt(t);
  }
  /**
   * {@link #_insertChild Inserts} one or more nodes at the end of this document fragment.
   *
   * @internal
   * @param items Items to be inserted.
   */
  _appendChild(e) {
    this._insertChild(this.childCount, e);
  }
  /**
   * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes
   * to this document fragment.
   *
   * @internal
   * @param index Index at which nodes should be inserted.
   * @param items Items to be inserted.
   */
  _insertChild(e, t) {
    const n = G2(t);
    for (const s of n)
      s.parent !== null && s._remove(), s.parent = this;
    this._children._insertNodes(e, n);
  }
  /**
   * Removes one or more nodes starting at the given index
   * and sets {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.
   *
   * @internal
   * @param index Index of the first node to remove.
   * @param howMany Number of nodes to remove.
   * @returns Array containing removed nodes.
   */
  _removeChildren(e, t = 1) {
    const n = this._children._removeNodes(e, t);
    for (const s of n)
      s.parent = null;
    return n;
  }
}
Tt.prototype.is = function(i) {
  return i === "documentFragment" || i === "model:documentFragment";
};
function G2(i) {
  return typeof i == "string" ? [new j(i)] : (Ue(i) || (i = [i]), Array.from(i).map((e) => typeof e == "string" ? new j(e) : e instanceof it ? new j(e.data, e.getAttributes()) : e));
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class j2 {
  /**
   * Creates a writer instance.
   *
   * **Note:** It is not recommended to use it directly. Use {@link module:engine/model/model~Model#change `Model#change()`} or
   * {@link module:engine/model/model~Model#enqueueChange `Model#enqueueChange()`} instead.
   *
   * @internal
   */
  constructor(e, t) {
    this.model = e, this.batch = t;
  }
  /**
   * Creates a new {@link module:engine/model/text~Text text node}.
   *
   * ```ts
   * writer.createText( 'foo' );
   * writer.createText( 'foo', { bold: true } );
   * ```
   *
   * @param data Text data.
   * @param attributes Text attributes.
   * @returns {module:engine/model/text~Text} Created text node.
   */
  createText(e, t) {
    return new j(e, t);
  }
  /**
   * Creates a new {@link module:engine/model/element~Element element}.
   *
   * ```ts
   * writer.createElement( 'paragraph' );
   * writer.createElement( 'paragraph', { alignment: 'center' } );
   * ```
   *
   * @param name Name of the element.
   * @param attributes Elements attributes.
   * @returns Created element.
   */
  createElement(e, t) {
    return new $(e, t);
  }
  /**
   * Creates a new {@link module:engine/model/documentfragment~DocumentFragment document fragment}.
   *
   * @returns Created document fragment.
   */
  createDocumentFragment() {
    return new Tt();
  }
  /**
   * Creates a copy of the element and returns it. Created element has the same name and attributes as the original element.
   * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.
   *
   * @param element The element to clone.
   * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
   * element will be cloned without any child.
   */
  cloneElement(e, t = !0) {
    return e._clone(t);
  }
  /**
   * Inserts item on given position.
   *
   * ```ts
   * const paragraph = writer.createElement( 'paragraph' );
   * writer.insert( paragraph, position );
   * ```
   *
   * Instead of using position you can use parent and offset:
   *
   * ```ts
   * const text = writer.createText( 'foo' );
   * writer.insert( text, paragraph, 5 );
   * ```
   *
   * You can also use `end` instead of the offset to insert at the end:
   *
   * ```ts
   * const text = writer.createText( 'foo' );
   * writer.insert( text, paragraph, 'end' );
   * ```
   *
   * Or insert before or after another element:
   *
   * ```ts
   * const paragraph = writer.createElement( 'paragraph' );
   * writer.insert( paragraph, anotherParagraph, 'after' );
   * ```
   *
   * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.
   *
   * Note that if the item already has parent it will be removed from the previous parent.
   *
   * Note that you cannot re-insert a node from a document to a different document or a document fragment. In this case,
   * `model-writer-insert-forbidden-move` is thrown.
   *
   * If you want to move {@link module:engine/model/range~Range range} instead of an
   * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.
   *
   * **Note:** For a paste-like content insertion mechanism see
   * {@link module:engine/model/model~Model#insertContent `model.insertContent()`}.
   *
   * @param item Item or document fragment to insert.
   * @param offset Offset or one of the flags. Used only when second parameter is a {@link module:engine/model/item~Item model item}.
   */
  insert(e, t, n = 0) {
    if (this._assertWriterUsedCorrectly(), e instanceof j && e.data == "")
      return;
    const s = y._createAt(t, n);
    if (e.parent)
      if (Su(e.root, s.root)) {
        this.move(_._createOn(e), s);
        return;
      } else {
        if (e.root.document)
          throw new g("model-writer-insert-forbidden-move", this);
        this.remove(e);
      }
    const o = s.root.document ? s.root.document.version : null, r = new _e(s, e, o);
    if (e instanceof j && (r.shouldReceiveAttributes = !0), this.batch.addOperation(r), this.model.applyOperation(r), e instanceof Tt)
      for (const [a, l] of e.markers) {
        const c = y._createAt(l.root, 0), d = { range: new _(l.start._getCombined(c, s), l.end._getCombined(c, s)), usingOperation: !0, affectsData: !0 };
        this.model.markers.has(a) ? this.updateMarker(a, d) : this.addMarker(a, d);
      }
  }
  insertText(e, t, n, s) {
    t instanceof Tt || t instanceof $ || t instanceof y ? this.insert(this.createText(e), t, n) : this.insert(this.createText(e, t), n, s);
  }
  insertElement(e, t, n, s) {
    t instanceof Tt || t instanceof $ || t instanceof y ? this.insert(this.createElement(e), t, n) : this.insert(this.createElement(e, t), n, s);
  }
  /**
   * Inserts item at the end of the given parent.
   *
   * ```ts
   * const paragraph = writer.createElement( 'paragraph' );
   * writer.append( paragraph, root );
   * ```
   *
   * Note that if the item already has parent it will be removed from the previous parent.
   *
   * If you want to move {@link module:engine/model/range~Range range} instead of an
   * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.
   *
   * @param item Item or document fragment to insert.
   */
  append(e, t) {
    this.insert(e, t, "end");
  }
  appendText(e, t, n) {
    t instanceof Tt || t instanceof $ ? this.insert(this.createText(e), t, "end") : this.insert(this.createText(e, t), n, "end");
  }
  appendElement(e, t, n) {
    t instanceof Tt || t instanceof $ ? this.insert(this.createElement(e), t, "end") : this.insert(this.createElement(e, t), n, "end");
  }
  /**
   * Sets value of the attribute with given key on a {@link module:engine/model/item~Item model item}
   * or on a {@link module:engine/model/range~Range range}.
   *
   * @param key Attribute key.
   * @param value Attribute new value.
   * @param itemOrRange Model item or range on which the attribute will be set.
   */
  setAttribute(e, t, n) {
    if (this._assertWriterUsedCorrectly(), n instanceof _) {
      const s = n.getMinimalFlatRanges();
      for (const o of s)
        xu(this, e, t, o);
    } else
      Iu(this, e, t, n);
  }
  /**
   * Sets values of attributes on a {@link module:engine/model/item~Item model item}
   * or on a {@link module:engine/model/range~Range range}.
   *
   * ```ts
   * writer.setAttributes( {
   * 	bold: true,
   * 	italic: true
   * }, range );
   * ```
   *
   * @param attributes Attributes keys and values.
   * @param itemOrRange Model item or range on which the attributes will be set.
   */
  setAttributes(e, t) {
    for (const [n, s] of pt(e))
      this.setAttribute(n, s, t);
  }
  /**
   * Removes an attribute with given key from a {@link module:engine/model/item~Item model item}
   * or from a {@link module:engine/model/range~Range range}.
   *
   * @param key Attribute key.
   * @param itemOrRange Model item or range from which the attribute will be removed.
   */
  removeAttribute(e, t) {
    if (this._assertWriterUsedCorrectly(), t instanceof _) {
      const n = t.getMinimalFlatRanges();
      for (const s of n)
        xu(this, e, null, s);
    } else
      Iu(this, e, null, t);
  }
  /**
   * Removes all attributes from all elements in the range or from the given item.
   *
   * @param itemOrRange Model item or range from which all attributes will be removed.
   */
  clearAttributes(e) {
    this._assertWriterUsedCorrectly();
    const t = (n) => {
      for (const s of n.getAttributeKeys())
        this.removeAttribute(s, n);
    };
    if (!(e instanceof _))
      t(e);
    else
      for (const n of e.getItems())
        t(n);
  }
  /**
   * Moves all items in the source range to the target position.
   *
   * ```ts
   * writer.move( sourceRange, targetPosition );
   * ```
   *
   * Instead of the target position you can use parent and offset or define that range should be moved to the end
   * or before or after chosen item:
   *
   * ```ts
   * // Moves all items in the range to the paragraph at offset 5:
   * writer.move( sourceRange, paragraph, 5 );
   * // Moves all items in the range to the end of a blockquote:
   * writer.move( sourceRange, blockquote, 'end' );
   * // Moves all items in the range to a position after an image:
   * writer.move( sourceRange, image, 'after' );
   * ```
   *
   * These parameters work the same way as {@link #createPositionAt `writer.createPositionAt()`}.
   *
   * Note that items can be moved only within the same tree. It means that you can move items within the same root
   * (element or document fragment) or between {@link module:engine/model/document~Document#roots documents roots},
   * but you can not move items from document fragment to the document or from one detached element to another. Use
   * {@link module:engine/model/writer~Writer#insert} in such cases.
   *
   * @param range Source range.
   * @param offset Offset or one of the flags. Used only when second parameter is a {@link module:engine/model/item~Item model item}.
   */
  move(e, t, n) {
    if (this._assertWriterUsedCorrectly(), !(e instanceof _))
      throw new g("writer-move-invalid-range", this);
    if (!e.isFlat)
      throw new g("writer-move-range-not-flat", this);
    const s = y._createAt(t, n);
    if (s.isEqual(e.start))
      return;
    if (this._addOperationForAffectedMarkers("move", e), !Su(e.root, s.root))
      throw new g("writer-move-different-document", this);
    const o = e.root.document ? e.root.document.version : null, r = new H(e.start, e.end.offset - e.start.offset, s, o);
    this.batch.addOperation(r), this.model.applyOperation(r);
  }
  /**
   * Removes given model {@link module:engine/model/item~Item item} or {@link module:engine/model/range~Range range}.
   *
   * @param itemOrRange Model item or range to remove.
   */
  remove(e) {
    this._assertWriterUsedCorrectly();
    const n = (e instanceof _ ? e : _._createOn(e)).getMinimalFlatRanges().reverse();
    for (const s of n)
      this._addOperationForAffectedMarkers("move", s), K2(s.start, s.end.offset - s.start.offset, this.batch, this.model);
  }
  /**
   * Merges two siblings at the given position.
   *
   * Node before and after the position have to be an element. Otherwise `writer-merge-no-element-before` or
   * `writer-merge-no-element-after` error will be thrown.
   *
   * @param position Position between merged elements.
   */
  merge(e) {
    this._assertWriterUsedCorrectly();
    const t = e.nodeBefore, n = e.nodeAfter;
    if (this._addOperationForAffectedMarkers("merge", e), !(t instanceof $))
      throw new g("writer-merge-no-element-before", this);
    if (!(n instanceof $))
      throw new g("writer-merge-no-element-after", this);
    e.root.document ? this._merge(e) : this._mergeDetached(e);
  }
  /**
   * Shortcut for {@link module:engine/model/model~Model#createPositionFromPath `Model#createPositionFromPath()`}.
   *
   * @param root Root of the position.
   * @param path Position path. See {@link module:engine/model/position~Position#path}.
   * @param stickiness Position stickiness. See {@link module:engine/model/position~PositionStickiness}.
   */
  createPositionFromPath(e, t, n) {
    return this.model.createPositionFromPath(e, t, n);
  }
  /**
   * Shortcut for {@link module:engine/model/model~Model#createPositionAt `Model#createPositionAt()`}.
   *
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/model/item~Item model item}.
   */
  createPositionAt(e, t) {
    return this.model.createPositionAt(e, t);
  }
  /**
   * Shortcut for {@link module:engine/model/model~Model#createPositionAfter `Model#createPositionAfter()`}.
   *
   * @param item Item after which the position should be placed.
   */
  createPositionAfter(e) {
    return this.model.createPositionAfter(e);
  }
  /**
   * Shortcut for {@link module:engine/model/model~Model#createPositionBefore `Model#createPositionBefore()`}.
   *
   * @param item Item after which the position should be placed.
   */
  createPositionBefore(e) {
    return this.model.createPositionBefore(e);
  }
  /**
   * Shortcut for {@link module:engine/model/model~Model#createRange `Model#createRange()`}.
   *
   * @param start Start position.
   * @param end End position. If not set, range will be collapsed at `start` position.
   */
  createRange(e, t) {
    return this.model.createRange(e, t);
  }
  /**
   * Shortcut for {@link module:engine/model/model~Model#createRangeIn `Model#createRangeIn()`}.
   *
   * @param element Element which is a parent for the range.
   */
  createRangeIn(e) {
    return this.model.createRangeIn(e);
  }
  /**
   * Shortcut for {@link module:engine/model/model~Model#createRangeOn `Model#createRangeOn()`}.
   *
   * @param element Element which is a parent for the range.
   */
  createRangeOn(e) {
    return this.model.createRangeOn(e);
  }
  createSelection(...e) {
    return this.model.createSelection(...e);
  }
  /**
   * Performs merge action in a detached tree.
   *
   * @param position Position between merged elements.
   */
  _mergeDetached(e) {
    const t = e.nodeBefore, n = e.nodeAfter;
    this.move(_._createIn(n), y._createAt(t, "end")), this.remove(n);
  }
  /**
   * Performs merge action in a non-detached tree.
   *
   * @param position Position between merged elements.
   */
  _merge(e) {
    const t = y._createAt(e.nodeBefore, "end"), n = y._createAt(e.nodeAfter, 0), s = e.root.document.graveyard, o = new y(s, [0]), r = e.root.document.version, a = new oe(n, e.nodeAfter.maxOffset, t, o, r);
    this.batch.addOperation(a), this.model.applyOperation(a);
  }
  /**
   * Renames the given element.
   *
   * @param element The element to rename.
   * @param newName New element name.
   */
  rename(e, t) {
    if (this._assertWriterUsedCorrectly(), !(e instanceof $))
      throw new g("writer-rename-not-element-instance", this);
    const n = e.root.document ? e.root.document.version : null, s = new Ve(y._createBefore(e), e.name, t, n);
    this.batch.addOperation(s), this.model.applyOperation(s);
  }
  /**
   * Splits elements starting from the given position and going to the top of the model tree as long as given
   * `limitElement` is reached. When `limitElement` is not defined then only the parent of the given position will be split.
   *
   * The element needs to have a parent. It cannot be a root element nor a document fragment.
   * The `writer-split-element-no-parent` error will be thrown if you try to split an element with no parent.
   *
   * @param position Position of split.
   * @param limitElement Stop splitting when this element will be reached.
   * @returns Split result with properties:
   * * `position` - Position between split elements.
   * * `range` - Range that stars from the end of the first split element and ends at the beginning of the first copy element.
   */
  split(e, t) {
    this._assertWriterUsedCorrectly();
    let n = e.parent;
    if (!n.parent)
      throw new g("writer-split-element-no-parent", this);
    if (t || (t = n.parent), !e.parent.getAncestors({ includeSelf: !0 }).includes(t))
      throw new g("writer-split-invalid-limit-element", this);
    let s, o;
    do {
      const r = n.root.document ? n.root.document.version : null, a = n.maxOffset - e.offset, l = K.getInsertionPosition(e), c = new K(e, a, l, null, r);
      this.batch.addOperation(c), this.model.applyOperation(c), !s && !o && (s = n, o = e.parent.nextSibling), e = this.createPositionAfter(e.parent), n = e.parent;
    } while (n !== t);
    return {
      position: e,
      range: new _(y._createAt(s, "end"), y._createAt(o, 0))
    };
  }
  /**
   * Wraps the given range with the given element or with a new element (if a string was passed).
   *
   * **Note:** range to wrap should be a "flat range" (see {@link module:engine/model/range~Range#isFlat `Range#isFlat`}).
   * If not, an error will be thrown.
   *
   * @param range Range to wrap.
   * @param elementOrString Element or name of element to wrap the range with.
   */
  wrap(e, t) {
    if (this._assertWriterUsedCorrectly(), !e.isFlat)
      throw new g("writer-wrap-range-not-flat", this);
    const n = t instanceof $ ? t : new $(t);
    if (n.childCount > 0)
      throw new g("writer-wrap-element-not-empty", this);
    if (n.parent !== null)
      throw new g("writer-wrap-element-attached", this);
    this.insert(n, e.start);
    const s = new _(e.start.getShiftedBy(1), e.end.getShiftedBy(1));
    this.move(s, y._createAt(n, 0));
  }
  /**
   * Unwraps children of the given element – all its children are moved before it and then the element is removed.
   * Throws error if you try to unwrap an element which does not have a parent.
   *
   * @param element Element to unwrap.
   */
  unwrap(e) {
    if (this._assertWriterUsedCorrectly(), e.parent === null)
      throw new g("writer-unwrap-element-no-parent", this);
    this.move(_._createIn(e), this.createPositionAfter(e)), this.remove(e);
  }
  /**
   * Adds a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks
   * changes in the document and updates its range automatically, when model tree changes.
   *
   * As the first parameter you can set marker name.
   *
   * The required `options.usingOperation` parameter lets you decide if the marker should be managed by operations or not. See
   * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between
   * markers managed by operations and not-managed by operations.
   *
   * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be
   * `true` when the marker change changes the data returned by the
   * {@link module:core/editor/editor~Editor#getData `editor.getData()`} method.
   * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.
   * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.
   *
   * Create marker directly base on marker's name:
   *
   * ```ts
   * addMarker( markerName, { range, usingOperation: false } );
   * ```
   *
   * Create marker using operation:
   *
   * ```ts
   * addMarker( markerName, { range, usingOperation: true } );
   * ```
   *
   * Create marker that affects the editor data:
   *
   * ```ts
   * addMarker( markerName, { range, usingOperation: false, affectsData: true } );
   * ```
   *
   * Note: For efficiency reasons, it's best to create and keep as little markers as possible.
   *
   * @see module:engine/model/markercollection~Marker
   * @param name Name of a marker to create - must be unique.
   * @param options.usingOperation Flag indicating that the marker should be added by MarkerOperation.
   * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.
   * @param options.range Marker range.
   * @param options.affectsData Flag indicating that the marker changes the editor data.
   * @returns Marker that was set.
   */
  addMarker(e, t) {
    if (this._assertWriterUsedCorrectly(), !t || typeof t.usingOperation != "boolean")
      throw new g("writer-addmarker-no-usingoperation", this);
    const n = t.usingOperation, s = t.range, o = t.affectsData === void 0 ? !1 : t.affectsData;
    if (this.model.markers.has(e))
      throw new g("writer-addmarker-marker-exists", this);
    if (!s)
      throw new g("writer-addmarker-no-range", this);
    return n ? (vi(this, e, null, s, o), this.model.markers.get(e)) : this.model.markers._set(e, s, n, o);
  }
  /**
   * Adds, updates or refreshes a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks
   * changes in the document and updates its range automatically, when model tree changes. Still, it is possible to change the
   * marker's range directly using this method.
   *
   * As the first parameter you can set marker name or instance. If none of them is provided, new marker, with a unique
   * name is created and returned.
   *
   * **Note**: If you want to change the {@link module:engine/view/element~Element view element} of the marker while its data in the model
   * remains the same, use the dedicated {@link module:engine/controller/editingcontroller~EditingController#reconvertMarker} method.
   *
   * The `options.usingOperation` parameter lets you change if the marker should be managed by operations or not. See
   * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between
   * markers managed by operations and not-managed by operations. It is possible to change this option for an existing marker.
   *
   * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be
   * `true` when the marker change changes the data returned by
   * the {@link module:core/editor/editor~Editor#getData `editor.getData()`} method.
   * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.
   * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.
   *
   * Update marker directly base on marker's name:
   *
   * ```ts
   * updateMarker( markerName, { range } );
   * ```
   *
   * Update marker using operation:
   *
   * ```ts
   * updateMarker( marker, { range, usingOperation: true } );
   * updateMarker( markerName, { range, usingOperation: true } );
   * ```
   *
   * Change marker's option (start using operations to manage it):
   *
   * ```ts
   * updateMarker( marker, { usingOperation: true } );
   * ```
   *
   * Change marker's option (inform the engine, that the marker does not affect the data anymore):
   *
   * ```ts
   * updateMarker( markerName, { affectsData: false } );
   * ```
   *
   * @see module:engine/model/markercollection~Marker
   * @param markerOrName Name of a marker to update, or a marker instance.
   * @param options If options object is not defined then marker will be refreshed by triggering
   * downcast conversion for this marker with the same data.
   * @param options.range Marker range to update.
   * @param options.usingOperation Flag indicated whether the marker should be added by MarkerOperation.
   * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.
   * @param options.affectsData Flag indicating that the marker changes the editor data.
   */
  updateMarker(e, t) {
    this._assertWriterUsedCorrectly();
    const n = typeof e == "string" ? e : e.name, s = this.model.markers.get(n);
    if (!s)
      throw new g("writer-updatemarker-marker-not-exists", this);
    if (!t) {
      D("writer-updatemarker-reconvert-using-editingcontroller", { markerName: n }), this.model.markers._refresh(s);
      return;
    }
    const o = typeof t.usingOperation == "boolean", r = typeof t.affectsData == "boolean", a = r ? t.affectsData : s.affectsData;
    if (!o && !t.range && !r)
      throw new g("writer-updatemarker-wrong-options", this);
    const l = s.getRange(), c = t.range ? t.range : l;
    if (o && t.usingOperation !== s.managedUsingOperations) {
      t.usingOperation ? vi(this, n, null, c, a) : (vi(this, n, l, null, a), this.model.markers._set(n, c, void 0, a));
      return;
    }
    s.managedUsingOperations ? vi(this, n, l, c, a) : this.model.markers._set(n, c, void 0, a);
  }
  /**
   * Removes given {@link module:engine/model/markercollection~Marker marker} or marker with given name.
   * The marker is removed accordingly to how it has been created, so if the marker was created using operation,
   * it will be destroyed using operation.
   *
   * @param markerOrName Marker or marker name to remove.
   */
  removeMarker(e) {
    this._assertWriterUsedCorrectly();
    const t = typeof e == "string" ? e : e.name;
    if (!this.model.markers.has(t))
      throw new g("writer-removemarker-no-marker", this);
    const n = this.model.markers.get(t);
    if (!n.managedUsingOperations) {
      this.model.markers._remove(t);
      return;
    }
    const s = n.getRange();
    vi(this, t, s, null, n.affectsData);
  }
  /**
   * Adds a new root to the document (or re-attaches a {@link #detachRoot detached root}).
   *
   * Throws an error, if trying to add a root that is already added and attached.
   *
   * @param rootName Name of the added root.
   * @param elementName The element name. Defaults to `'$root'` which also has some basic schema defined
   * (e.g. `$block` elements are allowed inside the `$root`). Make sure to define a proper schema if you use a different name.
   * @returns The added root element.
   */
  addRoot(e, t = "$root") {
    this._assertWriterUsedCorrectly();
    const n = this.model.document.getRoot(e);
    if (n && n.isAttached())
      throw new g("writer-addroot-root-exists", this);
    const s = this.model.document, o = new mt(e, t, !0, s, s.version);
    return this.batch.addOperation(o), this.model.applyOperation(o), this.model.document.getRoot(e);
  }
  /**
   * Detaches the root from the document.
   *
   * All content and markers are removed from the root upon detaching. New content and new markers cannot be added to the root, as long
   * as it is detached.
   *
   * A root cannot be fully removed from the document, it can be only detached. A root is permanently removed only after you
   * re-initialize the editor and do not specify the root in the initial data.
   *
   * A detached root can be re-attached using {@link #addRoot}.
   *
   * Throws an error if the root does not exist or the root is already detached.
   *
   * @param rootOrName Name of the detached root.
   */
  detachRoot(e) {
    this._assertWriterUsedCorrectly();
    const t = typeof e == "string" ? this.model.document.getRoot(e) : e;
    if (!t || !t.isAttached())
      throw new g("writer-detachroot-no-root", this);
    for (const o of this.model.markers)
      o.getRange().root === t && this.removeMarker(o);
    for (const o of t.getAttributeKeys())
      this.removeAttribute(o, t);
    this.remove(this.createRangeIn(t));
    const n = this.model.document, s = new mt(t.rootName, t.name, !1, n, n.version);
    this.batch.addOperation(s), this.model.applyOperation(s);
  }
  setSelection(...e) {
    this._assertWriterUsedCorrectly(), this.model.document.selection._setTo(...e);
  }
  /**
   * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.
   *
   * The location can be specified in the same form as
   * {@link #createPositionAt `writer.createPositionAt()`} parameters.
   *
   * @param itemOrPosition
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/model/item~Item model item}.
   */
  setSelectionFocus(e, t) {
    this._assertWriterUsedCorrectly(), this.model.document.selection._setFocus(e, t);
  }
  setSelectionAttribute(e, t) {
    if (this._assertWriterUsedCorrectly(), typeof e == "string")
      this._setSelectionAttribute(e, t);
    else
      for (const [n, s] of pt(e))
        this._setSelectionAttribute(n, s);
  }
  /**
   * Removes attribute(s) with given key(s) from the selection.
   *
   * Remove one attribute:
   *
   * ```ts
   * writer.removeSelectionAttribute( 'italic' );
   * ```
   *
   * Remove multiple attributes:
   *
   * ```ts
   * writer.removeSelectionAttribute( [ 'italic', 'bold' ] );
   * ```
   *
   * @param keyOrIterableOfKeys Key of the attribute to remove or an iterable of attribute keys to remove.
   */
  removeSelectionAttribute(e) {
    if (this._assertWriterUsedCorrectly(), typeof e == "string")
      this._removeSelectionAttribute(e);
    else
      for (const t of e)
        this._removeSelectionAttribute(t);
  }
  /**
   * Temporarily changes the {@link module:engine/model/documentselection~DocumentSelection#isGravityOverridden gravity}
   * of the selection from left to right.
   *
   * The gravity defines from which direction the selection inherits its attributes. If it's the default left gravity,
   * then the selection (after being moved by the user) inherits attributes from its left-hand side.
   * This method allows to temporarily override this behavior by forcing the gravity to the right.
   *
   * For the following model fragment:
   *
   * ```xml
   * <$text bold="true" linkHref="url">bar[]</$text><$text bold="true">biz</$text>
   * ```
   *
   * * Default gravity: selection will have the `bold` and `linkHref` attributes.
   * * Overridden gravity: selection will have `bold` attribute.
   *
   * **Note**: It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry
   * of the process.
   *
   * @returns The unique id which allows restoring the gravity.
   */
  overrideSelectionGravity() {
    return this.model.document.selection._overrideGravity();
  }
  /**
   * Restores {@link ~Writer#overrideSelectionGravity} gravity to default.
   *
   * Restoring the gravity is only possible using the unique identifier returned by
   * {@link ~Writer#overrideSelectionGravity}. Note that the gravity remains overridden as long as won't be restored
   * the same number of times it was overridden.
   *
   * @param uid The unique id returned by {@link ~Writer#overrideSelectionGravity}.
   */
  restoreSelectionGravity(e) {
    this.model.document.selection._restoreGravity(e);
  }
  /**
   * @param key Key of the attribute to remove.
   * @param value Attribute value.
   */
  _setSelectionAttribute(e, t) {
    const n = this.model.document.selection;
    if (n.isCollapsed && n.anchor.parent.isEmpty) {
      const s = at._getStoreAttributeKey(e);
      this.setAttribute(s, t, n.anchor.parent);
    }
    n._setAttribute(e, t);
  }
  /**
   * @param key Key of the attribute to remove.
   */
  _removeSelectionAttribute(e) {
    const t = this.model.document.selection;
    if (t.isCollapsed && t.anchor.parent.isEmpty) {
      const n = at._getStoreAttributeKey(e);
      this.removeAttribute(n, t.anchor.parent);
    }
    t._removeAttribute(e);
  }
  /**
   * Throws `writer-detached-writer-tries-to-modify-model` error when the writer is used outside of the `change()` block.
   */
  _assertWriterUsedCorrectly() {
    if (this.model._currentWriter !== this)
      throw new g("writer-incorrect-use", this);
  }
  /**
   * For given action `type` and `positionOrRange` where the action happens, this function finds all affected markers
   * and applies a marker operation with the new marker range equal to the current range. Thanks to this, the marker range
   * can be later correctly processed during undo.
   *
   * @param type Writer action type.
   * @param positionOrRange Position or range where the writer action happens.
   */
  _addOperationForAffectedMarkers(e, t) {
    for (const n of this.model.markers) {
      if (!n.managedUsingOperations)
        continue;
      const s = n.getRange();
      let o = !1;
      if (e === "move") {
        const r = t;
        o = r.containsPosition(s.start) || r.start.isEqual(s.start) || r.containsPosition(s.end) || r.end.isEqual(s.end);
      } else {
        const r = t, a = r.nodeBefore, l = r.nodeAfter, c = s.start.parent == a && s.start.isAtEnd, u = s.end.parent == l && s.end.offset == 0, d = s.end.nodeAfter == l, h = s.start.nodeAfter == l;
        o = c || u || d || h;
      }
      o && this.updateMarker(n.name, { range: s });
    }
  }
}
function xu(i, e, t, n) {
  const s = i.model, o = s.document;
  let r = n.start, a, l, c;
  for (const d of n.getWalker({ shallow: !0 }))
    c = d.item.getAttribute(e), a && l != c && (l != t && u(), r = a), a = d.nextPosition, l = c;
  a instanceof y && a != r && l != t && u();
  function u() {
    const d = new _(r, a), h = d.root.document ? o.version : null, f = new le(d, e, l, t, h);
    i.batch.addOperation(f), s.applyOperation(f);
  }
}
function Iu(i, e, t, n) {
  const s = i.model, o = s.document, r = n.getAttribute(e);
  let a, l;
  if (r != t) {
    if (n.root === n) {
      const u = n.document ? o.version : null;
      l = new It(n, e, r, t, u);
    } else {
      a = new _(y._createBefore(n), i.createPositionAfter(n));
      const u = a.root.document ? o.version : null;
      l = new le(a, e, r, t, u);
    }
    i.batch.addOperation(l), s.applyOperation(l);
  }
}
function vi(i, e, t, n, s) {
  const o = i.model, r = o.document, a = new Re(e, t, n, o.markers, !!s, r.version);
  i.batch.addOperation(a), o.applyOperation(a);
}
function K2(i, e, t, n) {
  let s;
  if (i.root.document) {
    const o = n.document, r = new y(o.graveyard, [0]);
    s = new H(i, e, r, o.version);
  } else
    s = new q2(i, e);
  t.addOperation(s), n.applyOperation(s);
}
function Su(i, e) {
  return i === e || i instanceof To && e instanceof To;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Z2(i, e, t = {}) {
  if (e.isCollapsed)
    return;
  const n = e.getFirstRange();
  if (n.root.rootName == "$graveyard")
    return;
  const s = i.schema;
  i.change((o) => {
    if (!t.doNotResetEntireContent && s5(s, e)) {
      i5(o, e);
      return;
    }
    const r = {};
    if (!t.doNotAutoparagraph) {
      const c = e.getSelectedElement();
      c && Object.assign(r, s.getAttributesWithProperty(c, "copyOnReplace", !0));
    }
    const [a, l] = J2(n);
    a.isTouching(l) || o.remove(o.createRange(a, l)), t.leaveUnmerged || (Q2(o, a, l), s.removeDisallowedAttributes(a.parent.getChildren(), o)), sg(o, e, a), !t.doNotAutoparagraph && t5(s, a) && ig(o, a, e, r), a.detach(), l.detach();
  });
}
function J2(i) {
  const e = i.root.document.model, t = i.start;
  let n = i.end;
  if (e.hasContent(i, { ignoreMarkers: !0 })) {
    const s = X2(n);
    if (s && n.isTouching(e.createPositionAt(s, 0))) {
      const o = e.createSelection(i);
      e.modifySelection(o, { direction: "backward" });
      const r = o.getLastPosition(), a = e.createRange(r, n);
      e.hasContent(a, { ignoreMarkers: !0 }) || (n = r);
    }
  }
  return [
    ce.fromPosition(t, "toPrevious"),
    ce.fromPosition(n, "toNext")
  ];
}
function X2(i) {
  const e = i.parent, t = e.root.document.model.schema, n = e.getAncestors({ parentFirst: !0, includeSelf: !0 });
  for (const s of n) {
    if (t.isLimit(s))
      return null;
    if (t.isBlock(s))
      return s;
  }
}
function Q2(i, e, t) {
  const n = i.model;
  if (!yl(i.model.schema, e, t))
    return;
  const [s, o] = e5(e, t);
  !s || !o || (!n.hasContent(s, { ignoreMarkers: !0 }) && n.hasContent(o, { ignoreMarkers: !0 }) ? ng(i, e, t, s.parent) : tg(i, e, t, s.parent));
}
function tg(i, e, t, n) {
  const s = e.parent, o = t.parent;
  if (!(s == n || o == n)) {
    for (e = i.createPositionAfter(s), t = i.createPositionBefore(o), t.isEqual(e) || i.insert(o, e), i.merge(e); t.parent.isEmpty; ) {
      const r = t.parent;
      t = i.createPositionBefore(r), i.remove(r);
    }
    yl(i.model.schema, e, t) && tg(i, e, t, n);
  }
}
function ng(i, e, t, n) {
  const s = e.parent, o = t.parent;
  if (!(s == n || o == n)) {
    for (e = i.createPositionAfter(s), t = i.createPositionBefore(o), t.isEqual(e) || i.insert(s, t); e.parent.isEmpty; ) {
      const r = e.parent;
      e = i.createPositionBefore(r), i.remove(r);
    }
    t = i.createPositionBefore(o), Y2(i, t), yl(i.model.schema, e, t) && ng(i, e, t, n);
  }
}
function Y2(i, e) {
  const t = e.nodeBefore, n = e.nodeAfter;
  t.name != n.name && i.rename(t, n.name), i.clearAttributes(t), i.setAttributes(Object.fromEntries(n.getAttributes()), t), i.merge(e);
}
function yl(i, e, t) {
  const n = e.parent, s = t.parent;
  return n == s || i.isLimit(n) || i.isLimit(s) ? !1 : n5(e, t, i);
}
function e5(i, e) {
  const t = i.getAncestors(), n = e.getAncestors();
  let s = 0;
  for (; t[s] && t[s] == n[s]; )
    s++;
  return [t[s], n[s]];
}
function t5(i, e) {
  const t = i.checkChild(e, "$text"), n = i.checkChild(e, "paragraph");
  return !t && n;
}
function n5(i, e, t) {
  const n = new _(i, e);
  for (const s of n.getWalker())
    if (t.isLimit(s.item))
      return !1;
  return !0;
}
function ig(i, e, t, n = {}) {
  const s = i.createElement("paragraph");
  i.model.schema.setAllowedAttributes(s, n, i), i.insert(s, e), sg(i, t, i.createPositionAt(s, 0));
}
function i5(i, e) {
  const t = i.model.schema.getLimitElement(e);
  i.remove(i.createRangeIn(t)), ig(i, i.createPositionAt(t, 0), e);
}
function s5(i, e) {
  const t = i.getLimitElement(e);
  if (!e.containsEntireContent(t))
    return !1;
  const n = e.getFirstRange();
  return n.start.parent == n.end.parent ? !1 : i.checkChild(t, "paragraph");
}
function sg(i, e, t) {
  e instanceof at ? i.setSelection(t) : e.setTo(t);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function o5(i, e) {
  return i.change((t) => {
    const n = t.createDocumentFragment(), s = e.getFirstRange();
    if (!s || s.isCollapsed)
      return n;
    const o = s.start.root, r = s.start.getCommonPath(s.end), a = o.getNodeByPath(r);
    let l;
    s.start.parent == s.end.parent ? l = s : l = t.createRange(t.createPositionAt(a, s.start.path[r.length]), t.createPositionAt(a, s.end.path[r.length] + 1));
    const c = l.end.offset - l.start.offset;
    for (const u of l.getItems({ shallow: !0 }))
      u.is("$textProxy") ? t.appendText(u.data, u.getAttributes(), n) : t.append(t.cloneElement(u, !0), n);
    if (l != s) {
      const u = s._getTransformedByMove(l.start, t.createPositionAt(n, 0), c)[0], d = t.createRange(t.createPositionAt(n, 0), u.start), h = t.createRange(u.end, t.createPositionAt(n, "end"));
      Pu(h, t), Pu(d, t);
    }
    return n;
  });
}
function Pu(i, e) {
  const t = [];
  Array.from(i.getItems({ direction: "backward" })).map((n) => e.createRangeOn(n)).filter((n) => (n.start.isAfter(i.start) || n.start.isEqual(i.start)) && (n.end.isBefore(i.end) || n.end.isEqual(i.end))).forEach((n) => {
    t.push(n.start.parent), e.remove(n);
  }), t.forEach((n) => {
    let s = n;
    for (; s.parent && s.isEmpty; ) {
      const o = e.createRangeOn(s);
      s = s.parent, e.remove(o);
    }
  });
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function r5(i, e, t) {
  return i.change((n) => {
    const s = t || i.document.selection;
    s.isCollapsed || i.deleteContent(s, { doNotAutoparagraph: !0 });
    const o = new a5(i, n, s.anchor), r = [];
    let a;
    if (e.is("documentFragment")) {
      if (e.markers.size) {
        const u = [];
        for (const [d, h] of e.markers) {
          const { start: f, end: m } = h, p = f.isEqual(m);
          u.push({ position: f, name: d, isCollapsed: p }, { position: m, name: d, isCollapsed: p });
        }
        u.sort(({ position: d }, { position: h }) => d.isBefore(h) ? 1 : -1);
        for (const { position: d, name: h, isCollapsed: f } of u) {
          let m = null, p = null;
          const w = d.parent === e && d.isAtStart, v = d.parent === e && d.isAtEnd;
          !w && !v ? (m = n.createElement("$marker"), n.insert(m, d)) : f && (p = w ? "start" : "end"), r.push({
            name: h,
            element: m,
            collapsed: p
          });
        }
      }
      a = e.getChildren();
    } else
      a = [e];
    o.handleNodes(a);
    let l = o.getSelectionRange();
    if (e.is("documentFragment") && r.length) {
      const u = l ? Pe.fromRange(l) : null, d = {};
      for (let h = r.length - 1; h >= 0; h--) {
        const { name: f, element: m, collapsed: p } = r[h], w = !d[f];
        if (w && (d[f] = []), m) {
          const v = n.createPositionAt(m, "before");
          d[f].push(v), n.remove(m);
        } else {
          const v = o.getAffectedRange();
          if (!v) {
            p && d[f].push(o.position);
            continue;
          }
          p ? d[f].push(v[p]) : d[f].push(w ? v.start : v.end);
        }
      }
      for (const [h, [f, m]] of Object.entries(d))
        f && m && f.root === m.root && f.root.document && !n.model.markers.has(h) && n.addMarker(h, {
          usingOperation: !0,
          affectsData: !0,
          range: new _(f, m)
        });
      u && (l = u.toRange(), u.detach());
    }
    /* istanbul ignore else -- @preserve */
    l && (s instanceof at ? n.setSelection(l) : s.setTo(l));
    const c = o.getAffectedRange() || i.createRange(s.anchor);
    return o.destroy(), c;
  });
}
class a5 {
  constructor(e, t, n) {
    this._firstNode = null, this._lastNode = null, this._lastAutoParagraph = null, this._filterAttributesOf = [], this._affectedStart = null, this._affectedEnd = null, this._nodeToSelect = null, this.model = e, this.writer = t, this.position = n, this.canMergeWith = /* @__PURE__ */ new Set([this.position.parent]), this.schema = e.schema, this._documentFragment = t.createDocumentFragment(), this._documentFragmentPosition = t.createPositionAt(this._documentFragment, 0);
  }
  /**
   * Handles insertion of a set of nodes.
   *
   * @param nodes Nodes to insert.
   */
  handleNodes(e) {
    for (const t of Array.from(e))
      this._handleNode(t);
    this._insertPartialFragment(), this._lastAutoParagraph && this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph), this._mergeOnRight(), this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer), this._filterAttributesOf = [];
  }
  /**
   * Updates the last node after the auto paragraphing.
   *
   * @param node The last auto paragraphing node.
   */
  _updateLastNodeFromAutoParagraph(e) {
    const t = this.writer.createPositionAfter(this._lastNode), n = this.writer.createPositionAfter(e);
    if (n.isAfter(t)) {
      this._lastNode = e;
      /* istanbul ignore if -- @preserve */
      if (this.position.parent != e || !this.position.isAtEnd)
        throw new g("insertcontent-invalid-insertion-position", this);
      this.position = n, this._setAffectedBoundaries(this.position);
    }
  }
  /**
   * Returns range to be selected after insertion.
   * Returns `null` if there is no valid range to select after insertion.
   */
  getSelectionRange() {
    return this._nodeToSelect ? _._createOn(this._nodeToSelect) : this.model.schema.getNearestSelectionRange(this.position);
  }
  /**
   * Returns a range which contains all the performed changes. This is a range that, if removed, would return the model to the state
   * before the insertion. Returns `null` if no changes were done.
   */
  getAffectedRange() {
    return this._affectedStart ? new _(this._affectedStart, this._affectedEnd) : null;
  }
  /**
   * Destroys `Insertion` instance.
   */
  destroy() {
    this._affectedStart && this._affectedStart.detach(), this._affectedEnd && this._affectedEnd.detach();
  }
  /**
   * Handles insertion of a single node.
   */
  _handleNode(e) {
    if (this.schema.isObject(e)) {
      this._handleObject(e);
      return;
    }
    let t = this._checkAndAutoParagraphToAllowedPosition(e);
    if (!t && (t = this._checkAndSplitToAllowedPosition(e), !t)) {
      this._handleDisallowedNode(e);
      return;
    }
    this._appendToFragment(e), this._firstNode || (this._firstNode = e), this._lastNode = e;
  }
  /**
   * Inserts the temporary DocumentFragment into the model.
   */
  _insertPartialFragment() {
    if (this._documentFragment.isEmpty)
      return;
    const e = ce.fromPosition(this.position, "toNext");
    this._setAffectedBoundaries(this.position), this._documentFragment.getChild(0) == this._firstNode && (this.writer.insert(this._firstNode, this.position), this._mergeOnLeft(), this.position = e.toPosition()), this._documentFragment.isEmpty || this.writer.insert(this._documentFragment, this.position), this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0), this.position = e.toPosition(), e.detach();
  }
  /**
   * @param node The object element.
   */
  _handleObject(e) {
    this._checkAndSplitToAllowedPosition(e) ? this._appendToFragment(e) : this._tryAutoparagraphing(e);
  }
  /**
   * @param node The disallowed node which needs to be handled.
   */
  _handleDisallowedNode(e) {
    e.is("element") ? this.handleNodes(e.getChildren()) : this._tryAutoparagraphing(e);
  }
  /**
   * Append a node to the temporary DocumentFragment.
   *
   * @param node The node to insert.
   */
  _appendToFragment(e) {
    /* istanbul ignore if -- @preserve */
    if (!this.schema.checkChild(this.position, e))
      throw new g("insertcontent-wrong-position", this, { node: e, position: this.position });
    this.writer.insert(e, this._documentFragmentPosition), this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(e.offsetSize), this.schema.isObject(e) && !this.schema.checkChild(this.position, "$text") ? this._nodeToSelect = e : this._nodeToSelect = null, this._filterAttributesOf.push(e);
  }
  /**
   * Sets `_affectedStart` and `_affectedEnd` to the given `position`. Should be used before a change is done during insertion process to
   * mark the affected range.
   *
   * This method is used before inserting a node or splitting a parent node. `_affectedStart` and `_affectedEnd` are also changed
   * during merging, but the logic there is more complicated so it is left out of this function.
   */
  _setAffectedBoundaries(e) {
    this._affectedStart || (this._affectedStart = ce.fromPosition(e, "toPrevious")), (!this._affectedEnd || this._affectedEnd.isBefore(e)) && (this._affectedEnd && this._affectedEnd.detach(), this._affectedEnd = ce.fromPosition(e, "toNext"));
  }
  /**
   * Merges the previous sibling of the first node if it should be merged.
   *
   * After the content was inserted we may try to merge it with its siblings.
   * This should happen only if the selection was in those elements initially.
   */
  _mergeOnLeft() {
    const e = this._firstNode;
    if (!(e instanceof $) || !this._canMergeLeft(e))
      return;
    const t = ce._createBefore(e);
    t.stickiness = "toNext";
    const n = ce.fromPosition(this.position, "toNext");
    this._affectedStart.isEqual(t) && (this._affectedStart.detach(), this._affectedStart = ce._createAt(t.nodeBefore, "end", "toPrevious")), this._firstNode === this._lastNode && (this._firstNode = t.nodeBefore, this._lastNode = t.nodeBefore), this.writer.merge(t), t.isEqual(this._affectedEnd) && this._firstNode === this._lastNode && (this._affectedEnd.detach(), this._affectedEnd = ce._createAt(t.nodeBefore, "end", "toNext")), this.position = n.toPosition(), n.detach(), this._filterAttributesOf.push(this.position.parent), t.detach();
  }
  /**
   * Merges the next sibling of the last node if it should be merged.
   *
   * After the content was inserted we may try to merge it with its siblings.
   * This should happen only if the selection was in those elements initially.
   */
  _mergeOnRight() {
    const e = this._lastNode;
    if (!(e instanceof $) || !this._canMergeRight(e))
      return;
    const t = ce._createAfter(e);
    t.stickiness = "toNext";
    /* istanbul ignore if -- @preserve */
    if (!this.position.isEqual(t))
      throw new g("insertcontent-invalid-insertion-position", this);
    this.position = y._createAt(t.nodeBefore, "end");
    const n = ce.fromPosition(this.position, "toPrevious");
    this._affectedEnd.isEqual(t) && (this._affectedEnd.detach(), this._affectedEnd = ce._createAt(t.nodeBefore, "end", "toNext")), this._firstNode === this._lastNode && (this._firstNode = t.nodeBefore, this._lastNode = t.nodeBefore), this.writer.merge(t), t.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode && (this._affectedStart.detach(), this._affectedStart = ce._createAt(t.nodeBefore, 0, "toPrevious")), this.position = n.toPosition(), n.detach(), this._filterAttributesOf.push(this.position.parent), t.detach();
  }
  /**
   * Checks whether specified node can be merged with previous sibling element.
   *
   * @param node The node which could potentially be merged.
   */
  _canMergeLeft(e) {
    const t = e.previousSibling;
    return t instanceof $ && this.canMergeWith.has(t) && this.model.schema.checkMerge(t, e);
  }
  /**
   * Checks whether specified node can be merged with next sibling element.
   *
   * @param node The node which could potentially be merged.
   */
  _canMergeRight(e) {
    const t = e.nextSibling;
    return t instanceof $ && this.canMergeWith.has(t) && this.model.schema.checkMerge(e, t);
  }
  /**
   * Tries wrapping the node in a new paragraph and inserting it this way.
   *
   * @param node The node which needs to be autoparagraphed.
   */
  _tryAutoparagraphing(e) {
    const t = this.writer.createElement("paragraph");
    this._getAllowedIn(this.position.parent, t) && this.schema.checkChild(t, e) && (t._appendChild(e), this._handleNode(t));
  }
  /**
   * Checks if a node can be inserted in the given position or it would be accepted if a paragraph would be inserted.
   * It also handles inserting the paragraph.
   *
   * @returns Whether an allowed position was found.
   * `false` is returned if the node isn't allowed at the current position or in auto paragraph, `true` if was.
   */
  _checkAndAutoParagraphToAllowedPosition(e) {
    if (this.schema.checkChild(this.position.parent, e))
      return !0;
    if (!this.schema.checkChild(this.position.parent, "paragraph") || !this.schema.checkChild("paragraph", e))
      return !1;
    this._insertPartialFragment();
    const t = this.writer.createElement("paragraph");
    return this.writer.insert(t, this.position), this._setAffectedBoundaries(this.position), this._lastAutoParagraph = t, this.position = this.writer.createPositionAt(t, 0), !0;
  }
  /**
   * @returns Whether an allowed position was found.
   * `false` is returned if the node isn't allowed at any position up in the tree, `true` if was.
   */
  _checkAndSplitToAllowedPosition(e) {
    const t = this._getAllowedIn(this.position.parent, e);
    if (!t)
      return !1;
    for (t != this.position.parent && this._insertPartialFragment(); t != this.position.parent; )
      if (this.position.isAtStart) {
        const n = this.position.parent;
        this.position = this.writer.createPositionBefore(n), n.isEmpty && n.parent === t && this.writer.remove(n);
      } else if (this.position.isAtEnd)
        this.position = this.writer.createPositionAfter(this.position.parent);
      else {
        const n = this.writer.createPositionAfter(this.position.parent);
        this._setAffectedBoundaries(this.position), this.writer.split(this.position), this.position = n, this.canMergeWith.add(this.position.nodeAfter);
      }
    return !0;
  }
  /**
   * Gets the element in which the given node is allowed. It checks the passed element and all its ancestors.
   *
   * @param contextElement The element in which context the node should be checked.
   * @param childNode The node to check.
   */
  _getAllowedIn(e, t) {
    return this.schema.checkChild(e, t) ? e : this.schema.isLimit(e) ? null : this._getAllowedIn(e.parent, t);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function l5(i, e, t, n = {}) {
  if (!i.schema.isObject(e))
    throw new g("insertobject-element-not-an-object", i, { object: e });
  const s = t || i.document.selection;
  let o = s;
  n.findOptimalPosition && i.schema.isBlock(e) && (o = i.createSelection(i.schema.findOptimalInsertionRange(s, n.findOptimalPosition)));
  const r = me(s.getSelectedBlocks()), a = {};
  return r && Object.assign(a, i.schema.getAttributesWithProperty(r, "copyOnReplace", !0)), i.change((l) => {
    o.isCollapsed || i.deleteContent(o, { doNotAutoparagraph: !0 });
    let c = e;
    const u = o.anchor.parent;
    !i.schema.checkChild(u, e) && i.schema.checkChild(u, "paragraph") && i.schema.checkChild("paragraph", e) && (c = l.createElement("paragraph"), l.insert(e, c)), i.schema.setAllowedAttributes(c, a, l);
    const d = i.insertContent(c, o);
    return d.isCollapsed || n.setSelection && c5(l, e, n.setSelection, a), d;
  });
}
function c5(i, e, t, n) {
  const s = i.model;
  if (t == "on") {
    i.setSelection(e, "on");
    return;
  }
  if (t != "after")
    throw new g("insertobject-invalid-place-parameter-value", s);
  let o = e.nextSibling;
  if (s.schema.isInline(e)) {
    i.setSelection(e, "after");
    return;
  }
  !(o && s.schema.checkChild(o, "$text")) && s.schema.checkChild(e.parent, "paragraph") && (o = i.createElement("paragraph"), s.schema.setAllowedAttributes(o, n, i), s.insertContent(o, i.createPositionAfter(e))), o && i.setSelection(o, 0);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const u5 = ' ,.?!:;"-()';
function d5(i, e, t = {}) {
  const n = i.schema, s = t.direction != "backward", o = t.unit ? t.unit : "character", r = !!t.treatEmojiAsSingleUnit, a = e.focus, l = new At({
    boundaries: g5(a, s),
    singleCharacters: !0,
    direction: s ? "forward" : "backward"
  }), c = { walker: l, schema: n, isForward: s, unit: o, treatEmojiAsSingleUnit: r };
  let u;
  for (; u = l.next(); ) {
    if (u.done)
      return;
    const d = h5(c, u.value);
    if (d) {
      e instanceof at ? i.change((h) => {
        h.setSelectionFocus(d);
      }) : e.setFocus(d);
      return;
    }
  }
}
function h5(i, e) {
  const { isForward: t, walker: n, unit: s, schema: o, treatEmojiAsSingleUnit: r } = i, { type: a, item: l, nextPosition: c } = e;
  if (a == "text")
    return i.unit === "word" ? m5(n, t) : f5(n, s, r);
  if (a == (t ? "elementStart" : "elementEnd")) {
    if (o.isSelectable(l))
      return y._createAt(l, t ? "after" : "before");
    if (o.checkChild(c, "$text"))
      return c;
  } else {
    if (o.isLimit(l)) {
      n.skip(() => !0);
      return;
    }
    if (o.checkChild(c, "$text"))
      return c;
  }
}
function f5(i, e, t) {
  const n = i.position.textNode;
  if (n) {
    const s = n.data;
    let o = i.position.offset - n.startOffset;
    for (; ul(s, o) || e == "character" && dl(s, o) || t && mm(s, o); )
      i.next(), o = i.position.offset - n.startOffset;
  }
  return i.position;
}
function m5(i, e) {
  let t = i.position.textNode;
  for (t || (t = e ? i.position.nodeAfter : i.position.nodeBefore); t && t.is("$text"); ) {
    const n = i.position.offset - t.startOffset;
    if (b5(t, n, e))
      t = e ? i.position.nodeAfter : i.position.nodeBefore;
    else {
      if (p5(t.data, n, e))
        break;
      i.next();
    }
  }
  return i.position;
}
function g5(i, e) {
  const t = i.root, n = y._createAt(t, e ? "end" : 0);
  return e ? new _(i, n) : new _(n, i);
}
function p5(i, e, t) {
  const n = e + (t ? 0 : -1);
  return u5.includes(i.charAt(n));
}
function b5(i, e, t) {
  return e === (t ? i.offsetSize : 0);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let w5 = class extends U() {
  // @if CK_DEBUG_ENGINE // private _operationLogs: Array<string>;
  // @if CK_DEBUG_ENGINE // private _appliedOperations: Array<Operation>;
  constructor() {
    super(), this.markers = new W2(), this.document = new $2(this), this.schema = new o2(), this._pendingChanges = [], this._currentWriter = null, ["deleteContent", "modifySelection", "getSelectedContent", "applyOperation"].forEach((e) => this.decorate(e)), this.on("applyOperation", (e, t) => {
      t[0]._validate();
    }, { priority: "highest" }), this.schema.register("$root", {
      isLimit: !0
    }), this.schema.register("$container", {
      allowIn: ["$root", "$container"]
    }), this.schema.register("$block", {
      allowIn: ["$root", "$container"],
      isBlock: !0
    }), this.schema.register("$blockObject", {
      allowWhere: "$block",
      isBlock: !0,
      isObject: !0
    }), this.schema.register("$inlineObject", {
      allowWhere: "$text",
      allowAttributesOf: "$text",
      isInline: !0,
      isObject: !0
    }), this.schema.register("$text", {
      allowIn: "$block",
      isInline: !0,
      isContent: !0
    }), this.schema.register("$clipboardHolder", {
      allowContentOf: "$root",
      allowChildren: "$text",
      isLimit: !0
    }), this.schema.register("$documentFragment", {
      allowContentOf: "$root",
      allowChildren: "$text",
      isLimit: !0
    }), this.schema.register("$marker"), this.schema.addChildCheck((e, t) => {
      if (t.name === "$marker")
        return !0;
    }), JT(this), this.document.registerPostFixer(Wm), this.on("insertContent", (e, [t, n]) => {
      e.return = r5(this, t, n);
    }), this.on("insertObject", (e, [t, n, s]) => {
      e.return = l5(this, t, n, s);
    }), this.on("canEditAt", (e) => {
      const t = !this.document.isReadOnly;
      e.return = t, t || e.stop();
    });
  }
  /**
   * The `change()` method is the primary way of changing the model. You should use it to modify all document nodes
   * (including detached nodes – i.e. nodes not added to the {@link module:engine/model/model~Model#document model document}),
   * the {@link module:engine/model/document~Document#selection document's selection}, and
   * {@link module:engine/model/model~Model#markers model markers}.
   *
   * ```ts
   * model.change( writer => {
   * 	writer.insertText( 'foo', paragraph, 'end' );
   * } );
   * ```
   *
   * All changes inside the change block use the same {@link module:engine/model/batch~Batch} so they are combined
   * into a single undo step.
   *
   * ```ts
   * model.change( writer => {
   * 	writer.insertText( 'foo', paragraph, 'end' ); // foo.
   *
   * 	model.change( writer => {
   * 		writer.insertText( 'bar', paragraph, 'end' ); // foobar.
   * 	} );
   *
   * 	writer.insertText( 'bom', paragraph, 'end' ); // foobarbom.
   * } );
   * ```
   *
   * The callback of the `change()` block is executed synchronously.
   *
   * You can also return a value from the change block.
   *
   * ```ts
   * const img = model.change( writer => {
   * 	return writer.createElement( 'img' );
   * } );
   * ```
   *
   * @see #enqueueChange
   * @typeParam TReturn The return type of the provided callback.
   * @param callback Callback function which may modify the model.
   */
  change(e) {
    try {
      return this._pendingChanges.length === 0 ? (this._pendingChanges.push({ batch: new Mn(), callback: e }), this._runPendingChanges()[0]) : e(this._currentWriter);
    } catch (t) {
      /* istanbul ignore next -- @preserve */
      g.rethrowUnexpectedError(t, this);
    }
  }
  enqueueChange(e, t) {
    try {
      e ? typeof e == "function" ? (t = e, e = new Mn()) : e instanceof Mn || (e = new Mn(e)) : e = new Mn(), this._pendingChanges.push({ batch: e, callback: t }), this._pendingChanges.length == 1 && this._runPendingChanges();
    } catch (n) {
      /* istanbul ignore next -- @preserve */
      g.rethrowUnexpectedError(n, this);
    }
  }
  /**
   * {@link module:utils/observablemixin~Observable#decorate Decorated} function for applying
   * {@link module:engine/model/operation/operation~Operation operations} to the model.
   *
   * This is a low-level way of changing the model. It is exposed for very specific use cases (like the undo feature).
   * Normally, to modify the model, you will want to use {@link module:engine/model/writer~Writer `Writer`}.
   * See also {@glink framework/architecture/editing-engine#changing-the-model Changing the model} section
   * of the {@glink framework/architecture/editing-engine Editing architecture} guide.
   *
   * @param operation The operation to apply.
   */
  applyOperation(e) {
    e._execute();
  }
  // @if CK_DEBUG_ENGINE // public getAppliedOperation(): string {
  // @if CK_DEBUG_ENGINE // 	if ( !this._appliedOperations ) {
  // @if CK_DEBUG_ENGINE // 		return '';
  // @if CK_DEBUG_ENGINE // 	}
  // @if CK_DEBUG_ENGINE // 	return this._appliedOperations.map( operation => JSON.stringify( operation ) ).join( '-------' );
  // @if CK_DEBUG_ENGINE // }
  // @if CK_DEBUG_ENGINE // public createReplayer( stringifiedOperations: string ): typeof OperationReplayer {
  // @if CK_DEBUG_ENGINE // 	return new OperationReplayer( this, '-------', stringifiedOperations );
  // @if CK_DEBUG_ENGINE // }
  /**
   * Inserts content at the position in the editor specified by the selection, as one would expect the paste
   * functionality to work.
   *
   * **Note**: If you want to insert an {@glink framework/deep-dive/schema#object-elements object element}
   * (e.g. a {@link module:widget/utils~toWidget widget}), see {@link #insertObject} instead.
   *
   * This is a high-level method. It takes the {@link #schema schema} into consideration when inserting
   * the content, clears the given selection's content before inserting nodes and moves the selection
   * to its target position at the end of the process.
   * It can split elements, merge them, wrap bare text nodes with paragraphs, etc. &ndash; just like the
   * pasting feature should do.
   *
   * For lower-level methods see {@link module:engine/model/writer~Writer `Writer`}.
   *
   * This method, unlike {@link module:engine/model/writer~Writer `Writer`}'s methods, does not have to be used
   * inside a {@link #change `change()` block}.
   *
   * # Conversion and schema
   *
   * Inserting elements and text nodes into the model is not enough to make CKEditor 5 render that content
   * to the user. CKEditor 5 implements a model-view-controller architecture and what `model.insertContent()` does
   * is only adding nodes to the model. Additionally, you need to define
   * {@glink framework/architecture/editing-engine#conversion converters} between the model and view
   * and define those nodes in the {@glink framework/architecture/editing-engine#schema schema}.
   *
   * So, while this method may seem similar to CKEditor 4 `editor.insertHtml()` (in fact, both methods
   * are used for paste-like content insertion), the CKEditor 5 method cannot be use to insert arbitrary HTML
   * unless converters are defined for all elements and attributes in that HTML.
   *
   * # Examples
   *
   * Using `insertContent()` with a manually created model structure:
   *
   * ```ts
   * // Let's create a document fragment containing such content as:
   * //
   * // <paragraph>foo</paragraph>
   * // <blockQuote>
   * //    <paragraph>bar</paragraph>
   * // </blockQuote>
   * const docFrag = editor.model.change( writer => {
   * 	const p1 = writer.createElement( 'paragraph' );
   * 	const p2 = writer.createElement( 'paragraph' );
   * 	const blockQuote = writer.createElement( 'blockQuote' );
   * 	const docFrag = writer.createDocumentFragment();
   *
   * 	writer.append( p1, docFrag );
   * 	writer.append( blockQuote, docFrag );
   * 	writer.append( p2, blockQuote );
   * 	writer.insertText( 'foo', p1 );
   * 	writer.insertText( 'bar', p2 );
   *
   * 	return docFrag;
   * } );
   *
   * // insertContent() does not have to be used in a change() block. It can, though,
   * // so this code could be moved to the callback defined above.
   * editor.model.insertContent( docFrag );
   * ```
   *
   * Using `insertContent()` with an HTML string converted to a model document fragment (similar to the pasting mechanism):
   *
   * ```ts
   * // You can create your own HtmlDataProcessor instance or use editor.data.processor
   * // if you have not overridden the default one (which is the HtmlDataProcessor instance).
   * const htmlDP = new HtmlDataProcessor( viewDocument );
   *
   * // Convert an HTML string to a view document fragment:
   * const viewFragment = htmlDP.toView( htmlString );
   *
   * // Convert the view document fragment to a model document fragment
   * // in the context of $root. This conversion takes the schema into
   * // account so if, for example, the view document fragment contained a bare text node,
   * // this text node cannot be a child of $root, so it will be automatically
   * // wrapped with a <paragraph>. You can define the context yourself (in the second parameter),
   * // and e.g. convert the content like it would happen in a <paragraph>.
   * // Note: The clipboard feature uses a custom context called $clipboardHolder
   * // which has a loosened schema.
   * const modelFragment = editor.data.toModel( viewFragment );
   *
   * editor.model.insertContent( modelFragment );
   * ```
   *
   * By default this method will use the document selection but it can also be used with a position, range or selection instance.
   *
   * ```ts
   * // Insert text at the current document selection position.
   * editor.model.change( writer => {
   * 	editor.model.insertContent( writer.createText( 'x' ) );
   * } );
   *
   * // Insert text at a given position - the document selection will not be modified.
   * editor.model.change( writer => {
   * 	editor.model.insertContent( writer.createText( 'x' ), doc.getRoot(), 2 );
   *
   * 	// Which is a shorthand for:
   * 	editor.model.insertContent( writer.createText( 'x' ), writer.createPositionAt( doc.getRoot(), 2 ) );
   * } );
   * ```
   *
   * If you want the document selection to be moved to the inserted content, use the
   * {@link module:engine/model/writer~Writer#setSelection `setSelection()`} method of the writer after inserting
   * the content:
   *
   * ```ts
   * editor.model.change( writer => {
   * 	const paragraph = writer.createElement( 'paragraph' );
   *
   * 	// Insert an empty paragraph at the beginning of the root.
   * 	editor.model.insertContent( paragraph, writer.createPositionAt( editor.model.document.getRoot(), 0 ) );
   *
   * 	// Move the document selection to the inserted paragraph.
   * 	writer.setSelection( paragraph, 'in' );
   * } );
   * ```
   *
   * If an instance of the {@link module:engine/model/selection~Selection model selection} is passed as `selectable`,
   * the new content will be inserted at the passed selection (instead of document selection):
   *
   * ```ts
   * editor.model.change( writer => {
   * 	// Create a selection in a paragraph that will be used as a place of insertion.
   * 	const selection = writer.createSelection( paragraph, 'in' );
   *
   * 	// Insert the new text at the created selection.
   * 	editor.model.insertContent( writer.createText( 'x' ), selection );
   *
   * 	// insertContent() modifies the passed selection instance so it can be used to set the document selection.
   * 	// Note: This is not necessary when you passed the document selection to insertContent().
   * 	writer.setSelection( selection );
   * } );
   * ```
   *
   * @fires insertContent
   * @param content The content to insert.
   * @param selectable The selection into which the content should be inserted.
   * If not provided the current model document selection will be used.
   * @param placeOrOffset To be used when a model item was passed as `selectable`.
   * This param defines a position in relation to that item.
   * at the insertion position.
   */
  insertContent(e, t, n, ...s) {
    const o = xr(t, n);
    return this.fire("insertContent", [e, o, n, ...s]);
  }
  /**
   * Inserts an {@glink framework/deep-dive/schema#object-elements object element} at a specific position in the editor content.
   *
   * This is a high-level API:
   * * It takes the {@link #schema schema} into consideration,
   * * It clears the content of passed `selectable` before inserting,
   * * It can move the selection at the end of the process,
   * * It will copy the selected block's attributes to preserve them upon insertion,
   * * It can split elements or wrap inline objects with paragraphs if they are not allowed in target position,
   * * etc.
   *
   * # Notes
   *
   * * If you want to insert a non-object content, see {@link #insertContent} instead.
   * * For lower-level API, see {@link module:engine/model/writer~Writer `Writer`}.
   * * Unlike {@link module:engine/model/writer~Writer `Writer`}, this method does not have to be used inside
   * a {@link #change `change()` block}.
   * * Inserting object into the model is not enough to make CKEditor 5 render that content to the user.
   * CKEditor 5 implements a model-view-controller architecture and what `model.insertObject()` does
   * is only adding nodes to the model. Additionally, you need to define
   * {@glink framework/architecture/editing-engine#conversion converters} between the model and view
   * and define those nodes in the {@glink framework/architecture/editing-engine#schema schema}.
   *
   * # Examples
   *
   * Use the following code to insert an object at the current selection and keep the selection on the inserted element:
   *
   * ```ts
   * const rawHtmlEmbedElement = writer.createElement( 'rawHtml' );
   *
   * model.insertObject( rawHtmlEmbedElement, null, null, {
   * 	setSelection: 'on'
   * } );
   * ```
   *
   * Use the following code to insert an object at the current selection and nudge the selection after the inserted object:
   *
   * ```ts
   * const pageBreakElement = writer.createElement( 'pageBreak' );
   *
   * model.insertObject( pageBreakElement, null, null, {
   * 	setSelection: 'after'
   * } );
   * ```
   *
   * Use the following code to insert an object at the current selection and avoid splitting the content (non-destructive insertion):
   *
   * ```ts
   * const tableElement = writer.createElement( 'table' );
   *
   * model.insertObject( tableElement, null, null, {
   * 	findOptimalPosition: 'auto'
   * } );
   * ```
   *
   * Use the following code to insert an object at the specific range (also: replace the content of the range):
   *
   * ```ts
   * const tableElement = writer.createElement( 'table' );
   * const range = model.createRangeOn( model.document.getRoot().getChild( 1 ) );
   *
   * model.insertObject( tableElement, range );
   * ```
   *
   * @param element An object to be inserted into the model document.
   * @param selectable A selectable where the content should be inserted. If not specified, the current
   * {@link module:engine/model/document~Document#selection document selection} will be used instead.
   * @param placeOrOffset Specifies the exact place or offset for the insertion to take place, relative to `selectable`.
   * @param options Additional options.
   * @param options.findOptimalPosition An option that, when set, adjusts the insertion position (relative to
   * `selectable` and `placeOrOffset`) so that the content of `selectable` is not split upon insertion (a.k.a. non-destructive insertion).
   * * When `'auto'`, the algorithm will decide whether to insert the object before or after `selectable` to avoid content splitting.
   * * When `'before'`, the closest position before `selectable` will be used that will not result in content splitting.
   * * When `'after'`, the closest position after `selectable` will be used that will not result in content splitting.
   *
   * Note that this option only works for block objects. Inline objects are inserted into text and do not split blocks.
   * @param options.setSelection An option that, when set, moves the
   * {@link module:engine/model/document~Document#selection document selection} after inserting the object.
   * * When `'on'`, the document selection will be set on the inserted object.
   * * When `'after'`, the document selection will move to the closest text node after the inserted object. If there is no
   * such text node, a paragraph will be created and the document selection will be moved inside it.
   * at the insertion position.
   */
  insertObject(e, t, n, s, ...o) {
    const r = xr(t, n);
    return this.fire("insertObject", [e, r, s, s, ...o]);
  }
  /**
   * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.
   *
   * **Note:** For the sake of predictability, the resulting selection should always be collapsed.
   * In cases where a feature wants to modify deleting behavior so selection isn't collapsed
   * (e.g. a table feature may want to keep row selection after pressing <kbd>Backspace</kbd>),
   * then that behavior should be implemented in the view's listener. At the same time, the table feature
   * will need to modify this method's behavior too, e.g. to "delete contents and then collapse
   * the selection inside the last selected cell" or "delete the row and collapse selection somewhere near".
   * That needs to be done in order to ensure that other features which use `deleteContent()` will work well with tables.
   *
   * @fires deleteContent
   * @param selection Selection of which the content should be deleted.
   * @param options.leaveUnmerged Whether to merge elements after removing the content of the selection.
   *
   * For example `<heading1>x[x</heading1><paragraph>y]y</paragraph>` will become:
   *
   * * `<heading1>x^y</heading1>` with the option disabled (`leaveUnmerged == false`)
   * * `<heading1>x^</heading1><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).
   *
   * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}
   * elements will not be merged.
   *
   * @param options.doNotResetEntireContent Whether to skip replacing the entire content with a
   * paragraph when the entire content was selected.
   *
   * For example `<heading1>[x</heading1><paragraph>y]</paragraph>` will become:
   *
   * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)
   * * `<heading1>^</heading1>` with enabled (`doNotResetEntireContent == true`)
   *
   * @param options.doNotAutoparagraph Whether to create a paragraph if after content deletion selection is moved
   * to a place where text cannot be inserted.
   *
   * For example `<paragraph>x</paragraph>[<imageBlock src="foo.jpg"></imageBlock>]` will become:
   *
   * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)
   * * `<paragraph>x[]</paragraph>` with the option enabled (`doNotAutoparagraph == true`).
   *
   * **Note:** if there is no valid position for the selection, the paragraph will always be created:
   *
   * `[<imageBlock src="foo.jpg"></imageBlock>]` -> `<paragraph>[]</paragraph>`.
   *
   * @param options.direction The direction in which the content is being consumed.
   * Deleting backward corresponds to using the <kbd>Backspace</kbd> key, while deleting content forward corresponds to
   * the <kbd>Shift</kbd>+<kbd>Backspace</kbd> keystroke.
   */
  deleteContent(e, t) {
    Z2(this, e, t);
  }
  /**
   * Modifies the selection. Currently, the supported modifications are:
   *
   * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.
   * Possible values for `unit` are:
   *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one
   *  character in `String` sense. However, unicode also defines "combing marks". These are special symbols, that combines
   *  with a symbol before it ("base character") to create one user-perceived character. For example, `q̣̇` is a normal
   *  letter `q` with two "combining marks": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending
   *  selection by one position, it is correct to include both "base character" and all of it's "combining marks". That is
   *  why `'character'` value is most natural and common method of modifying selection.
   *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert
   *  selection between "base character" and "combining mark", because "combining marks" have their own unicode code points.
   *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by
   *  two characters, called "surrogate pairs". Halves of "surrogate pairs" have a meaning only when placed next to each other.
   *  For example `𨭎` is represented in `String` by `\uD862\uDF4E`. Both `\uD862` and `\uDF4E` do not have any meaning
   *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection
   *  extension will include whole "surrogate pair".
   *  * `'word'` - moves selection by a whole word.
   *
   * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.
   *
   * @fires modifySelection
   * @param selection The selection to modify.
   * @param options.direction The direction in which the selection should be modified.
   * @param options.unit The unit by which selection should be modified.
   * @param options.treatEmojiAsSingleUnit Whether multi-characer emoji sequences should be handled as single unit.
   */
  modifySelection(e, t) {
    d5(this, e, t);
  }
  /**
   * Gets a clone of the selected content.
   *
   * For example, for the following selection:
   *
   * ```html
   * <paragraph>x</paragraph>
   * <blockQuote>
   * 	<paragraph>y</paragraph>
   * 	<heading1>fir[st</heading1>
   * </blockQuote>
   * <paragraph>se]cond</paragraph>
   * <paragraph>z</paragraph>
   * ```
   *
   * It will return a document fragment with such a content:
   *
   * ```html
   * <blockQuote>
   * 	<heading1>st</heading1>
   * </blockQuote>
   * <paragraph>se</paragraph>
   * ```
   *
   * @fires getSelectedContent
   * @param selection The selection of which content will be returned.
   */
  getSelectedContent(e) {
    return o5(this, e);
  }
  /**
   * Checks whether the given {@link module:engine/model/range~Range range} or
   * {@link module:engine/model/element~Element element} has any meaningful content.
   *
   * Meaningful content is:
   *
   * * any text node (`options.ignoreWhitespaces` allows controlling whether this text node must also contain
   * any non-whitespace characters),
   * * or any {@link module:engine/model/schema~Schema#isContent content element},
   * * or any {@link module:engine/model/markercollection~Marker marker} which
   * {@link module:engine/model/markercollection~Marker#_affectsData affects data}.
   *
   * This means that a range containing an empty `<paragraph></paragraph>` is not considered to have a meaningful content.
   * However, a range containing an `<imageBlock></imageBlock>` (which would normally be marked in the schema as an object element)
   * is considered non-empty.
   *
   * @param rangeOrElement Range or element to check.
   * @param options.ignoreWhitespaces Whether text node with whitespaces only should be considered empty.
   * @param options.ignoreMarkers Whether markers should be ignored.
   */
  hasContent(e, t = {}) {
    const n = e instanceof _ ? e : _._createIn(e);
    if (n.isCollapsed)
      return !1;
    const { ignoreWhitespaces: s = !1, ignoreMarkers: o = !1 } = t;
    if (!o) {
      for (const r of this.markers.getMarkersIntersectingRange(n))
        if (r.affectsData)
          return !0;
    }
    for (const r of n.getItems())
      if (this.schema.isContent(r))
        if (r.is("$textProxy"))
          if (s) {
            if (r.data.search(/\S/) !== -1)
              return !0;
          } else return !0;
        else
          return !0;
    return !1;
  }
  /**
   * Check whether given selectable is at a place in the model where it can be edited (returns `true`) or not (returns `false`).
   *
   * Should be used instead of {@link module:core/editor/editor~Editor#isReadOnly} to check whether a user action can happen at
   * given selectable. It may be decorated and used differently in different environment (e.g. multi-root editor can disable
   * a particular root).
   *
   * This method is decorated. Although this method accepts any parameter of `Selectable` type, the
   * {@link ~Model#event:canEditAt `canEditAt` event} is fired with `selectable` normalized to an instance of
   * {@link module:engine/model/selection~Selection} or {@link module:engine/model/documentselection~DocumentSelection}
   *
   * @fires canEditAt
   */
  canEditAt(e) {
    const t = xr(e);
    return this.fire("canEditAt", [t]);
  }
  /**
   * Creates a position from the given root and path in that root.
   *
   * Note: This method is also available as
   * {@link module:engine/model/writer~Writer#createPositionFromPath `Writer#createPositionFromPath()`}.
   *
   * @param root Root of the position.
   * @param path Position path. See {@link module:engine/model/position~Position#path}.
   * @param stickiness Position stickiness. See {@link module:engine/model/position~PositionStickiness}.
   */
  createPositionFromPath(e, t, n) {
    return new y(e, t, n);
  }
  /**
   * Creates position at the given location. The location can be specified as:
   *
   * * a {@link module:engine/model/position~Position position},
   * * a parent element and offset in that element,
   * * a parent element and `'end'` (the position will be set at the end of that element),
   * * a {@link module:engine/model/item~Item model item} and `'before'` or `'after'`
   * (the position will be set before or after the given model item).
   *
   * This method is a shortcut to other factory methods such as:
   *
   * * {@link module:engine/model/model~Model#createPositionBefore `createPositionBefore()`},
   * * {@link module:engine/model/model~Model#createPositionAfter `createPositionAfter()`}.
   *
   * Note: This method is also available as
   * {@link module:engine/model/writer~Writer#createPositionAt `Writer#createPositionAt()`},
   *
   * @param itemOrPosition
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/model/item~Item model item}.
   */
  createPositionAt(e, t) {
    return y._createAt(e, t);
  }
  /**
   * Creates a new position after the given {@link module:engine/model/item~Item model item}.
   *
   * Note: This method is also available as
   * {@link module:engine/model/writer~Writer#createPositionAfter `Writer#createPositionAfter()`}.
   *
   * @param item Item after which the position should be placed.
   */
  createPositionAfter(e) {
    return y._createAfter(e);
  }
  /**
   * Creates a new position before the given {@link module:engine/model/item~Item model item}.
   *
   * Note: This method is also available as
   * {@link module:engine/model/writer~Writer#createPositionBefore `Writer#createPositionBefore()`}.
   *
   * @param item Item before which the position should be placed.
   */
  createPositionBefore(e) {
    return y._createBefore(e);
  }
  /**
   * Creates a range spanning from the `start` position to the `end` position.
   *
   * Note: This method is also available as
   * {@link module:engine/model/writer~Writer#createRange `Writer#createRange()`}:
   *
   * ```ts
   * model.change( writer => {
   * 	const range = writer.createRange( start, end );
   * } );
   * ```
   *
   * @param start Start position.
   * @param end End position. If not set, the range will be collapsed to the `start` position.
   */
  createRange(e, t) {
    return new _(e, t);
  }
  /**
   * Creates a range inside the given element which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * Note: This method is also available as
   * {@link module:engine/model/writer~Writer#createRangeIn `Writer#createRangeIn()`}:
   *
   * ```ts
   * model.change( writer => {
   * 	const range = writer.createRangeIn( paragraph );
   * } );
   * ```
   *
   * @param element Element which is a parent for the range.
   */
  createRangeIn(e) {
    return _._createIn(e);
  }
  /**
   * Creates a range that starts before the given {@link module:engine/model/item~Item model item} and ends after it.
   *
   * Note: This method is also available on `writer` instance as
   * {@link module:engine/model/writer~Writer#createRangeOn `Writer.createRangeOn()`}:
   *
   * ```ts
   * model.change( writer => {
   * 	const range = writer.createRangeOn( paragraph );
   * } );
   * ```
   *
   * @param item
   */
  createRangeOn(e) {
    return _._createOn(e);
  }
  createSelection(...e) {
    return new De(...e);
  }
  /**
   * Creates a {@link module:engine/model/batch~Batch} instance.
   *
   * **Note:** In most cases creating a batch instance is not necessary as they are created when using:
   *
   * * {@link #change `change()`},
   * * {@link #enqueueChange `enqueueChange()`}.
   *
   * @param type {@link module:engine/model/batch~Batch#constructor The type} of the batch.
   */
  createBatch(e) {
    return new Mn(e);
  }
  /**
   * Creates an operation instance from a JSON object (parsed JSON string).
   *
   * This is an alias for {@link module:engine/model/operation/operationfactory~OperationFactory.fromJSON `OperationFactory.fromJSON()`}.
   *
   * @param json Deserialized JSON object.
   */
  createOperationFromJSON(e) {
    return R2.fromJSON(e, this.document);
  }
  /**
   * Removes all events listeners set by model instance and destroys {@link module:engine/model/document~Document}.
   */
  destroy() {
    this.document.destroy(), this.stopListening();
  }
  /**
   * Common part of {@link module:engine/model/model~Model#change} and {@link module:engine/model/model~Model#enqueueChange}
   * which calls callbacks and returns array of values returned by these callbacks.
   */
  _runPendingChanges() {
    const e = [];
    this.fire("_beforeChanges");
    try {
      for (; this._pendingChanges.length; ) {
        const t = this._pendingChanges[0].batch;
        this._currentWriter = new j2(this, t);
        const n = this._pendingChanges[0].callback(this._currentWriter);
        e.push(n), this.document._handleChangeBlock(this._currentWriter), this._pendingChanges.shift(), this._currentWriter = null;
      }
    } finally {
      this._pendingChanges.length = 0, this._currentWriter = null, this.fire("_afterChanges");
    }
    return e;
  }
};
function xr(i, e) {
  if (i)
    return i instanceof De || i instanceof at ? i : i instanceof vn ? e || e === 0 ? new De(i, e) : i.is("rootElement") ? new De(i, "in") : new De(i, "on") : new De(i);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class _5 extends Gt {
  constructor() {
    super(...arguments), this.domEventType = "click";
  }
  /**
   * @inheritDoc
   */
  onDomEvent(e) {
    this.fire(e.type, e);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Qo extends Gt {
  constructor() {
    super(...arguments), this.domEventType = ["mousedown", "mouseup", "mouseover", "mouseout"];
  }
  /**
   * @inheritDoc
   */
  onDomEvent(e) {
    this.fire(e.type, e);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Bt {
  /**
   * @param document The view document instance in which this upcast writer operates.
   */
  constructor(e) {
    this.document = e;
  }
  /**
   * Creates a new {@link module:engine/view/documentfragment~DocumentFragment} instance.
   *
   * @param children A list of nodes to be inserted into the created document fragment.
   * @returns The created document fragment.
   */
  createDocumentFragment(e) {
    return new rn(this.document, e);
  }
  /**
   * Creates a new {@link module:engine/view/element~Element} instance.
   *
   * Attributes can be passed in various formats:
   *
   * ```ts
   * upcastWriter.createElement( 'div', { class: 'editor', contentEditable: 'true' } ); // object
   * upcastWriter.createElement( 'div', [ [ 'class', 'editor' ], [ 'contentEditable', 'true' ] ] ); // map-like iterator
   * upcastWriter.createElement( 'div', mapOfAttributes ); // map
   * ```
   *
   * @param name Node name.
   * @param attrs Collection of attributes.
   * @param children A list of nodes to be inserted into created element.
   * @returns Created element.
   */
  createElement(e, t, n) {
    return new rt(this.document, e, t, n);
  }
  /**
   * Creates a new {@link module:engine/view/text~Text} instance.
   *
   * @param data The text's data.
   * @returns The created text node.
   */
  createText(e) {
    return new ne(this.document, e);
  }
  /**
   * Clones the provided element.
   *
   * @see module:engine/view/element~Element#_clone
   * @param element Element to be cloned.
   * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
   * element will be cloned without any children.
   * @returns Clone of this element.
   */
  clone(e, t = !1) {
    return e._clone(t);
  }
  /**
   * Appends a child node or a list of child nodes at the end of this node
   * and sets the parent of these nodes to this element.
   *
   * @see module:engine/view/element~Element#_appendChild
   * @param items Items to be inserted.
   * @param element Element to which items will be appended.
   * @returns Number of appended nodes.
   */
  appendChild(e, t) {
    return t._appendChild(e);
  }
  /**
   * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
   * this element.
   *
   * @see module:engine/view/element~Element#_insertChild
   * @param index Offset at which nodes should be inserted.
   * @param items Items to be inserted.
   * @param element Element to which items will be inserted.
   * @returns Number of inserted nodes.
   */
  insertChild(e, t, n) {
    return n._insertChild(e, t);
  }
  /**
   * Removes the given number of child nodes starting at the given index and set the parent of these nodes to `null`.
   *
   * @see module:engine/view/element~Element#_removeChildren
   * @param index Offset from which nodes will be removed.
   * @param howMany Number of nodes to remove.
   * @param element Element which children will be removed.
   * @returns The array containing removed nodes.
   */
  removeChildren(e, t, n) {
    return n._removeChildren(e, t);
  }
  /**
   * Removes given element from the view structure. Will not have effect on detached elements.
   *
   * @param element Element which will be removed.
   * @returns The array containing removed nodes.
   */
  remove(e) {
    const t = e.parent;
    return t ? this.removeChildren(t.getChildIndex(e), 1, t) : [];
  }
  /**
   * Replaces given element with the new one in the view structure. Will not have effect on detached elements.
   *
   * @param oldElement Element which will be replaced.
   * @param newElement Element which will be inserted in the place of the old element.
   * @returns Whether old element was successfully replaced.
   */
  replace(e, t) {
    const n = e.parent;
    if (n) {
      const s = n.getChildIndex(e);
      return this.removeChildren(s, 1, n), this.insertChild(s, t, n), !0;
    }
    return !1;
  }
  /**
   * Removes given element from view structure and places its children in its position.
   * It does nothing if element has no parent.
   *
   * @param element Element to unwrap.
   */
  unwrapElement(e) {
    const t = e.parent;
    if (t) {
      const n = t.getChildIndex(e);
      this.remove(e), this.insertChild(n, e.getChildren(), t);
    }
  }
  /**
   * Renames element by creating a copy of a given element but with its name changed and then moving contents of the
   * old element to the new one.
   *
   * Since this function creates a new element and removes the given one, the new element is returned to keep reference.
   *
   * @param newName New element name.
   * @param  element Element to be renamed.
   * @returns New element or null if the old element was not replaced (happens for detached elements).
   */
  rename(e, t) {
    const n = new rt(this.document, e, t.getAttributes(), t.getChildren());
    return this.replace(t, n) ? n : null;
  }
  /**
   * Adds or overwrites element's attribute with a specified key and value.
   *
   * ```ts
   * writer.setAttribute( 'href', 'http://ckeditor.com', linkElement );
   * ```
   *
   * @see module:engine/view/element~Element#_setAttribute
   * @param key Attribute key.
   * @param value Attribute value.
   * @param element Element for which attribute will be set.
   */
  setAttribute(e, t, n) {
    n._setAttribute(e, t);
  }
  /**
   * Removes attribute from the element.
   *
   * ```ts
   * writer.removeAttribute( 'href', linkElement );
   * ```
   *
   * @see module:engine/view/element~Element#_removeAttribute
   * @param key Attribute key.
   * @param element Element from which attribute will be removed.
   */
  removeAttribute(e, t) {
    t._removeAttribute(e);
  }
  /**
   * Adds specified class to the element.
   *
   * ```ts
   * writer.addClass( 'foo', linkElement );
   * writer.addClass( [ 'foo', 'bar' ], linkElement );
   * ```
   *
   * @see module:engine/view/element~Element#_addClass
   * @param className Single class name or array of class names which will be added.
   * @param element Element for which class will be added.
   */
  addClass(e, t) {
    t._addClass(e);
  }
  /**
   * Removes specified class from the element.
   *
   * ```ts
   * writer.removeClass( 'foo', linkElement );
   * writer.removeClass( [ 'foo', 'bar' ], linkElement );
   * ```
   *
   * @see module:engine/view/element~Element#_removeClass
   * @param className Single class name or array of class names which will be removed.
   * @param element Element from which class will be removed.
   */
  removeClass(e, t) {
    t._removeClass(e);
  }
  setStyle(e, t, n) {
    Ne(e) && n === void 0 ? t._setStyle(e) : n._setStyle(e, t);
  }
  /**
   * Removes specified style from the element.
   *
   * ```ts
   * writer.removeStyle( 'color', element );  // Removes 'color' style.
   * writer.removeStyle( [ 'color', 'border-top' ], element ); // Removes both 'color' and 'border-top' styles.
   * ```
   *
   * **Note**: This method can work with normalized style names if
   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
   * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.
   *
   * @see module:engine/view/element~Element#_removeStyle
   * @param property Style property name or names to be removed.
   * @param element Element from which style will be removed.
   */
  removeStyle(e, t) {
    t._removeStyle(e);
  }
  /**
   * Sets a custom property on element. Unlike attributes, custom properties are not rendered to the DOM,
   * so they can be used to add special data to elements.
   *
   * @see module:engine/view/element~Element#_setCustomProperty
   * @param key Custom property name/key.
   * @param value Custom property value to be stored.
   * @param element Element for which custom property will be set.
   */
  setCustomProperty(e, t, n) {
    n._setCustomProperty(e, t);
  }
  /**
   * Removes a custom property stored under the given key.
   *
   * @see module:engine/view/element~Element#_removeCustomProperty
   * @param key Name/key of the custom property to be removed.
   * @param element Element from which the custom property will be removed.
   * @returns Returns true if property was removed.
   */
  removeCustomProperty(e, t) {
    return t._removeCustomProperty(e);
  }
  /**
   * Creates position at the given location. The location can be specified as:
   *
   * * a {@link module:engine/view/position~Position position},
   * * parent element and offset (offset defaults to `0`),
   * * parent element and `'end'` (sets position at the end of that element),
   * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
   *
   * This method is a shortcut to other constructors such as:
   *
   * * {@link #createPositionBefore},
   * * {@link #createPositionAfter},
   *
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
   */
  createPositionAt(e, t) {
    return k._createAt(e, t);
  }
  /**
   * Creates a new position after given view item.
   *
   * @param item View item after which the position should be located.
   */
  createPositionAfter(e) {
    return k._createAfter(e);
  }
  /**
   * Creates a new position before given view item.
   *
   * @param item View item before which the position should be located.
   */
  createPositionBefore(e) {
    return k._createBefore(e);
  }
  /**
   * Creates a range spanning from `start` position to `end` position.
   *
   * **Note:** This factory method creates it's own {@link module:engine/view/position~Position} instances basing on passed values.
   *
   * @param start Start position.
   * @param end End position. If not set, range will be collapsed at `start` position.
   */
  createRange(e, t) {
    return new O(e, t);
  }
  /**
   * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
   */
  createRangeOn(e) {
    return O._createOn(e);
  }
  /**
   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * @param element Element which is a parent for the range.
   */
  createRangeIn(e) {
    return O._createIn(e);
  }
  createSelection(...e) {
    return new xt(...e);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const v5 = /^#([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i, y5 = /^rgb\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}[0-9]{1,3}[ %]?\)$/i, C5 = /^rgba\([ ]?([0-9]{1,3}[ %]?,[ ]?){3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i, k5 = /^hsl\([ ]?([0-9]{1,3}[ %]?[,]?[ ]*){3}(1|[0-9]+%|[0]?\.?[0-9]+)?\)$/i, T5 = /^hsla\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i, E5 = /\w+\((?:[^()]|\([^()]*\))*\)|\S+/gi, A5 = /* @__PURE__ */ new Set([
  // CSS Level 1
  "black",
  "silver",
  "gray",
  "white",
  "maroon",
  "red",
  "purple",
  "fuchsia",
  "green",
  "lime",
  "olive",
  "yellow",
  "navy",
  "blue",
  "teal",
  "aqua",
  // CSS Level 2 (Revision 1)
  "orange",
  // CSS Color Module Level 3
  "aliceblue",
  "antiquewhite",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "blanchedalmond",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkgrey",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkslategrey",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dimgrey",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "greenyellow",
  "grey",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightgrey",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightslategrey",
  "lightsteelblue",
  "lightyellow",
  "limegreen",
  "linen",
  "magenta",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "oldlace",
  "olivedrab",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "skyblue",
  "slateblue",
  "slategray",
  "slategrey",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "whitesmoke",
  "yellowgreen",
  // CSS Color Module Level 3 (System Colors)
  "activeborder",
  "activecaption",
  "appworkspace",
  "background",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "captiontext",
  "graytext",
  "highlight",
  "highlighttext",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infobackground",
  "infotext",
  "menu",
  "menutext",
  "scrollbar",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "window",
  "windowframe",
  "windowtext",
  // CSS Color Module Level 4
  "rebeccapurple",
  // Keywords
  "currentcolor",
  "transparent"
]);
function og(i) {
  return i.startsWith("#") ? v5.test(i) : i.startsWith("rgb") ? y5.test(i) || C5.test(i) : i.startsWith("hsl") ? k5.test(i) || T5.test(i) : A5.has(i.toLowerCase());
}
const x5 = ["none", "hidden", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset"];
function I5(i) {
  return x5.includes(i);
}
const S5 = /^([+-]?[0-9]*([.][0-9]+)?(px|cm|mm|in|pc|pt|ch|em|ex|rem|vh|vw|vmin|vmax)|0)$/;
function Yo(i) {
  return S5.test(i);
}
const P5 = /^[+-]?[0-9]*([.][0-9]+)?%$/;
function rg(i) {
  return P5.test(i);
}
const R5 = ["repeat-x", "repeat-y", "repeat", "space", "round", "no-repeat"];
function V5(i) {
  return R5.includes(i);
}
const M5 = ["center", "top", "bottom", "left", "right"];
function B5(i) {
  return M5.includes(i);
}
const L5 = ["fixed", "scroll", "local"];
function O5(i) {
  return L5.includes(i);
}
const F5 = /^url\(/;
function N5(i) {
  return F5.test(i);
}
function zi(i = "") {
  if (i === "")
    return { top: void 0, right: void 0, bottom: void 0, left: void 0 };
  const e = Cl(i), t = e[0], n = e[2] || t, s = e[1] || t, o = e[3] || s;
  return { top: t, bottom: n, right: s, left: o };
}
function Hi(i) {
  return (e) => {
    const { top: t, right: n, bottom: s, left: o } = e, r = [];
    return [t, n, o, s].every((a) => !!a) ? r.push([i, D5(e)]) : (t && r.push([i + "-top", t]), n && r.push([i + "-right", n]), s && r.push([i + "-bottom", s]), o && r.push([i + "-left", o])), r;
  };
}
function D5({ top: i, right: e, bottom: t, left: n }) {
  const s = [];
  return n !== e ? s.push(i, e, t, n) : t !== i ? s.push(i, e, t) : e !== i ? s.push(i, e) : s.push(i), s.join(" ");
}
function ag(i) {
  return (e) => ({
    path: i,
    value: zi(e)
  });
}
function Cl(i) {
  const e = i.matchAll(E5);
  return Array.from(e).map((t) => t[0]);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function kl(i) {
  i.setNormalizer("background", z5()), i.setNormalizer("background-color", H5()), i.setReducer("background", U5()), i.setStyleRelation("background", ["background-color"]);
}
function z5() {
  return (i) => {
    const e = {}, t = Cl(i);
    for (const n of t)
      V5(n) ? (e.repeat = e.repeat || [], e.repeat.push(n)) : B5(n) ? (e.position = e.position || [], e.position.push(n)) : O5(n) ? e.attachment = n : og(n) ? e.color = n : N5(n) && (e.image = n);
    return {
      path: "background",
      value: e
    };
  };
}
function H5() {
  return (i) => ({ path: "background.color", value: i });
}
function U5() {
  return (i) => {
    const e = [];
    return e.push(["background-color", i.color]), e;
  };
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function lg(i) {
  i.setNormalizer("border", $5()), i.setNormalizer("border-top", Ms("top")), i.setNormalizer("border-right", Ms("right")), i.setNormalizer("border-bottom", Ms("bottom")), i.setNormalizer("border-left", Ms("left")), i.setNormalizer("border-color", Ir("color")), i.setNormalizer("border-width", Ir("width")), i.setNormalizer("border-style", Ir("style")), i.setNormalizer("border-top-color", We("color", "top")), i.setNormalizer("border-top-style", We("style", "top")), i.setNormalizer("border-top-width", We("width", "top")), i.setNormalizer("border-right-color", We("color", "right")), i.setNormalizer("border-right-style", We("style", "right")), i.setNormalizer("border-right-width", We("width", "right")), i.setNormalizer("border-bottom-color", We("color", "bottom")), i.setNormalizer("border-bottom-style", We("style", "bottom")), i.setNormalizer("border-bottom-width", We("width", "bottom")), i.setNormalizer("border-left-color", We("color", "left")), i.setNormalizer("border-left-style", We("style", "left")), i.setNormalizer("border-left-width", We("width", "left")), i.setExtractor("border-top", Bs("top")), i.setExtractor("border-right", Bs("right")), i.setExtractor("border-bottom", Bs("bottom")), i.setExtractor("border-left", Bs("left")), i.setExtractor("border-top-color", "border.color.top"), i.setExtractor("border-right-color", "border.color.right"), i.setExtractor("border-bottom-color", "border.color.bottom"), i.setExtractor("border-left-color", "border.color.left"), i.setExtractor("border-top-width", "border.width.top"), i.setExtractor("border-right-width", "border.width.right"), i.setExtractor("border-bottom-width", "border.width.bottom"), i.setExtractor("border-left-width", "border.width.left"), i.setExtractor("border-top-style", "border.style.top"), i.setExtractor("border-right-style", "border.style.right"), i.setExtractor("border-bottom-style", "border.style.bottom"), i.setExtractor("border-left-style", "border.style.left"), i.setReducer("border-color", Hi("border-color")), i.setReducer("border-style", Hi("border-style")), i.setReducer("border-width", Hi("border-width")), i.setReducer("border-top", Ls("top")), i.setReducer("border-right", Ls("right")), i.setReducer("border-bottom", Ls("bottom")), i.setReducer("border-left", Ls("left")), i.setReducer("border", q5()), i.setStyleRelation("border", [
    "border-color",
    "border-style",
    "border-width",
    "border-top",
    "border-right",
    "border-bottom",
    "border-left",
    "border-top-color",
    "border-right-color",
    "border-bottom-color",
    "border-left-color",
    "border-top-style",
    "border-right-style",
    "border-bottom-style",
    "border-left-style",
    "border-top-width",
    "border-right-width",
    "border-bottom-width",
    "border-left-width"
  ]), i.setStyleRelation("border-color", [
    "border-top-color",
    "border-right-color",
    "border-bottom-color",
    "border-left-color"
  ]), i.setStyleRelation("border-style", [
    "border-top-style",
    "border-right-style",
    "border-bottom-style",
    "border-left-style"
  ]), i.setStyleRelation("border-width", [
    "border-top-width",
    "border-right-width",
    "border-bottom-width",
    "border-left-width"
  ]), i.setStyleRelation("border-top", ["border-top-color", "border-top-style", "border-top-width"]), i.setStyleRelation("border-right", ["border-right-color", "border-right-style", "border-right-width"]), i.setStyleRelation("border-bottom", ["border-bottom-color", "border-bottom-style", "border-bottom-width"]), i.setStyleRelation("border-left", ["border-left-color", "border-left-style", "border-left-width"]);
}
function $5() {
  return (i) => {
    const { color: e, style: t, width: n } = cg(i);
    return {
      path: "border",
      value: {
        color: zi(e),
        style: zi(t),
        width: zi(n)
      }
    };
  };
}
function Ms(i) {
  return (e) => {
    const { color: t, style: n, width: s } = cg(e), o = {};
    return t !== void 0 && (o.color = { [i]: t }), n !== void 0 && (o.style = { [i]: n }), s !== void 0 && (o.width = { [i]: s }), {
      path: "border",
      value: o
    };
  };
}
function Ir(i) {
  return (e) => ({
    path: "border",
    value: W5(e, i)
  });
}
function W5(i, e) {
  return {
    [e]: zi(i)
  };
}
function We(i, e) {
  return (t) => ({
    path: "border",
    value: {
      [i]: {
        [e]: t
      }
    }
  });
}
function Bs(i) {
  return (e, t) => {
    if (t.border)
      return Ri(t.border, i);
  };
}
function Ri(i, e) {
  const t = {};
  return i.width && i.width[e] && (t.width = i.width[e]), i.style && i.style[e] && (t.style = i.style[e]), i.color && i.color[e] && (t.color = i.color[e]), t;
}
function cg(i) {
  const e = {}, t = Cl(i);
  for (const n of t)
    Yo(n) || /thin|medium|thick/.test(n) ? e.width = n : I5(n) ? e.style = n : e.color = n;
  return e;
}
function q5() {
  return (e) => {
    const t = Ri(e, "top"), n = Ri(e, "right"), s = Ri(e, "bottom"), o = Ri(e, "left"), r = [t, n, s, o], a = {
      width: i(r, "width"),
      style: i(r, "style"),
      color: i(r, "color")
    }, l = Hn(a, "all");
    return l.length ? l : [
      ...Object.entries(a).reduce((u, [d, h]) => (h && (u.push([`border-${d}`, h]), r.forEach((f) => delete f[d])), u), []),
      ...Hn(t, "top"),
      ...Hn(n, "right"),
      ...Hn(s, "bottom"),
      ...Hn(o, "left")
    ];
  };
  function i(e, t) {
    return e.map((n) => n[t]).reduce((n, s) => n == s ? n : null);
  }
}
function Ls(i) {
  return (e) => Hn(e, i);
}
function Hn(i, e) {
  const t = [];
  if (i && i.width && t.push("width"), i && i.style && t.push("style"), i && i.color && t.push("color"), t.length == 3) {
    const n = t.map((s) => i[s]).join(" ");
    return [
      e == "all" ? ["border", n] : [`border-${e}`, n]
    ];
  }
  return e == "all" ? [] : t.map((n) => [`border-${e}-${n}`, i[n]]);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function G5(i) {
  i.setNormalizer("margin", ag("margin")), i.setNormalizer("margin-top", (e) => ({ path: "margin.top", value: e })), i.setNormalizer("margin-right", (e) => ({ path: "margin.right", value: e })), i.setNormalizer("margin-bottom", (e) => ({ path: "margin.bottom", value: e })), i.setNormalizer("margin-left", (e) => ({ path: "margin.left", value: e })), i.setReducer("margin", Hi("margin")), i.setStyleRelation("margin", ["margin-top", "margin-right", "margin-bottom", "margin-left"]);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function j5(i) {
  i.setNormalizer("padding", ag("padding")), i.setNormalizer("padding-top", (e) => ({ path: "padding.top", value: e })), i.setNormalizer("padding-right", (e) => ({ path: "padding.right", value: e })), i.setNormalizer("padding-bottom", (e) => ({ path: "padding.bottom", value: e })), i.setNormalizer("padding-left", (e) => ({ path: "padding.left", value: e })), i.setReducer("padding", Hi("padding")), i.setStyleRelation("padding", ["padding-top", "padding-right", "padding-bottom", "padding-left"]);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class K5 {
  /**
   * Creates collection instance.
   */
  constructor() {
    this._commands = /* @__PURE__ */ new Map();
  }
  /**
   * Registers a new command.
   *
   * @param commandName The name of the command.
   */
  add(e, t) {
    this._commands.set(e, t);
  }
  /**
   * Retrieves a command from the collection.
   *
   * @param commandName The name of the command.
   */
  get(e) {
    return this._commands.get(e);
  }
  /**
   * Executes a command.
   *
   * @param commandName The name of the command.
   * @param commandParams Command parameters.
   * @returns The value returned by the {@link module:core/command~Command#execute `command.execute()`}.
   */
  execute(e, ...t) {
    const n = this.get(e);
    if (!n)
      throw new g("commandcollection-command-not-found", this, { commandName: e });
    return n.execute(...t);
  }
  /**
   * Returns iterator of command names.
   */
  *names() {
    yield* this._commands.keys();
  }
  /**
   * Returns iterator of command instances.
   */
  *commands() {
    yield* this._commands.values();
  }
  /**
   * Iterable interface.
   *
   * Returns `[ commandName, commandInstance ]` pairs.
   */
  [Symbol.iterator]() {
    return this._commands[Symbol.iterator]();
  }
  /**
   * Destroys all collection commands.
   */
  destroy() {
    for (const e of this.commands())
      e.destroy();
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Z5 extends ie {
  /**
   * Creates an instance of the keystroke handler.
   */
  constructor(e) {
    super(), this.editor = e;
  }
  /**
   * Registers a handler for the specified keystroke.
   *
   * The handler can be specified as a command name or a callback.
   *
   * @param keystroke Keystroke defined in a format accepted by
   * the {@link module:utils/keyboard~parseKeystroke} function.
   * @param callback If a string is passed, then the keystroke will
   * {@link module:core/editor/editor~Editor#execute execute a command}.
   * If a function, then it will be called with the
   * {@link module:engine/view/observer/keyobserver~KeyEventData key event data} object and
   * a `cancel()` helper to both `preventDefault()` and `stopPropagation()` of the event.
   * @param options Additional options.
   * @param options.priority The priority of the keystroke callback. The higher the priority value
   * the sooner the callback will be executed. Keystrokes having the same priority
   * are called in the order they were added.
   */
  set(e, t, n = {}) {
    if (typeof t == "string") {
      const s = t;
      t = (o, r) => {
        this.editor.execute(s), r();
      };
    }
    super.set(e, t, n);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Sr = "contentEditing", Ru = "common";
class J5 {
  /**
   * @inheritDoc
   */
  constructor(e) {
    this.keystrokeInfos = /* @__PURE__ */ new Map(), this._editor = e;
    const t = e.config.get("menuBar.isVisible"), n = e.locale.t;
    this.addKeystrokeInfoCategory({
      id: Sr,
      label: n("Content editing keystrokes"),
      description: n("These keyboard shortcuts allow for quick access to content editing features.")
    });
    const s = [
      {
        label: n("Close contextual balloons, dropdowns, and dialogs"),
        keystroke: "Esc"
      },
      {
        label: n("Open the accessibility help dialog"),
        keystroke: "Alt+0"
      },
      {
        label: n("Move focus between form fields (inputs, buttons, etc.)"),
        keystroke: [["Tab"], ["Shift+Tab"]]
      },
      {
        label: n("Move focus to the toolbar, navigate between toolbars"),
        keystroke: "Alt+F10",
        mayRequireFn: !0
      },
      {
        label: n("Navigate through the toolbar or menu bar"),
        keystroke: [["arrowup"], ["arrowright"], ["arrowdown"], ["arrowleft"]]
      },
      {
        // eslint-disable-next-line max-len
        label: n("Execute the currently focused button. Executing buttons that interact with the editor content moves the focus back to the content."),
        keystroke: [["Enter"], ["Space"]]
      }
    ];
    t && s.push({
      label: n("Move focus to the menu bar, navigate between menu bars"),
      keystroke: "Alt+F9",
      mayRequireFn: !0
    }), this.addKeystrokeInfoCategory({
      id: "navigation",
      label: n("User interface and content navigation keystrokes"),
      description: n("Use the following keystrokes for more efficient navigation in the CKEditor 5 user interface."),
      groups: [
        {
          id: "common",
          keystrokes: s
        }
      ]
    });
  }
  /**
   * Adds a top-level category in the {@link #keystrokeInfos keystroke information database} with a label and optional description.
   *
   * Categories organize keystrokes and help users to find the right keystroke. Each category can have multiple groups
   * of keystrokes that narrow down the context in which the keystrokes are available. Every keystroke category comes
   * with a `'common'` group by default.
   *
   * By default, two categories are available:
   * * `'contentEditing'` for keystrokes related to content creation,
   * * `'navigation'` for keystrokes related to navigation in the UI and the content.
   *
   * To create a new keystroke category with new groups, use the following code:
   *
   * ```js
   * class MyPlugin extends Plugin {
   * 	// ...
   * 	init() {
   * 		const editor = this.editor;
   * 		const t = editor.t;
   *
   * 		// ...
   *
   * 		editor.accessibility.addKeystrokeInfoCategory( {
   * 			id: 'myCategory',
   * 			label: t( 'My category' ),
   * 			description: t( 'My category description.' ),
   * 			groups: [
   * 				{
   * 					id: 'myGroup',
   * 					label: t( 'My keystroke group' ),
   * 					keystrokes: [
   * 						{
   * 							label: t( 'Keystroke label 1' ),
   * 							keystroke: 'Ctrl+Shift+N'
   * 						},
   * 						{
   * 							label: t( 'Keystroke label 2' ),
   * 							keystroke: 'Ctrl+Shift+M'
   * 						}
   * 					]
   * 				}
   * 			]
   * 		};
   * 	}
   * }
   * ```
   *
   * See {@link #keystrokeInfos}, {@link #addKeystrokeInfoGroup}, and {@link #addKeystrokeInfos}.
   */
  addKeystrokeInfoCategory({ id: e, label: t, description: n, groups: s }) {
    this.keystrokeInfos.set(e, {
      id: e,
      label: t,
      description: n,
      groups: /* @__PURE__ */ new Map()
    }), this.addKeystrokeInfoGroup({
      categoryId: e,
      id: Ru
    }), s && s.forEach((o) => {
      this.addKeystrokeInfoGroup({
        categoryId: e,
        ...o
      });
    });
  }
  /**
   * Adds a group of keystrokes in a specific category to the {@link #keystrokeInfos keystroke information database}.
   *
   * Groups narrow down the context in which the keystrokes are available. When `categoryId` is not specified,
   * the group goes to the `'contentEditing'` category (default).
   *
   * To create a new group within an existing category, use the following code:
   *
   * ```js
   * class MyPlugin extends Plugin {
   * 	// ...
   * 	init() {
   * 		const editor = this.editor;
   * 		const t = editor.t;
   *
   * 		// ...
   *
   * 		editor.accessibility.addKeystrokeInfoGroup( {
   * 			id: 'myGroup',
   * 			categoryId: 'navigation',
   * 			label: t( 'My keystroke group' ),
   * 			keystrokes: [
   * 				{
   * 					label: t( 'Keystroke label 1' ),
   * 					keystroke: 'Ctrl+Shift+N'
   * 				},
   * 				{
   * 					label: t( 'Keystroke label 2' ),
   * 					keystroke: 'Ctrl+Shift+M'
   * 				}
   * 			]
   * 		} );
   * 	}
   * }
   * ```
   *
   * See {@link #keystrokeInfos}, {@link #addKeystrokeInfoCategory}, and {@link #addKeystrokeInfos}.
   */
  addKeystrokeInfoGroup({ categoryId: e = Sr, id: t, label: n, keystrokes: s }) {
    const o = this.keystrokeInfos.get(e);
    if (!o)
      throw new g("accessibility-unknown-keystroke-info-category", this._editor, { groupId: t, categoryId: e });
    o.groups.set(t, {
      id: t,
      label: n,
      keystrokes: s || []
    });
  }
  /**
   * Adds information about keystrokes to the {@link #keystrokeInfos keystroke information database}.
   *
   * Keystrokes without specified `groupId` or `categoryId` go to the `'common'` group in the `'contentEditing'` category (default).
   *
   * To add a keystroke brought by your plugin (using default group and category), use the following code:
   *
   * ```js
   * class MyPlugin extends Plugin {
   * 	// ...
   * 	init() {
   * 		const editor = this.editor;
   * 		const t = editor.t;
   *
   * 		// ...
   *
   * 		editor.accessibility.addKeystrokeInfos( {
   * 			keystrokes: [
   * 				{
   * 					label: t( 'Keystroke label' ),
   * 					keystroke: 'CTRL+B'
   * 				}
   * 			]
   * 		} );
   * 	}
   * }
   * ```
   * To add a keystroke in a specific existing `'widget'` group in the default `'contentEditing'` category:
   *
   * ```js
   * class MyPlugin extends Plugin {
   * 	// ...
   * 	init() {
   * 		const editor = this.editor;
   * 		const t = editor.t;
   *
   * 		// ...
   *
   * 		editor.accessibility.addKeystrokeInfos( {
   * 			// Add a keystroke to the existing "widget" group.
   * 			groupId: 'widget',
   * 			keystrokes: [
   * 				{
   * 					label: t( 'A an action on a selected widget' ),
   * 					keystroke: 'Ctrl+D',
   * 				}
   * 			]
   * 		} );
   * 	}
   * }
   * ```
   *
   * To add a keystroke to another existing category (using default group):
   *
   * ```js
   * class MyPlugin extends Plugin {
   * 	// ...
   * 	init() {
   * 		const editor = this.editor;
   * 		const t = editor.t;
   *
   * 		// ...
   *
   * 		editor.accessibility.addKeystrokeInfos( {
   * 			// Add keystrokes to the "navigation" category (one of defaults).
   * 			categoryId: 'navigation',
   * 			keystrokes: [
   * 				{
   * 					label: t( 'Keystroke label' ),
   * 					keystroke: 'CTRL+B'
   * 				}
   * 			]
   * 		} );
   * 	}
   * }
   * ```
   *
   * See {@link #keystrokeInfos}, {@link #addKeystrokeInfoGroup}, and {@link #addKeystrokeInfoCategory}.
   */
  addKeystrokeInfos({ categoryId: e = Sr, groupId: t = Ru, keystrokes: n }) {
    if (!this.keystrokeInfos.has(e))
      throw new g("accessibility-unknown-keystroke-info-category", this._editor, { categoryId: e, keystrokes: n });
    const s = this.keystrokeInfos.get(e);
    if (!s.groups.has(t))
      throw new g("accessibility-unknown-keystroke-info-group", this._editor, { groupId: t, categoryId: e, keystrokes: n });
    s.groups.get(t).keystrokes.push(...n);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class X5 extends U() {
  /**
   * Creates a new instance of the editor class.
   *
   * Usually, not to be used directly. See the static {@link module:core/editor/editor~Editor.create `create()`} method.
   *
   * @param config The editor configuration.
   */
  constructor(e = {}) {
    super();
    const t = this.constructor, { translations: n, ...s } = t.defaultConfig || {}, { translations: o = n, ...r } = e, a = e.language || s.language;
    this._context = e.context || new pm({ language: a, translations: o }), this._context._addEditor(this, !e.context);
    const l = Array.from(t.builtinPlugins || []);
    this.config = new nm(r, s), this.config.define("plugins", l), this.config.define(this._context._getEditorConfig()), this.plugins = new gm(this, l, this._context.plugins), this.locale = this._context.locale, this.t = this.locale.t, this._readOnlyLocks = /* @__PURE__ */ new Set(), this.commands = new K5(), this.set("state", "initializing"), this.once("ready", () => this.state = "ready", { priority: "high" }), this.once("destroy", () => this.state = "destroyed", { priority: "high" }), this.model = new w5(), this.on("change:isReadOnly", () => {
      this.model.document.isReadOnly = this.isReadOnly;
    });
    const c = new sk();
    this.data = new x2(this.model, c), this.editing = new n2(this.model, c), this.editing.view.document.bind("isReadOnly").to(this), this.conversion = new S2([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher), this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher), this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher), this.keystrokes = new Z5(this), this.keystrokes.listenTo(this.editing.view.document), this.accessibility = new J5(this);
  }
  /**
   * Defines whether the editor is in the read-only mode.
   *
   * In read-only mode the editor {@link #commands commands} are disabled so it is not possible
   * to modify the document by using them. Also, the editable element(s) become non-editable.
   *
   * In order to make the editor read-only, you need to call the {@link #enableReadOnlyMode} method:
   *
   * ```ts
   * editor.enableReadOnlyMode( 'feature-id' );
   * ```
   *
   * Later, to turn off the read-only mode, call {@link #disableReadOnlyMode}:
   *
   * ```ts
   * editor.disableReadOnlyMode( 'feature-id' );
   * ```
   *
   * @readonly
   * @observable
   */
  get isReadOnly() {
    return this._readOnlyLocks.size > 0;
  }
  set isReadOnly(e) {
    throw new g("editor-isreadonly-has-no-setter");
  }
  /**
   * Turns on the read-only mode in the editor.
   *
   * Editor can be switched to or out of the read-only mode by many features, under various circumstances. The editor supports locking
   * mechanism for the read-only mode. It enables easy control over the read-only mode when many features wants to turn it on or off at
   * the same time, without conflicting with each other. It guarantees that you will not make the editor editable accidentally (which
   * could lead to errors).
   *
   * Each read-only mode request is identified by a unique id (also called "lock"). If multiple plugins requested to turn on the
   * read-only mode, then, the editor will become editable only after all these plugins turn the read-only mode off (using the same ids).
   *
   * Note, that you cannot force the editor to disable the read-only mode if other plugins set it.
   *
   * After the first `enableReadOnlyMode()` call, the {@link #isReadOnly `isReadOnly` property} will be set to `true`:
   *
   * ```ts
   * editor.isReadOnly; // `false`.
   * editor.enableReadOnlyMode( 'my-feature-id' );
   * editor.isReadOnly; // `true`.
   * ```
   *
   * You can turn off the read-only mode ("clear the lock") using the {@link #disableReadOnlyMode `disableReadOnlyMode()`} method:
   *
   * ```ts
   * editor.enableReadOnlyMode( 'my-feature-id' );
   * // ...
   * editor.disableReadOnlyMode( 'my-feature-id' );
   * editor.isReadOnly; // `false`.
   * ```
   *
   * All "locks" need to be removed to enable editing:
   *
   * ```ts
   * editor.enableReadOnlyMode( 'my-feature-id' );
   * editor.enableReadOnlyMode( 'my-other-feature-id' );
   * // ...
   * editor.disableReadOnlyMode( 'my-feature-id' );
   * editor.isReadOnly; // `true`.
   * editor.disableReadOnlyMode( 'my-other-feature-id' );
   * editor.isReadOnly; // `false`.
   * ```
   *
   * @param lockId A unique ID for setting the editor to the read-only state.
   */
  enableReadOnlyMode(e) {
    if (typeof e != "string" && typeof e != "symbol")
      throw new g("editor-read-only-lock-id-invalid", null, { lockId: e });
    this._readOnlyLocks.has(e) || (this._readOnlyLocks.add(e), this._readOnlyLocks.size === 1 && this.fire("change:isReadOnly", "isReadOnly", !0, !1));
  }
  /**
   * Removes the read-only lock from the editor with given lock ID.
   *
   * When no lock is present on the editor anymore, then the {@link #isReadOnly `isReadOnly` property} will be set to `false`.
   *
   * @param lockId The lock ID for setting the editor to the read-only state.
   */
  disableReadOnlyMode(e) {
    if (typeof e != "string" && typeof e != "symbol")
      throw new g("editor-read-only-lock-id-invalid", null, { lockId: e });
    this._readOnlyLocks.has(e) && (this._readOnlyLocks.delete(e), this._readOnlyLocks.size === 0 && this.fire("change:isReadOnly", "isReadOnly", !1, !0));
  }
  /**
   * Sets the data in the editor.
   *
   * ```ts
   * editor.setData( '<p>This is editor!</p>' );
   * ```
   *
   * If your editor implementation uses multiple roots, you should pass an object with keys corresponding
   * to the editor root names and values equal to the data that should be set in each root:
   *
   * ```ts
   * editor.setData( {
   *     header: '<p>Content for header part.</p>',
   *     content: '<p>Content for main part.</p>',
   *     footer: '<p>Content for footer part.</p>'
   * } );
   * ```
   *
   * By default the editor accepts HTML. This can be controlled by injecting a different data processor.
   * See the {@glink features/markdown Markdown output} guide for more details.
   *
   * @param data Input data.
   */
  setData(e) {
    this.data.set(e);
  }
  /**
   * Gets the data from the editor.
   *
   * ```ts
   * editor.getData(); // -> '<p>This is editor!</p>'
   * ```
   *
   * If your editor implementation uses multiple roots, you should pass root name as one of the options:
   *
   * ```ts
   * editor.getData( { rootName: 'header' } ); // -> '<p>Content for header part.</p>'
   * ```
   *
   * By default, the editor outputs HTML. This can be controlled by injecting a different data processor.
   * See the {@glink features/markdown Markdown output} guide for more details.
   *
   * A warning is logged when you try to retrieve data for a detached root, as most probably this is a mistake. A detached root should
   * be treated like it is removed, and you should not save its data. Note, that the detached root data is always an empty string.
   *
   * @param options Additional configuration for the retrieved data.
   * Editor features may introduce more configuration options that can be set through this parameter.
   * @param options.rootName Root name. Defaults to `'main'`.
   * @param options.trim Whether returned data should be trimmed. This option is set to `'empty'` by default,
   * which means that whenever editor content is considered empty, an empty string is returned. To turn off trimming
   * use `'none'`. In such cases exact content will be returned (for example `'<p>&nbsp;</p>'` for an empty editor).
   * @returns Output data.
   */
  getData(e) {
    return this.data.get(e);
  }
  /**
   * Loads and initializes plugins specified in the configuration.
   *
   * @returns A promise which resolves once the initialization is completed, providing an array of loaded plugins.
   */
  initPlugins() {
    const e = this.config, t = e.get("plugins"), n = e.get("removePlugins") || [], s = e.get("extraPlugins") || [], o = e.get("substitutePlugins") || [];
    return this.plugins.init(t.concat(s), n, o);
  }
  /**
   * Destroys the editor instance, releasing all resources used by it.
   *
   * **Note** The editor cannot be destroyed during the initialization phase so if it is called
   * while the editor {@link #state is being initialized}, it will wait for the editor initialization before destroying it.
   *
   * @fires destroy
   * @returns A promise that resolves once the editor instance is fully destroyed.
   */
  destroy() {
    let e = Promise.resolve();
    return this.state == "initializing" && (e = new Promise((t) => this.once("ready", t))), e.then(() => {
      this.fire("destroy"), this.stopListening(), this.commands.destroy();
    }).then(() => this.plugins.destroy()).then(() => {
      this.model.destroy(), this.data.destroy(), this.editing.destroy(), this.keystrokes.destroy();
    }).then(() => this._context._removeEditor(this));
  }
  /**
   * Executes the specified command with given parameters.
   *
   * Shorthand for:
   *
   * ```ts
   * editor.commands.get( commandName ).execute( ... );
   * ```
   *
   * @param commandName The name of the command to execute.
   * @param commandParams Command parameters.
   * @returns The value returned by the {@link module:core/commandcollection~CommandCollection#execute `commands.execute()`}.
   */
  execute(e, ...t) {
    try {
      return this.commands.execute(e, ...t);
    } catch (n) {
      /* istanbul ignore next -- @preserve */
      g.rethrowUnexpectedError(n, this);
    }
  }
  /**
   * Focuses the editor.
   *
   * **Note** To explicitly focus the editing area of the editor, use the
   * {@link module:engine/view/view~View#focus `editor.editing.view.focus()`} method of the editing view.
   *
   * Check out the {@glink framework/deep-dive/ui/focus-tracking#focus-in-the-editor-ui Focus in the editor UI} section
   * of the {@glink framework/deep-dive/ui/focus-tracking Deep dive into focus tracking} guide to learn more.
   */
  focus() {
    this.editing.view.focus();
  }
  /* istanbul ignore next -- @preserve */
  /**
   * Creates and initializes a new editor instance.
   *
   * This is an abstract method. Every editor type needs to implement its own initialization logic.
   *
   * See the `create()` methods of the existing editor types to learn how to use them:
   *
   * * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`}
   * * {@link module:editor-balloon/ballooneditor~BalloonEditor.create `BalloonEditor.create()`}
   * * {@link module:editor-decoupled/decouplededitor~DecoupledEditor.create `DecoupledEditor.create()`}
   * * {@link module:editor-inline/inlineeditor~InlineEditor.create `InlineEditor.create()`}
   */
  static create(...e) {
    throw new Error("This is an abstract method.");
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Q5(i) {
  if (!dn(i.updateSourceElement))
    throw new g("attachtoform-missing-elementapi-interface", i);
  const e = i.sourceElement;
  if (Y5(e) && e.form) {
    let t;
    const n = e.form, s = () => i.updateSourceElement();
    dn(n.submit) && (t = n.submit, n.submit = () => {
      s(), t.apply(n);
    }), n.addEventListener("submit", s), i.on("destroy", () => {
      n.removeEventListener("submit", s), t && (n.submit = t);
    });
  }
}
function Y5(i) {
  return !!i && i.tagName.toLowerCase() === "textarea";
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function pa(i) {
  class e extends i {
    updateSourceElement(n) {
      if (!this.sourceElement)
        throw new g("editor-missing-sourceelement", this);
      const s = this.config.get("updateSourceElementOnDestroy"), o = this.sourceElement instanceof HTMLTextAreaElement;
      if (!s && !o) {
        Dc(this.sourceElement, "");
        return;
      }
      const r = typeof n == "string" ? n : this.data.get();
      Dc(this.sourceElement, r);
    }
  }
  return e;
}
pa.updateSourceElement = pa(Object).prototype.updateSourceElement;
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Vu extends jo {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "PendingActions";
  }
  /**
   * @inheritDoc
   */
  init() {
    this.set("hasAny", !1), this._actions = new ke({ idProperty: "_id" }), this._actions.delegate("add", "remove").to(this);
  }
  /**
   * Adds an action to the list of pending actions.
   *
   * This method returns an action object with an observable message property.
   * The action object can be later used in the {@link #remove} method. It also allows you to change the message.
   *
   * @param message The action message.
   * @returns An observable object that represents a pending action.
   */
  add(e) {
    if (typeof e != "string")
      throw new g("pendingactions-add-invalid-message", this);
    const t = new (U())();
    return t.set("message", e), this._actions.add(t), this.hasAny = !0, t;
  }
  /**
   * Removes an action from the list of pending actions.
   *
   * @param action An action object.
   */
  remove(e) {
    this._actions.remove(e), this.hasAny = !!this._actions.length;
  }
  /**
   * Returns the first action from the list or null if the list is empty
   *
   * @returns The pending action object.
   */
  get first() {
    return this._actions.get(0);
  }
  /**
   * Iterable interface.
   */
  [Symbol.iterator]() {
    return this._actions[Symbol.iterator]();
  }
}
const eE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>', tE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>', nE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>', iE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>', sE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.209 18.717A8.5 8.5 0 1 1 18.686 9.6h-.008l.002.12a3 3 0 0 1-2.866 2.997h-.268l-.046-.002v.002h-4.791a2 2 0 1 0 0 4 1 1 0 1 1-.128 1.992 8.665 8.665 0 0 1-.372.008Zm-3.918-7.01a1.25 1.25 0 1 0-2.415-.648 1.25 1.25 0 0 0 2.415.647ZM5.723 8.18a1.25 1.25 0 1 0 .647-2.414 1.25 1.25 0 0 0-.647 2.414ZM9.76 6.155a1.25 1.25 0 1 0 .647-2.415 1.25 1.25 0 0 0-.647 2.415Zm4.028 1.759a1.25 1.25 0 1 0 .647-2.415 1.25 1.25 0 0 0-.647 2.415Z"/></svg>', oE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>', rE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11 1a9 9 0 1 1-8.027 13.075l1.128-1.129A7.502 7.502 0 0 0 18.5 10a7.5 7.5 0 1 0-14.962.759l-.745-.746-.76.76A9 9 0 0 1 11 1z"/><path d="M.475 8.17a.75.75 0 0 1 .978.047l.075.082 1.284 1.643 1.681-1.284a.75.75 0 0 1 .978.057l.073.083a.75.75 0 0 1-.057.978l-.083.073-2.27 1.737a.75.75 0 0 1-.973-.052l-.074-.082-1.741-2.23a.75.75 0 0 1 .13-1.052z"/><path d="M11.5 5v4.999l3.196 3.196-1.06 1.06L10.1 10.72l-.1-.113V5z"/></svg>', aE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>', lE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3.035 1C2.446 1 2 1.54 2 2.098V10.5h1.5v-8h13v8H18V2.098C18 1.539 17.48 1 16.9 1H3.035Zm10.453 2.61a1.885 1.885 0 0 0-1.442.736 1.89 1.89 0 0 0 1.011 2.976 1.903 1.903 0 0 0 2.253-1.114 1.887 1.887 0 0 0-1.822-2.598ZM7.463 8.163a.611.611 0 0 0-.432.154L5.071 10.5h5.119L7.88 8.348a.628.628 0 0 0-.417-.185Zm6.236 1.059a.62.62 0 0 0-.42.164L12.07 10.5h2.969l-.92-1.113a.618.618 0 0 0-.42-.165ZM.91 11.5a.91.91 0 0 0-.91.912v6.877c0 .505.405.91.91.91h18.178a.91.91 0 0 0 .912-.91v-6.877a.908.908 0 0 0-.912-.912H.91ZM3.668 13h1.947l2.135 5.7H5.898l-.28-.946H3.601l-.278.945H1.516L3.668 13Zm4.947 0h1.801v4.3h2.7v1.4h-4.5V13h-.001Zm4.5 0h5.4v1.4h-1.798v4.3h-1.701v-4.3h-1.9V13h-.001Zm-8.517 1.457-.614 2.059h1.262l-.648-2.059Z"/></svg>', cE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.68 13.74h-.001l4.209 4.208a1 1 0 1 0 1.414-1.414l-4.267-4.268a6 6 0 1 0-1.355 1.474ZM13 9a4 4 0 1 1-8 0 4 4 0 0 1 8 0Z"/></svg>', uE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>', dE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>', hE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.66 9.118a.693.693 0 0 1 .956.032l3.65 3.411 2.422-2.238a.695.695 0 0 1 .945 0L17.5 13.6V2.5h-15v11.1l4.16-4.482ZM17.8 1c.652 0 1.2.47 1.2 1.1v14.362c0 .64-.532 1.038-1.184 1.038H2.184C1.532 17.5 1 17.103 1 16.462V2.1C1 1.47 1.537 1 2.2 1h15.6Zm-5.655 6a2.128 2.128 0 0 1 .157-2.364A2.133 2.133 0 1 1 12.145 7Z"/></svg>', fE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M1.201 1C.538 1 0 1.47 0 2.1v14.363c0 .64.534 1.037 1.186 1.037h9.494a2.97 2.97 0 0 1-.414-.287 2.998 2.998 0 0 1-1.055-2.03 3.003 3.003 0 0 1 .693-2.185l.383-.455-.02.018-3.65-3.41a.695.695 0 0 0-.957-.034L1.5 13.6V2.5h15v5.535a2.97 2.97 0 0 1 1.412.932l.088.105V2.1c0-.63-.547-1.1-1.2-1.1H1.202Zm11.713 2.803a2.146 2.146 0 0 0-2.049 1.992 2.14 2.14 0 0 0 1.28 2.096 2.13 2.13 0 0 0 2.644-3.11 2.134 2.134 0 0 0-1.875-.978Z"/><path d="M15.522 19.1a.79.79 0 0 0 .79-.79v-5.373l2.059 2.455a.79.79 0 1 0 1.211-1.015l-3.352-3.995a.79.79 0 0 0-.995-.179.784.784 0 0 0-.299.221l-3.35 3.99a.79.79 0 1 0 1.21 1.017l1.936-2.306v5.185c0 .436.353.79.79.79Z"/><path d="M15.522 19.1a.79.79 0 0 0 .79-.79v-5.373l2.059 2.455a.79.79 0 1 0 1.211-1.015l-3.352-3.995a.79.79 0 0 0-.995-.179.784.784 0 0 0-.299.221l-3.35 3.99a.79.79 0 1 0 1.21 1.017l1.936-2.306v5.185c0 .436.353.79.79.79Z"/></svg>', mE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M1.201 1c-.662 0-1.2.47-1.2 1.1v14.248c0 .64.533 1.152 1.185 1.152h6.623v-7.236L6.617 9.15a.694.694 0 0 0-.957-.033L1.602 13.55V2.553l14.798.003V9.7H18V2.1c0-.63-.547-1.1-1.2-1.1H1.202Zm11.723 2.805a2.094 2.094 0 0 0-1.621.832 2.127 2.127 0 0 0 1.136 3.357 2.13 2.13 0 0 0 2.611-1.506 2.133 2.133 0 0 0-.76-2.244 2.13 2.13 0 0 0-1.366-.44Z"/><path clip-rule="evenodd" d="M19.898 12.369v6.187a.844.844 0 0 1-.844.844h-8.719a.844.844 0 0 1-.843-.844v-7.312a.844.844 0 0 1 .843-.844h2.531a.843.843 0 0 1 .597.248l.838.852h4.75c.223 0 .441.114.6.272a.844.844 0 0 1 .247.597Zm-1.52.654-4.377.02-1.1-1.143H11v6h7.4l-.023-4.877Z"/></svg>', gE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M1.201 1C.538 1 0 1.47 0 2.1v14.363c0 .64.534 1.037 1.186 1.037h7.029a5.401 5.401 0 0 1 .615-4.338l.762-1.232-2.975-2.78a.696.696 0 0 0-.957-.033L1.5 13.6V2.5h15v6.023c.449.131.887.32 1.307.573l.058.033c.046.028.09.057.135.086V2.1c0-.63-.547-1.1-1.2-1.1H1.202Zm11.713 2.803a2.15 2.15 0 0 0-1.611.834 2.118 2.118 0 0 0-.438 1.158 2.14 2.14 0 0 0 1.277 2.096 2.132 2.132 0 0 0 2.645-3.11 2.13 2.13 0 0 0-1.873-.978Z"/><path d="M16.63 10.294a3.003 3.003 0 0 0-4.142.887l-.117.177a.647.647 0 0 0-.096.492.664.664 0 0 0 .278.418.7.7 0 0 0 .944-.234 1.741 1.741 0 0 1 2.478-.463 1.869 1.869 0 0 1 .476 2.55.637.637 0 0 0-.071.5.646.646 0 0 0 .309.396.627.627 0 0 0 .869-.19l.027-.041a3.226 3.226 0 0 0-.956-4.492Zm-6.061 3.78-.044.066a3.228 3.228 0 0 0 .82 4.403 3.005 3.005 0 0 0 4.275-.798l.13-.197a.626.626 0 0 0 .092-.475.638.638 0 0 0-.268-.402.713.713 0 0 0-.99.26l-.018.029a1.741 1.741 0 0 1-2.477.461 1.87 1.87 0 0 1-.475-2.55l.029-.047a.647.647 0 0 0 .086-.485.66.66 0 0 0-.275-.408l-.04-.027a.609.609 0 0 0-.845.17Z"/><path d="M15.312 13.925c.24-.36.154-.838-.19-1.067-.346-.23-.82-.124-1.059.236l-1.268 1.907c-.239.36-.153.838.192 1.067.345.23.818.123 1.057-.236l1.268-1.907Z"/></svg>', pE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>', bE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>', wE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>', _E = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>', vE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>', yE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>', CE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>', kE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', TE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>', EE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>', AE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>', xE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', IE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', SE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>', PE = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>', RE = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:v="https://vecta.io/nano" viewBox="0 0 20 20"><path d="M.95 1.43a.95.95 0 0 0-.95.95v3.1a.95.95 0 0 0 .95.95h.75v6.3H.95a.95.95 0 0 0-.95.95v3.1a.95.95 0 0 0 .95.95h3.1a.95.95 0 0 0 .95-.95v-.65h1.932l1.539-1.5H5v-.95a.95.95 0 0 0-.95-.95H3.2v-6.3h.85A.95.95 0 0 0 5 5.48v-.55h10v.55a.95.95 0 0 0 .95.95h3.1a.95.95 0 0 0 .95-.95v-3.1a.95.95 0 0 0-.95-.95h-3.1a.95.95 0 0 0-.95.95v1.05H5V2.38a.95.95 0 0 0-.95-.95H.95zm.55 3.5v-2h2v2h-2zm0 9.3v2h2v-2h-2zm15-11.3v2h2v-2h-2z"/><path d="M8.139 20.004v-2.388l7.045-7.048 2.391 2.391-7.046 7.046h-2.39zm11.421-9.101a.64.64 0 0 1-.138.206l-1.165 1.168-2.391-2.391 1.167-1.163a.63.63 0 0 1 .206-.138.635.635 0 0 1 .243-.049.63.63 0 0 1 .449.187l1.491 1.488c.059.059.108.129.138.206s.049.16.049.243a.6.6 0 0 1-.049.243z"/></svg>', VE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 16.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1ZM1 15v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 13v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 11v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 9v1H0V9h1Zm19 0v1h-1V9h1ZM1 7v1H0V7h1Zm19 0v1h-1V7h1ZM1 5v1H0V5h1Zm19 0v1h-1V5h1Zm0-2v1h-1V3h1ZM1 3v1H0V3h1Zm13.5-1.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm-8 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm8 0v1h-1v-1h1Zm-10 0v1h-1v-1h1Z"/><path d="M13 5.5H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2v-8a2 2 0 0 0-2-2ZM13 7a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-8A.5.5 0 0 1 2 7h11Z"/></svg>', ME = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 16.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1ZM1 15v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 13v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 11v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 9v1H0V9h1Zm19 0v1h-1V9h1ZM1 7v1H0V7h1Zm19 0v1h-1V7h1ZM1 5v1H0V5h1Zm19 0v1h-1V5h1Zm0-2v1h-1V3h1ZM1 3v1H0V3h1Zm13.5-1.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm-8 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm8 0v1h-1v-1h1Zm-10 0v1h-1v-1h1Z"/><path d="M7 9.5H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2ZM7 11a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4A.5.5 0 0 1 2 11h5Z"/></svg>', BE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 16.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1ZM1 15v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 13v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 11v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 9v1H0V9h1Zm19 0v1h-1V9h1ZM1 7v1H0V7h1Zm19 0v1h-1V7h1ZM1 5v1H0V5h1Zm19 0v1h-1V5h1Zm0-2v1h-1V3h1ZM1 3v1H0V3h1Zm13.5-1.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm-8 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm8 0v1h-1v-1h1Zm-10 0v1h-1v-1h1Z"/><path d="M10 7.5H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2ZM10 9a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6A.5.5 0 0 1 2 9h8Z"/></svg>', LE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>', OE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>', FE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>', NE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>', DE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5 3.25a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 3.25a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M5 10a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 10a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M5 16.75a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 16.75a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/></svg>', zE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>', HE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5zM5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/></svg>', UE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 0 0-1 1v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V3a1 1 0 0 0-1-1Z"/></svg>', $E = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555Zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13Z"/><path d="m12.09 17-.534-1.292.848-1.971.545 1.319L12.113 17h-.023Zm1.142-5.187.545 1.319L15.5 9.13l1.858 4.316h-3.45l.398.965h3.467L18.887 17H20l-3.873-9h-1.254l-1.641 3.813Z"/></svg>', WE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M19 4.5 14 0H3v12.673l.868-1.041c.185-.222.4-.402.632-.54V1.5h8v5h5v7.626a2.24 2.24 0 0 1 1.5.822V4.5ZM14 5V2l3.3 3H14Zm-3.692 12.5c.062.105.133.206.213.303L11.52 19H8v-.876a2.243 2.243 0 0 0 1.82-.624h.488Zm7.518-.657a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0l2.346-2.815Zm-15.056-.38a.75.75 0 0 1-.096-1.056l2.346-2.815a.95.95 0 0 1 1.46 0l2.346 2.815a.75.75 0 1 1-1.152.96L6.5 14.96V20H5v-5.04l-1.174 1.408a.75.75 0 0 1-1.056.096Z"/></svg>', qE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>', GE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>', jE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>', KE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>', ZE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m2.315 14.705 2.224-2.24a.689.689 0 0 1 .963 0 .664.664 0 0 1 0 .949L2.865 16.07a.682.682 0 0 1-.112.089.647.647 0 0 1-.852-.051L.688 14.886a.635.635 0 0 1 0-.903.647.647 0 0 1 .91 0l.717.722zm5.185.045a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75zM2.329 5.745l2.21-2.226a.689.689 0 0 1 .963 0 .664.664 0 0 1 0 .95L2.865 7.125a.685.685 0 0 1-.496.196.644.644 0 0 1-.468-.187L.688 5.912a.635.635 0 0 1 0-.903.647.647 0 0 1 .91 0l.73.736zM7.5 5.75A.75.75 0 0 1 8.25 5h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>', JE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.87 12.61a.75.75 0 0 1-.089.976l-.085.07-3.154 2.254 3.412 2.414a.75.75 0 0 1 .237.95l-.057.095a.75.75 0 0 1-.95.237l-.096-.058-4.272-3.022-.003-1.223 4.01-2.867a.75.75 0 0 1 1.047.174zm2.795-.231.095.057 4.011 2.867-.003 1.223-4.272 3.022-.095.058a.75.75 0 0 1-.88-.151l-.07-.086-.058-.095a.75.75 0 0 1 .15-.88l.087-.07 3.412-2.414-3.154-2.253-.085-.071a.75.75 0 0 1 .862-1.207zM16 0a2 2 0 0 1 2 2v9.354l-.663-.492-.837-.001V2a.5.5 0 0 0-.5-.5H2a.5.5 0 0 0-.5.5v15a.5.5 0 0 0 .5.5h3.118L7.156 19H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h14zM5.009 15l.003 1H3v-1h2.009zm2.188-2-1.471 1H5v-1h2.197zM10 11v.095L8.668 12H7v-1h3zm4-2v1H7V9h7zm0-2v1H7V7h7zm-4-2v1H5V5h5zM6 3v1H3V3h3z"/></svg>', XE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.627 16.5zm5.873-.196zm0-7.001V8h-13v8.5h4.341c.191.54.457 1.044.785 1.5H2a1.5 1.5 0 0 1-1.5-1.5v-13A1.5 1.5 0 0 1 2 2h4.5a1.5 1.5 0 0 1 1.06.44L9.122 4H16a1.5 1.5 0 0 1 1.5 1.5v1A1.5 1.5 0 0 1 19 8v2.531a6.027 6.027 0 0 0-1.5-1.228zM16 6.5v-1H8.5l-2-2H2v13h1V8a1.5 1.5 0 0 1 1.5-1.5H16z"/><path d="M14.5 19.5a5 5 0 1 1 0-10 5 5 0 0 1 0 10zM15 14v-2h-1v2h-2v1h2v2h1v-2h2v-1h-2z"/></svg>', QE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M19 9v10h-2v-8h-2V9h4zM4 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1H10a1 1 0 0 1-1-1V11H4v4.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1H3a1 1 0 0 1 1 1v4.5z"/></svg>', YE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1V11H3v4.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1H2a1 1 0 0 1 1 1v4.5zm16.076 8.343V18.5h-6.252c.067-.626.27-1.22.61-1.78.338-.561 1.006-1.305 2.005-2.232.804-.749 1.297-1.257 1.479-1.523.245-.368.368-.732.368-1.092 0-.398-.107-.703-.32-.917-.214-.214-.51-.32-.886-.32-.372 0-.669.111-.889.336-.22.224-.347.596-.38 1.117l-1.778-.178c.106-.982.438-1.686.997-2.114.558-.427 1.257-.64 2.095-.64.918 0 1.64.247 2.164.742.525.495.787 1.11.787 1.847 0 .419-.075.818-.225 1.197-.15.378-.388.775-.714 1.19-.216.275-.605.67-1.168 1.187-.563.516-.92.859-1.07 1.028a3.11 3.11 0 0 0-.365.495h3.542z"/></svg>', eA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1V11H3v4.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1H2a1 1 0 0 1 1 1v4.5zm9.989 7.53 1.726-.209c.055.44.203.777.445 1.01.24.232.533.349.876.349.368 0 .678-.14.93-.42.251-.279.377-.655.377-1.13 0-.448-.12-.803-.362-1.066a1.153 1.153 0 0 0-.882-.393c-.228 0-.501.044-.819.133l.197-1.453c.482.012.85-.092 1.105-.315.253-.222.38-.517.38-.885 0-.313-.093-.563-.279-.75-.186-.185-.434-.278-.743-.278a1.07 1.07 0 0 0-.78.317c-.216.212-.347.52-.394.927l-1.644-.28c.114-.562.287-1.012.517-1.348.231-.337.553-.601.965-.794a3.24 3.24 0 0 1 1.387-.289c.876 0 1.579.28 2.108.838.436.457.653.973.653 1.549 0 .817-.446 1.468-1.339 1.955.533.114.96.37 1.28.768.319.398.478.878.478 1.441 0 .817-.298 1.513-.895 2.088-.596.576-1.339.864-2.228.864-.842 0-1.54-.243-2.094-.727-.555-.485-.876-1.118-.965-1.901z"/></svg>', tA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3.5 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V11h-5v4.5a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v4.5zm13.55 10v-1.873h-3.81v-1.561l4.037-5.91h1.498v5.904h1.156v1.567h-1.156V18.5H17.05zm0-3.44v-3.18l-2.14 3.18h2.14z"/></svg>', nA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3.5 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V11h-5v4.5a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v4.5zm9.578 7.607 1.777-.184c.05.402.201.72.45.955a1.223 1.223 0 0 0 1.81-.101c.258-.303.387-.759.387-1.368 0-.572-.128-1-.384-1.286-.256-.285-.59-.428-1-.428-.512 0-.971.226-1.377.679l-1.448-.21.915-4.843h4.716v1.67H15.56l-.28 1.58a2.697 2.697 0 0 1 1.219-.298 2.68 2.68 0 0 1 2.012.863c.55.576.825 1.323.825 2.241a3.36 3.36 0 0 1-.666 2.05c-.605.821-1.445 1.232-2.52 1.232-.86 0-1.56-.23-2.101-.692-.542-.461-.866-1.081-.971-1.86z"/></svg>', iA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3.5 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V11h-5v4.5a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v4.5zm15.595 2.973-1.726.19c-.043-.355-.153-.617-.33-.787-.178-.169-.409-.253-.692-.253-.377 0-.695.169-.956.507-.26.339-.424 1.043-.492 2.114.445-.525.997-.787 1.657-.787.745 0 1.383.284 1.914.85.531.568.797 1.3.797 2.197 0 .952-.28 1.716-.838 2.291-.559.576-1.276.864-2.152.864-.94 0-1.712-.365-2.317-1.095-.605-.73-.908-1.927-.908-3.59 0-1.705.316-2.935.946-3.688.63-.753 1.45-1.13 2.457-1.13.706 0 1.291.198 1.755.594.463.395.758.97.885 1.723zm-4.043 3.891c0 .58.133 1.028.4 1.343.266.315.57.473.914.473.33 0 .605-.13.825-.388.22-.258.33-.68.33-1.27 0-.604-.118-1.047-.355-1.329a1.115 1.115 0 0 0-.89-.422c-.342 0-.632.134-.869.403s-.355.666-.355 1.19z"/></svg>', sA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 9h16v2H2z"/></svg>', oA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M17 0a2 2 0 0 1 2 2v7a1 1 0 0 1 1 1v5a1 1 0 0 1-.883.993l-.118.006L19 17a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2l-.001-1.001-.116-.006A1 1 0 0 1 0 15v-5a1 1 0 0 1 .999-1L1 2a2 2 0 0 1 2-2h14zm.499 15.999h-15L2.5 17a.5.5 0 0 0 .5.5h14a.5.5 0 0 0 .5-.5l-.001-1.001zm-3.478-6.013-.014.014H14v.007l-1.525 1.525-1.46-1.46-.015.013V10h-1v5h1v-3.53l1.428 1.43.048.043.131-.129L14 11.421V15h1v-5h-.965l-.014-.014zM2 10H1v5h1v-2h2v2h1v-5H4v2H2v-2zm7 0H6v1h1v4h1v-4h1v-1zm8 0h-1v5h3v-1h-2v-4zm0-8.5H3a.5.5 0 0 0-.5.5l-.001 6.999h15L17.5 2a.5.5 0 0 0-.5-.5zM10 7v1H4V7h6zm3-2v1H4V5h9zm-3-2v1H4V3h6z"/></svg>', rA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95 5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>', aA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>', lA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 5.5v3h4v-3H3Zm0 4v3h4v-3H3Zm0 4v3h4v-3H3Zm5 3h4v-3H8v3Zm5 0h4v-3h-4v3Zm4-4v-3h-4v3h4Zm0-4v-3h-4v3h4Zm1.5 8A1.5 1.5 0 0 1 17 18H3a1.5 1.5 0 0 1-1.5-1.5V3c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13.5Zm-6.5-4v-3H8v3h4Zm0-4v-3H8v3h4Z"/></svg>';
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const A = {
  bold: zE,
  cancel: eE,
  caption: tE,
  check: nE,
  cog: iE,
  colorPalette: sE,
  eraser: oE,
  history: rE,
  image: hE,
  imageUpload: fE,
  imageAssetManager: mE,
  imageUrl: gE,
  lowVision: aE,
  textAlternative: lE,
  loupe: cE,
  previousArrow: uE,
  nextArrow: dE,
  importExport: WE,
  paragraph: HE,
  plus: UE,
  text: $E,
  alignBottom: pE,
  alignMiddle: bE,
  alignTop: wE,
  alignLeft: _E,
  alignCenter: vE,
  alignRight: yE,
  alignJustify: CE,
  objectLeft: IE,
  objectCenter: TE,
  objectRight: SE,
  objectFullWidth: AE,
  objectInline: xE,
  objectBlockLeft: kE,
  objectBlockRight: EE,
  objectSizeCustom: RE,
  objectSizeFull: PE,
  objectSizeLarge: VE,
  objectSizeSmall: ME,
  objectSizeMedium: BE,
  pencil: LE,
  pilcrow: OE,
  quote: FE,
  threeVerticalDots: NE,
  dragIndicator: DE,
  redo: qE,
  undo: GE,
  bulletedList: jE,
  numberedList: KE,
  todoList: ZE,
  codeBlock: JE,
  browseFiles: XE,
  heading1: QE,
  heading2: YE,
  heading3: eA,
  heading4: tA,
  heading5: nA,
  heading6: iA,
  horizontalLine: sA,
  html: oA,
  indent: rA,
  outdent: aA,
  table: lA
};
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class is extends Gt {
  constructor(e) {
    super(e), this.domEventType = [
      "paste",
      "copy",
      "cut",
      "drop",
      "dragover",
      "dragstart",
      "dragend",
      "dragenter",
      "dragleave"
    ];
    const t = this.document;
    this.listenTo(t, "paste", n("clipboardInput"), { priority: "low" }), this.listenTo(t, "drop", n("clipboardInput"), { priority: "low" }), this.listenTo(t, "dragover", n("dragging"), { priority: "low" });
    function n(s) {
      return (o, r) => {
        r.preventDefault();
        const a = r.dropRange ? [r.dropRange] : null, l = new St(t, s);
        t.fire(l, {
          dataTransfer: r.dataTransfer,
          method: o.name,
          targetRanges: a,
          target: r.target,
          domEvent: r.domEvent
        }), l.stop.called && r.stopPropagation();
      };
    }
  }
  onDomEvent(e) {
    const t = "clipboardData" in e ? e.clipboardData : e.dataTransfer, n = e.type == "drop" || e.type == "paste", s = {
      dataTransfer: new Sm(t, { cacheFiles: n })
    };
    (e.type == "drop" || e.type == "dragover") && (s.dropRange = cA(this.view, e)), this.fire(e.type, e, s);
  }
}
function cA(i, e) {
  const t = e.target.ownerDocument, n = e.clientX, s = e.clientY;
  let o;
  return t.caretRangeFromPoint && t.caretRangeFromPoint(n, s) ? o = t.caretRangeFromPoint(n, s) : e.rangeParent && (o = t.createRange(), o.setStart(e.rangeParent, e.rangeOffset), o.collapse(!0)), o ? i.domConverter.domRangeToView(o) : null;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function uA(i) {
  return i = i.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n\r?\n/g, "</p><p>").replace(/\r?\n/g, "<br>").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;"), (i.includes("</p><p>") || i.includes("<br>")) && (i = `<p>${i}</p>`), i;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function dA(i) {
  return i.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (e, t) => t.length == 1 ? " " : t).replace(/<!--[\s\S]*?-->/g, "");
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Mu = ["figcaption", "li"], Bu = ["ol", "ul"];
function ug(i) {
  if (i.is("$text") || i.is("$textProxy"))
    return i.data;
  if (i.is("element", "img") && i.hasAttribute("alt"))
    return i.getAttribute("alt");
  if (i.is("element", "br"))
    return `
`;
  let e = "", t = null;
  for (const n of i.getChildren())
    e += hA(n, t) + ug(n), t = n;
  return e;
}
function hA(i, e) {
  return e ? i.is("element", "li") && !i.isEmpty && i.getChild(0).is("containerElement") || Bu.includes(i.name) && Bu.includes(e.name) ? `

` : !i.is("containerElement") && !e.is("containerElement") ? "" : Mu.includes(i.name) || Mu.includes(e.name) ? `
` : `

` : "";
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Ui extends b {
  constructor() {
    super(...arguments), this._markersToCopy = /* @__PURE__ */ new Map();
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ClipboardMarkersUtils";
  }
  /**
   * Registers marker name as copyable in clipboard pipeline.
   *
   * @param markerName Name of marker that can be copied.
   * @param config Configuration that describes what can be performed on specified marker.
   * @internal
   */
  _registerMarkerToCopy(e, t) {
    this._markersToCopy.set(e, t);
  }
  /**
   * Performs copy markers on provided selection and paste it to fragment returned from `getCopiedFragment`.
   *
   * 	1. Picks all markers in provided selection.
   * 	2. Inserts fake markers to document.
   * 	3. Gets copied selection fragment from document.
   * 	4. Removes fake elements from fragment and document.
   * 	5. Inserts markers in the place of removed fake markers.
   *
   * Due to selection modification, when inserting items, `getCopiedFragment` must *always* operate on `writer.model.document.selection'.
   * Do not use any other custom selection object within callback, as this will lead to out-of-bounds exceptions in rare scenarios.
   *
   * @param action Type of clipboard action.
   * @param writer An instance of the model writer.
   * @param selection Selection to be checked.
   * @param getCopiedFragment	Callback that performs copy of selection and returns it as fragment.
   * @internal
   */
  _copySelectedFragmentWithMarkers(e, t, n = (s) => s.model.getSelectedContent(s.model.document.selection)) {
    return this.editor.model.change((s) => {
      const o = s.model.document.selection;
      s.setSelection(t);
      const r = this._insertFakeMarkersIntoSelection(s, s.model.document.selection, e), a = n(s), l = this._removeFakeMarkersInsideElement(s, a);
      for (const [c, u] of Object.entries(r)) {
        l[c] || (l[c] = s.createRangeIn(a));
        for (const d of u)
          s.remove(d);
      }
      a.markers.clear();
      for (const [c, u] of Object.entries(l))
        a.markers.set(c, u);
      return s.setSelection(o), a;
    });
  }
  /**
   * Performs paste of markers on already pasted element.
   *
   * 	1. Inserts fake markers that are present in fragment element (such fragment will be processed in `getPastedDocumentElement`).
   * 	2. Calls `getPastedDocumentElement` and gets element that is inserted into root model.
   * 	3. Removes all fake markers present in transformed element.
   * 	4. Inserts new markers with removed fake markers ranges into pasted fragment.
   *
   * There are multiple edge cases that have to be considered before calling this function:
   *
   * 	* `markers` are inserted into the same element that must be later transformed inside `getPastedDocumentElement`.
   * 	* Fake marker elements inside `getPastedDocumentElement` can be cloned, but their ranges cannot overlap.
   * 	* If `duplicateOnPaste` is `true` in marker config then associated marker ID is regenerated before pasting.
   *
   * @param action Type of clipboard action.
   * @param markers Object that maps marker name to corresponding range.
   * @param getPastedDocumentElement Getter used to get target markers element.
   * @internal
   */
  _pasteMarkersIntoTransformedElement(e, t) {
    const n = this._getPasteMarkersFromRangeMap(e);
    return this.editor.model.change((s) => {
      const o = this._insertFakeMarkersElements(s, n), r = t(s), a = this._removeFakeMarkersInsideElement(s, r);
      for (const l of Object.values(o).flat())
        s.remove(l);
      for (const [l, c] of Object.entries(a))
        s.model.markers.has(l) || s.addMarker(l, {
          usingOperation: !0,
          affectsData: !0,
          range: c
        });
      return r;
    });
  }
  /**
   * Pastes document fragment with markers to document.
   * If `duplicateOnPaste` is `true` in marker config then associated markers IDs
   * are regenerated before pasting to avoid markers duplications in content.
   *
   * @param fragment Document fragment that should contain already processed by pipeline markers.
   * @internal
   */
  _pasteFragmentWithMarkers(e) {
    const t = this._getPasteMarkersFromRangeMap(e.markers);
    e.markers.clear();
    for (const n of t)
      e.markers.set(n.name, n.range);
    return this.editor.model.insertContent(e);
  }
  /**
   * In some situations we have to perform copy on selected fragment with certain markers. This function allows to temporarily bypass
   * restrictions on markers that we want to copy.
   *
   * This function executes `executor()` callback. For the duration of the callback, if the clipboard pipeline is used to copy
   * content, markers with the specified name will be copied to the clipboard as well.
   *
   * @param markerName Which markers should be copied.
   * @param executor Callback executed.
   * @param config Optional configuration flags used to copy (such like partial copy flag).
   * @internal
   */
  _forceMarkersCopy(e, t, n = {
    allowedActions: "all",
    copyPartiallySelected: !0,
    duplicateOnPaste: !0
  }) {
    const s = this._markersToCopy.get(e);
    this._markersToCopy.set(e, n), t(), s ? this._markersToCopy.set(e, s) : this._markersToCopy.delete(e);
  }
  /**
   * Checks if marker can be copied.
   *
   * @param markerName Name of checked marker.
   * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.
   * @internal
   */
  _isMarkerCopyable(e, t) {
    const n = this._getMarkerClipboardConfig(e);
    if (!n)
      return !1;
    if (!t)
      return !0;
    const { allowedActions: s } = n;
    return s === "all" || s.includes(t);
  }
  /**
   * Checks if marker has any clipboard copy behavior configuration.
   *
   * @param markerName Name of checked marker.
   */
  _hasMarkerConfiguration(e) {
    return !!this._getMarkerClipboardConfig(e);
  }
  /**
   * Returns marker's configuration flags passed during registration.
   *
   * @param markerName Name of marker that should be returned.
   * @internal
   */
  _getMarkerClipboardConfig(e) {
    const [t] = e.split(":");
    return this._markersToCopy.get(t) || null;
  }
  /**
   * First step of copying markers. It looks for markers intersecting with given selection and inserts `$marker` elements
   * at positions where document markers start or end. This way `$marker` elements can be easily copied together with
   * the rest of the content of the selection.
   *
   * @param writer An instance of the model writer.
   * @param selection Selection to be checked.
   * @param action Type of clipboard action.
   */
  _insertFakeMarkersIntoSelection(e, t, n) {
    const s = this._getCopyableMarkersFromSelection(e, t, n);
    return this._insertFakeMarkersElements(e, s);
  }
  /**
   * Returns array of markers that can be copied in specified selection.
   *
   * If marker cannot be copied partially (according to `copyPartiallySelected` configuration flag) and
   * is not present entirely in any selection range then it will be skipped.
   *
   * @param writer An instance of the model writer.
   * @param selection  Selection which will be checked.
   * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.
   */
  _getCopyableMarkersFromSelection(e, t, n) {
    const s = Array.from(t.getRanges()), o = new Set(s.flatMap((a) => Array.from(e.model.markers.getMarkersIntersectingRange(a)))), r = (a) => {
      if (!this._isMarkerCopyable(a.name, n))
        return !1;
      const { copyPartiallySelected: c } = this._getMarkerClipboardConfig(a.name);
      if (!c) {
        const u = a.getRange();
        return s.some((d) => d.containsRange(u, !0));
      }
      return !0;
    };
    return Array.from(o).filter(r).map((a) => ({
      name: n === "dragstart" ? this._getUniqueMarkerName(a.name) : a.name,
      range: a.getRange()
    }));
  }
  /**
   * Picks all markers from markers map that can be pasted.
   * If `duplicateOnPaste` is `true`, it regenerates their IDs to ensure uniqueness.
   * If marker is not registered, it will be kept in the array anyway.
   *
   * @param markers Object that maps marker name to corresponding range.
   * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.
   */
  _getPasteMarkersFromRangeMap(e, t = null) {
    const { model: n } = this.editor;
    return (e instanceof Map ? Array.from(e.entries()) : Object.entries(e)).flatMap(([o, r]) => {
      if (!this._hasMarkerConfiguration(o))
        return [
          {
            name: o,
            range: r
          }
        ];
      if (this._isMarkerCopyable(o, t)) {
        const a = this._getMarkerClipboardConfig(o), l = n.markers.has(o) && n.markers.get(o).getRange().root.rootName === "$graveyard";
        return (a.duplicateOnPaste || l) && (o = this._getUniqueMarkerName(o)), [
          {
            name: o,
            range: r
          }
        ];
      }
      return [];
    });
  }
  /**
   * Inserts specified array of fake markers elements to document and assigns them `type` and `name` attributes.
   * Fake markers elements are used to calculate position of markers on pasted fragment that were transformed during
   * steps between copy and paste.
   *
   * @param writer An instance of the model writer.
   * @param markers Array of markers that will be inserted.
   */
  _insertFakeMarkersElements(e, t) {
    const n = {}, s = t.flatMap((o) => {
      const { start: r, end: a } = o.range;
      return [
        { position: r, marker: o, type: "start" },
        { position: a, marker: o, type: "end" }
      ];
    }).sort(({ position: o }, { position: r }) => o.isBefore(r) ? 1 : -1);
    for (const { position: o, marker: r, type: a } of s) {
      const l = e.createElement("$marker", {
        "data-name": r.name,
        "data-type": a
      });
      n[r.name] || (n[r.name] = []), n[r.name].push(l), e.insert(l, o);
    }
    return n;
  }
  /**
   * Removes all `$marker` elements from the given document fragment.
   *
   * Returns an object where keys are marker names, and values are ranges corresponding to positions
   * where `$marker` elements were inserted.
   *
   * If the document fragment had only one `$marker` element for given marker (start or end) the other boundary is set automatically
   * (to the end or start of the document fragment, respectively).
   *
   * @param writer An instance of the model writer.
   * @param rootElement The element to be checked.
   */
  _removeFakeMarkersInsideElement(e, t) {
    const s = this._getAllFakeMarkersFromElement(e, t).reduce((o, r) => {
      const a = r.markerElement && e.createPositionBefore(r.markerElement);
      let l = o[r.name], c = !1;
      return l && l.start && l.end && (this._getMarkerClipboardConfig(r.name).duplicateOnPaste ? o[this._getUniqueMarkerName(r.name)] = o[r.name] : c = !0, l = null), c || (o[r.name] = {
        ...l,
        [r.type]: a
      }), r.markerElement && e.remove(r.markerElement), o;
    }, {});
    return Ky(s, (o) => new _(o.start || e.createPositionFromPath(t, [0]), o.end || e.createPositionAt(t, "end")));
  }
  /**
   * Returns array that contains list of fake markers with corresponding `$marker` elements.
   *
   * For each marker, there can be two `$marker` elements or only one (if the document fragment contained
   * only the beginning or only the end of a marker).
   *
   * @param writer An instance of the model writer.
   * @param rootElement The element to be checked.
   */
  _getAllFakeMarkersFromElement(e, t) {
    const n = Array.from(e.createRangeIn(t)).flatMap(({ item: r }) => {
      if (!r.is("element", "$marker"))
        return [];
      const a = r.getAttribute("data-name"), l = r.getAttribute("data-type");
      return [
        {
          markerElement: r,
          name: a,
          type: l
        }
      ];
    }), s = [], o = [];
    for (const r of n)
      r.type === "end" && (n.some((l) => l.name === r.name && l.type === "start") || s.push({
        markerElement: null,
        name: r.name,
        type: "start"
      })), r.type === "start" && (n.some((l) => l.name === r.name && l.type === "end") || o.unshift({
        markerElement: null,
        name: r.name,
        type: "end"
      }));
    return [
      ...s,
      ...n,
      ...o
    ];
  }
  /**
   * When copy of markers occurs we have to make sure that pasted markers have different names
   * than source markers. This functions helps with assigning unique part to marker name to
   * prevent duplicated markers error.
   *
   * @param name Name of marker
   */
  _getUniqueMarkerName(e) {
    const t = e.split(":"), n = je().substring(1, 6);
    return t.length === 3 ? `${t.slice(0, 2).join(":")}:${n}` : `${t.join(":")}:${n}`;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Ze extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ClipboardPipeline";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Ui];
  }
  /**
   * @inheritDoc
   */
  init() {
    this.editor.editing.view.addObserver(is), this._setupPasteDrop(), this._setupCopyCut();
  }
  /**
   * Fires Clipboard `'outputTransformation'` event for given parameters.
   *
   * @internal
   */
  _fireOutputTransformationEvent(e, t, n) {
    const s = this.editor.plugins.get("ClipboardMarkersUtils");
    this.editor.model.enqueueChange({ isUndoable: n === "cut" }, () => {
      const o = s._copySelectedFragmentWithMarkers(n, t);
      this.fire("outputTransformation", {
        dataTransfer: e,
        content: o,
        method: n
      });
    });
  }
  /**
   * The clipboard paste pipeline.
   */
  _setupPasteDrop() {
    const e = this.editor, t = e.model, n = e.editing.view, s = n.document, o = this.editor.plugins.get("ClipboardMarkersUtils");
    this.listenTo(s, "clipboardInput", (r, a) => {
      a.method == "paste" && !e.model.canEditAt(e.model.document.selection) && r.stop();
    }, { priority: "highest" }), this.listenTo(s, "clipboardInput", (r, a) => {
      const l = a.dataTransfer;
      let c;
      if (a.content)
        c = a.content;
      else {
        let d = "";
        l.getData("text/html") ? d = dA(l.getData("text/html")) : l.getData("text/plain") && (d = uA(l.getData("text/plain"))), c = this.editor.data.htmlProcessor.toView(d);
      }
      const u = new St(this, "inputTransformation");
      this.fire(u, {
        content: c,
        dataTransfer: l,
        targetRanges: a.targetRanges,
        method: a.method
      }), u.stop.called && r.stop(), n.scrollToTheSelection();
    }, { priority: "low" }), this.listenTo(this, "inputTransformation", (r, a) => {
      if (a.content.isEmpty)
        return;
      const c = this.editor.data.toModel(a.content, "$clipboardHolder");
      c.childCount != 0 && (r.stop(), t.change(() => {
        this.fire("contentInsertion", {
          content: c,
          method: a.method,
          dataTransfer: a.dataTransfer,
          targetRanges: a.targetRanges
        });
      }));
    }, { priority: "low" }), this.listenTo(this, "contentInsertion", (r, a) => {
      a.resultRange = o._pasteFragmentWithMarkers(a.content);
    }, { priority: "low" });
  }
  /**
   * The clipboard copy/cut pipeline.
   */
  _setupCopyCut() {
    const e = this.editor, t = e.model.document, s = e.editing.view.document, o = (r, a) => {
      const l = a.dataTransfer;
      a.preventDefault(), this._fireOutputTransformationEvent(l, t.selection, r.name);
    };
    this.listenTo(s, "copy", o, { priority: "low" }), this.listenTo(s, "cut", (r, a) => {
      e.model.canEditAt(e.model.document.selection) ? o(r, a) : a.preventDefault();
    }, { priority: "low" }), this.listenTo(this, "outputTransformation", (r, a) => {
      const l = e.data.toView(a.content);
      s.fire("clipboardOutput", {
        dataTransfer: a.dataTransfer,
        content: l,
        method: a.method
      });
    }, { priority: "low" }), this.listenTo(s, "clipboardOutput", (r, a) => {
      a.content.isEmpty || (a.dataTransfer.setData("text/html", this.editor.data.htmlProcessor.toData(a.content)), a.dataTransfer.setData("text/plain", ug(a.content))), a.method == "cut" && e.model.deleteContent(t.selection);
    }, { priority: "low" });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class dg {
  /**
   * Creates a new instance of the change buffer.
   *
   * @param limit The maximum number of atomic changes which can be contained in one batch.
   */
  constructor(e, t = 20) {
    this._batch = null, this.model = e, this._size = 0, this.limit = t, this._isLocked = !1, this._changeCallback = (n, s) => {
      s.isLocal && s.isUndoable && s !== this._batch && this._reset(!0);
    }, this._selectionChangeCallback = () => {
      this._reset();
    }, this.model.document.on("change", this._changeCallback), this.model.document.selection.on("change:range", this._selectionChangeCallback), this.model.document.selection.on("change:attribute", this._selectionChangeCallback);
  }
  /**
   * The current batch to which a feature should add its operations. Once the {@link #size}
   * is reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.
   */
  get batch() {
    return this._batch || (this._batch = this.model.createBatch({ isTyping: !0 })), this._batch;
  }
  /**
   * The number of atomic changes in the buffer. Once it exceeds the {@link #limit},
   * the {@link #batch batch} is set to a new one.
   */
  get size() {
    return this._size;
  }
  /**
   * The input number of changes into the buffer. Once the {@link #size} is
   * reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.
   *
   * @param changeCount The number of atomic changes to input.
   */
  input(e) {
    this._size += e, this._size >= this.limit && this._reset(!0);
  }
  /**
   * Whether the buffer is locked. A locked buffer cannot be reset unless it gets unlocked.
   */
  get isLocked() {
    return this._isLocked;
  }
  /**
   * Locks the buffer.
   */
  lock() {
    this._isLocked = !0;
  }
  /**
   * Unlocks the buffer.
   */
  unlock() {
    this._isLocked = !1;
  }
  /**
   * Destroys the buffer.
   */
  destroy() {
    this.model.document.off("change", this._changeCallback), this.model.document.selection.off("change:range", this._selectionChangeCallback), this.model.document.selection.off("change:attribute", this._selectionChangeCallback);
  }
  /**
   * Resets the change buffer.
   *
   * @param ignoreLock Whether internal lock {@link #isLocked} should be ignored.
   */
  _reset(e = !1) {
    (!this.isLocked || e) && (this._batch = null, this._size = 0);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class fA extends V {
  /**
   * Creates an instance of the command.
   *
   * @param undoStepSize The maximum number of atomic changes
   * which can be contained in one batch in the command buffer.
   */
  constructor(e, t) {
    super(e), this._buffer = new dg(e.model, t), this._isEnabledBasedOnSelection = !1;
  }
  /**
   * The current change buffer.
   */
  get buffer() {
    return this._buffer;
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this._buffer.destroy();
  }
  /**
   * Executes the input command. It replaces the content within the given range with the given text.
   * Replacing is a two step process, first the content within the range is removed and then the new text is inserted
   * at the beginning of the range (which after the removal is a collapsed range).
   *
   * @fires execute
   * @param options The command options.
   */
  execute(e = {}) {
    const t = this.editor.model, n = t.document, s = e.text || "", o = s.length;
    let r = n.selection;
    if (e.selection ? r = e.selection : e.range && (r = t.createSelection(e.range)), !t.canEditAt(r))
      return;
    const a = e.resultRange;
    t.enqueueChange(this._buffer.batch, (l) => {
      this._buffer.lock();
      const c = Array.from(n.selection.getAttributes());
      t.deleteContent(r), s && t.insertContent(l.createText(s, c), r), a ? l.setSelection(a) : r.is("documentSelection") || l.setSelection(r), this._buffer.unlock(), this._buffer.input(o);
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Lu = [
  // For collapsed range:
  //	- This one is a regular typing (all browsers, all systems).
  //	- This one is used by Chrome when typing accented letter – 2nd step when the user selects the accent (Mac).
  // For non-collapsed range:
  //	- This one is used by Chrome when typing accented letter – when the selection box first appears (Mac).
  //	- This one is used by Safari when accepting spell check suggestions from the context menu (Mac).
  "insertText",
  // This one is used by Safari when typing accented letter (Mac).
  // This one is used by Safari when accepting spell check suggestions from the autocorrection pop-up (Mac).
  "insertReplacementText"
];
class mA extends wt {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.focusObserver = e.getObserver(ko), M.isAndroid && Lu.push("insertCompositionText");
    const t = e.document;
    t.on("beforeinput", (n, s) => {
      if (!this.isEnabled)
        return;
      const { data: o, targetRanges: r, inputType: a, domEvent: l } = s;
      if (!Lu.includes(a))
        return;
      this.focusObserver.flush();
      const c = new St(t, "insertText");
      t.fire(c, new Yn(e, l, {
        text: o,
        selection: e.createSelection(r)
      })), c.stop.called && n.stop();
    }), t.on("compositionend", (n, { data: s, domEvent: o }) => {
      !this.isEnabled || M.isAndroid || s && t.fire("insertText", new Yn(e, o, {
        text: s,
        selection: t.selection
      }));
    }, { priority: "lowest" });
  }
  /**
   * @inheritDoc
   */
  observe() {
  }
  /**
   * @inheritDoc
   */
  stopObserving() {
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class hg extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Input";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model, n = e.editing.view, s = t.document.selection;
    n.addObserver(mA);
    const o = new fA(e, e.config.get("typing.undoStep") || 20);
    e.commands.add("insertText", o), e.commands.add("input", o), this.listenTo(n.document, "insertText", (r, a) => {
      n.document.isComposing || a.preventDefault();
      const { text: l, selection: c, resultRange: u } = a, d = Array.from(c.getRanges()).map((m) => e.editing.mapper.toModelRange(m));
      let h = l;
      if (M.isAndroid) {
        const m = Array.from(d[0].getItems()).reduce((p, w) => p + (w.is("$textProxy") ? w.data : ""), "");
        m && (m.length <= h.length ? h.startsWith(m) && (h = h.substring(m.length), d[0].start = d[0].start.getShiftedBy(m.length)) : m.startsWith(h) && (d[0].start = d[0].start.getShiftedBy(h.length), h = ""));
      }
      const f = {
        text: h,
        selection: t.createSelection(d)
      };
      u && (f.resultRange = e.editing.mapper.toModelRange(u)), e.execute("insertText", f), n.scrollToTheSelection();
    }), M.isAndroid ? this.listenTo(n.document, "keydown", (r, a) => {
      s.isCollapsed || a.keyCode != 229 || !n.document.isComposing || Ou(t, o);
    }) : this.listenTo(n.document, "compositionstart", () => {
      s.isCollapsed || Ou(t, o);
    });
  }
}
function Ou(i, e) {
  if (!e.isEnabled)
    return;
  const t = e.buffer;
  t.lock(), i.enqueueChange(t.batch, () => {
    i.deleteContent(i.document.selection);
  }), t.unlock();
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Fu extends V {
  /**
   * Creates an instance of the command.
   *
   * @param direction The directionality of the delete describing in what direction it
   * should consume the content when the selection is collapsed.
   */
  constructor(e, t) {
    super(e), this.direction = t, this._buffer = new dg(e.model, e.config.get("typing.undoStep")), this._isEnabledBasedOnSelection = !1;
  }
  /**
   * The current change buffer.
   */
  get buffer() {
    return this._buffer;
  }
  /**
   * Executes the delete command. Depending on whether the selection is collapsed or not, deletes its content
   * or a piece of content in the {@link #direction defined direction}.
   *
   * @fires execute
   * @param options The command options.
   * @param options.unit See {@link module:engine/model/utils/modifyselection~modifySelection}'s options.
   * @param options.sequence A number describing which subsequent delete event it is without the key being released.
   * See the {@link module:engine/view/document~Document#event:delete} event data.
   * @param options.selection Selection to remove. If not set, current model selection will be used.
   */
  execute(e = {}) {
    const t = this.editor.model, n = t.document;
    t.enqueueChange(this._buffer.batch, (s) => {
      this._buffer.lock();
      const o = s.createSelection(e.selection || n.selection);
      if (!t.canEditAt(o))
        return;
      const r = e.sequence || 1, a = o.isCollapsed;
      if (o.isCollapsed && t.modifySelection(o, {
        direction: this.direction,
        unit: e.unit,
        treatEmojiAsSingleUnit: !0
      }), this._shouldEntireContentBeReplacedWithParagraph(r)) {
        this._replaceEntireContentWithParagraph(s);
        return;
      }
      if (this._shouldReplaceFirstBlockWithParagraph(o, r)) {
        this.editor.execute("paragraph", { selection: o });
        return;
      }
      if (o.isCollapsed)
        return;
      let l = 0;
      o.getFirstRange().getMinimalFlatRanges().forEach((c) => {
        l += oa(c.getWalker({ singleCharacters: !0, ignoreElementEnd: !0, shallow: !0 }));
      }), t.deleteContent(o, {
        doNotResetEntireContent: a,
        direction: this.direction
      }), this._buffer.input(l), s.setSelection(o), this._buffer.unlock();
    });
  }
  /**
   * If the user keeps <kbd>Backspace</kbd> or <kbd>Delete</kbd> key pressed, the content of the current
   * editable will be cleared. However, this will not yet lead to resetting the remaining block to a paragraph
   * (which happens e.g. when the user does <kbd>Ctrl</kbd> + <kbd>A</kbd>, <kbd>Backspace</kbd>).
   *
   * But, if the user pressed the key in an empty editable for the first time,
   * we want to replace the entire content with a paragraph if:
   *
   * * the current limit element is empty,
   * * the paragraph is allowed in the limit element,
   * * the limit doesn't already have a paragraph inside.
   *
   * See https://github.com/ckeditor/ckeditor5-typing/issues/61.
   *
   * @param sequence A number describing which subsequent delete event it is without the key being released.
   */
  _shouldEntireContentBeReplacedWithParagraph(e) {
    if (e > 1)
      return !1;
    const t = this.editor.model, s = t.document.selection, o = t.schema.getLimitElement(s);
    if (!(s.isCollapsed && s.containsEntireContent(o)) || !t.schema.checkChild(o, "paragraph"))
      return !1;
    const a = o.getChild(0);
    return !(a && a.is("element", "paragraph"));
  }
  /**
   * The entire content is replaced with the paragraph. Selection is moved inside the paragraph.
   *
   * @param writer The model writer.
   */
  _replaceEntireContentWithParagraph(e) {
    const t = this.editor.model, s = t.document.selection, o = t.schema.getLimitElement(s), r = e.createElement("paragraph");
    e.remove(e.createRangeIn(o)), e.insert(r, o), e.setSelection(r, 0);
  }
  /**
   * Checks if the selection is inside an empty element that is the first child of the limit element
   * and should be replaced with a paragraph.
   *
   * @param selection The selection.
   * @param sequence A number describing which subsequent delete event it is without the key being released.
   */
  _shouldReplaceFirstBlockWithParagraph(e, t) {
    const n = this.editor.model;
    if (t > 1 || this.direction != "backward" || !e.isCollapsed)
      return !1;
    const s = e.getFirstPosition(), o = n.schema.getLimitElement(s), r = o.getChild(0);
    return !(s.parent != r || !e.containsEntireContent(r) || !n.schema.checkChild(o, "paragraph") || r.name == "paragraph");
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const gA = "character", Nu = "word", pA = "codePoint", zt = "selection", Un = "backward", Vi = "forward", fg = {
  // --------------------------------------- Backward delete types -----------------------------------------------------
  // This happens in Safari on Mac when some content is selected and Ctrl + K is pressed.
  deleteContent: {
    unit: zt,
    // According to the Input Events Level 2 spec, this delete type has no direction
    // but to keep things simple, let's default to backward.
    direction: Un
  },
  // Chrome and Safari on Mac: Backspace or Ctrl + H
  deleteContentBackward: {
    // This kind of deletions must be done on the code point-level instead of target range provided by the DOM beforeinput event.
    // Take for instance "👨‍👩‍👧‍👧", it equals:
    //
    //	* [ "👨", "ZERO WIDTH JOINER", "👩", "ZERO WIDTH JOINER", "👧", "ZERO WIDTH JOINER", "👧" ]
    //	* or simply "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}"
    //
    // The range provided by the browser would cause the entire multi-byte grapheme to disappear while the user
    // intention when deleting backwards ("👨‍👩‍👧‍👧[]", then backspace) is gradual "decomposition" (first to "👨‍👩‍👧‍[]",
    // then to "👨‍👩‍[]", etc.).
    //
    //	* "👨‍👩‍👧‍👧[]" + backward delete (by code point)  -> results in "👨‍👩‍👧[]", removed the last "👧" 👍
    //	* "👨‍👩‍👧‍👧[]" + backward delete (by character)  -> results in "[]", removed the whole grapheme 👎
    //
    // Deleting by code-point is simply a better UX. See "deleteContentForward" to learn more.
    unit: pA,
    direction: Un
  },
  // On Mac: Option + Backspace.
  // On iOS: Hold the backspace for a while and the whole words will start to disappear.
  deleteWordBackward: {
    unit: Nu,
    direction: Un
  },
  // Safari on Mac: Cmd + Backspace
  deleteHardLineBackward: {
    unit: zt,
    direction: Un
  },
  // Chrome on Mac: Cmd + Backspace.
  deleteSoftLineBackward: {
    unit: zt,
    direction: Un
  },
  // --------------------------------------- Forward delete types -----------------------------------------------------
  // Chrome on Mac: Fn + Backspace or Ctrl + D
  // Safari on Mac: Ctrl + K or Ctrl + D
  deleteContentForward: {
    // Unlike backward delete, this delete must be performed by character instead of by code point, which
    // provides the best UX for working with accented letters.
    // Take, for example "b̂" ("\u0062\u0302", or [ "LATIN SMALL LETTER B", "COMBINING CIRCUMFLEX ACCENT" ]):
    //
    //	* "b̂[]" + backward delete (by code point)  -> results in "b[]", removed the combining mark 👍
    //	* "[]b̂" + forward delete (by code point)   -> results in "[]^", a bare combining mark does that not make sense when alone 👎
    //	* "[]b̂" + forward delete (by character)    -> results in "[]", removed both "b" and the combining mark 👍
    //
    // See: "deleteContentBackward" to learn more.
    unit: gA,
    direction: Vi
  },
  // On Mac: Fn + Option + Backspace.
  deleteWordForward: {
    unit: Nu,
    direction: Vi
  },
  // Chrome on Mac: Ctrl + K (you have to disable the Link plugin first, though, because it uses the same keystroke)
  // This is weird that it does not work in Safari on Mac despite being listed in the official shortcuts listing
  // on Apple's webpage.
  deleteHardLineForward: {
    unit: zt,
    direction: Vi
  },
  // At this moment there is no known way to trigger this event type but let's keep it for the symmetry with
  // deleteSoftLineBackward.
  deleteSoftLineForward: {
    unit: zt,
    direction: Vi
  }
};
class bA extends wt {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e);
    const t = e.document;
    let n = 0;
    t.on("keydown", () => {
      n++;
    }), t.on("keyup", () => {
      n = 0;
    }), t.on("beforeinput", (s, o) => {
      if (!this.isEnabled)
        return;
      const { targetRanges: r, domEvent: a, inputType: l } = o, c = fg[l];
      if (!c)
        return;
      const u = {
        direction: c.direction,
        unit: c.unit,
        sequence: n
      };
      u.unit == zt && (u.selectionToRemove = e.createSelection(r[0])), l === "deleteContentBackward" && (M.isAndroid && (u.sequence = 1), _A(r) && (u.unit = zt, u.selectionToRemove = e.createSelection(r)));
      const d = new hi(t, "delete", r[0]);
      t.fire(d, new Yn(e, a, u)), d.stop.called && s.stop();
    }), M.isBlink && wA(this);
  }
  /**
   * @inheritDoc
   */
  observe() {
  }
  /**
   * @inheritDoc
   */
  stopObserving() {
  }
}
function wA(i) {
  const e = i.view, t = e.document;
  let n = null, s = !1;
  t.on("keydown", (a, { keyCode: l }) => {
    n = l, s = !1;
  }), t.on("keyup", (a, { keyCode: l, domEvent: c }) => {
    const u = t.selection, d = i.isEnabled && l == n && o(l) && !u.isCollapsed && !s;
    if (n = null, d) {
      const h = u.getFirstRange(), f = new hi(t, "delete", h), m = {
        unit: zt,
        direction: r(l),
        selectionToRemove: u
      };
      t.fire(f, new Yn(e, c, m));
    }
  }), t.on("beforeinput", (a, { inputType: l }) => {
    const c = fg[l];
    o(n) && c && c.direction == r(n) && (s = !0);
  }, { priority: "high" }), t.on("beforeinput", (a, { inputType: l, data: c }) => {
    n == N.delete && l == "insertText" && c == "" && a.stop();
  }, { priority: "high" });
  function o(a) {
    return a == N.backspace || a == N.delete;
  }
  function r(a) {
    return a == N.backspace ? Un : Vi;
  }
}
function _A(i) {
  if (i.length != 1 || i[0].isCollapsed)
    return !1;
  const e = i[0].getWalker({
    direction: "backward",
    singleCharacters: !0,
    ignoreElementEnd: !0
  });
  let t = 0;
  for (const { nextPosition: n, item: s } of e) {
    if (n.parent.is("$text")) {
      const o = n.parent.data, r = n.offset;
      if (ul(o, r) || dl(o, r) || mm(o, r))
        continue;
      t++;
    } else (s.is("containerElement") || s.is("emptyElement")) && t++;
    if (t > 1)
      return !0;
  }
  return !1;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class bt extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Delete";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.editing.view, n = t.document, s = e.model.document;
    t.addObserver(bA), this._undoOnBackspace = !1;
    const o = new Fu(e, "forward");
    e.commands.add("deleteForward", o), e.commands.add("forwardDelete", o), e.commands.add("delete", new Fu(e, "backward")), this.listenTo(n, "delete", (r, a) => {
      n.isComposing || a.preventDefault();
      const { direction: l, sequence: c, selectionToRemove: u, unit: d } = a, h = l === "forward" ? "deleteForward" : "delete", f = { sequence: c };
      if (d == "selection") {
        const m = Array.from(u.getRanges()).map((p) => e.editing.mapper.toModelRange(p));
        f.selection = e.model.createSelection(m);
      } else
        f.unit = d;
      e.execute(h, f), t.scrollToTheSelection();
    }, { priority: "low" }), this.editor.plugins.has("UndoEditing") && (this.listenTo(n, "delete", (r, a) => {
      this._undoOnBackspace && a.direction == "backward" && a.sequence == 1 && a.unit == "codePoint" && (this._undoOnBackspace = !1, e.execute("undo"), a.preventDefault(), r.stop());
    }, { context: "$capture" }), this.listenTo(s, "change", () => {
      this._undoOnBackspace = !1;
    }));
  }
  /**
   * If the next user action after calling this method is pressing backspace, it would undo the last change.
   *
   * Requires {@link module:undo/undoediting~UndoEditing} plugin. If not loaded, does nothing.
   */
  requestUndoOnBackspace() {
    this.editor.plugins.has("UndoEditing") && (this._undoOnBackspace = !0);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class mg extends b {
  static get requires() {
    return [hg, bt];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Typing";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function gg(i, e) {
  let t = i.start;
  return { text: Array.from(i.getWalker({ ignoreElementEnd: !1 })).reduce((s, { item: o }) => o.is("$text") || o.is("$textProxy") ? s + o.data : (t = e.createPositionAfter(o), ""), ""), range: e.createRange(t, i.end) };
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class pg extends U() {
  /**
   * Creates a text watcher instance.
   *
   * @param testCallback See {@link module:typing/textwatcher~TextWatcher#testCallback}.
   */
  constructor(e, t) {
    super(), this.model = e, this.testCallback = t, this._hasMatch = !1, this.set("isEnabled", !0), this.on("change:isEnabled", () => {
      this.isEnabled ? this._startListening() : (this.stopListening(e.document.selection), this.stopListening(e.document));
    }), this._startListening();
  }
  /**
   * Flag indicating whether there is a match currently.
   */
  get hasMatch() {
    return this._hasMatch;
  }
  /**
   * Starts listening to the editor for typing and selection events.
   */
  _startListening() {
    const t = this.model.document;
    this.listenTo(t.selection, "change:range", (n, { directChange: s }) => {
      if (s) {
        if (!t.selection.isCollapsed) {
          this.hasMatch && (this.fire("unmatched"), this._hasMatch = !1);
          return;
        }
        this._evaluateTextBeforeSelection("selection");
      }
    }), this.listenTo(t, "change:data", (n, s) => {
      s.isUndo || !s.isLocal || this._evaluateTextBeforeSelection("data", { batch: s });
    });
  }
  /**
   * Checks the editor content for matched text.
   *
   * @fires matched:data
   * @fires matched:selection
   * @fires unmatched
   *
   * @param suffix A suffix used for generating the event name.
   * @param data Data object for event.
   */
  _evaluateTextBeforeSelection(e, t = {}) {
    const n = this.model, o = n.document.selection, r = n.createRange(n.createPositionAt(o.focus.parent, 0), o.focus), { text: a, range: l } = gg(r, n), c = this.testCallback(a);
    if (!c && this.hasMatch && this.fire("unmatched"), this._hasMatch = !!c, c) {
      const u = Object.assign(t, { text: a, range: l });
      typeof c == "object" && Object.assign(u, c), this.fire(`matched:${e}`, u);
    }
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Eo extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TwoStepCaretMovement";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this._isNextGravityRestorationSkipped = !1, this.attributes = /* @__PURE__ */ new Set(), this._overrideUid = null;
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model, n = e.editing.view, s = e.locale, o = t.document.selection;
    this.listenTo(n.document, "arrowKey", (r, a) => {
      if (!o.isCollapsed || a.shiftKey || a.altKey || a.ctrlKey)
        return;
      const l = a.keyCode == N.arrowright, c = a.keyCode == N.arrowleft;
      if (!l && !c)
        return;
      const u = s.contentLanguageDirection;
      let d = !1;
      u === "ltr" && l || u === "rtl" && c ? d = this._handleForwardMovement(a) : d = this._handleBackwardMovement(a), d === !0 && r.stop();
    }, { context: "$text", priority: "highest" }), this.listenTo(o, "change:range", (r, a) => {
      if (this._isNextGravityRestorationSkipped) {
        this._isNextGravityRestorationSkipped = !1;
        return;
      }
      this._isGravityOverridden && (!a.directChange && qe(o.getFirstPosition(), this.attributes) || this._restoreGravity());
    }), this._enableClickingAfterNode(), this._enableInsertContentSelectionAttributesFixer(), this._handleDeleteContentAfterNode();
  }
  /**
   * Registers a given attribute for the two-step caret movement.
   *
   * @param attribute Name of the attribute to handle.
   */
  registerAttribute(e) {
    this.attributes.add(e);
  }
  /**
   * Updates the document selection and the view according to the two–step caret movement state
   * when moving **forwards**. Executed upon `keypress` in the {@link module:engine/view/view~View}.
   *
   * @param data Data of the key press.
   * @returns `true` when the handler prevented caret movement.
   */
  _handleForwardMovement(e) {
    const t = this.attributes, n = this.editor.model, s = n.document.selection, o = s.getFirstPosition();
    return this._isGravityOverridden || o.isAtStart && vt(s, t) ? !1 : qe(o, t) ? (Ci(e), vt(s, t) && qe(o, t, !0) ? yi(n, t) : this._overrideGravity(), !0) : !1;
  }
  /**
   * Updates the document selection and the view according to the two–step caret movement state
   * when moving **backwards**. Executed upon `keypress` in the {@link module:engine/view/view~View}.
   *
   * @param data Data of the key press.
   * @returns `true` when the handler prevented caret movement
   */
  _handleBackwardMovement(e) {
    const t = this.attributes, n = this.editor.model, s = n.document.selection, o = s.getFirstPosition();
    return this._isGravityOverridden ? (Ci(e), this._restoreGravity(), qe(o, t, !0) ? yi(n, t) : Os(n, t, o), !0) : o.isAtStart ? vt(s, t) ? (Ci(e), Os(n, t, o), !0) : !1 : !vt(s, t) && qe(o, t, !0) ? (Ci(e), Os(n, t, o), !0) : Du(o, t) ? o.isAtEnd && !vt(s, t) && qe(o, t) ? (Ci(e), Os(n, t, o), !0) : (this._isNextGravityRestorationSkipped = !0, this._overrideGravity(), !1) : !1;
  }
  /**
   * Starts listening to {@link module:engine/view/document~Document#event:mousedown} and
   * {@link module:engine/view/document~Document#event:selectionChange} and puts the selection before/after a 2-step node
   * if clicked at the beginning/ending of the 2-step node.
   *
   * The purpose of this action is to allow typing around the 2-step node directly after a click.
   *
   * See https://github.com/ckeditor/ckeditor5/issues/1016.
   */
  _enableClickingAfterNode() {
    const e = this.editor, t = e.model, n = t.document.selection, s = e.editing.view.document;
    e.editing.view.addObserver(Qo);
    let o = !1;
    this.listenTo(s, "mousedown", () => {
      o = !0;
    }), this.listenTo(s, "selectionChange", () => {
      const r = this.attributes;
      if (!o || (o = !1, !n.isCollapsed) || !vt(n, r))
        return;
      const a = n.getFirstPosition();
      qe(a, r) && (a.isAtStart || qe(a, r, !0) ? yi(t, r) : this._isGravityOverridden || this._overrideGravity());
    });
  }
  /**
   * Starts listening to {@link module:engine/model/model~Model#event:insertContent} and corrects the model
   * selection attributes if the selection is at the end of a two-step node after inserting the content.
   *
   * The purpose of this action is to improve the overall UX because the user is no longer "trapped" by the
   * two-step attribute of the selection, and they can type a "clean" (`linkHref`–less) text right away.
   *
   * See https://github.com/ckeditor/ckeditor5/issues/6053.
   */
  _enableInsertContentSelectionAttributesFixer() {
    const t = this.editor.model, n = t.document.selection, s = this.attributes;
    this.listenTo(t, "insertContent", () => {
      const o = n.getFirstPosition();
      vt(n, s) && qe(o, s) && yi(t, s);
    }, { priority: "low" });
  }
  /**
   * Starts listening to {@link module:engine/model/model~Model#deleteContent} and checks whether
   * removing a content right after the tow-step attribute.
   *
   * If so, the selection should not preserve the two-step attribute. However, if
   * the {@link module:typing/twostepcaretmovement~TwoStepCaretMovement} plugin is active and
   * the selection has the two-step attribute due to overridden gravity (at the end), the two-step attribute should stay untouched.
   *
   * The purpose of this action is to allow removing the link text and keep the selection outside the link.
   *
   * See https://github.com/ckeditor/ckeditor5/issues/7521.
   */
  _handleDeleteContentAfterNode() {
    const e = this.editor, t = e.model, n = t.document.selection, s = e.editing.view;
    let o = !1, r = !1;
    this.listenTo(s.document, "delete", (a, l) => {
      o = l.direction === "backward";
    }, { priority: "high" }), this.listenTo(t, "deleteContent", () => {
      if (!o)
        return;
      const a = n.getFirstPosition();
      r = vt(n, this.attributes) && !Du(a, this.attributes);
    }, { priority: "high" }), this.listenTo(t, "deleteContent", () => {
      o && (o = !1, !r && e.model.enqueueChange(() => {
        const a = n.getFirstPosition();
        vt(n, this.attributes) && qe(a, this.attributes) && (a.isAtStart || qe(a, this.attributes, !0) ? yi(t, this.attributes) : this._isGravityOverridden || this._overrideGravity());
      }));
    }, { priority: "low" });
  }
  /**
   * `true` when the gravity is overridden for the plugin.
   */
  get _isGravityOverridden() {
    return !!this._overrideUid;
  }
  /**
   * Overrides the gravity using the {@link module:engine/model/writer~Writer model writer}
   * and stores the information about this fact in the {@link #_overrideUid}.
   *
   * A shorthand for {@link module:engine/model/writer~Writer#overrideSelectionGravity}.
   */
  _overrideGravity() {
    this._overrideUid = this.editor.model.change((e) => e.overrideSelectionGravity());
  }
  /**
   * Restores the gravity using the {@link module:engine/model/writer~Writer model writer}.
   *
   * A shorthand for {@link module:engine/model/writer~Writer#restoreSelectionGravity}.
   */
  _restoreGravity() {
    this.editor.model.change((e) => {
      e.restoreSelectionGravity(this._overrideUid), this._overrideUid = null;
    });
  }
}
function vt(i, e) {
  for (const t of e)
    if (i.hasAttribute(t))
      return !0;
  return !1;
}
function Os(i, e, t) {
  const n = t.nodeBefore;
  i.change((s) => {
    if (n) {
      const o = [], r = i.schema.isObject(n) && i.schema.isInline(n);
      for (const [a, l] of n.getAttributes())
        i.schema.checkAttribute("$text", a) && (!r || i.schema.getAttributeProperties(a).copyFromObject !== !1) && o.push([a, l]);
      s.setSelectionAttribute(o);
    } else
      s.removeSelectionAttribute(e);
  });
}
function yi(i, e) {
  i.change((t) => {
    t.removeSelectionAttribute(e);
  });
}
function Ci(i) {
  i.preventDefault();
}
function Du(i, e) {
  const t = i.getShiftedBy(-1);
  return qe(t, e);
}
function qe(i, e, t = !1) {
  const { nodeBefore: n, nodeAfter: s } = i;
  for (const o of e) {
    const r = n ? n.getAttribute(o) : void 0, a = s ? s.getAttribute(o) : void 0;
    if (!(t && (r === void 0 || a === void 0)) && a !== r)
      return !0;
  }
  return !1;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const zu = {
  // Common symbols:
  copyright: { from: "(c)", to: "©" },
  registeredTrademark: { from: "(r)", to: "®" },
  trademark: { from: "(tm)", to: "™" },
  // Mathematical:
  oneHalf: { from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i, to: [null, "½", null] },
  oneThird: { from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i, to: [null, "⅓", null] },
  twoThirds: { from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i, to: [null, "⅔", null] },
  oneForth: { from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i, to: [null, "¼", null] },
  threeQuarters: { from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i, to: [null, "¾", null] },
  lessThanOrEqual: { from: "<=", to: "≤" },
  greaterThanOrEqual: { from: ">=", to: "≥" },
  notEqual: { from: "!=", to: "≠" },
  arrowLeft: { from: "<-", to: "←" },
  arrowRight: { from: "->", to: "→" },
  // Typography:
  horizontalEllipsis: { from: "...", to: "…" },
  enDash: { from: /(^| )(--)( )$/, to: [null, "–", null] },
  emDash: { from: /(^| )(---)( )$/, to: [null, "—", null] },
  // Quotations:
  // English, US
  quotesPrimary: { from: Bn('"'), to: [null, "“", null, "”"] },
  quotesSecondary: { from: Bn("'"), to: [null, "‘", null, "’"] },
  // English, UK
  quotesPrimaryEnGb: { from: Bn("'"), to: [null, "‘", null, "’"] },
  quotesSecondaryEnGb: { from: Bn('"'), to: [null, "“", null, "”"] },
  // Polish
  quotesPrimaryPl: { from: Bn('"'), to: [null, "„", null, "”"] },
  quotesSecondaryPl: { from: Bn("'"), to: [null, "‚", null, "’"] }
}, Hu = {
  symbols: ["copyright", "registeredTrademark", "trademark"],
  mathematical: [
    "oneHalf",
    "oneThird",
    "twoThirds",
    "oneForth",
    "threeQuarters",
    "lessThanOrEqual",
    "greaterThanOrEqual",
    "notEqual",
    "arrowLeft",
    "arrowRight"
  ],
  typography: ["horizontalEllipsis", "enDash", "emDash"],
  quotes: ["quotesPrimary", "quotesSecondary"]
}, vA = [
  "symbols",
  "mathematical",
  "typography",
  "quotes"
];
class yA extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return ["Delete", "Input"];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TextTransformation";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), e.config.define("typing", {
      transformations: {
        include: vA
      }
    });
  }
  /**
   * @inheritDoc
   */
  init() {
    const t = this.editor.model.document.selection;
    t.on("change:range", () => {
      this.isEnabled = !t.anchor.parent.is("element", "codeBlock");
    }), this._enableTransformationWatchers();
  }
  /**
   * Create new TextWatcher listening to the editor for typing and selection events.
   */
  _enableTransformationWatchers() {
    const e = this.editor, t = e.model, n = e.plugins.get("Delete"), s = EA(e.config.get("typing.transformations")), o = (a) => {
      for (const l of s)
        if (l.from.test(a))
          return { normalizedTransformation: l };
    }, r = new pg(e.model, o);
    r.on("matched:data", (a, l) => {
      if (!l.batch.isTyping)
        return;
      const { from: c, to: u } = l.normalizedTransformation, d = c.exec(l.text), h = u(d.slice(1)), f = l.range;
      let m = d.index;
      t.enqueueChange((p) => {
        for (let w = 1; w < d.length; w++) {
          const v = d[w], C = h[w - 1];
          if (C == null) {
            m += v.length;
            continue;
          }
          const L = f.start.getShiftedBy(m), F = t.createRange(L, L.getShiftedBy(v.length)), q = TA(L);
          t.insertContent(p.createText(C, q), F), m += C.length;
        }
        t.enqueueChange(() => {
          n.requestUndoOnBackspace();
        });
      });
    }), r.bind("isEnabled").to(this);
  }
}
function CA(i) {
  return typeof i == "string" ? new RegExp(`(${Yf(i)})$`) : i;
}
function kA(i) {
  return typeof i == "string" ? () => [i] : i instanceof Array ? () => i : i;
}
function TA(i) {
  return (i.textNode ? i.textNode : i.nodeAfter).getAttributes();
}
function Bn(i) {
  return new RegExp(`(^|\\s)(${i})([^${i}]*)(${i})$`);
}
function EA(i) {
  const e = i.extra || [], t = i.remove || [], n = (o) => !t.includes(o), s = i.include.concat(e).filter(n);
  return AA(s).filter(n).map((o) => typeof o == "string" && zu[o] ? zu[o] : o).filter((o) => typeof o == "object").map((o) => ({
    from: CA(o.from),
    to: kA(o.to)
  }));
}
function AA(i) {
  const e = /* @__PURE__ */ new Set();
  for (const t of i)
    if (typeof t == "string" && Hu[t])
      for (const n of Hu[t])
        e.add(n);
    else
      e.add(t);
  return Array.from(e);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function er(i, e, t, n) {
  return n.createRange(Uu(i, e, t, !0, n), Uu(i, e, t, !1, n));
}
function Uu(i, e, t, n, s) {
  let o = i.textNode || (n ? i.nodeBefore : i.nodeAfter), r = null;
  for (; o && o.getAttribute(e) == t; )
    r = o, o = n ? o.previousSibling : o.nextSibling;
  return r ? s.createPositionAt(r, n ? "before" : "after") : i;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function bg(i, e, t, n) {
  const s = i.editing.view, o = /* @__PURE__ */ new Set();
  s.document.registerPostFixer((r) => {
    const a = i.model.document.selection;
    let l = !1;
    if (a.hasAttribute(e)) {
      const c = er(a.getFirstPosition(), e, a.getAttribute(e), i.model), u = i.editing.mapper.toViewRange(c);
      for (const d of u.getItems())
        d.is("element", t) && !d.hasClass(n) && (r.addClass(n, d), o.add(d), l = !0);
    }
    return l;
  }), i.conversion.for("editingDowncast").add((r) => {
    r.on("insert", a, { priority: "highest" }), r.on("remove", a, { priority: "highest" }), r.on("attribute", a, { priority: "highest" }), r.on("selection", a, { priority: "highest" });
    function a() {
      s.change((l) => {
        for (const c of o.values())
          l.removeClass(n, c), o.delete(c);
      });
    }
  });
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ve extends ke {
  /**
   * Creates a new instance of the {@link module:ui/viewcollection~ViewCollection}.
   *
   * @param initialItems The initial items of the collection.
   */
  constructor(e = []) {
    super(e, {
      // An #id Number attribute should be legal and not break the `ViewCollection` instance.
      // https://github.com/ckeditor/ckeditor5-ui/issues/93
      idProperty: "viewUid"
    }), this.on("add", (t, n, s) => {
      this._renderViewIntoCollectionParent(n, s);
    }), this.on("remove", (t, n) => {
      n.element && this._parentElement && n.element.remove();
    }), this._parentElement = null;
  }
  /**
   * Destroys the view collection along with child views.
   * See the view {@link module:ui/view~View#destroy} method.
   */
  destroy() {
    this.map((e) => e.destroy());
  }
  /**
   * Sets the parent HTML element of this collection. When parent is set, {@link #add adding} and
   * {@link #remove removing} views in the collection synchronizes their
   * {@link module:ui/view~View#element elements} in the parent element.
   *
   * @param element A new parent element.
   */
  setParent(e) {
    this._parentElement = e;
    for (const t of this)
      this._renderViewIntoCollectionParent(t);
  }
  /**
   * Delegates selected events coming from within views in the collection to any
   * {@link module:utils/emittermixin~Emitter}.
   *
   * For the following views and collection:
   *
   * ```ts
   * const viewA = new View();
   * const viewB = new View();
   * const viewC = new View();
   *
   * const views = parentView.createCollection();
   *
   * views.delegate( 'eventX' ).to( viewB );
   * views.delegate( 'eventX', 'eventY' ).to( viewC );
   *
   * views.add( viewA );
   * ```
   *
   * the `eventX` is delegated (fired by) `viewB` and `viewC` along with `customData`:
   *
   * ```ts
   * viewA.fire( 'eventX', customData );
   * ```
   *
   * and `eventY` is delegated (fired by) `viewC` along with `customData`:
   *
   * ```ts
   * viewA.fire( 'eventY', customData );
   * ```
   *
   * See {@link module:utils/emittermixin~Emitter#delegate}.
   *
   * @param events {@link module:ui/view~View} event names to be delegated to another
   * {@link module:utils/emittermixin~Emitter}.
   * @returns Object with `to` property, a function which accepts the destination
   * of {@link module:utils/emittermixin~Emitter#delegate delegated} events.
   */
  delegate(...e) {
    if (!e.length || !xA(e))
      throw new g("ui-viewcollection-delegate-wrong-events", this);
    return {
      to: (t) => {
        for (const n of this)
          for (const s of e)
            n.delegate(s).to(t);
        this.on("add", (n, s) => {
          for (const o of e)
            s.delegate(o).to(t);
        }), this.on("remove", (n, s) => {
          for (const o of e)
            s.stopDelegating(o, t);
        });
      }
    };
  }
  /**
   * This method {@link module:ui/view~View#render renders} a new view added to the collection.
   *
   * If the {@link #_parentElement parent element} of the collection is set, this method also adds
   * the view's {@link module:ui/view~View#element} as a child of the parent in DOM at a specified index.
   *
   * **Note**: If index is not specified, the view's element is pushed as the last child
   * of the parent element.
   *
   * @param view A new view added to the collection.
   * @param index An index the view holds in the collection. When not specified,
   * the view is added at the end.
   */
  _renderViewIntoCollectionParent(e, t) {
    e.isRendered || e.render(), e.element && this._parentElement && this._parentElement.insertBefore(e.element, this._parentElement.children[t]);
  }
  /**
   * Removes a child view from the collection. If the {@link #setParent parent element} of the
   * collection has been set, the {@link module:ui/view~View#element element} of the view is also removed
   * in DOM, reflecting the order of the collection.
   *
   * See the {@link #add} method.
   *
   * @param subject The view to remove, its id or index in the collection.
   * @returns The removed view.
   */
  remove(e) {
    return super.remove(e);
  }
}
function xA(i) {
  return i.every((e) => typeof e == "string");
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const IA = "http://www.w3.org/1999/xhtml";
class Me extends G() {
  /**
   * Creates an instance of the {@link ~Template} class.
   *
   * @param def The definition of the template.
   */
  constructor(e) {
    super(), Object.assign(this, Wu($u(e))), this._isRendered = !1, this._revertData = null;
  }
  /**
   * Renders a DOM Node (an HTML element or text) out of the template.
   *
   * ```ts
   * const domNode = new Template( { ... } ).render();
   * ```
   *
   * See: {@link #apply}.
   */
  render() {
    const e = this._renderNode({
      intoFragment: !0
    });
    return this._isRendered = !0, e;
  }
  /**
   * Applies the template to an existing DOM Node, either HTML element or text.
   *
   * **Note:** No new DOM nodes will be created. Applying extends:
   *
   * {@link module:ui/template~TemplateDefinition attributes},
   * {@link module:ui/template~TemplateDefinition event listeners}, and
   * `textContent` of {@link module:ui/template~TemplateDefinition children} only.
   *
   * **Note:** Existing `class` and `style` attributes are extended when a template
   * is applied to an HTML element, while other attributes and `textContent` are overridden.
   *
   * **Note:** The process of applying a template can be easily reverted using the
   * {@link module:ui/template~Template#revert} method.
   *
   * ```ts
   * const element = document.createElement( 'div' );
   * const observable = new Model( { divClass: 'my-div' } );
   * const emitter = Object.create( EmitterMixin );
   * const bind = Template.bind( observable, emitter );
   *
   * new Template( {
   * 	attributes: {
   * 		id: 'first-div',
   * 		class: bind.to( 'divClass' )
   * 	},
   * 	on: {
   * 		click: bind( 'elementClicked' ) // Will be fired by the observable.
   * 	},
   * 	children: [
   * 		'Div text.'
   * 	]
   * } ).apply( element );
   *
   * console.log( element.outerHTML ); // -> '<div id="first-div" class="my-div"></div>'
   * ```
   *
   * @see module:ui/template~Template#render
   * @see module:ui/template~Template#revert
   * @param node Root node for the template to apply.
   */
  apply(e) {
    return this._revertData = ju(), this._renderNode({
      node: e,
      intoFragment: !1,
      isApplying: !0,
      revertData: this._revertData
    }), e;
  }
  /**
   * Reverts a template {@link module:ui/template~Template#apply applied} to a DOM node.
   *
   * @param node The root node for the template to revert. In most of the cases, it is the
   * same node used by {@link module:ui/template~Template#apply}.
   */
  revert(e) {
    if (!this._revertData)
      throw new g("ui-template-revert-not-applied", [this, e]);
    this._revertTemplateFromNode(e, this._revertData);
  }
  /**
   * Returns an iterator which traverses the template in search of {@link module:ui/view~View}
   * instances and returns them one by one.
   *
   * ```ts
   * const viewFoo = new View();
   * const viewBar = new View();
   * const viewBaz = new View();
   * const template = new Template( {
   * 	tag: 'div',
   * 	children: [
   * 		viewFoo,
   * 		{
   * 			tag: 'div',
   * 			children: [
   * 				viewBar
   * 			]
   * 		},
   * 		viewBaz
   * 	]
   * } );
   *
   * // Logs: viewFoo, viewBar, viewBaz
   * for ( const view of template.getViews() ) {
   * 	console.log( view );
   * }
   * ```
   */
  *getViews() {
    function* e(t) {
      if (t.children)
        for (const n of t.children)
          Ao(n) ? yield n : Tl(n) && (yield* e(n));
    }
    yield* e(this);
  }
  /**
   * An entry point to the interface which binds DOM nodes to
   * {@link module:utils/observablemixin~Observable observables}.
   * There are two types of bindings:
   *
   * * HTML element attributes or text `textContent` synchronized with attributes of an
   * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}
   * and {@link module:ui/template~BindChain#if}.
   *
   * ```ts
   * const bind = Template.bind( observable, emitter );
   *
   * new Template( {
   * 	attributes: {
   * 		// Binds the element "class" attribute to observable#classAttribute.
   * 		class: bind.to( 'classAttribute' )
   * 	}
   * } ).render();
   * ```
   *
   * * DOM events fired on HTML element propagated through
   * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}.
   *
   * ```ts
   * const bind = Template.bind( observable, emitter );
   *
   * new Template( {
   * 	on: {
   * 		// Will be fired by the observable.
   * 		click: bind( 'elementClicked' )
   * 	}
   * } ).render();
   * ```
   *
   * Also see {@link module:ui/view~View#bindTemplate}.
   *
   * @param observable An observable which provides boundable attributes.
   * @param emitter An emitter that listens to observable attribute
   * changes or DOM Events (depending on the kind of the binding). Usually, a {@link module:ui/view~View} instance.
   */
  static bind(e, t) {
    return {
      to(n, s) {
        return new SA({
          eventNameOrFunction: n,
          attribute: n,
          observable: e,
          emitter: t,
          callback: s
        });
      },
      if(n, s, o) {
        return new wg({
          observable: e,
          emitter: t,
          attribute: n,
          valueIfTrue: s,
          callback: o
        });
      }
    };
  }
  /**
   * Extends an existing {@link module:ui/template~Template} instance with some additional content
   * from another {@link module:ui/template~TemplateDefinition}.
   *
   * ```ts
   * const bind = Template.bind( observable, emitter );
   *
   * const template = new Template( {
   * 	tag: 'p',
   * 	attributes: {
   * 		class: 'a',
   * 		data-x: bind.to( 'foo' )
   * 	},
   * 	children: [
   * 		{
   * 			tag: 'span',
   * 			attributes: {
   * 				class: 'b'
   * 			},
   * 			children: [
   * 				'Span'
   * 			]
   * 		}
   * 	]
   *  } );
   *
   * // Instance-level extension.
   * Template.extend( template, {
   * 	attributes: {
   * 		class: 'b',
   * 		data-x: bind.to( 'bar' )
   * 	},
   * 	children: [
   * 		{
   * 			attributes: {
   * 				class: 'c'
   * 			}
   * 		}
   * 	]
   * } );
   *
   * // Child extension.
   * Template.extend( template.children[ 0 ], {
   * 	attributes: {
   * 		class: 'd'
   * 	}
   * } );
   * ```
   *
   * the `outerHTML` of `template.render()` is:
   *
   * ```html
   * <p class="a b" data-x="{ observable.foo } { observable.bar }">
   * 	<span class="b c d">Span</span>
   * </p>
   * ```
   *
   * @param template An existing template instance to be extended.
   * @param def Additional definition to be applied to a template.
   */
  static extend(e, t) {
    if (e._isRendered)
      throw new g("template-extend-render", [this, e]);
    Cg(e, Wu($u(t)));
  }
  /**
   * Renders a DOM Node (either an HTML element or text) out of the template.
   *
   * @param data Rendering data.
   */
  _renderNode(e) {
    let t;
    if (e.node ? t = this.tag && this.text : t = this.tag ? this.text : !this.text, t)
      throw new g("ui-template-wrong-syntax", this);
    return this.text ? this._renderText(e) : this._renderElement(e);
  }
  /**
   * Renders an HTML element out of the template.
   *
   * @param data Rendering data.
   */
  _renderElement(e) {
    let t = e.node;
    return t || (t = e.node = document.createElementNS(this.ns || IA, this.tag)), this._renderAttributes(e), this._renderElementChildren(e), this._setUpListeners(e), t;
  }
  /**
   * Renders a text node out of {@link module:ui/template~Template#text}.
   *
   * @param data Rendering data.
   */
  _renderText(e) {
    let t = e.node;
    return t ? e.revertData.text = t.textContent : t = e.node = document.createTextNode(""), oo(this.text) ? this._bindToObservable({
      schema: this.text,
      updater: RA(t),
      data: e
    }) : t.textContent = this.text.join(""), t;
  }
  /**
   * Renders HTML element attributes out of {@link module:ui/template~Template#attributes}.
   *
   * @param data Rendering data.
   */
  _renderAttributes(e) {
    if (!this.attributes)
      return;
    const t = e.node, n = e.revertData;
    for (const s in this.attributes) {
      const o = t.getAttribute(s), r = this.attributes[s];
      n && (n.attributes[s] = o);
      const a = Gu(r) ? r[0].ns : null;
      if (oo(r)) {
        const l = Gu(r) ? r[0].value : r;
        n && Ku(s) && l.unshift(o), this._bindToObservable({
          schema: l,
          updater: VA(t, s, a),
          data: e
        });
      } else if (s == "style" && typeof r[0] != "string")
        this._renderStyleAttribute(r[0], e);
      else {
        n && o && Ku(s) && r.unshift(o);
        const l = r.map((c) => c && (c.value || c)).reduce((c, u) => c.concat(u), []).reduce(yg, "");
        ei(l) || t.setAttributeNS(a, s, l);
      }
    }
  }
  /**
   * Renders the `style` attribute of an HTML element based on
   * {@link module:ui/template~Template#attributes}.
   *
   * A style attribute is an object with static values:
   *
   * ```ts
   * attributes: {
   * 	style: {
   * 		color: 'red'
   * 	}
   * }
   * ```
   *
   * or values bound to {@link module:ui/model~Model} properties:
   *
   * ```ts
   * attributes: {
   * 	style: {
   * 		color: bind.to( ... )
   * 	}
   * }
   * ```
   *
   * Note: The `style` attribute is rendered without setting the namespace. It does not seem to be
   * needed.
   *
   * @param styles Styles located in `attributes.style` of {@link module:ui/template~TemplateDefinition}.
   * @param data Rendering data.
   */
  _renderStyleAttribute(e, t) {
    const n = t.node;
    for (const s in e) {
      const o = e[s];
      oo(o) ? this._bindToObservable({
        schema: [o],
        updater: MA(n, s),
        data: t
      }) : n.style[s] = o;
    }
  }
  /**
   * Recursively renders HTML element's children from {@link module:ui/template~Template#children}.
   *
   * @param data Rendering data.
   */
  _renderElementChildren(e) {
    const t = e.node, n = e.intoFragment ? document.createDocumentFragment() : t, s = e.isApplying;
    let o = 0;
    for (const r of this.children)
      if (El(r)) {
        if (!s) {
          r.setParent(t);
          for (const a of r)
            n.appendChild(a.element);
        }
      } else if (Ao(r))
        s || (r.isRendered || r.render(), n.appendChild(r.element));
      else if (Ut(r))
        n.appendChild(r);
      else if (s) {
        const a = e.revertData, l = ju();
        a.children.push(l), r._renderNode({
          intoFragment: !1,
          node: n.childNodes[o++],
          isApplying: !0,
          revertData: l
        });
      } else
        n.appendChild(r.render());
    e.intoFragment && t.appendChild(n);
  }
  /**
   * Activates `on` event listeners from the {@link module:ui/template~TemplateDefinition}
   * on an HTML element.
   *
   * @param data Rendering data.
   */
  _setUpListeners(e) {
    if (this.eventListeners)
      for (const t in this.eventListeners) {
        const n = this.eventListeners[t].map((s) => {
          const [o, r] = t.split("@");
          return s.activateDomEventListener(o, r, e);
        });
        e.revertData && e.revertData.bindings.push(n);
      }
  }
  /**
   * For a given {@link module:ui/template~TemplateValueSchema} containing {@link module:ui/template~TemplateBinding}
   * activates the binding and sets its initial value.
   *
   * Note: {@link module:ui/template~TemplateValueSchema} can be for HTML element attributes or
   * text node `textContent`.
   *
   * @param options Binding options.
   * @param options.updater A function which updates the DOM (like attribute or text).
   * @param options.data Rendering data.
   */
  _bindToObservable({ schema: e, updater: t, data: n }) {
    const s = n.revertData;
    _g(e, t, n);
    const o = e.filter((r) => !ei(r)).filter((r) => r.observable).map((r) => r.activateAttributeListener(e, t, n));
    s && s.bindings.push(o);
  }
  /**
   * Reverts {@link module:ui/template~RenderData#revertData template data} from a node to
   * return it to the original state.
   *
   * @param node A node to be reverted.
   * @param revertData An object that stores information about what changes have been made by
   * {@link #apply} to the node. See {@link module:ui/template~RenderData#revertData} for more information.
   */
  _revertTemplateFromNode(e, t) {
    for (const s of t.bindings)
      for (const o of s)
        o();
    if (t.text) {
      e.textContent = t.text;
      return;
    }
    const n = e;
    for (const s in t.attributes) {
      const o = t.attributes[s];
      o === null ? n.removeAttribute(s) : n.setAttribute(s, o);
    }
    for (let s = 0; s < t.children.length; ++s)
      this._revertTemplateFromNode(n.childNodes[s], t.children[s]);
  }
}
class ps {
  /**
   * Creates an instance of the {@link module:ui/template~TemplateBinding} class.
   *
   * @param def The definition of the binding.
   */
  constructor(e) {
    this.attribute = e.attribute, this.observable = e.observable, this.emitter = e.emitter, this.callback = e.callback;
  }
  /**
   * Returns the value of the binding. It is the value of the {@link module:ui/template~TemplateBinding#attribute} in
   * {@link module:ui/template~TemplateBinding#observable}. The value may be processed by the
   * {@link module:ui/template~TemplateBinding#callback}, if such has been passed to the binding.
   *
   * @param node A native DOM node, passed to the custom {@link module:ui/template~TemplateBinding#callback}.
   * @returns The value of {@link module:ui/template~TemplateBinding#attribute} in
   * {@link module:ui/template~TemplateBinding#observable}.
   */
  getValue(e) {
    const t = this.observable[this.attribute];
    return this.callback ? this.callback(t, e) : t;
  }
  /**
   * Activates the listener which waits for changes of the {@link module:ui/template~TemplateBinding#attribute} in
   * {@link module:ui/template~TemplateBinding#observable}, then updates the DOM with the aggregated
   * value of {@link module:ui/template~TemplateValueSchema}.
   *
   * @param schema A full schema to generate an attribute or text in the DOM.
   * @param updater A DOM updater function used to update the native DOM attribute or text.
   * @param data Rendering data.
   * @returns A function to sever the listener binding.
   */
  activateAttributeListener(e, t, n) {
    const s = () => _g(e, t, n);
    return this.emitter.listenTo(this.observable, `change:${this.attribute}`, s), () => {
      this.emitter.stopListening(this.observable, `change:${this.attribute}`, s);
    };
  }
}
class SA extends ps {
  constructor(e) {
    super(e), this.eventNameOrFunction = e.eventNameOrFunction;
  }
  /**
   * Activates the listener for the native DOM event, which when fired, is propagated by
   * the {@link module:ui/template~TemplateBinding#emitter}.
   *
   * @param domEvtName The name of the native DOM event.
   * @param domSelector The selector in the DOM to filter delegated events.
   * @param data Rendering data.
   * @returns A function to sever the listener binding.
   */
  activateDomEventListener(e, t, n) {
    const s = (o, r) => {
      (!t || r.target.matches(t)) && (typeof this.eventNameOrFunction == "function" ? this.eventNameOrFunction(r) : this.observable.fire(this.eventNameOrFunction, r));
    };
    return this.emitter.listenTo(n.node, e, s), () => {
      this.emitter.stopListening(n.node, e, s);
    };
  }
}
class wg extends ps {
  constructor(e) {
    super(e), this.valueIfTrue = e.valueIfTrue;
  }
  /**
   * @inheritDoc
   */
  getValue(e) {
    const t = super.getValue(e);
    return ei(t) ? !1 : this.valueIfTrue || !0;
  }
}
function oo(i) {
  return i ? (i.value && (i = i.value), Array.isArray(i) ? i.some(oo) : i instanceof ps) : !1;
}
function PA(i, e) {
  return i.map((t) => t instanceof ps ? t.getValue(e) : t);
}
function _g(i, e, { node: t }) {
  const n = PA(i, t);
  let s;
  i.length == 1 && i[0] instanceof wg ? s = n[0] : s = n.reduce(yg, ""), ei(s) ? e.remove() : e.set(s);
}
function RA(i) {
  return {
    set(e) {
      i.textContent = e;
    },
    remove() {
      i.textContent = "";
    }
  };
}
function VA(i, e, t) {
  return {
    set(n) {
      i.setAttributeNS(t, e, n);
    },
    remove() {
      i.removeAttributeNS(t, e);
    }
  };
}
function MA(i, e) {
  return {
    set(t) {
      i.style[e] = t;
    },
    remove() {
      i.style[e] = null;
    }
  };
}
function $u(i) {
  return ol(i, (t) => {
    if (t && (t instanceof ps || Tl(t) || Ao(t) || El(t)))
      return t;
  });
}
function Wu(i) {
  if (typeof i == "string" ? i = OA(i) : i.text && FA(i), i.on && (i.eventListeners = LA(i.on), delete i.on), !i.text) {
    i.attributes && BA(i.attributes);
    const e = [];
    if (i.children)
      if (El(i.children))
        e.push(i.children);
      else
        for (const t of i.children)
          Tl(t) || Ao(t) || Ut(t) ? e.push(t) : e.push(new Me(t));
    i.children = e;
  }
  return i;
}
function BA(i) {
  for (const e in i)
    i[e].value && (i[e].value = Z(i[e].value)), vg(i, e);
}
function LA(i) {
  for (const e in i)
    vg(i, e);
  return i;
}
function OA(i) {
  return {
    text: [i]
  };
}
function FA(i) {
  i.text = Z(i.text);
}
function vg(i, e) {
  i[e] = Z(i[e]);
}
function yg(i, e) {
  return ei(e) ? i : ei(i) ? e : `${i} ${e}`;
}
function qu(i, e) {
  for (const t in e)
    i[t] ? i[t].push(...e[t]) : i[t] = e[t];
}
function Cg(i, e) {
  if (e.attributes && (i.attributes || (i.attributes = {}), qu(i.attributes, e.attributes)), e.eventListeners && (i.eventListeners || (i.eventListeners = {}), qu(i.eventListeners, e.eventListeners)), e.text && i.text.push(...e.text), e.children && e.children.length) {
    if (i.children.length != e.children.length)
      throw new g("ui-template-extend-children-mismatch", i);
    let t = 0;
    for (const n of e.children)
      Cg(i.children[t++], n);
  }
}
function ei(i) {
  return !i && i !== 0;
}
function Ao(i) {
  return i instanceof T;
}
function Tl(i) {
  return i instanceof Me;
}
function El(i) {
  return i instanceof ve;
}
function Gu(i) {
  return J(i[0]) && i[0].ns;
}
function ju() {
  return {
    children: [],
    bindings: [],
    attributes: {}
  };
}
function Ku(i) {
  return i == "class" || i == "style";
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class T extends Le(U()) {
  /**
   * Creates an instance of the {@link module:ui/view~View} class.
   *
   * Also see {@link #render}.
   *
   * @param locale The localization services instance.
   */
  constructor(e) {
    super(), this.element = null, this.isRendered = !1, this.locale = e, this.t = e && e.t, this._viewCollections = new ke(), this._unboundChildren = this.createCollection(), this._viewCollections.on("add", (t, n) => {
      n.locale = e, n.t = e && e.t;
    }), this.decorate("render");
  }
  /**
   * Shorthand for {@link module:ui/template~Template.bind}, a binding
   * {@link module:ui/template~BindChain interface} pre–configured for the view instance.
   *
   * It provides {@link module:ui/template~BindChain#to `to()`} and
   * {@link module:ui/template~BindChain#if `if()`} methods that initialize bindings with
   * observable attributes and attach DOM listeners.
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor( locale ) {
   * 		super( locale );
   *
   * 		const bind = this.bindTemplate;
   *
   * 		// These {@link module:utils/observablemixin~Observable observable} attributes will control
   * 		// the state of the view in DOM.
   * 		this.set( {
   * 			elementClass: 'foo',
   * 		 	isEnabled: true
   * 		 } );
   *
   * 		this.setTemplate( {
   * 			tag: 'p',
   *
   * 			attributes: {
   * 				// The class HTML attribute will follow elementClass
   * 				// and isEnabled view attributes.
   * 				class: [
   * 					bind.to( 'elementClass' )
   * 					bind.if( 'isEnabled', 'present-when-enabled' )
   * 				]
   * 			},
   *
   * 			on: {
   * 				// The view will fire the "clicked" event upon clicking <p> in DOM.
   * 				click: bind.to( 'clicked' )
   * 			}
   * 		} );
   * 	}
   * }
   * ```
   */
  get bindTemplate() {
    return this._bindTemplate ? this._bindTemplate : this._bindTemplate = Me.bind(this, this);
  }
  /**
   * Creates a new collection of views, which can be used as
   * {@link module:ui/template~Template#children} of this view.
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor( locale ) {
   * 		super( locale );
   *
   * 		const child = new ChildView( locale );
   * 		this.items = this.createCollection( [ child ] );
   *
   * 		this.setTemplate( {
   * 			tag: 'p',
   *
   * 			// `items` collection will render here.
   * 			children: this.items
   * 		} );
   * 	}
   * }
   *
   * const view = new SampleView( locale );
   * view.render();
   *
   * // It will append <p><child#element></p> to the <body>.
   * document.body.appendChild( view.element );
   * ```
   *
   * @param views Initial views of the collection.
   * @returns A new collection of view instances.
   */
  createCollection(e) {
    const t = new ve(e);
    return this._viewCollections.add(t), t;
  }
  /**
   * Registers a new child view under the view instance. Once registered, a child
   * view is managed by its parent, including {@link #render rendering}
   * and {@link #destroy destruction}.
   *
   * To revert this, use {@link #deregisterChild}.
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor( locale ) {
   * 		super( locale );
   *
   * 		this.childA = new SomeChildView( locale );
   * 		this.childB = new SomeChildView( locale );
   *
   * 		this.setTemplate( { tag: 'p' } );
   *
   * 		// Register the children.
   * 		this.registerChild( [ this.childA, this.childB ] );
   * 	}
   *
   * 	render() {
   * 		super.render();
   *
   * 		this.element.appendChild( this.childA.element );
   * 		this.element.appendChild( this.childB.element );
   * 	}
   * }
   *
   * const view = new SampleView( locale );
   *
   * view.render();
   *
   * // Will append <p><childA#element><b></b><childB#element></p>.
   * document.body.appendChild( view.element );
   * ```
   *
   * **Note**: There's no need to add child views if they're already referenced in the
   * {@link #template}:
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor( locale ) {
   * 		super( locale );
   *
   * 		this.childA = new SomeChildView( locale );
   * 		this.childB = new SomeChildView( locale );
   *
   * 		this.setTemplate( {
   * 			tag: 'p',
   *
   * 			// These children will be added automatically. There's no
   * 			// need to call {@link #registerChild} for any of them.
   * 			children: [ this.childA, this.childB ]
   * 		} );
   * 	}
   *
   * 	// ...
   * }
   * ```
   *
   * @param children Children views to be registered.
   */
  registerChild(e) {
    Ue(e) || (e = [e]);
    for (const t of e)
      this._unboundChildren.add(t);
  }
  /**
   * The opposite of {@link #registerChild}. Removes a child view from this view instance.
   * Once removed, the child is no longer managed by its parent, e.g. it can safely
   * become a child of another parent view.
   *
   * @see #registerChild
   * @param children Child views to be removed.
   */
  deregisterChild(e) {
    Ue(e) || (e = [e]);
    for (const t of e)
      this._unboundChildren.remove(t);
  }
  /**
   * Sets the {@link #template} of the view with with given definition.
   *
   * A shorthand for:
   *
   * ```ts
   * view.setTemplate( definition );
   * ```
   *
   * @param definition Definition of view's template.
   */
  setTemplate(e) {
    this.template = new Me(e);
  }
  /**
   * {@link module:ui/template~Template.extend Extends} the {@link #template} of the view with
   * with given definition.
   *
   * A shorthand for:
   *
   * ```ts
   * Template.extend( view.template, definition );
   * ```
   *
   * **Note**: Is requires the {@link #template} to be already set. See {@link #setTemplate}.
   *
   * @param definition Definition which extends the {@link #template}.
   */
  extendTemplate(e) {
    Me.extend(this.template, e);
  }
  /**
   * Recursively renders the view.
   *
   * Once the view is rendered:
   * * the {@link #element} becomes an HTML element out of {@link #template},
   * * the {@link #isRendered} flag is set `true`.
   *
   * **Note**: The children of the view:
   * * defined directly in the {@link #template}
   * * residing in collections created by the {@link #createCollection} method,
   * * and added by {@link #registerChild}
   * are also rendered in the process.
   *
   * In general, `render()` method is the right place to keep the code which refers to the
   * {@link #element} and should be executed at the very beginning of the view's life cycle.
   *
   * It is possible to {@link module:ui/template~Template.extend} the {@link #template} before
   * the view is rendered. To allow an early customization of the view (e.g. by its parent),
   * such references should be done in `render()`.
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor() {
   * 		this.setTemplate( {
   * 			// ...
   * 		} );
   * 	},
   *
   * 	render() {
   * 		// View#element becomes available.
   * 		super.render();
   *
   * 		// The "scroll" listener depends on #element.
   * 		this.listenTo( window, 'scroll', () => {
   * 			// A reference to #element would render the #template and make it non-extendable.
   * 			if ( window.scrollY > 0 ) {
   * 				this.element.scrollLeft = 100;
   * 			} else {
   * 				this.element.scrollLeft = 0;
   * 			}
   * 		} );
   * 	}
   * }
   *
   * const view = new SampleView();
   *
   * // Let's customize the view before it gets rendered.
   * view.extendTemplate( {
   * 	attributes: {
   * 		class: [
   * 			'additional-class'
   * 		]
   * 	}
   * } );
   *
   * // Late rendering allows customization of the view.
   * view.render();
   * ```
   */
  render() {
    if (this.isRendered)
      throw new g("ui-view-render-already-rendered", this);
    this.template && (this.element = this.template.render(), this.registerChild(this.template.getViews())), this.isRendered = !0;
  }
  /**
   * Recursively destroys the view instance and child views added by {@link #registerChild} and
   * residing in collections created by the {@link #createCollection}.
   *
   * Destruction disables all event listeners:
   * * created on the view, e.g. `view.on( 'event', () => {} )`,
   * * defined in the {@link #template} for DOM events.
   */
  destroy() {
    this.stopListening(), this._viewCollections.map((e) => e.destroy()), this.template && this.template._revertData && this.template.revert(this.element);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function yn({ emitter: i, activator: e, callback: t, contextElements: n }) {
  i.listenTo(document, "mousedown", (s, o) => {
    if (!e())
      return;
    const r = typeof o.composedPath == "function" ? o.composedPath() : [], a = typeof n == "function" ? n() : n;
    for (const l of a)
      if (l.contains(o.target) || r.includes(l))
        return;
    t();
  });
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function tr(i) {
  class e extends i {
    disableCssTransitions() {
      this._isCssTransitionsDisabled = !0;
    }
    enableCssTransitions() {
      this._isCssTransitionsDisabled = !1;
    }
    constructor(...n) {
      super(...n), this.set("_isCssTransitionsDisabled", !1), this.initializeCssTransitionDisablerMixin();
    }
    initializeCssTransitionDisablerMixin() {
      this.extendTemplate({
        attributes: {
          class: [
            this.bindTemplate.if("_isCssTransitionsDisabled", "ck-transitions-disabled")
          ]
        }
      });
    }
  }
  return e;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Cn({ view: i }) {
  i.listenTo(i.element, "submit", (e, t) => {
    t.preventDefault(), i.fire("submit");
  }, { useCapture: !0 });
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Al({ keystrokeHandler: i, focusTracker: e, gridItems: t, numberOfColumns: n, uiLanguageDirection: s }) {
  const o = typeof n == "number" ? () => n : n;
  i.set("arrowright", r((c, u) => s === "rtl" ? l(c, u.length) : a(c, u.length))), i.set("arrowleft", r((c, u) => s === "rtl" ? a(c, u.length) : l(c, u.length))), i.set("arrowup", r((c, u) => {
    let d = c - o();
    return d < 0 && (d = c + o() * Math.floor(u.length / o()), d > u.length - 1 && (d -= o())), d;
  })), i.set("arrowdown", r((c, u) => {
    let d = c + o();
    return d > u.length - 1 && (d = c % o()), d;
  }));
  function r(c) {
    return (u) => {
      const d = t.find((m) => m.element === e.focusedElement), h = t.getIndex(d), f = c(h, t);
      t.get(f).focus(), u.stopPropagation(), u.preventDefault();
    };
  }
  function a(c, u) {
    return c === u - 1 ? 0 : c + 1;
  }
  function l(c, u) {
    return c === 0 ? u - 1 : c - 1;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ze extends T {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.set("text", void 0), this.set("for", void 0), this.id = `ck-editor__label_${je()}`;
    const t = this.bindTemplate;
    this.setTemplate({
      tag: "label",
      attributes: {
        class: [
          "ck",
          "ck-label"
        ],
        id: this.id,
        for: t.to("for")
      },
      children: [
        {
          text: t.to("text")
        }
      ]
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class NA extends T {
  /**
   * @inheritDoc
   */
  constructor(e, t) {
    super(e);
    const n = e.t, s = new ze();
    s.text = n("Help Contents. To close this dialog press ESC."), this.setTemplate({
      tag: "div",
      attributes: {
        class: ["ck", "ck-accessibility-help-dialog__content"],
        "aria-labelledby": s.id,
        role: "document",
        tabindex: -1
      },
      children: [
        Ye(document, "p", {}, n("Below, you can find a list of keyboard shortcuts that can be used in the editor.")),
        ...this._createCategories(Array.from(t.values())),
        s
      ]
    });
  }
  /**
   * @inheritDoc
   */
  focus() {
    this.element.focus();
  }
  /**
   * Creates `<section><h3>Category label</h3>...</section>` elements for each category of keystrokes.
   */
  _createCategories(e) {
    return e.map((t) => {
      const n = [
        // Category header.
        Ye(document, "h3", {}, t.label),
        // Category definitions (<dl>) and their optional headers (<h4>).
        ...Array.from(t.groups.values()).map((s) => this._createGroup(s)).flat()
      ];
      return t.description && n.splice(1, 0, Ye(document, "p", {}, t.description)), Ye(document, "section", {}, n);
    });
  }
  /**
   * Creates `[<h4>Optional label</h4>]<dl>...</dl>` elements for each group of keystrokes in a category.
   */
  _createGroup(e) {
    const t = e.keystrokes.sort((s, o) => s.label.localeCompare(o.label)).map((s) => this._createGroupRow(s)).flat(), n = [
      Ye(document, "dl", {}, t)
    ];
    return e.label && n.unshift(Ye(document, "h4", {}, e.label)), n;
  }
  /**
   * Creates `<dt>Keystroke label</dt><dd>Keystroke definition</dd>` elements for each keystroke in a group.
   */
  _createGroupRow(e) {
    const t = this.locale.t, n = Ye(document, "dt"), s = Ye(document, "dd"), o = zA(e.keystroke), r = [];
    for (const a of o)
      r.push(a.map(DA).join(""));
    return n.innerHTML = e.label, s.innerHTML = r.join(", ") + (e.mayRequireFn && M.isMac ? ` ${t("(may require <kbd>Fn</kbd>)")}` : ""), [n, s];
  }
}
function DA(i) {
  return Co(i).split("+").map((e) => `<kbd>${e}</kbd>`).join("+");
}
function zA(i) {
  return typeof i == "string" ? [[i]] : typeof i[0] == "string" ? [i] : i;
}
const Zu = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 6.628a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3Z"/><path d="M8.5 9.125a.3.3 0 0 0-.253-.296L5.11 8.327a.75.75 0 1 1 .388-1.449l4.04.716c.267.072.624.08.893.009l4.066-.724a.75.75 0 1 1 .388 1.45l-3.132.5a.3.3 0 0 0-.253.296v1.357a.3.3 0 0 0 .018.102l1.615 4.438a.75.75 0 0 1-1.41.513l-1.35-3.71a.3.3 0 0 0-.281-.197h-.209a.3.3 0 0 0-.282.198l-1.35 3.711a.75.75 0 0 1-1.41-.513l1.64-4.509a.3.3 0 0 0 .019-.103V9.125Z"/><path clip-rule="evenodd" d="M10 18.5a8.5 8.5 0 1 1 0-17 8.5 8.5 0 0 1 0 17Zm0 1.5c5.523 0 10-4.477 10-10S15.523 0 10 0 0 4.477 0 10s4.477 10 10 10Z"/></svg>';
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class HA extends b {
  constructor() {
    super(...arguments), this.contentView = null;
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [kt];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "AccessibilityHelp";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.locale.t;
    e.ui.componentFactory.add("accessibilityHelp", () => {
      const n = this._createButton(P);
      return n.set({
        tooltip: !0,
        withText: !1,
        label: t("Accessibility help")
      }), n;
    }), e.ui.componentFactory.add("menuBar:accessibilityHelp", () => {
      const n = this._createButton(de);
      return n.label = t("Accessibility"), n;
    }), e.keystrokes.set("Alt+0", (n, s) => {
      this._showDialog(), s();
    }), this._setupRootLabels();
  }
  /**
   * Creates a button to show accessibility help dialog, for use either in toolbar or in menu bar.
   */
  _createButton(e) {
    const n = this.editor.locale, s = new e(n);
    return s.set({
      keystroke: "Alt+0",
      icon: Zu
    }), s.on("execute", () => this._showDialog()), s;
  }
  /**
   * Injects a help text into each editing root's `aria-label` attribute allowing assistive technology users
   * to discover the availability of the Accessibility help dialog.
   */
  _setupRootLabels() {
    const e = this.editor, t = e.editing.view, n = e.t;
    e.ui.on("ready", () => {
      t.change((o) => {
        for (const r of t.document.roots)
          s(o, r);
      }), e.on("addRoot", (o, r) => {
        const a = e.editing.view.document.getRoot(r.rootName);
        t.change((l) => s(l, a));
      }, { priority: "low" });
    });
    function s(o, r) {
      const l = `${r.getAttribute("aria-label")}. ${n("Press %0 for help.", [Co("Alt+0")])}`;
      o.setAttribute("aria-label", l, r);
    }
  }
  /**
   * Shows the accessibility help dialog. Also, creates {@link #contentView} on demand.
   */
  _showDialog() {
    const e = this.editor, t = e.plugins.get("Dialog"), n = e.locale.t;
    this.contentView || (this.contentView = new NA(e.locale, e.accessibility.keystrokeInfos)), t.show({
      id: "accessibilityHelp",
      className: "ck-accessibility-help-dialog",
      title: n("Accessibility help"),
      icon: Zu,
      hasCloseButton: !0,
      content: this.contentView
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class UA extends ve {
  /**
   * Creates a new instance of the {@link module:ui/editorui/bodycollection~BodyCollection}.
   *
   * @param locale The {@link module:core/editor/editor~Editor editor's locale} instance.
   * @param initialItems The initial items of the collection.
   */
  constructor(e, t = []) {
    super(t), this.locale = e;
  }
  /**
   * The element holding elements of the body region.
   */
  get bodyCollectionContainer() {
    return this._bodyCollectionContainer;
  }
  /**
   * Attaches the body collection to the DOM body element. You need to execute this method to render the content of
   * the body collection.
   */
  attachToDom() {
    this._bodyCollectionContainer = new Me({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-reset_all",
          "ck-body",
          "ck-rounded-corners"
        ],
        dir: this.locale.uiLanguageDirection
      },
      children: this
    }).render();
    let e = document.querySelector(".ck-body-wrapper");
    e || (e = Ye(document, "div", { class: "ck-body-wrapper" }), document.body.appendChild(e)), e.appendChild(this._bodyCollectionContainer);
  }
  /**
   * Detaches the collection from the DOM structure. Use this method when you do not need to use the body collection
   * anymore to clean-up the DOM structure.
   */
  detachFromDom() {
    super.destroy(), this._bodyCollectionContainer && this._bodyCollectionContainer.remove();
    const e = document.querySelector(".ck-body-wrapper");
    e && e.childElementCount == 0 && e.remove();
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ut extends T {
  /**
   * @inheritDoc
   */
  constructor() {
    super();
    const e = this.bindTemplate;
    this.set("content", ""), this.set("viewBox", "0 0 20 20"), this.set("fillColor", ""), this.set("isColorInherited", !0), this.set("isVisible", !0), this.setTemplate({
      tag: "svg",
      ns: "http://www.w3.org/2000/svg",
      attributes: {
        class: [
          "ck",
          "ck-icon",
          e.if("isVisible", "ck-hidden", (t) => !t),
          // Exclude icon internals from the CSS reset to allow rich (non-monochromatic) icons
          // (https://github.com/ckeditor/ckeditor5/issues/12599).
          "ck-reset_all-excluded",
          // The class to remove the dynamic color inheritance is toggleable
          // (https://github.com/ckeditor/ckeditor5/issues/12599).
          e.if("isColorInherited", "ck-icon_inherit-color")
        ],
        viewBox: e.to("viewBox")
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this._updateXMLContent(), this._colorFillPaths(), this.on("change:content", () => {
      this._updateXMLContent(), this._colorFillPaths();
    }), this.on("change:fillColor", () => {
      this._colorFillPaths();
    });
  }
  /**
   * Updates the {@link #element} with the value of {@link #content}.
   */
  _updateXMLContent() {
    if (this.content) {
      const t = new DOMParser().parseFromString(this.content.trim(), "image/svg+xml").querySelector("svg"), n = t.getAttribute("viewBox");
      n && (this.viewBox = n);
      for (const { name: s, value: o } of Array.from(t.attributes))
        ut.presentationalAttributeNames.includes(s) && this.element.setAttribute(s, o);
      for (; this.element.firstChild; )
        this.element.removeChild(this.element.firstChild);
      for (; t.childNodes.length > 0; )
        this.element.appendChild(t.childNodes[0]);
    }
  }
  /**
   * Fills all child `path.ck-icon__fill` with the `#fillColor`.
   */
  _colorFillPaths() {
    this.fillColor && this.element.querySelectorAll(".ck-icon__fill").forEach((e) => {
      e.style.fill = this.fillColor;
    });
  }
}
ut.presentationalAttributeNames = [
  "alignment-baseline",
  "baseline-shift",
  "clip-path",
  "clip-rule",
  "color",
  "color-interpolation",
  "color-interpolation-filters",
  "color-rendering",
  "cursor",
  "direction",
  "display",
  "dominant-baseline",
  "fill",
  "fill-opacity",
  "fill-rule",
  "filter",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "mask",
  "opacity",
  "overflow",
  "paint-order",
  "pointer-events",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "stroke",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-overflow",
  "text-rendering",
  "transform",
  "unicode-bidi",
  "vector-effect",
  "visibility",
  "white-space",
  "word-spacing",
  "writing-mode"
];
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class $A extends T {
  /**
   * @inheritDoc
   */
  constructor() {
    super(), this.set({
      style: void 0,
      text: void 0,
      id: void 0
    });
    const e = this.bindTemplate;
    this.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-button__label"
        ],
        style: e.to("style"),
        id: e.to("id")
      },
      children: [
        {
          text: e.to("text")
        }
      ]
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class P extends T {
  /**
   * Creates an instance of the button view class.
   *
   * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
   * @param labelView The instance of the button's label. If not provided, an instance of
   * {@link module:ui/button/buttonlabelview~ButtonLabelView} is used.
   */
  constructor(e, t = new $A()) {
    super(e), this._focusDelayed = null;
    const n = this.bindTemplate, s = je();
    this.set("ariaLabel", void 0), this.set("ariaLabelledBy", `ck-editor__aria-label_${s}`), this.set("class", void 0), this.set("labelStyle", void 0), this.set("icon", void 0), this.set("isEnabled", !0), this.set("isOn", !1), this.set("isVisible", !0), this.set("isToggleable", !1), this.set("keystroke", void 0), this.set("label", void 0), this.set("role", void 0), this.set("tabindex", -1), this.set("tooltip", !1), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", !1), this.set("withKeystroke", !1), this.children = this.createCollection(), this.labelView = this._setupLabelView(t), this.iconView = new ut(), this.iconView.extendTemplate({
      attributes: {
        class: "ck-button__icon"
      }
    }), this.keystrokeView = this._createKeystrokeView(), this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this));
    const o = {
      tag: "button",
      attributes: {
        class: [
          "ck",
          "ck-button",
          n.to("class"),
          n.if("isEnabled", "ck-disabled", (r) => !r),
          n.if("isVisible", "ck-hidden", (r) => !r),
          n.to("isOn", (r) => r ? "ck-on" : "ck-off"),
          n.if("withText", "ck-button_with-text"),
          n.if("withKeystroke", "ck-button_with-keystroke")
        ],
        role: n.to("role"),
        type: n.to("type", (r) => r || "button"),
        tabindex: n.to("tabindex"),
        "aria-checked": n.to("ariaChecked"),
        "aria-label": n.to("ariaLabel"),
        "aria-labelledby": n.to("ariaLabelledBy"),
        "aria-disabled": n.if("isEnabled", !0, (r) => !r),
        "aria-pressed": n.to("isOn", (r) => this.isToggleable ? String(!!r) : !1),
        "data-cke-tooltip-text": n.to("_tooltipString"),
        "data-cke-tooltip-position": n.to("tooltipPosition")
      },
      children: this.children,
      on: {
        click: n.to((r) => {
          this.isEnabled ? this.fire("execute") : r.preventDefault();
        })
      }
    };
    M.isSafari && (this._focusDelayed || (this._focusDelayed = cl(() => this.focus(), 0)), o.on.mousedown = n.to(() => {
      this._focusDelayed();
    }), o.on.mouseup = n.to(() => {
      this._focusDelayed.cancel();
    })), this.setTemplate(o);
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.icon && (this.iconView.bind("content").to(this, "icon"), this.children.add(this.iconView)), this.children.add(this.labelView), this.withKeystroke && this.keystroke && this.children.add(this.keystrokeView);
  }
  /**
   * Focuses the {@link #element} of the button.
   */
  focus() {
    this.element.focus();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    this._focusDelayed && this._focusDelayed.cancel(), super.destroy();
  }
  /**
   * Binds the label view instance it with button attributes.
   */
  _setupLabelView(e) {
    return e.bind("text", "style", "id").to(this, "label", "labelStyle", "ariaLabelledBy"), e;
  }
  /**
   * Creates a view that displays a keystroke next to a {@link #labelView label }
   * and binds it with button attributes.
   */
  _createKeystrokeView() {
    const e = new T();
    return e.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-button__keystroke"
        ]
      },
      children: [
        {
          text: this.bindTemplate.to("keystroke", (t) => Co(t))
        }
      ]
    }), e;
  }
  /**
   * Gets the text for the tooltip from the combination of
   * {@link #tooltip}, {@link #label} and {@link #keystroke} attributes.
   *
   * @see #tooltip
   * @see #_tooltipString
   * @param tooltip Button tooltip.
   * @param label Button label.
   * @param keystroke Button keystroke.
   */
  _getTooltipString(e, t, n) {
    return e ? typeof e == "string" ? e : (n && (n = Co(n)), e instanceof Function ? e(t, n) : `${t}${n ? ` (${n})` : ""}`) : "";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class nr extends P {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.isToggleable = !0, this.toggleSwitchView = this._createToggleView(), this.extendTemplate({
      attributes: {
        class: "ck-switchbutton"
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.children.add(this.toggleSwitchView);
  }
  /**
   * Creates a toggle child view.
   */
  _createToggleView() {
    const e = new T();
    return e.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-button__toggle"
        ]
      },
      children: [
        {
          tag: "span",
          attributes: {
            class: [
              "ck",
              "ck-button__toggle__inner"
            ]
          }
        }
      ]
    }), e;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class kg extends P {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.buttonView = this, this._fileInputView = new WA(e), this._fileInputView.bind("acceptedType").to(this), this._fileInputView.bind("allowMultipleFiles").to(this), this._fileInputView.delegate("done").to(this), this.on("execute", () => {
      this._fileInputView.open();
    }), this.extendTemplate({
      attributes: {
        class: "ck-file-dialog-button"
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.children.add(this._fileInputView);
  }
}
class WA extends T {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.set("acceptedType", void 0), this.set("allowMultipleFiles", !1);
    const t = this.bindTemplate;
    this.setTemplate({
      tag: "input",
      attributes: {
        class: [
          "ck-hidden"
        ],
        type: "file",
        tabindex: "-1",
        accept: t.to("acceptedType"),
        multiple: t.to("allowMultipleFiles")
      },
      on: {
        // Removing from code coverage since we cannot programmatically set input element files.
        change: t.to(
          /* istanbul ignore next -- @preserve */
          () => {
            this.element && this.element.files && this.element.files.length && this.fire("done", this.element.files), this.element.value = "";
          }
        )
      }
    });
  }
  /**
   * Opens file dialog.
   */
  open() {
    this.element.click();
  }
}
const ir = '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Tg extends T {
  /**
   * Creates an instance of the collapsible view.
   *
   * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
   * @param childViews An optional array of initial child views to be inserted into the collapsible.
   */
  constructor(e, t) {
    super(e);
    const n = this.bindTemplate;
    this.set("isCollapsed", !1), this.set("label", ""), this.buttonView = this._createButtonView(), this.children = this.createCollection(), this.set("_collapsibleAriaLabelUid", void 0), t && this.children.addMany(t), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-collapsible",
          n.if("isCollapsed", "ck-collapsible_collapsed")
        ]
      },
      children: [
        this.buttonView,
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-collapsible__children"
            ],
            role: "region",
            hidden: n.if("isCollapsed", "hidden"),
            "aria-labelledby": n.to("_collapsibleAriaLabelUid")
          },
          children: this.children
        }
      ]
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this._collapsibleAriaLabelUid = this.buttonView.labelView.element.id;
  }
  /**
   * Focuses the first focusable.
   */
  focus() {
    this.buttonView.focus();
  }
  /**
   * Creates the main {@link #buttonView} of the collapsible.
   */
  _createButtonView() {
    const e = new P(this.locale), t = e.bindTemplate;
    return e.set({
      withText: !0,
      icon: ir
    }), e.extendTemplate({
      attributes: {
        "aria-expanded": t.to("isOn", (n) => String(n))
      }
    }), e.bind("label").to(this), e.bind("isOn").to(this, "isCollapsed", (n) => !n), e.on("execute", () => {
      this.isCollapsed = !this.isCollapsed;
    }), e;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function ss(i, e) {
  const t = i.t, n = {
    Black: t("Black"),
    "Dim grey": t("Dim grey"),
    Grey: t("Grey"),
    "Light grey": t("Light grey"),
    White: t("White"),
    Red: t("Red"),
    Orange: t("Orange"),
    Yellow: t("Yellow"),
    "Light green": t("Light green"),
    Green: t("Green"),
    Aquamarine: t("Aquamarine"),
    Turquoise: t("Turquoise"),
    "Light blue": t("Light blue"),
    Blue: t("Blue"),
    Purple: t("Purple")
  };
  return e.map((s) => {
    const o = n[s.label];
    return o && o != s.label && (s.label = o), s;
  });
}
function os(i) {
  return i.map(qA).filter((e) => !!e);
}
function qA(i) {
  return typeof i == "string" ? {
    model: i,
    label: i,
    hasBorder: !1,
    view: {
      name: "span",
      styles: {
        color: i
      }
    }
  } : {
    model: i.color,
    label: i.label || i.color,
    hasBorder: i.hasBorder === void 0 ? !1 : i.hasBorder,
    view: {
      name: "span",
      styles: {
        color: `${i.color}`
      }
    }
  };
}
const GA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M16.935 5.328a2 2 0 0 1 0 2.829l-7.778 7.778a2 2 0 0 1-2.829 0L3.5 13.107a1.999 1.999 0 1 1 2.828-2.829l.707.707a1 1 0 0 0 1.414 0l5.658-5.657a2 2 0 0 1 2.828 0z"/><path d="M14.814 6.035 8.448 12.4a1 1 0 0 1-1.414 0l-1.413-1.415A1 1 0 1 0 4.207 12.4l2.829 2.829a1 1 0 0 0 1.414 0l7.778-7.778a1 1 0 1 0-1.414-1.415z"/></svg>';
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Eg extends P {
  constructor(e) {
    super(e);
    const t = this.bindTemplate;
    this.set("color", void 0), this.set("hasBorder", !1), this.icon = GA, this.extendTemplate({
      attributes: {
        style: {
          // https://github.com/ckeditor/ckeditor5/issues/14907
          backgroundColor: t.to("color", (n) => M.isMediaForcedColors ? null : n)
        },
        class: [
          "ck",
          "ck-color-grid__tile",
          t.if("hasBorder", "ck-color-selector__color-tile_bordered")
        ]
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.iconView.fillColor = "hsl(0, 0%, 100%)";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Ju extends T {
  /**
   * Creates an instance of a color grid containing {@link module:ui/colorgrid/colortileview~ColorTileView tiles}.
   *
   * @fires execute
   * @param locale The localization services instance.
   * @param options Component configuration
   * @param options.colorDefinitions Array with definitions
   * required to create the {@link module:ui/colorgrid/colortileview~ColorTileView tiles}.
   * @param options.columns A number of columns to display the tiles.
   */
  constructor(e, t) {
    super(e);
    const n = t && t.colorDefinitions ? t.colorDefinitions : [];
    this.columns = t && t.columns ? t.columns : 5;
    const s = {
      gridTemplateColumns: `repeat( ${this.columns}, 1fr)`
    };
    this.set("selectedColor", void 0), this.items = this.createCollection(), this.focusTracker = new X(), this.keystrokes = new ie(), this.items.on("add", (o, r) => {
      r.isOn = r.color === this.selectedColor;
    }), n.forEach((o) => {
      const r = new Eg();
      r.set({
        color: o.color,
        label: o.label,
        tooltip: !0,
        hasBorder: o.options.hasBorder
      }), r.on("execute", () => {
        this.fire("execute", {
          value: o.color,
          hasBorder: o.options.hasBorder,
          label: o.label
        });
      }), this.items.add(r);
    }), this.setTemplate({
      tag: "div",
      children: this.items,
      attributes: {
        class: [
          "ck",
          "ck-color-grid"
        ],
        style: s
      }
    }), this.on("change:selectedColor", (o, r, a) => {
      for (const l of this.items)
        l.isOn = l.color === a;
    });
  }
  /**
   * Focuses the first focusable in {@link #items}.
   */
  focus() {
    this.items.length && this.items.first.focus();
  }
  /**
   * Focuses the last focusable in {@link #items}.
   */
  focusLast() {
    this.items.length && this.items.last.focus();
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    for (const e of this.items)
      this.focusTracker.add(e.element);
    this.items.on("add", (e, t) => {
      this.focusTracker.add(t.element);
    }), this.items.on("remove", (e, t) => {
      this.focusTracker.remove(t.element);
    }), this.keystrokes.listenTo(this.element), Al({
      keystrokeHandler: this.keystrokes,
      focusTracker: this.focusTracker,
      gridItems: this.items,
      numberOfColumns: this.columns,
      uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
    });
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
}
function Ag(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
var xg = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};
const Xu = /* @__PURE__ */ Ag(xg);
var Qu = {
  red: 0,
  orange: 60,
  yellow: 120,
  green: 180,
  blue: 240,
  purple: 300
};
function Yu(i) {
  var e, t = [], n = 1, s;
  if (typeof i == "string")
    if (Xu[i])
      t = Xu[i].slice(), s = "rgb";
    else if (i === "transparent")
      n = 0, s = "rgb", t = [0, 0, 0];
    else if (/^#[A-Fa-f0-9]+$/.test(i)) {
      var o = i.slice(1), r = o.length, a = r <= 4;
      n = 1, a ? (t = [
        parseInt(o[0] + o[0], 16),
        parseInt(o[1] + o[1], 16),
        parseInt(o[2] + o[2], 16)
      ], r === 4 && (n = parseInt(o[3] + o[3], 16) / 255)) : (t = [
        parseInt(o[0] + o[1], 16),
        parseInt(o[2] + o[3], 16),
        parseInt(o[4] + o[5], 16)
      ], r === 8 && (n = parseInt(o[6] + o[7], 16) / 255)), t[0] || (t[0] = 0), t[1] || (t[1] = 0), t[2] || (t[2] = 0), s = "rgb";
    } else if (e = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(i)) {
      var l = e[1], c = l === "rgb", o = l.replace(/a$/, "");
      s = o;
      var r = o === "cmyk" ? 4 : o === "gray" ? 1 : 3;
      t = e[2].trim().split(/\s*[,\/]\s*|\s+/).map(function(h, f) {
        if (/%$/.test(h))
          return f === r ? parseFloat(h) / 100 : o === "rgb" ? parseFloat(h) * 255 / 100 : parseFloat(h);
        if (o[f] === "h") {
          if (/deg$/.test(h))
            return parseFloat(h);
          if (Qu[h] !== void 0)
            return Qu[h];
        }
        return parseFloat(h);
      }), l === o && t.push(1), n = c || t[r] === void 0 ? 1 : t[r], t = t.slice(0, r);
    } else i.length > 10 && /[0-9](?:\s|\/)/.test(i) && (t = i.match(/([0-9]+)/g).map(function(u) {
      return parseFloat(u);
    }), s = i.match(/([a-z])/ig).join("").toLowerCase());
  else isNaN(i) ? Array.isArray(i) || i.length ? (t = [i[0], i[1], i[2]], s = "rgb", n = i.length === 4 ? i[3] : 1) : i instanceof Object && (i.r != null || i.red != null || i.R != null ? (s = "rgb", t = [
    i.r || i.red || i.R || 0,
    i.g || i.green || i.G || 0,
    i.b || i.blue || i.B || 0
  ]) : (s = "hsl", t = [
    i.h || i.hue || i.H || 0,
    i.s || i.saturation || i.S || 0,
    i.l || i.lightness || i.L || i.b || i.brightness
  ]), n = i.a || i.alpha || i.opacity || 1, i.opacity != null && (n /= 100)) : (s = "rgb", t = [i >>> 16, (i & 65280) >>> 8, i & 255]);
  return {
    space: s,
    values: t,
    alpha: n
  };
}
const rs = xg, Ig = {};
for (const i of Object.keys(rs))
  Ig[rs[i]] = i;
const I = {
  rgb: { channels: 3, labels: "rgb" },
  hsl: { channels: 3, labels: "hsl" },
  hsv: { channels: 3, labels: "hsv" },
  hwb: { channels: 3, labels: "hwb" },
  cmyk: { channels: 4, labels: "cmyk" },
  xyz: { channels: 3, labels: "xyz" },
  lab: { channels: 3, labels: "lab" },
  lch: { channels: 3, labels: "lch" },
  hex: { channels: 1, labels: ["hex"] },
  keyword: { channels: 1, labels: ["keyword"] },
  ansi16: { channels: 1, labels: ["ansi16"] },
  ansi256: { channels: 1, labels: ["ansi256"] },
  hcg: { channels: 3, labels: ["h", "c", "g"] },
  apple: { channels: 3, labels: ["r16", "g16", "b16"] },
  gray: { channels: 1, labels: ["gray"] }
};
var Sg = I;
for (const i of Object.keys(I)) {
  if (!("channels" in I[i]))
    throw new Error("missing channels property: " + i);
  if (!("labels" in I[i]))
    throw new Error("missing channel labels property: " + i);
  if (I[i].labels.length !== I[i].channels)
    throw new Error("channel and label counts mismatch: " + i);
  const { channels: e, labels: t } = I[i];
  delete I[i].channels, delete I[i].labels, Object.defineProperty(I[i], "channels", { value: e }), Object.defineProperty(I[i], "labels", { value: t });
}
I.rgb.hsl = function(i) {
  const e = i[0] / 255, t = i[1] / 255, n = i[2] / 255, s = Math.min(e, t, n), o = Math.max(e, t, n), r = o - s;
  let a, l;
  o === s ? a = 0 : e === o ? a = (t - n) / r : t === o ? a = 2 + (n - e) / r : n === o && (a = 4 + (e - t) / r), a = Math.min(a * 60, 360), a < 0 && (a += 360);
  const c = (s + o) / 2;
  return o === s ? l = 0 : c <= 0.5 ? l = r / (o + s) : l = r / (2 - o - s), [a, l * 100, c * 100];
};
I.rgb.hsv = function(i) {
  let e, t, n, s, o;
  const r = i[0] / 255, a = i[1] / 255, l = i[2] / 255, c = Math.max(r, a, l), u = c - Math.min(r, a, l), d = function(h) {
    return (c - h) / 6 / u + 1 / 2;
  };
  return u === 0 ? (s = 0, o = 0) : (o = u / c, e = d(r), t = d(a), n = d(l), r === c ? s = n - t : a === c ? s = 1 / 3 + e - n : l === c && (s = 2 / 3 + t - e), s < 0 ? s += 1 : s > 1 && (s -= 1)), [
    s * 360,
    o * 100,
    c * 100
  ];
};
I.rgb.hwb = function(i) {
  const e = i[0], t = i[1];
  let n = i[2];
  const s = I.rgb.hsl(i)[0], o = 1 / 255 * Math.min(e, Math.min(t, n));
  return n = 1 - 1 / 255 * Math.max(e, Math.max(t, n)), [s, o * 100, n * 100];
};
I.rgb.cmyk = function(i) {
  const e = i[0] / 255, t = i[1] / 255, n = i[2] / 255, s = Math.min(1 - e, 1 - t, 1 - n), o = (1 - e - s) / (1 - s) || 0, r = (1 - t - s) / (1 - s) || 0, a = (1 - n - s) / (1 - s) || 0;
  return [o * 100, r * 100, a * 100, s * 100];
};
function jA(i, e) {
  return (i[0] - e[0]) ** 2 + (i[1] - e[1]) ** 2 + (i[2] - e[2]) ** 2;
}
I.rgb.keyword = function(i) {
  const e = Ig[i];
  if (e)
    return e;
  let t = 1 / 0, n;
  for (const s of Object.keys(rs)) {
    const o = rs[s], r = jA(i, o);
    r < t && (t = r, n = s);
  }
  return n;
};
I.keyword.rgb = function(i) {
  return rs[i];
};
I.rgb.xyz = function(i) {
  let e = i[0] / 255, t = i[1] / 255, n = i[2] / 255;
  e = e > 0.04045 ? ((e + 0.055) / 1.055) ** 2.4 : e / 12.92, t = t > 0.04045 ? ((t + 0.055) / 1.055) ** 2.4 : t / 12.92, n = n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92;
  const s = e * 0.4124 + t * 0.3576 + n * 0.1805, o = e * 0.2126 + t * 0.7152 + n * 0.0722, r = e * 0.0193 + t * 0.1192 + n * 0.9505;
  return [s * 100, o * 100, r * 100];
};
I.rgb.lab = function(i) {
  const e = I.rgb.xyz(i);
  let t = e[0], n = e[1], s = e[2];
  t /= 95.047, n /= 100, s /= 108.883, t = t > 8856e-6 ? t ** (1 / 3) : 7.787 * t + 16 / 116, n = n > 8856e-6 ? n ** (1 / 3) : 7.787 * n + 16 / 116, s = s > 8856e-6 ? s ** (1 / 3) : 7.787 * s + 16 / 116;
  const o = 116 * n - 16, r = 500 * (t - n), a = 200 * (n - s);
  return [o, r, a];
};
I.hsl.rgb = function(i) {
  const e = i[0] / 360, t = i[1] / 100, n = i[2] / 100;
  let s, o, r;
  if (t === 0)
    return r = n * 255, [r, r, r];
  n < 0.5 ? s = n * (1 + t) : s = n + t - n * t;
  const a = 2 * n - s, l = [0, 0, 0];
  for (let c = 0; c < 3; c++)
    o = e + 1 / 3 * -(c - 1), o < 0 && o++, o > 1 && o--, 6 * o < 1 ? r = a + (s - a) * 6 * o : 2 * o < 1 ? r = s : 3 * o < 2 ? r = a + (s - a) * (2 / 3 - o) * 6 : r = a, l[c] = r * 255;
  return l;
};
I.hsl.hsv = function(i) {
  const e = i[0];
  let t = i[1] / 100, n = i[2] / 100, s = t;
  const o = Math.max(n, 0.01);
  n *= 2, t *= n <= 1 ? n : 2 - n, s *= o <= 1 ? o : 2 - o;
  const r = (n + t) / 2, a = n === 0 ? 2 * s / (o + s) : 2 * t / (n + t);
  return [e, a * 100, r * 100];
};
I.hsv.rgb = function(i) {
  const e = i[0] / 60, t = i[1] / 100;
  let n = i[2] / 100;
  const s = Math.floor(e) % 6, o = e - Math.floor(e), r = 255 * n * (1 - t), a = 255 * n * (1 - t * o), l = 255 * n * (1 - t * (1 - o));
  switch (n *= 255, s) {
    case 0:
      return [n, l, r];
    case 1:
      return [a, n, r];
    case 2:
      return [r, n, l];
    case 3:
      return [r, a, n];
    case 4:
      return [l, r, n];
    case 5:
      return [n, r, a];
  }
};
I.hsv.hsl = function(i) {
  const e = i[0], t = i[1] / 100, n = i[2] / 100, s = Math.max(n, 0.01);
  let o, r;
  r = (2 - t) * n;
  const a = (2 - t) * s;
  return o = t * s, o /= a <= 1 ? a : 2 - a, o = o || 0, r /= 2, [e, o * 100, r * 100];
};
I.hwb.rgb = function(i) {
  const e = i[0] / 360;
  let t = i[1] / 100, n = i[2] / 100;
  const s = t + n;
  let o;
  s > 1 && (t /= s, n /= s);
  const r = Math.floor(6 * e), a = 1 - n;
  o = 6 * e - r, r & 1 && (o = 1 - o);
  const l = t + o * (a - t);
  let c, u, d;
  switch (r) {
    default:
    case 6:
    case 0:
      c = a, u = l, d = t;
      break;
    case 1:
      c = l, u = a, d = t;
      break;
    case 2:
      c = t, u = a, d = l;
      break;
    case 3:
      c = t, u = l, d = a;
      break;
    case 4:
      c = l, u = t, d = a;
      break;
    case 5:
      c = a, u = t, d = l;
      break;
  }
  return [c * 255, u * 255, d * 255];
};
I.cmyk.rgb = function(i) {
  const e = i[0] / 100, t = i[1] / 100, n = i[2] / 100, s = i[3] / 100, o = 1 - Math.min(1, e * (1 - s) + s), r = 1 - Math.min(1, t * (1 - s) + s), a = 1 - Math.min(1, n * (1 - s) + s);
  return [o * 255, r * 255, a * 255];
};
I.xyz.rgb = function(i) {
  const e = i[0] / 100, t = i[1] / 100, n = i[2] / 100;
  let s, o, r;
  return s = e * 3.2406 + t * -1.5372 + n * -0.4986, o = e * -0.9689 + t * 1.8758 + n * 0.0415, r = e * 0.0557 + t * -0.204 + n * 1.057, s = s > 31308e-7 ? 1.055 * s ** (1 / 2.4) - 0.055 : s * 12.92, o = o > 31308e-7 ? 1.055 * o ** (1 / 2.4) - 0.055 : o * 12.92, r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92, s = Math.min(Math.max(0, s), 1), o = Math.min(Math.max(0, o), 1), r = Math.min(Math.max(0, r), 1), [s * 255, o * 255, r * 255];
};
I.xyz.lab = function(i) {
  let e = i[0], t = i[1], n = i[2];
  e /= 95.047, t /= 100, n /= 108.883, e = e > 8856e-6 ? e ** (1 / 3) : 7.787 * e + 16 / 116, t = t > 8856e-6 ? t ** (1 / 3) : 7.787 * t + 16 / 116, n = n > 8856e-6 ? n ** (1 / 3) : 7.787 * n + 16 / 116;
  const s = 116 * t - 16, o = 500 * (e - t), r = 200 * (t - n);
  return [s, o, r];
};
I.lab.xyz = function(i) {
  const e = i[0], t = i[1], n = i[2];
  let s, o, r;
  o = (e + 16) / 116, s = t / 500 + o, r = o - n / 200;
  const a = o ** 3, l = s ** 3, c = r ** 3;
  return o = a > 8856e-6 ? a : (o - 16 / 116) / 7.787, s = l > 8856e-6 ? l : (s - 16 / 116) / 7.787, r = c > 8856e-6 ? c : (r - 16 / 116) / 7.787, s *= 95.047, o *= 100, r *= 108.883, [s, o, r];
};
I.lab.lch = function(i) {
  const e = i[0], t = i[1], n = i[2];
  let s;
  s = Math.atan2(n, t) * 360 / 2 / Math.PI, s < 0 && (s += 360);
  const r = Math.sqrt(t * t + n * n);
  return [e, r, s];
};
I.lch.lab = function(i) {
  const e = i[0], t = i[1], s = i[2] / 360 * 2 * Math.PI, o = t * Math.cos(s), r = t * Math.sin(s);
  return [e, o, r];
};
I.rgb.ansi16 = function(i, e = null) {
  const [t, n, s] = i;
  let o = e === null ? I.rgb.hsv(i)[2] : e;
  if (o = Math.round(o / 50), o === 0)
    return 30;
  let r = 30 + (Math.round(s / 255) << 2 | Math.round(n / 255) << 1 | Math.round(t / 255));
  return o === 2 && (r += 60), r;
};
I.hsv.ansi16 = function(i) {
  return I.rgb.ansi16(I.hsv.rgb(i), i[2]);
};
I.rgb.ansi256 = function(i) {
  const e = i[0], t = i[1], n = i[2];
  return e === t && t === n ? e < 8 ? 16 : e > 248 ? 231 : Math.round((e - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(e / 255 * 5) + 6 * Math.round(t / 255 * 5) + Math.round(n / 255 * 5);
};
I.ansi16.rgb = function(i) {
  let e = i % 10;
  if (e === 0 || e === 7)
    return i > 50 && (e += 3.5), e = e / 10.5 * 255, [e, e, e];
  const t = (~~(i > 50) + 1) * 0.5, n = (e & 1) * t * 255, s = (e >> 1 & 1) * t * 255, o = (e >> 2 & 1) * t * 255;
  return [n, s, o];
};
I.ansi256.rgb = function(i) {
  if (i >= 232) {
    const o = (i - 232) * 10 + 8;
    return [o, o, o];
  }
  i -= 16;
  let e;
  const t = Math.floor(i / 36) / 5 * 255, n = Math.floor((e = i % 36) / 6) / 5 * 255, s = e % 6 / 5 * 255;
  return [t, n, s];
};
I.rgb.hex = function(i) {
  const t = (((Math.round(i[0]) & 255) << 16) + ((Math.round(i[1]) & 255) << 8) + (Math.round(i[2]) & 255)).toString(16).toUpperCase();
  return "000000".substring(t.length) + t;
};
I.hex.rgb = function(i) {
  const e = i.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
  if (!e)
    return [0, 0, 0];
  let t = e[0];
  e[0].length === 3 && (t = t.split("").map((a) => a + a).join(""));
  const n = parseInt(t, 16), s = n >> 16 & 255, o = n >> 8 & 255, r = n & 255;
  return [s, o, r];
};
I.rgb.hcg = function(i) {
  const e = i[0] / 255, t = i[1] / 255, n = i[2] / 255, s = Math.max(Math.max(e, t), n), o = Math.min(Math.min(e, t), n), r = s - o;
  let a, l;
  return r < 1 ? a = o / (1 - r) : a = 0, r <= 0 ? l = 0 : s === e ? l = (t - n) / r % 6 : s === t ? l = 2 + (n - e) / r : l = 4 + (e - t) / r, l /= 6, l %= 1, [l * 360, r * 100, a * 100];
};
I.hsl.hcg = function(i) {
  const e = i[1] / 100, t = i[2] / 100, n = t < 0.5 ? 2 * e * t : 2 * e * (1 - t);
  let s = 0;
  return n < 1 && (s = (t - 0.5 * n) / (1 - n)), [i[0], n * 100, s * 100];
};
I.hsv.hcg = function(i) {
  const e = i[1] / 100, t = i[2] / 100, n = e * t;
  let s = 0;
  return n < 1 && (s = (t - n) / (1 - n)), [i[0], n * 100, s * 100];
};
I.hcg.rgb = function(i) {
  const e = i[0] / 360, t = i[1] / 100, n = i[2] / 100;
  if (t === 0)
    return [n * 255, n * 255, n * 255];
  const s = [0, 0, 0], o = e % 1 * 6, r = o % 1, a = 1 - r;
  let l = 0;
  switch (Math.floor(o)) {
    case 0:
      s[0] = 1, s[1] = r, s[2] = 0;
      break;
    case 1:
      s[0] = a, s[1] = 1, s[2] = 0;
      break;
    case 2:
      s[0] = 0, s[1] = 1, s[2] = r;
      break;
    case 3:
      s[0] = 0, s[1] = a, s[2] = 1;
      break;
    case 4:
      s[0] = r, s[1] = 0, s[2] = 1;
      break;
    default:
      s[0] = 1, s[1] = 0, s[2] = a;
  }
  return l = (1 - t) * n, [
    (t * s[0] + l) * 255,
    (t * s[1] + l) * 255,
    (t * s[2] + l) * 255
  ];
};
I.hcg.hsv = function(i) {
  const e = i[1] / 100, t = i[2] / 100, n = e + t * (1 - e);
  let s = 0;
  return n > 0 && (s = e / n), [i[0], s * 100, n * 100];
};
I.hcg.hsl = function(i) {
  const e = i[1] / 100, n = i[2] / 100 * (1 - e) + 0.5 * e;
  let s = 0;
  return n > 0 && n < 0.5 ? s = e / (2 * n) : n >= 0.5 && n < 1 && (s = e / (2 * (1 - n))), [i[0], s * 100, n * 100];
};
I.hcg.hwb = function(i) {
  const e = i[1] / 100, t = i[2] / 100, n = e + t * (1 - e);
  return [i[0], (n - e) * 100, (1 - n) * 100];
};
I.hwb.hcg = function(i) {
  const e = i[1] / 100, n = 1 - i[2] / 100, s = n - e;
  let o = 0;
  return s < 1 && (o = (n - s) / (1 - s)), [i[0], s * 100, o * 100];
};
I.apple.rgb = function(i) {
  return [i[0] / 65535 * 255, i[1] / 65535 * 255, i[2] / 65535 * 255];
};
I.rgb.apple = function(i) {
  return [i[0] / 255 * 65535, i[1] / 255 * 65535, i[2] / 255 * 65535];
};
I.gray.rgb = function(i) {
  return [i[0] / 100 * 255, i[0] / 100 * 255, i[0] / 100 * 255];
};
I.gray.hsl = function(i) {
  return [0, 0, i[0]];
};
I.gray.hsv = I.gray.hsl;
I.gray.hwb = function(i) {
  return [0, 100, i[0]];
};
I.gray.cmyk = function(i) {
  return [0, 0, 0, i[0]];
};
I.gray.lab = function(i) {
  return [i[0], 0, 0];
};
I.gray.hex = function(i) {
  const e = Math.round(i[0] / 100 * 255) & 255, n = ((e << 16) + (e << 8) + e).toString(16).toUpperCase();
  return "000000".substring(n.length) + n;
};
I.rgb.gray = function(i) {
  return [(i[0] + i[1] + i[2]) / 3 / 255 * 100];
};
const xo = Sg;
function KA() {
  const i = {}, e = Object.keys(xo);
  for (let t = e.length, n = 0; n < t; n++)
    i[e[n]] = {
      // http://jsperf.com/1-vs-infinity
      // micro-opt, but this is simple.
      distance: -1,
      parent: null
    };
  return i;
}
function ZA(i) {
  const e = KA(), t = [i];
  for (e[i].distance = 0; t.length; ) {
    const n = t.pop(), s = Object.keys(xo[n]);
    for (let o = s.length, r = 0; r < o; r++) {
      const a = s[r], l = e[a];
      l.distance === -1 && (l.distance = e[n].distance + 1, l.parent = n, t.unshift(a));
    }
  }
  return e;
}
function JA(i, e) {
  return function(t) {
    return e(i(t));
  };
}
function XA(i, e) {
  const t = [e[i].parent, i];
  let n = xo[e[i].parent][i], s = e[i].parent;
  for (; e[s].parent; )
    t.unshift(e[s].parent), n = JA(xo[e[s].parent][s], n), s = e[s].parent;
  return n.conversion = t, n;
}
var QA = function(i) {
  const e = ZA(i), t = {}, n = Object.keys(e);
  for (let s = n.length, o = 0; o < s; o++) {
    const r = n[o];
    e[r].parent !== null && (t[r] = XA(r, e));
  }
  return t;
};
const ba = Sg, YA = QA, $n = {}, ex = Object.keys(ba);
function tx(i) {
  const e = function(...t) {
    const n = t[0];
    return n == null ? n : (n.length > 1 && (t = n), i(t));
  };
  return "conversion" in i && (e.conversion = i.conversion), e;
}
function nx(i) {
  const e = function(...t) {
    const n = t[0];
    if (n == null)
      return n;
    n.length > 1 && (t = n);
    const s = i(t);
    if (typeof s == "object")
      for (let o = s.length, r = 0; r < o; r++)
        s[r] = Math.round(s[r]);
    return s;
  };
  return "conversion" in i && (e.conversion = i.conversion), e;
}
ex.forEach((i) => {
  $n[i] = {}, Object.defineProperty($n[i], "channels", { value: ba[i].channels }), Object.defineProperty($n[i], "labels", { value: ba[i].labels });
  const e = YA(i);
  Object.keys(e).forEach((n) => {
    const s = e[n];
    $n[i][n] = nx(s), $n[i][n].raw = tx(s);
  });
});
var Pg = $n;
const ix = /* @__PURE__ */ Ag(Pg), Rg = /* @__PURE__ */ Ub({
  __proto__: null,
  default: ix
}, [Pg]);
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Vg(i, e) {
  if (!i)
    return "";
  const t = Mg(i);
  if (!t)
    return "";
  if (t.space === e)
    return i;
  if (!ax(t))
    return "";
  const s = Rg[t.space][e];
  if (!s)
    return "";
  const o = s(t.space === "hex" ? t.hexValue : t.values);
  return rx(o, e);
}
function sx(i) {
  if (!i)
    return "";
  const e = Mg(i);
  return e ? e.space === "hex" ? e.hexValue : Vg(i, "hex") : "#000";
}
function ox(i, e) {
  customElements.get(i) === void 0 && customElements.define(i, e);
}
function rx(i, e) {
  switch (e) {
    case "hex":
      return `#${i}`;
    case "rgb":
      return `rgb( ${i[0]}, ${i[1]}, ${i[2]} )`;
    case "hsl":
      return `hsl( ${i[0]}, ${i[1]}%, ${i[2]}% )`;
    case "hwb":
      return `hwb( ${i[0]}, ${i[1]}, ${i[2]} )`;
    case "lab":
      return `lab( ${i[0]}% ${i[1]} ${i[2]} )`;
    case "lch":
      return `lch( ${i[0]}% ${i[1]} ${i[2]} )`;
    default:
      return "";
  }
}
function Mg(i) {
  if (i.startsWith("#")) {
    const t = Yu(i);
    return {
      space: "hex",
      values: t.values,
      hexValue: i,
      alpha: t.alpha
    };
  }
  const e = Yu(i);
  return e.space ? e : null;
}
function ax(i) {
  return Object.keys(Rg).includes(i.space);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ue extends T {
  /**
   * Creates an instance of the labeled field view class using a provided creator function
   * that provides the view to be labeled.
   *
   * @param locale The locale instance.
   * @param viewCreator A function that returns a {@link module:ui/view~View}
   * that will be labeled. The following arguments are passed to the creator function:
   *
   * * an instance of the `LabeledFieldView` to allow binding observable properties,
   * * an UID string that connects the {@link #labelView label} and the labeled field view in DOM,
   * * an UID string that connects the {@link #statusView status} and the labeled field view in DOM.
   */
  constructor(e, t) {
    super(e);
    const n = `ck-labeled-field-view-${je()}`, s = `ck-labeled-field-view-status-${je()}`;
    this.fieldView = t(this, n, s), this.set("label", void 0), this.set("isEnabled", !0), this.set("isEmpty", !0), this.set("isFocused", !1), this.set("errorText", null), this.set("infoText", null), this.set("class", void 0), this.set("placeholder", void 0), this.labelView = this._createLabelView(n), this.statusView = this._createStatusView(s), this.fieldWrapperChildren = this.createCollection([this.fieldView, this.labelView]), this.bind("_statusText").to(this, "errorText", this, "infoText", (r, a) => r || a);
    const o = this.bindTemplate;
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-labeled-field-view",
          o.to("class"),
          o.if("isEnabled", "ck-disabled", (r) => !r),
          o.if("isEmpty", "ck-labeled-field-view_empty"),
          o.if("isFocused", "ck-labeled-field-view_focused"),
          o.if("placeholder", "ck-labeled-field-view_placeholder"),
          o.if("errorText", "ck-error")
        ]
      },
      children: [
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-labeled-field-view__input-wrapper"
            ]
          },
          children: this.fieldWrapperChildren
        },
        this.statusView
      ]
    });
  }
  /**
   * Creates label view class instance and bind with view.
   *
   * @param id Unique id to set as labelView#for attribute.
   */
  _createLabelView(e) {
    const t = new ze(this.locale);
    return t.for = e, t.bind("text").to(this, "label"), t;
  }
  /**
   * Creates the status view instance. It displays {@link #errorText} and {@link #infoText}
   * next to the {@link #fieldView}. See {@link #_statusText}.
   *
   * @param statusUid Unique id of the status, shared with the {@link #fieldView view's}
   * `aria-describedby` attribute.
   */
  _createStatusView(e) {
    const t = new T(this.locale), n = this.bindTemplate;
    return t.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-labeled-field-view__status",
          n.if("errorText", "ck-labeled-field-view__status_error"),
          n.if("_statusText", "ck-hidden", (s) => !s)
        ],
        id: e,
        role: n.if("errorText", "alert")
      },
      children: [
        {
          text: n.to("_statusText")
        }
      ]
    }), t;
  }
  /**
   * Focuses the {@link #fieldView}.
   */
  focus(e) {
    this.fieldView.focus(e);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class lx extends T {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.set("value", void 0), this.set("id", void 0), this.set("placeholder", void 0), this.set("tabIndex", void 0), this.set("isReadOnly", !1), this.set("hasError", !1), this.set("ariaDescribedById", void 0), this.set("ariaLabel", void 0), this.focusTracker = new X(), this.bind("isFocused").to(this.focusTracker), this.set("isEmpty", !0);
    const t = this.bindTemplate;
    this.setTemplate({
      tag: "input",
      attributes: {
        class: [
          "ck",
          "ck-input",
          t.if("isFocused", "ck-input_focused"),
          t.if("isEmpty", "ck-input-text_empty"),
          t.if("hasError", "ck-error")
        ],
        id: t.to("id"),
        placeholder: t.to("placeholder"),
        tabindex: t.to("tabIndex"),
        readonly: t.to("isReadOnly"),
        "aria-invalid": t.if("hasError", !0),
        "aria-describedby": t.to("ariaDescribedById"),
        "aria-label": t.to("ariaLabel")
      },
      on: {
        input: t.to((...n) => {
          this.fire("input", ...n), this._updateIsEmpty();
        }),
        change: t.to(this._updateIsEmpty.bind(this))
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.focusTracker.add(this.element), this._setDomElementValue(this.value), this._updateIsEmpty(), this.on("change:value", (e, t, n) => {
      this._setDomElementValue(n), this._updateIsEmpty();
    });
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.focusTracker.destroy();
  }
  /**
   * Moves the focus to the input and selects the value.
   */
  select() {
    this.element.select();
  }
  /**
   * Focuses the input.
   */
  focus() {
    this.element.focus();
  }
  /**
   * Resets the value of the input
   */
  reset() {
    this.value = this.element.value = "", this._updateIsEmpty();
  }
  /**
   * Updates the {@link #isEmpty} property value on demand.
   */
  _updateIsEmpty() {
    this.isEmpty = cx(this.element);
  }
  /**
   * Sets the `value` property of the {@link #element DOM element} on demand.
   */
  _setDomElementValue(e) {
    this.element.value = !e && e !== 0 ? "" : e;
  }
}
function cx(i) {
  return !i.value;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Bg extends lx {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.set("inputMode", "text");
    const t = this.bindTemplate;
    this.extendTemplate({
      attributes: {
        inputmode: t.to("inputMode")
      }
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Lg extends Bg {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.extendTemplate({
      attributes: {
        type: "text",
        class: [
          "ck-input-text"
        ]
      }
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ux extends Bg {
  /**
   * Creates an instance of the input number view.
   *
   * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
   * @param options The options of the input.
   * @param options.min The value of the `min` DOM attribute (the lowest accepted value).
   * @param options.max The value of the `max` DOM attribute (the highest accepted value).
   * @param options.step The value of the `step` DOM attribute.
   */
  constructor(e, { min: t, max: n, step: s } = {}) {
    super(e);
    const o = this.bindTemplate;
    this.set("min", t), this.set("max", n), this.set("step", s), this.extendTemplate({
      attributes: {
        type: "number",
        class: [
          "ck-input-number"
        ],
        min: o.to("min"),
        max: o.to("max"),
        step: o.to("step")
      }
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class dx extends T {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e);
    const t = this.bindTemplate;
    this.set("isVisible", !1), this.set("position", "se"), this.children = this.createCollection(), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-reset",
          "ck-dropdown__panel",
          t.to("position", (n) => `ck-dropdown__panel_${n}`),
          t.if("isVisible", "ck-dropdown__panel-visible")
        ],
        tabindex: "-1"
      },
      children: this.children,
      on: {
        // Drag and drop in the panel should not break the selection in the editor.
        // https://github.com/ckeditor/ckeditor5-ui/issues/228
        selectstart: t.to((n) => {
          n.target.tagName.toLocaleLowerCase() !== "input" && n.preventDefault();
        })
      }
    });
  }
  /**
   * Focuses the first view in the {@link #children} collection.
   *
   * See also {@link module:ui/dropdown/dropdownpanelfocusable~DropdownPanelFocusable}.
   */
  focus() {
    if (this.children.length) {
      const e = this.children.first;
      typeof e.focus == "function" ? e.focus() : D("ui-dropdown-panel-focus-child-missing-focus", { childView: this.children.first, dropdownPanel: this });
    }
  }
  /**
   * Focuses the view element or last item in view collection on opening dropdown's panel.
   *
   * See also {@link module:ui/dropdown/dropdownpanelfocusable~DropdownPanelFocusable}.
   */
  focusLast() {
    if (this.children.length) {
      const e = this.children.last;
      typeof e.focusLast == "function" ? e.focusLast() : e.focus();
    }
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ti extends T {
  /**
   * Creates an instance of the dropdown.
   *
   * Also see {@link #render}.
   *
   * @param locale The localization services instance.
   */
  constructor(e, t, n) {
    super(e);
    const s = this.bindTemplate;
    this.buttonView = t, this.panelView = n, this.set("isOpen", !1), this.set("isEnabled", !0), this.set("class", void 0), this.set("id", void 0), this.set("panelPosition", "auto"), this.panelView.bind("isVisible").to(this, "isOpen"), this.keystrokes = new ie(), this.focusTracker = new X(), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-dropdown",
          s.to("class"),
          s.if("isEnabled", "ck-disabled", (o) => !o)
        ],
        id: s.to("id"),
        "aria-describedby": s.to("ariaDescribedById")
      },
      children: [
        t,
        n
      ]
    }), t.extendTemplate({
      attributes: {
        class: [
          "ck-dropdown__button"
        ],
        "data-cke-tooltip-disabled": s.to("isOpen")
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.focusTracker.add(this.buttonView.element), this.focusTracker.add(this.panelView.element), this.listenTo(this.buttonView, "open", () => {
      this.isOpen = !this.isOpen;
    }), this.on("change:isOpen", (t, n, s) => {
      if (s)
        if (this.panelPosition === "auto") {
          const o = ti._getOptimalPosition({
            element: this.panelView.element,
            target: this.buttonView.element,
            fitInViewport: !0,
            positions: this._panelPositions
          });
          this.panelView.position = o ? o.name : this._panelPositions[0].name;
        } else
          this.panelView.position = this.panelPosition;
    }), this.keystrokes.listenTo(this.element);
    const e = (t, n) => {
      this.isOpen && (this.isOpen = !1, n());
    };
    this.keystrokes.set("arrowdown", (t, n) => {
      this.buttonView.isEnabled && !this.isOpen && (this.isOpen = !0, n());
    }), this.keystrokes.set("arrowright", (t, n) => {
      this.isOpen && n();
    }), this.keystrokes.set("arrowleft", e), this.keystrokes.set("esc", e);
  }
  /**
   * Focuses the {@link #buttonView}.
   */
  focus() {
    this.buttonView.focus();
  }
  /**
   * Returns {@link #panelView panel} positions to be used by the
   * {@link module:utils/dom/position~getOptimalPosition `getOptimalPosition()`}
   * utility considering the direction of the language the UI of the editor is displayed in.
   */
  get _panelPositions() {
    const { south: e, north: t, southEast: n, southWest: s, northEast: o, northWest: r, southMiddleEast: a, southMiddleWest: l, northMiddleEast: c, northMiddleWest: u } = ti.defaultPanelPositions;
    return this.locale.uiLanguageDirection !== "rtl" ? [
      n,
      s,
      a,
      l,
      e,
      o,
      r,
      c,
      u,
      t
    ] : [
      s,
      n,
      l,
      a,
      e,
      r,
      o,
      u,
      c,
      t
    ];
  }
}
ti.defaultPanelPositions = {
  south: (i, e) => ({
    top: i.bottom,
    left: i.left - (e.width - i.width) / 2,
    name: "s"
  }),
  southEast: (i) => ({
    top: i.bottom,
    left: i.left,
    name: "se"
  }),
  southWest: (i, e) => ({
    top: i.bottom,
    left: i.left - e.width + i.width,
    name: "sw"
  }),
  southMiddleEast: (i, e) => ({
    top: i.bottom,
    left: i.left - (e.width - i.width) / 4,
    name: "sme"
  }),
  southMiddleWest: (i, e) => ({
    top: i.bottom,
    left: i.left - (e.width - i.width) * 3 / 4,
    name: "smw"
  }),
  north: (i, e) => ({
    top: i.top - e.height,
    left: i.left - (e.width - i.width) / 2,
    name: "n"
  }),
  northEast: (i, e) => ({
    top: i.top - e.height,
    left: i.left,
    name: "ne"
  }),
  northWest: (i, e) => ({
    top: i.top - e.height,
    left: i.left - e.width + i.width,
    name: "nw"
  }),
  northMiddleEast: (i, e) => ({
    top: i.top - e.height,
    left: i.left - (e.width - i.width) / 4,
    name: "nme"
  }),
  northMiddleWest: (i, e) => ({
    top: i.top - e.height,
    left: i.left - (e.width - i.width) * 3 / 4,
    name: "nmw"
  })
};
ti._getOptimalPosition = Go;
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class xl extends P {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.arrowView = this._createArrowView(), this.extendTemplate({
      attributes: {
        "aria-haspopup": !0,
        "aria-expanded": this.bindTemplate.to("isOn", (t) => String(t))
      }
    }), this.delegate("execute").to(this, "open");
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.children.add(this.arrowView);
  }
  /**
   * Creates a {@link module:ui/icon/iconview~IconView} instance as {@link #arrowView}.
   */
  _createArrowView() {
    const e = new ut();
    return e.content = ir, e.extendTemplate({
      attributes: {
        class: "ck-dropdown__arrow"
      }
    }), e;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ge extends G() {
  /**
   * Creates an instance of the focus cycler utility.
   *
   * @param options Configuration options.
   */
  constructor(e) {
    if (super(), this.focusables = e.focusables, this.focusTracker = e.focusTracker, this.keystrokeHandler = e.keystrokeHandler, this.actions = e.actions, e.actions && e.keystrokeHandler)
      for (const t in e.actions) {
        let n = e.actions[t];
        typeof n == "string" && (n = [n]);
        for (const s of n)
          e.keystrokeHandler.set(s, (o, r) => {
            this[t](), r();
          });
      }
    this.on("forwardCycle", () => this.focusFirst(), { priority: "low" }), this.on("backwardCycle", () => this.focusLast(), { priority: "low" });
  }
  /**
   * Returns the first focusable view in {@link #focusables}.
   * Returns `null` if there is none.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  get first() {
    return this.focusables.find(Pr) || null;
  }
  /**
   * Returns the last focusable view in {@link #focusables}.
   * Returns `null` if there is none.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  get last() {
    return this.focusables.filter(Pr).slice(-1)[0] || null;
  }
  /**
   * Returns the next focusable view in {@link #focusables} based on {@link #current}.
   * Returns `null` if there is none.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  get next() {
    return this._getDomFocusableItem(1);
  }
  /**
   * Returns the previous focusable view in {@link #focusables} based on {@link #current}.
   * Returns `null` if there is none.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  get previous() {
    return this._getDomFocusableItem(-1);
  }
  /**
   * An index of the view in the {@link #focusables} which is focused according
   * to {@link #focusTracker}. Returns `null` when there is no such view.
   */
  get current() {
    let e = null;
    return this.focusTracker.focusedElement === null ? null : (this.focusables.find((t, n) => {
      const s = t.element === this.focusTracker.focusedElement;
      return s && (e = n), s;
    }), e);
  }
  /**
   * Focuses the {@link #first} item in {@link #focusables}.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  focusFirst() {
    this._focus(this.first, 1);
  }
  /**
   * Focuses the {@link #last} item in {@link #focusables}.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  focusLast() {
    this._focus(this.last, -1);
  }
  /**
   * Focuses the {@link #next} item in {@link #focusables}.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  focusNext() {
    const e = this.next;
    if (e && this.focusables.getIndex(e) === this.current) {
      this.fire("forwardCycle");
      return;
    }
    e === this.first ? this.fire("forwardCycle") : this._focus(e, 1);
  }
  /**
   * Focuses the {@link #previous} item in {@link #focusables}.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  focusPrevious() {
    const e = this.previous;
    if (e && this.focusables.getIndex(e) === this.current) {
      this.fire("backwardCycle");
      return;
    }
    e === this.last ? this.fire("backwardCycle") : this._focus(e, -1);
  }
  /**
   * Focuses the given view if it exists.
   *
   * @param view The view to be focused
   * @param direction The direction of the focus if the view has focusable children.
   * @returns
   */
  _focus(e, t) {
    e && this.focusTracker.focusedElement !== e.element && e.focus(t);
  }
  /**
   * Returns the next or previous focusable view in {@link #focusables} with respect
   * to {@link #current}.
   *
   * @param step Either `1` for checking forward from {@link #current} or `-1` for checking backwards.
   */
  _getDomFocusableItem(e) {
    const t = this.focusables.length;
    if (!t)
      return null;
    const n = this.current;
    if (n === null)
      return this[e === 1 ? "first" : "last"];
    let s = this.focusables.get(n), o = (n + t + e) % t;
    do {
      const r = this.focusables.get(o);
      if (Pr(r)) {
        s = r;
        break;
      }
      o = (o + t + e) % t;
    } while (o !== n);
    return s;
  }
}
function Pr(i) {
  return bs(i) && mn(i.element);
}
function bs(i) {
  return "focus" in i && typeof i.focus == "function";
}
function hx(i) {
  return bs(i) && "focusCycler" in i && i.focusCycler instanceof ge;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Og extends T {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-toolbar__separator"
        ]
      }
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class fx extends T {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-toolbar__line-break"
        ]
      }
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function mx(i) {
  return i.bindTemplate.to((e) => {
    e.target === i.element && e.preventDefault();
  });
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Fg(i) {
  if (Array.isArray(i))
    return {
      items: i,
      removeItems: []
    };
  const e = {
    items: [],
    removeItems: []
  };
  return i ? {
    ...e,
    ...i
  } : e;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const gx = {
  alignLeft: A.alignLeft,
  bold: A.bold,
  importExport: A.importExport,
  paragraph: A.paragraph,
  plus: A.plus,
  text: A.text,
  threeVerticalDots: A.threeVerticalDots,
  pilcrow: A.pilcrow,
  dragIndicator: A.dragIndicator
};
class ni extends T {
  /**
   * Creates an instance of the {@link module:ui/toolbar/toolbarview~ToolbarView} class.
   *
   * Also see {@link #render}.
   *
   * @param locale The localization services instance.
   * @param options Configuration options of the toolbar.
   */
  constructor(e, t) {
    super(e);
    const n = this.bindTemplate, s = this.t;
    this.options = t || {}, this.set("ariaLabel", s("Editor toolbar")), this.set("maxWidth", "auto"), this.items = this.createCollection(), this.focusTracker = new X(), this.keystrokes = new ie(), this.set("class", void 0), this.set("isCompact", !1), this.itemsView = new px(e), this.children = this.createCollection(), this.children.add(this.itemsView), this.focusables = this.createCollection();
    const o = e.uiLanguageDirection === "rtl";
    this._focusCycler = new ge({
      focusables: this.focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate toolbar items backwards using the arrow[left,up] keys.
        focusPrevious: [o ? "arrowright" : "arrowleft", "arrowup"],
        // Navigate toolbar items forwards using the arrow[right,down] keys.
        focusNext: [o ? "arrowleft" : "arrowright", "arrowdown"]
      }
    });
    const r = [
      "ck",
      "ck-toolbar",
      n.to("class"),
      n.if("isCompact", "ck-toolbar_compact")
    ];
    this.options.shouldGroupWhenFull && this.options.isFloating && r.push("ck-toolbar_floating"), this.setTemplate({
      tag: "div",
      attributes: {
        class: r,
        role: "toolbar",
        "aria-label": n.to("ariaLabel"),
        style: {
          maxWidth: n.to("maxWidth")
        },
        tabindex: -1
      },
      children: this.children,
      on: {
        // https://github.com/ckeditor/ckeditor5-ui/issues/206
        mousedown: mx(this)
      }
    }), this._behavior = this.options.shouldGroupWhenFull ? new wx(this) : new bx(this);
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.focusTracker.add(this.element);
    for (const e of this.items)
      this.focusTracker.add(e.element);
    this.items.on("add", (e, t) => {
      this.focusTracker.add(t.element);
    }), this.items.on("remove", (e, t) => {
      this.focusTracker.remove(t.element);
    }), this.keystrokes.listenTo(this.element), this._behavior.render(this);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    return this._behavior.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy(), super.destroy();
  }
  /**
   * Focuses the first focusable in {@link #focusables}.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
   * Focuses the last focusable in {@link #focusables}.
   */
  focusLast() {
    this._focusCycler.focusLast();
  }
  /**
   * A utility that expands the plain toolbar configuration into
   * {@link module:ui/toolbar/toolbarview~ToolbarView#items} using a given component factory.
   *
   * @param itemsOrConfig The toolbar items or the entire toolbar configuration object.
   * @param factory A factory producing toolbar items.
   * @param removeItems An array of items names to be removed from the configuration. When present, applies
   * to this toolbar and all nested ones as well.
   */
  fillFromConfig(e, t, n) {
    this.items.addMany(this._buildItemsFromConfig(e, t, n));
  }
  /**
   * A utility that expands the plain toolbar configuration into a list of view items using a given component factory.
   *
   * @param itemsOrConfig The toolbar items or the entire toolbar configuration object.
   * @param factory A factory producing toolbar items.
   * @param removeItems An array of items names to be removed from the configuration. When present, applies
   * to this toolbar and all nested ones as well.
   */
  _buildItemsFromConfig(e, t, n) {
    const s = Fg(e), o = n || s.removeItems;
    return this._cleanItemsConfiguration(s.items, t, o).map((a) => J(a) ? this._createNestedToolbarDropdown(a, t, o) : a === "|" ? new Og() : a === "-" ? new fx() : t.create(a)).filter((a) => !!a);
  }
  /**
   * Cleans up the {@link module:ui/toolbar/toolbarview~ToolbarView#items} of the toolbar by removing unwanted items and
   * duplicated (obsolete) separators or line breaks.
   *
   * @param items The toolbar items configuration.
   * @param factory A factory producing toolbar items.
   * @param removeItems An array of items names to be removed from the configuration.
   * @returns Items after the clean-up.
   */
  _cleanItemsConfiguration(e, t, n) {
    const s = e.filter((o, r, a) => o === "|" ? !0 : n.indexOf(o) !== -1 ? !1 : o === "-" ? this.options.shouldGroupWhenFull ? (D("toolbarview-line-break-ignored-when-grouping-items", a), !1) : !0 : !J(o) && !t.has(o) ? (D("toolbarview-item-unavailable", { item: o }), !1) : !0);
    return this._cleanSeparatorsAndLineBreaks(s);
  }
  /**
   * Remove leading, trailing, and duplicated separators (`-` and `|`).
   *
   * @returns Toolbar items after the separator and line break clean-up.
   */
  _cleanSeparatorsAndLineBreaks(e) {
    const t = (r) => r !== "-" && r !== "|", n = e.length, s = e.findIndex(t);
    if (s === -1)
      return [];
    const o = n - e.slice().reverse().findIndex(t);
    return e.slice(s, o).filter((r, a, l) => t(r) ? !0 : !(a > 0 && l[a - 1] === r));
  }
  /**
   * Creates a user-defined dropdown containing a toolbar with items.
   *
   * @param definition A definition of the nested toolbar dropdown.
   * @param definition.label A label of the dropdown.
   * @param definition.icon An icon of the drop-down. One of 'bold', 'plus', 'text', 'importExport', 'alignLeft',
   * 'paragraph' or an SVG string. When `false` is passed, no icon will be used.
   * @param definition.withText When set `true`, the label of the dropdown will be visible. See
   * {@link module:ui/button/buttonview~ButtonView#withText} to learn more.
   * @param definition.tooltip A tooltip of the dropdown button. See
   * {@link module:ui/button/buttonview~ButtonView#tooltip} to learn more. Defaults to `true`.
   * @param componentFactory Component factory used to create items
   * of the nested toolbar.
   */
  _createNestedToolbarDropdown(e, t, n) {
    let { label: s, icon: o, items: r, tooltip: a = !0, withText: l = !1 } = e;
    if (r = this._cleanItemsConfiguration(r, t, n), !r.length)
      return null;
    const c = this.locale, u = we(c);
    return s || D("toolbarview-nested-toolbar-dropdown-missing-label", e), u.class = "ck-toolbar__nested-toolbar-dropdown", u.buttonView.set({
      label: s,
      tooltip: a,
      withText: !!l
    }), o !== !1 ? u.buttonView.icon = gx[o] || o || A.threeVerticalDots : u.buttonView.withText = !0, or(u, () => u.toolbarView._buildItemsFromConfig(r, t, n)), u;
  }
}
class px extends T {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.children = this.createCollection(), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-toolbar__items"
        ]
      },
      children: this.children
    });
  }
}
class bx {
  /**
   * Creates an instance of the {@link module:ui/toolbar/toolbarview~StaticLayout} toolbar
   * behavior.
   *
   * @param view An instance of the toolbar that this behavior is added to.
   */
  constructor(e) {
    const t = e.bindTemplate;
    e.set("isVertical", !1), e.itemsView.children.bindTo(e.items).using((n) => n), e.focusables.bindTo(e.items).using((n) => bs(n) ? n : null), e.extendTemplate({
      attributes: {
        class: [
          // When vertical, the toolbar has an additional CSS class.
          t.if("isVertical", "ck-toolbar_vertical")
        ]
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
  }
  /**
   * @inheritDoc
   */
  destroy() {
  }
}
class wx {
  /**
   * Creates an instance of the {@link module:ui/toolbar/toolbarview~DynamicGrouping} toolbar
   * behavior.
   *
   * @param view An instance of the toolbar that this behavior is added to.
   */
  constructor(e) {
    this.resizeObserver = null, this.cachedPadding = null, this.shouldUpdateGroupingOnNextResize = !1, this.view = e, this.viewChildren = e.children, this.viewFocusables = e.focusables, this.viewItemsView = e.itemsView, this.viewFocusTracker = e.focusTracker, this.viewLocale = e.locale, this.ungroupedItems = e.createCollection(), this.groupedItems = e.createCollection(), this.groupedItemsDropdown = this._createGroupedItemsDropdown(), e.itemsView.children.bindTo(this.ungroupedItems).using((t) => t), this.ungroupedItems.on("change", this._updateFocusCyclableItems.bind(this)), e.children.on("change", this._updateFocusCyclableItems.bind(this)), e.items.on("change", (t, n) => {
      const s = n.index, o = Array.from(n.added);
      for (const r of n.removed)
        s >= this.ungroupedItems.length ? this.groupedItems.remove(r) : this.ungroupedItems.remove(r);
      for (let r = s; r < s + o.length; r++) {
        const a = o[r - s];
        r > this.ungroupedItems.length ? this.groupedItems.add(a, r - this.ungroupedItems.length) : this.ungroupedItems.add(a, r);
      }
      this._updateGrouping();
    }), e.extendTemplate({
      attributes: {
        class: [
          // To group items dynamically, the toolbar needs a dedicated CSS class.
          "ck-toolbar_grouping"
        ]
      }
    });
  }
  /**
   * Enables dynamic items grouping based on the dimensions of the toolbar.
   *
   * @param view An instance of the toolbar that this behavior is added to.
   */
  render(e) {
    this.viewElement = e.element, this._enableGroupingOnResize(), this._enableGroupingOnMaxWidthChange(e);
  }
  /**
   * Cleans up the internals used by this behavior.
   */
  destroy() {
    this.groupedItemsDropdown.destroy(), this.resizeObserver.destroy();
  }
  /**
   * When called, it will check if any of the {@link #ungroupedItems} do not fit into a single row of the toolbar,
   * and it will move them to the {@link #groupedItems} when it happens.
   *
   * At the same time, it will also check if there is enough space in the toolbar for the first of the
   * {@link #groupedItems} to be returned back to {@link #ungroupedItems} and still fit into a single row
   * without the toolbar wrapping.
   */
  _updateGrouping() {
    if (!this.viewElement.ownerDocument.body.contains(this.viewElement))
      return;
    if (!mn(this.viewElement)) {
      this.shouldUpdateGroupingOnNextResize = !0;
      return;
    }
    const e = this.groupedItems.length;
    let t;
    for (; this._areItemsOverflowing; )
      this._groupLastItem(), t = !0;
    if (!t && this.groupedItems.length) {
      for (; this.groupedItems.length && !this._areItemsOverflowing; )
        this._ungroupFirstItem();
      this._areItemsOverflowing && this._groupLastItem();
    }
    this.groupedItems.length !== e && this.view.fire("groupedItemsUpdate");
  }
  /**
   * Returns `true` when {@link module:ui/toolbar/toolbarview~ToolbarView#element} children visually overflow,
   * for instance if the toolbar is narrower than its members. Returns `false` otherwise.
   */
  get _areItemsOverflowing() {
    if (!this.ungroupedItems.length)
      return !1;
    const e = this.viewElement, t = this.viewLocale.uiLanguageDirection, n = new B(e.lastChild), s = new B(e);
    if (!this.cachedPadding) {
      const o = E.window.getComputedStyle(e), r = t === "ltr" ? "paddingRight" : "paddingLeft";
      this.cachedPadding = Number.parseInt(o[r]);
    }
    return t === "ltr" ? n.right > s.right - this.cachedPadding : n.left < s.left + this.cachedPadding;
  }
  /**
   * Enables the functionality that prevents {@link #ungroupedItems} from overflowing (wrapping to the next row)
   * upon resize when there is little space available. Instead, the toolbar items are moved to the
   * {@link #groupedItems} collection and displayed in a dropdown at the end of the row (which has its own nested toolbar).
   *
   * When called, the toolbar will automatically analyze the location of its {@link #ungroupedItems} and "group"
   * them in the dropdown if necessary. It will also observe the browser window for size changes in
   * the future and respond to them by grouping more items or reverting already grouped back, depending
   * on the visual space available.
   */
  _enableGroupingOnResize() {
    let e;
    this.resizeObserver = new Y(this.viewElement, (t) => {
      (!e || e !== t.contentRect.width || this.shouldUpdateGroupingOnNextResize) && (this.shouldUpdateGroupingOnNextResize = !1, this._updateGrouping(), e = t.contentRect.width);
    }), this._updateGrouping();
  }
  /**
   * Enables the grouping functionality, just like {@link #_enableGroupingOnResize} but the difference is that
   * it listens to the changes of {@link module:ui/toolbar/toolbarview~ToolbarView#maxWidth} instead.
   */
  _enableGroupingOnMaxWidthChange(e) {
    e.on("change:maxWidth", () => {
      this._updateGrouping();
    });
  }
  /**
   * When called, it will remove the last item from {@link #ungroupedItems} and move it back
   * to the {@link #groupedItems} collection.
   *
   * The opposite of {@link #_ungroupFirstItem}.
   */
  _groupLastItem() {
    this.groupedItems.length || (this.viewChildren.add(new Og()), this.viewChildren.add(this.groupedItemsDropdown), this.viewFocusTracker.add(this.groupedItemsDropdown.element)), this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0);
  }
  /**
   * Moves the very first item belonging to {@link #groupedItems} back
   * to the {@link #ungroupedItems} collection.
   *
   * The opposite of {@link #_groupLastItem}.
   */
  _ungroupFirstItem() {
    this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first)), this.groupedItems.length || (this.viewChildren.remove(this.groupedItemsDropdown), this.viewChildren.remove(this.viewChildren.last), this.viewFocusTracker.remove(this.groupedItemsDropdown.element));
  }
  /**
   * Creates the {@link #groupedItemsDropdown} that hosts the members of the {@link #groupedItems}
   * collection when there is not enough space in the toolbar to display all items in a single row.
   */
  _createGroupedItemsDropdown() {
    const e = this.viewLocale, t = e.t, n = we(e);
    return n.class = "ck-toolbar__grouped-dropdown", n.panelPosition = e.uiLanguageDirection === "ltr" ? "sw" : "se", or(n, this.groupedItems), n.buttonView.set({
      label: t("Show more items"),
      tooltip: !0,
      tooltipPosition: e.uiLanguageDirection === "rtl" ? "se" : "sw",
      icon: A.threeVerticalDots
    }), n;
  }
  /**
   * Updates the {@link module:ui/toolbar/toolbarview~ToolbarView#focusables focus–cyclable items}
   * collection so it represents the up–to–date state of the UI from the perspective of the user.
   *
   * For instance, the {@link #groupedItemsDropdown} can show up and hide but when it is visible,
   * it must be subject to focus cycling in the toolbar.
   *
   * See the {@link module:ui/toolbar/toolbarview~ToolbarView#focusables collection} documentation
   * to learn more about the purpose of this method.
   */
  _updateFocusCyclableItems() {
    this.viewFocusables.clear(), this.ungroupedItems.map((e) => {
      bs(e) && this.viewFocusables.add(e);
    }), this.groupedItems.length && this.viewFocusables.add(this.groupedItemsDropdown);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ii extends T {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e);
    const t = this.bindTemplate;
    this.set("isVisible", !0), this.children = this.createCollection(), this.setTemplate({
      tag: "li",
      attributes: {
        class: [
          "ck",
          "ck-list__item",
          t.if("isVisible", "ck-hidden", (n) => !n)
        ],
        role: "presentation"
      },
      children: this.children
    });
  }
  /**
   * Focuses the list item.
   */
  focus() {
    this.children.first && this.children.first.focus();
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Il extends T {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.setTemplate({
      tag: "li",
      attributes: {
        class: [
          "ck",
          "ck-list__separator"
        ]
      }
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ro extends T {
  /**
   * Creates an instance of the list item group view class.
   *
   * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
   * @param labelView The instance of the group's label. If not provided, an instance of
   * {@link module:ui/label/labelview~LabelView} is used.
   */
  constructor(e, t = new ze()) {
    super(e);
    const n = this.bindTemplate, s = new Sl(e);
    this.set({
      label: "",
      isVisible: !0
    }), this.labelView = t, this.labelView.bind("text").to(this, "label"), this.children = this.createCollection(), this.children.addMany([this.labelView, s]), s.set({
      role: "group",
      ariaLabelledBy: t.id
    }), s.focusTracker.destroy(), s.keystrokes.destroy(), this.items = s.items, this.setTemplate({
      tag: "li",
      attributes: {
        role: "presentation",
        class: [
          "ck",
          "ck-list__group",
          n.if("isVisible", "ck-hidden", (o) => !o)
        ]
      },
      children: this.children
    });
  }
  /**
   * Focuses the list item (which is not a separator).
   */
  focus() {
    if (this.items) {
      const e = this.items.find((t) => !(t instanceof Il));
      e && e.focus();
    }
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Sl extends T {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this._listItemGroupToChangeListeners = /* @__PURE__ */ new WeakMap();
    const t = this.bindTemplate;
    this.focusables = new ve(), this.items = this.createCollection(), this.focusTracker = new X(), this.keystrokes = new ie(), this._focusCycler = new ge({
      focusables: this.focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate list items backwards using the arrowup key.
        focusPrevious: "arrowup",
        // Navigate toolbar items forwards using the arrowdown key.
        focusNext: "arrowdown"
      }
    }), this.set("ariaLabel", void 0), this.set("ariaLabelledBy", void 0), this.set("role", void 0), this.setTemplate({
      tag: "ul",
      attributes: {
        class: [
          "ck",
          "ck-reset",
          "ck-list"
        ],
        role: t.to("role"),
        "aria-label": t.to("ariaLabel"),
        "aria-labelledby": t.to("ariaLabelledBy")
      },
      children: this.items
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    for (const e of this.items)
      e instanceof ro ? this._registerFocusableItemsGroup(e) : e instanceof ii && this._registerFocusableListItem(e);
    this.items.on("change", (e, t) => {
      for (const n of t.removed)
        n instanceof ro ? this._deregisterFocusableItemsGroup(n) : n instanceof ii && this._deregisterFocusableListItem(n);
      for (const n of Array.from(t.added).reverse())
        n instanceof ro ? this._registerFocusableItemsGroup(n, t.index) : this._registerFocusableListItem(n, t.index);
    }), this.keystrokes.listenTo(this.element);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  /**
   * Focuses the first focusable in {@link #items}.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
   * Focuses the first focusable in {@link #items}.
   */
  focusFirst() {
    this._focusCycler.focusFirst();
  }
  /**
   * Focuses the last focusable in {@link #items}.
   */
  focusLast() {
    this._focusCycler.focusLast();
  }
  /**
   * Registers a list item view in the focus tracker.
   *
   * @param item The list item view to be registered.
   * @param index Index of the list item view in the {@link #items} collection. If not specified, the item will be added at the end.
   */
  _registerFocusableListItem(e, t) {
    this.focusTracker.add(e.element), this.focusables.add(e, t);
  }
  /**
   * Removes a list item view from the focus tracker.
   *
   * @param item The list item view to be removed.
   */
  _deregisterFocusableListItem(e) {
    this.focusTracker.remove(e.element), this.focusables.remove(e);
  }
  /**
   * Gets a callback that will be called when the `items` collection of a {@link module:ui/list/listitemgroupview~ListItemGroupView}
   * change.
   *
   * @param groupView The group view for which the callback will be created.
   * @returns The callback function to be used for the items `change` event listener in a group.
   */
  _getOnGroupItemsChangeCallback(e) {
    return (t, n) => {
      for (const s of n.removed)
        this._deregisterFocusableListItem(s);
      for (const s of Array.from(n.added).reverse())
        this._registerFocusableListItem(s, this.items.getIndex(e) + n.index);
    };
  }
  /**
   * Registers a list item group view (and its children) in the focus tracker.
   *
   * @param groupView A group view to be registered.
   * @param groupIndex Index of the group view in the {@link #items} collection. If not specified, the group will be added at the end.
   */
  _registerFocusableItemsGroup(e, t) {
    Array.from(e.items).forEach((s, o) => {
      const r = typeof t != "undefined" ? t + o : void 0;
      this._registerFocusableListItem(s, r);
    });
    const n = this._getOnGroupItemsChangeCallback(e);
    this._listItemGroupToChangeListeners.set(e, n), e.items.on("change", n);
  }
  /**
   * Removes a list item group view (and its children) from the focus tracker.
   *
   * @param groupView The group view to be removed.
   */
  _deregisterFocusableItemsGroup(e) {
    for (const t of e.items)
      this._deregisterFocusableListItem(t);
    e.items.off("change", this._listItemGroupToChangeListeners.get(e)), this._listItemGroupToChangeListeners.delete(e);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class sr extends T {
  /**
   * @inheritDoc
   */
  constructor(e, t) {
    super(e);
    const n = this.bindTemplate;
    this.set("class", void 0), this.set("labelStyle", void 0), this.set("icon", void 0), this.set("isEnabled", !0), this.set("isOn", !1), this.set("isToggleable", !1), this.set("isVisible", !0), this.set("keystroke", void 0), this.set("withKeystroke", !1), this.set("label", void 0), this.set("tabindex", -1), this.set("tooltip", !1), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", !1), this.children = this.createCollection(), this.actionView = this._createActionView(t), this.arrowView = this._createArrowView(), this.keystrokes = new ie(), this.focusTracker = new X(), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-splitbutton",
          n.to("class"),
          n.if("isVisible", "ck-hidden", (s) => !s),
          this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")
        ]
      },
      children: this.children
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.children.add(this.actionView), this.children.add(this.arrowView), this.focusTracker.add(this.actionView.element), this.focusTracker.add(this.arrowView.element), this.keystrokes.listenTo(this.element), this.keystrokes.set("arrowright", (e, t) => {
      this.focusTracker.focusedElement === this.actionView.element && (this.arrowView.focus(), t());
    }), this.keystrokes.set("arrowleft", (e, t) => {
      this.focusTracker.focusedElement === this.arrowView.element && (this.actionView.focus(), t());
    });
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  /**
   * Focuses the {@link module:ui/button/buttonview~ButtonView#element} of the action part of split button.
   */
  focus() {
    this.actionView.focus();
  }
  /**
   * Creates a {@link module:ui/button/buttonview~ButtonView} instance as {@link #actionView} and binds it with main split button
   * attributes.
   */
  _createActionView(e) {
    const t = e || new P();
    return e || t.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this), t.extendTemplate({
      attributes: {
        class: "ck-splitbutton__action"
      }
    }), t.delegate("execute").to(this), t;
  }
  /**
   * Creates a {@link module:ui/button/buttonview~ButtonView} instance as {@link #arrowView} and binds it with main split button
   * attributes.
   */
  _createArrowView() {
    const e = new P(), t = e.bindTemplate;
    return e.icon = ir, e.extendTemplate({
      attributes: {
        class: [
          "ck-splitbutton__arrow"
        ],
        "data-cke-tooltip-disabled": t.to("isOn"),
        "aria-haspopup": !0,
        "aria-expanded": t.to("isOn", (n) => String(n))
      }
    }), e.bind("isEnabled").to(this), e.bind("label").to(this), e.bind("tooltip").to(this), e.delegate("execute").to(this, "open"), e;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function we(i, e = xl) {
  const t = typeof e == "function" ? new e(i) : e, n = new dx(i), s = new ti(i, t, n);
  return t.bind("isEnabled").to(s), t instanceof sr ? t.arrowView.bind("isOn").to(s, "isOpen") : t.bind("isOn").to(s, "isOpen"), _x(s), s;
}
function or(i, e, t = {}) {
  i.extendTemplate({
    attributes: {
      class: ["ck-toolbar-dropdown"]
    }
  }), i.isOpen ? ed(i, e, t) : i.once("change:isOpen", () => ed(i, e, t), { priority: "highest" }), t.enableActiveItemFocusOnDropdownOpen && Pl(i, () => i.toolbarView.items.find((n) => n.isOn));
}
function ed(i, e, t) {
  const n = i.locale, s = n.t, o = i.toolbarView = new ni(n), r = typeof e == "function" ? e() : e;
  o.ariaLabel = t.ariaLabel || s("Dropdown toolbar"), t.maxWidth && (o.maxWidth = t.maxWidth), t.class && (o.class = t.class), t.isCompact && (o.isCompact = t.isCompact), t.isVertical && (o.isVertical = !0), r instanceof ve ? o.items.bindTo(r).using((a) => a) : o.items.addMany(r), i.panelView.children.add(o), o.items.delegate("execute").to(i);
}
function Kt(i, e, t = {}) {
  i.isOpen ? td(i, e, t) : i.once("change:isOpen", () => td(i, e, t), { priority: "highest" }), Pl(i, () => i.listView.items.find((n) => n instanceof ii ? n.children.first.isOn : !1));
}
function td(i, e, t) {
  const n = i.locale, s = i.listView = new Sl(n), o = typeof e == "function" ? e() : e;
  s.ariaLabel = t.ariaLabel, s.role = t.role, Ng(i, s.items, o, n), i.panelView.children.add(s), s.items.delegate("execute").to(i);
}
function Pl(i, e) {
  i.on("change:isOpen", () => {
    if (!i.isOpen)
      return;
    const t = e();
    t && (typeof t.focus == "function" ? t.focus() : D("ui-dropdown-focus-child-on-open-child-missing-focus", { view: t }));
  }, { priority: Ht.low - 10 });
}
function _x(i) {
  vx(i), yx(i), Cx(i), kx(i), Tx(i), Ex(i);
}
function vx(i) {
  i.on("render", () => {
    yn({
      emitter: i,
      activator: () => i.isOpen,
      callback: () => {
        i.isOpen = !1;
      },
      contextElements: () => [
        i.element,
        ...i.focusTracker._elements
      ]
    });
  });
}
function yx(i) {
  i.on("execute", (e) => {
    e.source instanceof nr || (i.isOpen = !1);
  });
}
function Cx(i) {
  i.focusTracker.on("change:isFocused", (e, t, n) => {
    i.isOpen && !n && (i.isOpen = !1);
  });
}
function kx(i) {
  i.keystrokes.set("arrowdown", (e, t) => {
    i.isOpen && (i.panelView.focus(), t());
  }), i.keystrokes.set("arrowup", (e, t) => {
    i.isOpen && (i.panelView.focusLast(), t());
  });
}
function Tx(i) {
  i.on("change:isOpen", (e, t, n) => {
    if (n)
      return;
    const s = i.panelView.element;
    s && s.contains(E.document.activeElement) && i.buttonView.focus();
  });
}
function Ex(i) {
  i.on("change:isOpen", (e, t, n) => {
    n && i.panelView.focus();
  }, { priority: "low" });
}
function Ng(i, e, t, n) {
  e.bindTo(t).using((s) => {
    if (s.type === "separator")
      return new Il(n);
    if (s.type === "group") {
      const o = new ro(n);
      return o.set({ label: s.label }), Ng(i, o.items, s.items, n), o.items.delegate("execute").to(i), o;
    } else if (s.type === "button" || s.type === "switchbutton") {
      const o = new ii(n);
      let r;
      return s.type === "button" ? (r = new P(n), r.bind("ariaChecked").to(r, "isOn")) : r = new nr(n), r.bind(...Object.keys(s.model)).to(s.model), r.delegate("execute").to(o), o.children.add(r), o;
    }
    return null;
  });
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const He = (i, e, t) => {
  const n = new Lg(i.locale);
  return n.set({
    id: e,
    ariaDescribedById: t
  }), n.bind("isReadOnly").to(i, "isEnabled", (s) => !s), n.bind("hasError").to(i, "errorText", (s) => !!s), n.on("input", () => {
    i.errorText = null;
  }), i.bind("isEmpty", "isFocused", "placeholder").to(n), n;
}, Ax = (i, e, t) => {
  const n = new ux(i.locale);
  return n.set({
    id: e,
    ariaDescribedById: t,
    inputMode: "numeric"
  }), n.bind("isReadOnly").to(i, "isEnabled", (s) => !s), n.bind("hasError").to(i, "errorText", (s) => !!s), n.on("input", () => {
    i.errorText = null;
  }), i.bind("isEmpty", "isFocused", "placeholder").to(n), n;
}, Dg = (i, e, t) => {
  const n = we(i.locale);
  return n.set({
    id: e,
    ariaDescribedById: t
  }), n.bind("isEnabled").to(i), n;
}, as = (i, e = 0, t = 1) => i > t ? t : i < e ? e : i, ye = (i, e = 0, t = Math.pow(10, e)) => Math.round(t * i) / t, xx = (i) => Vx(wa(i)), wa = (i) => (i[0] === "#" && (i = i.substring(1)), i.length < 6 ? {
  r: parseInt(i[0] + i[0], 16),
  g: parseInt(i[1] + i[1], 16),
  b: parseInt(i[2] + i[2], 16),
  a: i.length === 4 ? ye(parseInt(i[3] + i[3], 16) / 255, 2) : 1
} : {
  r: parseInt(i.substring(0, 2), 16),
  g: parseInt(i.substring(2, 4), 16),
  b: parseInt(i.substring(4, 6), 16),
  a: i.length === 8 ? ye(parseInt(i.substring(6, 8), 16) / 255, 2) : 1
}), Ix = (i) => Rx(Px(i)), Sx = ({ h: i, s: e, v: t, a: n }) => {
  const s = (200 - e) * t / 100;
  return {
    h: ye(i),
    s: ye(s > 0 && s < 200 ? e * t / 100 / (s <= 100 ? s : 200 - s) * 100 : 0),
    l: ye(s / 2),
    a: ye(n, 2)
  };
}, _a = (i) => {
  const { h: e, s: t, l: n } = Sx(i);
  return `hsl(${e}, ${t}%, ${n}%)`;
}, Px = ({ h: i, s: e, v: t, a: n }) => {
  i = i / 360 * 6, e = e / 100, t = t / 100;
  const s = Math.floor(i), o = t * (1 - e), r = t * (1 - (i - s) * e), a = t * (1 - (1 - i + s) * e), l = s % 6;
  return {
    r: ye([t, r, o, o, a, t][l] * 255),
    g: ye([a, t, t, r, o, o][l] * 255),
    b: ye([o, o, a, t, t, r][l] * 255),
    a: ye(n, 2)
  };
}, Fs = (i) => {
  const e = i.toString(16);
  return e.length < 2 ? "0" + e : e;
}, Rx = ({ r: i, g: e, b: t, a: n }) => {
  const s = n < 1 ? Fs(ye(n * 255)) : "";
  return "#" + Fs(i) + Fs(e) + Fs(t) + s;
}, Vx = ({ r: i, g: e, b: t, a: n }) => {
  const s = Math.max(i, e, t), o = s - Math.min(i, e, t), r = o ? s === i ? (e - t) / o : s === e ? 2 + (t - i) / o : 4 + (i - e) / o : 0;
  return {
    h: ye(60 * (r < 0 ? r + 6 : r)),
    s: ye(s ? o / s * 100 : 0),
    v: ye(s / 255 * 100),
    a: n
  };
}, zg = (i, e) => {
  if (i === e)
    return !0;
  for (const t in i)
    if (i[t] !== e[t])
      return !1;
  return !0;
}, Mx = (i, e) => i.toLowerCase() === e.toLowerCase() ? !0 : zg(wa(i), wa(e)), nd = {}, Hg = (i) => {
  let e = nd[i];
  return e || (e = document.createElement("template"), e.innerHTML = i, nd[i] = e), e;
}, Rl = (i, e, t) => {
  i.dispatchEvent(new CustomEvent(e, {
    bubbles: !0,
    detail: t
  }));
};
let Zn = !1;
const va = (i) => "touches" in i, Bx = (i) => Zn && !va(i) ? !1 : (Zn || (Zn = va(i)), !0), id = (i, e) => {
  const t = va(e) ? e.touches[0] : e, n = i.el.getBoundingClientRect();
  Rl(i.el, "move", i.getMove({
    x: as((t.pageX - (n.left + window.pageXOffset)) / n.width),
    y: as((t.pageY - (n.top + window.pageYOffset)) / n.height)
  }));
}, Lx = (i, e) => {
  const t = e.keyCode;
  t > 40 || i.xy && t < 37 || t < 33 || (e.preventDefault(), Rl(i.el, "move", i.getMove({
    x: t === 39 ? 0.01 : t === 37 ? -0.01 : t === 34 ? 0.05 : t === 33 ? -0.05 : t === 35 ? 1 : t === 36 ? -1 : 0,
    y: t === 40 ? 0.01 : t === 38 ? -0.01 : 0
  }, !0)));
};
class Ug {
  constructor(e, t, n, s) {
    const o = Hg(`<div role="slider" tabindex="0" part="${t}" ${n}><div part="${t}-pointer"></div></div>`);
    e.appendChild(o.content.cloneNode(!0));
    const r = e.querySelector(`[part=${t}]`);
    r.addEventListener("mousedown", this), r.addEventListener("touchstart", this), r.addEventListener("keydown", this), this.el = r, this.xy = s, this.nodes = [r.firstChild, r];
  }
  set dragging(e) {
    const t = e ? document.addEventListener : document.removeEventListener;
    t(Zn ? "touchmove" : "mousemove", this), t(Zn ? "touchend" : "mouseup", this);
  }
  handleEvent(e) {
    switch (e.type) {
      case "mousedown":
      case "touchstart":
        if (e.preventDefault(), !Bx(e) || !Zn && e.button != 0)
          return;
        this.el.focus(), id(this, e), this.dragging = !0;
        break;
      case "mousemove":
      case "touchmove":
        e.preventDefault(), id(this, e);
        break;
      case "mouseup":
      case "touchend":
        this.dragging = !1;
        break;
      case "keydown":
        Lx(this, e);
        break;
    }
  }
  style(e) {
    e.forEach((t, n) => {
      for (const s in t)
        this.nodes[n].style.setProperty(s, t[s]);
    });
  }
}
class Ox extends Ug {
  constructor(e) {
    super(e, "hue", 'aria-label="Hue" aria-valuemin="0" aria-valuemax="360"', !1);
  }
  update({ h: e }) {
    this.h = e, this.style([
      {
        left: `${e / 360 * 100}%`,
        color: _a({ h: e, s: 100, v: 100, a: 1 })
      }
    ]), this.el.setAttribute("aria-valuenow", `${ye(e)}`);
  }
  getMove(e, t) {
    return { h: t ? as(this.h + e.x * 360, 0, 360) : 360 * e.x };
  }
}
class Fx extends Ug {
  constructor(e) {
    super(e, "saturation", 'aria-label="Color"', !0);
  }
  update(e) {
    this.hsva = e, this.style([
      {
        top: `${100 - e.v}%`,
        left: `${e.s}%`,
        color: _a(e)
      },
      {
        "background-color": _a({ h: e.h, s: 100, v: 100, a: 1 })
      }
    ]), this.el.setAttribute("aria-valuetext", `Saturation ${ye(e.s)}%, Brightness ${ye(e.v)}%`);
  }
  getMove(e, t) {
    return {
      s: t ? as(this.hsva.s + e.x * 100, 0, 100) : e.x * 100,
      v: t ? as(this.hsva.v - e.y * 100, 0, 100) : Math.round(100 - e.y * 100)
    };
  }
}
const Nx = ':host{display:flex;flex-direction:column;position:relative;width:200px;height:200px;user-select:none;-webkit-user-select:none;cursor:default}:host([hidden]){display:none!important}[role=slider]{position:relative;touch-action:none;user-select:none;-webkit-user-select:none;outline:0}[role=slider]:last-child{border-radius:0 0 8px 8px}[part$=pointer]{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;display:flex;place-content:center center;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}[part$=pointer]::after{content:"";width:100%;height:100%;border-radius:inherit;background-color:currentColor}[role=slider]:focus [part$=pointer]{transform:translate(-50%,-50%) scale(1.1)}', Dx = "[part=hue]{flex:0 0 24px;background:linear-gradient(to right,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red 100%)}[part=hue-pointer]{top:50%;z-index:2}", zx = "[part=saturation]{flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(to top,#000,transparent),linear-gradient(to right,#fff,rgba(255,255,255,0));box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}[part=saturation-pointer]{z-index:3}", Ns = Symbol("same"), Rr = Symbol("color"), sd = Symbol("hsva"), Vr = Symbol("update"), od = Symbol("parts"), rd = Symbol("css"), ad = Symbol("sliders");
class Hx extends HTMLElement {
  static get observedAttributes() {
    return ["color"];
  }
  get [rd]() {
    return [Nx, Dx, zx];
  }
  get [ad]() {
    return [Fx, Ox];
  }
  get color() {
    return this[Rr];
  }
  set color(e) {
    if (!this[Ns](e)) {
      const t = this.colorModel.toHsva(e);
      this[Vr](t), this[Rr] = e;
    }
  }
  constructor() {
    super();
    const e = Hg(`<style>${this[rd].join("")}</style>`), t = this.attachShadow({ mode: "open" });
    t.appendChild(e.content.cloneNode(!0)), t.addEventListener("move", this), this[od] = this[ad].map((n) => new n(t));
  }
  connectedCallback() {
    if (this.hasOwnProperty("color")) {
      const e = this.color;
      delete this.color, this.color = e;
    } else this.color || (this.color = this.colorModel.defaultColor);
  }
  attributeChangedCallback(e, t, n) {
    const s = this.colorModel.fromAttr(n);
    this[Ns](s) || (this.color = s);
  }
  handleEvent(e) {
    const t = this[sd], n = { ...t, ...e.detail };
    this[Vr](n);
    let s;
    !zg(n, t) && !this[Ns](s = this.colorModel.fromHsva(n)) && (this[Rr] = s, Rl(this, "color-changed", { value: s }));
  }
  [Ns](e) {
    return this.color && this.colorModel.equal(e, this.color);
  }
  [Vr](e) {
    this[sd] = e, this[od].forEach((t) => t.update(e));
  }
}
const Ux = {
  defaultColor: "#000",
  toHsva: xx,
  fromHsva: ({ h: i, s: e, v: t }) => Ix({ h: i, s: e, v: t, a: 1 }),
  equal: Mx,
  fromAttr: (i) => i
};
class $x extends Hx {
  get colorModel() {
    return Ux;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Wx = 150;
class qx extends T {
  /**
   * Creates a view of color picker.
   *
   * @param locale
   * @param config
   */
  constructor(e, t = {}) {
    super(e), this.set({
      color: "",
      _hexColor: ""
    }), this.hexInputRow = this._createInputRow();
    const n = this.createCollection();
    t.hideInput || n.add(this.hexInputRow), this.setTemplate({
      tag: "div",
      attributes: {
        class: ["ck", "ck-color-picker"],
        tabindex: -1
      },
      children: n
    }), this._config = t, this._debounceColorPickerEvent = Pt((s) => {
      this.set("color", s), this.fire("colorSelected", { color: this.color });
    }, Wx, {
      leading: !0
    }), this.on("set:color", (s, o, r) => {
      s.return = Vg(r, this._config.format || "hsl");
    }), this.on("change:color", () => {
      this._hexColor = Mr(this.color);
    }), this.on("change:_hexColor", () => {
      document.activeElement !== this.picker && this.picker.setAttribute("color", this._hexColor), Mr(this.color) != Mr(this._hexColor) && (this.color = this._hexColor);
    });
  }
  /**
   * Renders color picker in the view.
   */
  render() {
    if (super.render(), ox("hex-color-picker", $x), this.picker = E.document.createElement("hex-color-picker"), this.picker.setAttribute("class", "hex-color-picker"), this.picker.setAttribute("tabindex", "-1"), this._createSlidersView(), this.element) {
      this.hexInputRow.element ? this.element.insertBefore(this.picker, this.hexInputRow.element) : this.element.appendChild(this.picker);
      const e = document.createElement("style");
      e.textContent = '[role="slider"]:focus [part$="pointer"] {border: 1px solid #fff;outline: 1px solid var(--ck-color-focus-border);box-shadow: 0 0 0 2px #fff;}', this.picker.shadowRoot.appendChild(e);
    }
    this.picker.addEventListener("color-changed", (e) => {
      const t = e.detail.value;
      this._debounceColorPickerEvent(t);
    });
  }
  /**
   * Focuses the first pointer in color picker.
   *
   */
  focus() {
    /* istanbul ignore next -- @preserve */
    !this._config.hideInput && (M.isGecko || M.isiOS || M.isSafari) && this.hexInputRow.children.get(1).focus(), this.slidersView.first.focus();
  }
  /**
   * Creates collection of sliders in color picker.
   *
   * @private
   */
  _createSlidersView() {
    const n = [...this.picker.shadowRoot.children].filter((s) => s.getAttribute("role") === "slider").map((s) => new Gx(s));
    this.slidersView = this.createCollection(), n.forEach((s) => {
      this.slidersView.add(s);
    });
  }
  /**
   * Creates input row for defining custom colors in color picker.
   *
   * @private
   */
  _createInputRow() {
    const e = this._createColorInput();
    return new Kx(this.locale, e);
  }
  /**
   * Creates the input where user can type or paste the color in hex format.
   *
   * @private
   */
  _createColorInput() {
    const e = new ue(this.locale, He), { t } = this.locale;
    return e.set({
      label: t("HEX"),
      class: "color-picker-hex-input"
    }), e.fieldView.bind("value").to(this, "_hexColor", (n) => e.isFocused ? e.fieldView.value : n.startsWith("#") ? n.substring(1) : n), e.fieldView.on("input", () => {
      const n = e.fieldView.element.value;
      if (n) {
        const s = $g(n);
        s && this._debounceColorPickerEvent(s);
      }
    }), e;
  }
  /**
   * Validates the view and returns `false` when some fields are invalid.
   */
  isValid() {
    const { t: e } = this.locale;
    return this.resetValidationStatus(), this.hexInputRow.getParsedColor() ? !0 : (this.hexInputRow.inputView.errorText = e('Please enter a valid color (e.g. "ff0000").'), !1);
  }
  /**
   * Cleans up the supplementary error and information text of input inside the {@link #hexInputRow}
   * bringing them back to the state when the form has been displayed for the first time.
   *
   * See {@link #isValid}.
   */
  resetValidationStatus() {
    this.hexInputRow.inputView.errorText = null;
  }
}
function Mr(i) {
  let e = sx(i);
  return e || (e = "#000"), e.length === 4 && (e = "#" + [e[1], e[1], e[2], e[2], e[3], e[3]].join("")), e.toLowerCase();
}
class Gx extends T {
  /**
   * @param element HTML element of slider in color picker.
   */
  constructor(e) {
    super(), this.element = e;
  }
  /**
   * Focuses element.
   */
  focus() {
    this.element.focus();
  }
}
class jx extends T {
  constructor(e) {
    super(e), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-color-picker__hash-view"
        ]
      },
      children: "#"
    });
  }
}
class Kx extends T {
  /**
   * Creates an instance of the form row class.
   *
   * @param locale The locale instance.
   * @param inputView Hex color input element.
   */
  constructor(e, t) {
    super(e), this.inputView = t, this.children = this.createCollection([
      new jx(),
      this.inputView
    ]), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-color-picker__row"
        ]
      },
      children: this.children
    });
  }
  /**
   * Returns false if color input value is not in hex format.
   */
  getParsedColor() {
    return $g(this.inputView.fieldView.element.value);
  }
}
function $g(i) {
  if (!i)
    return null;
  const e = i.trim().replace(/^#/, "");
  return ![3, 4, 6, 8].includes(e.length) || !/^(([0-9a-fA-F]{2}){3,4}|([0-9a-fA-F]){3,4})$/.test(e) ? null : `#${e}`;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Zx extends U(ke) {
  constructor(e) {
    super(e), this.set("isEmpty", !0), this.on("change", () => {
      this.set("isEmpty", this.length === 0);
    });
  }
  /**
   * Adds a color to the document color collection.
   *
   * This method ensures that no color duplicates are inserted (compared using
   * the color value of the {@link module:ui/colorgrid/colorgridview~ColorDefinition}).
   *
   * If the item does not have an ID, it will be automatically generated and set on the item.
   *
   * @param index The position of the item in the collection. The item is pushed to the collection when `index` is not specified.
   * @fires add
   * @fires change
   */
  add(e, t) {
    return this.find((n) => n.color === e.color) ? this : super.add(e, t);
  }
  /**
   * Checks if an object with given colors is present in the document color collection.
   */
  hasColor(e) {
    return !!this.find((t) => t.color === e);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const { eraser: Jx, colorPalette: Xx } = A;
class Qx extends T {
  /**
   * Creates an instance of the view.
   *
   * @param locale The localization services instance.
   * @param colors An array with definitions of colors to be displayed in the table.
   * @param columns The number of columns in the color grid.
   * @param removeButtonLabel The label of the button responsible for removing the color.
   * @param colorPickerLabel The label of the button responsible for color picker appearing.
   * @param documentColorsLabel The label for the section with the document colors.
   * @param documentColorsCount The number of colors in the document colors section inside the color dropdown.
   * @param focusTracker Tracks information about the DOM focus in the list.
   * @param focusables A collection of views that can be focused in the view.
   */
  constructor(e, { colors: t, columns: n, removeButtonLabel: s, documentColorsLabel: o, documentColorsCount: r, colorPickerLabel: a, focusTracker: l, focusables: c }) {
    super(e);
    const u = this.bindTemplate;
    this.set("isVisible", !0), this.focusTracker = l, this.items = this.createCollection(), this.colorDefinitions = t, this.columns = n, this.documentColors = new Zx(), this.documentColorsCount = r, this._focusables = c, this._removeButtonLabel = s, this._colorPickerLabel = a, this._documentColorsLabel = o, this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck-color-grids-fragment",
          u.if("isVisible", "ck-hidden", (d) => !d)
        ]
      },
      children: this.items
    }), this.removeColorButtonView = this._createRemoveColorButton(), this.items.add(this.removeColorButtonView);
  }
  /**
   * Scans through the editor model and searches for text node attributes with the given attribute name.
   * Found entries are set as document colors.
   *
   * All the previously stored document colors will be lost in the process.
   *
   * @param model The model used as a source to obtain the document colors.
   * @param attributeName Determines the name of the related model's attribute for a given dropdown.
   */
  updateDocumentColors(e, t) {
    const n = e.document, s = this.documentColorsCount;
    this.documentColors.clear();
    for (const o of n.getRoots()) {
      const r = e.createRangeIn(o);
      for (const a of r.getItems())
        if (a.is("$textProxy") && a.hasAttribute(t) && (this._addColorToDocumentColors(a.getAttribute(t)), this.documentColors.length >= s))
          return;
    }
  }
  /**
   * Refreshes the state of the selected color in one or both {@link module:ui/colorgrid/colorgridview~ColorGridView}s
   * available in the {@link module:ui/colorselector/colorselectorview~ColorSelectorView}. It guarantees that the selection will
   * occur only in one of them.
   */
  updateSelectedColors() {
    const e = this.documentColorsGrid, t = this.staticColorsGrid, n = this.selectedColor;
    t.selectedColor = n, e && (e.selectedColor = n);
  }
  /**
   * @inheritDoc
   */
  render() {
    if (super.render(), this.staticColorsGrid = this._createStaticColorsGrid(), this.items.add(this.staticColorsGrid), this.documentColorsCount) {
      const e = Me.bind(this.documentColors, this.documentColors), t = new ze(this.locale);
      t.text = this._documentColorsLabel, t.extendTemplate({
        attributes: {
          class: [
            "ck",
            "ck-color-grid__label",
            e.if("isEmpty", "ck-hidden")
          ]
        }
      }), this.items.add(t), this.documentColorsGrid = this._createDocumentColorsGrid(), this.items.add(this.documentColorsGrid);
    }
    this._createColorPickerButton(), this._addColorSelectorElementsToFocusTracker();
  }
  /**
   * Focuses the component.
   */
  focus() {
    this.removeColorButtonView.focus();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
  }
  /**
   * Handles displaying the color picker button (if it was previously created) and making it focusable.
   */
  addColorPickerButton() {
    this.colorPickerButtonView && (this.items.add(this.colorPickerButtonView), this.focusTracker.add(this.colorPickerButtonView.element), this._focusables.add(this.colorPickerButtonView));
  }
  /**
   * Adds color selector elements to focus tracker.
   */
  _addColorSelectorElementsToFocusTracker() {
    this.focusTracker.add(this.removeColorButtonView.element), this._focusables.add(this.removeColorButtonView), this.staticColorsGrid && (this.focusTracker.add(this.staticColorsGrid.element), this._focusables.add(this.staticColorsGrid)), this.documentColorsGrid && (this.focusTracker.add(this.documentColorsGrid.element), this._focusables.add(this.documentColorsGrid));
  }
  /**
   * Creates the button responsible for displaying the color picker component.
   */
  _createColorPickerButton() {
    this.colorPickerButtonView = new P(), this.colorPickerButtonView.set({
      label: this._colorPickerLabel,
      withText: !0,
      icon: Xx,
      class: "ck-color-selector__color-picker"
    }), this.colorPickerButtonView.on("execute", () => {
      this.fire("colorPicker:show");
    });
  }
  /**
   * Adds the remove color button as a child of the current view.
   */
  _createRemoveColorButton() {
    const e = new P();
    return e.set({
      withText: !0,
      icon: Jx,
      label: this._removeButtonLabel
    }), e.class = "ck-color-selector__remove-color", e.on("execute", () => {
      this.fire("execute", {
        value: null,
        source: "removeColorButton"
      });
    }), e.render(), e;
  }
  /**
   * Creates a static color grid based on the editor configuration.
   */
  _createStaticColorsGrid() {
    const e = new Ju(this.locale, {
      colorDefinitions: this.colorDefinitions,
      columns: this.columns
    });
    return e.on("execute", (t, n) => {
      this.fire("execute", {
        value: n.value,
        source: "staticColorsGrid"
      });
    }), e;
  }
  /**
   * Creates the document colors section view and binds it to {@link #documentColors}.
   */
  _createDocumentColorsGrid() {
    const e = Me.bind(this.documentColors, this.documentColors), t = new Ju(this.locale, {
      columns: this.columns
    });
    return t.extendTemplate({
      attributes: {
        class: e.if("isEmpty", "ck-hidden")
      }
    }), t.items.bindTo(this.documentColors).using((n) => {
      const s = new Eg();
      return s.set({
        color: n.color,
        hasBorder: n.options && n.options.hasBorder
      }), n.label && s.set({
        label: n.label,
        tooltip: !0
      }), s.on("execute", () => {
        this.fire("execute", {
          value: n.color,
          source: "documentColorsGrid"
        });
      }), s;
    }), this.documentColors.on("change:isEmpty", (n, s, o) => {
      o && (t.selectedColor = null);
    }), t;
  }
  /**
   * Adds a given color to the document colors list. If possible, the method will attempt to use
   * data from the {@link #colorDefinitions} (label, color options).
   *
   * @param color A string that stores the value of the recently applied color.
   */
  _addColorToDocumentColors(e) {
    const t = this.colorDefinitions.find((n) => n.color === e);
    t ? this.documentColors.add(Object.assign({}, t)) : this.documentColors.add({
      color: e,
      label: e,
      options: {
        hasBorder: !1
      }
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Yx extends T {
  /**
   * Creates an instance of the view.
   *
   * @param locale The localization services instance.
   * @param focusTracker Tracks information about the DOM focus in the list.
   * @param focusables A collection of views that can be focused in the view..
   * @param keystrokes An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
   * @param colorPickerViewConfig The configuration of color picker feature. If set to `false`, the color picker
   * will not be rendered.
   */
  constructor(e, { focusTracker: t, focusables: n, keystrokes: s, colorPickerViewConfig: o }) {
    super(e), this.items = this.createCollection(), this.focusTracker = t, this.keystrokes = s, this.set("isVisible", !1), this.set("selectedColor", void 0), this._focusables = n, this._colorPickerViewConfig = o;
    const r = this.bindTemplate, { saveButtonView: a, cancelButtonView: l } = this._createActionButtons();
    this.saveButtonView = a, this.cancelButtonView = l, this.actionBarView = this._createActionBarView({ saveButtonView: a, cancelButtonView: l }), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck-color-picker-fragment",
          r.if("isVisible", "ck-hidden", (c) => !c)
        ]
      },
      children: this.items
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    const e = new qx(this.locale, {
      ...this._colorPickerViewConfig
    });
    this.colorPickerView = e, this.colorPickerView.render(), this.selectedColor && (e.color = this.selectedColor), this.listenTo(this, "change:selectedColor", (t, n, s) => {
      e.color = s;
    }), this.items.add(this.colorPickerView), this.items.add(this.actionBarView), this._addColorPickersElementsToFocusTracker(), this._stopPropagationOnArrowsKeys(), this._executeOnEnterPress(), this._executeUponColorChange();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
  }
  /**
   * Focuses the color picker.
   */
  focus() {
    this.colorPickerView.focus();
  }
  /**
   * Reset validation messages.
   */
  resetValidationStatus() {
    this.colorPickerView.resetValidationStatus();
  }
  /**
   * When color picker is focused and "enter" is pressed it executes command.
   */
  _executeOnEnterPress() {
    this.keystrokes.set("enter", (e) => {
      this.isVisible && this.focusTracker.focusedElement !== this.cancelButtonView.element && this.colorPickerView.isValid() && (this.fire("execute", {
        value: this.selectedColor
      }), e.stopPropagation(), e.preventDefault());
    });
  }
  /**
   * Removes default behavior of arrow keys in dropdown.
   */
  _stopPropagationOnArrowsKeys() {
    const e = (t) => t.stopPropagation();
    this.keystrokes.set("arrowright", e), this.keystrokes.set("arrowleft", e), this.keystrokes.set("arrowup", e), this.keystrokes.set("arrowdown", e);
  }
  /**
   * Adds color picker elements to focus tracker.
   */
  _addColorPickersElementsToFocusTracker() {
    for (const t of this.colorPickerView.slidersView)
      this.focusTracker.add(t.element), this._focusables.add(t);
    const e = this.colorPickerView.hexInputRow.children.get(1);
    e.element && (this.focusTracker.add(e.element), this._focusables.add(e)), this.focusTracker.add(this.saveButtonView.element), this._focusables.add(this.saveButtonView), this.focusTracker.add(this.cancelButtonView.element), this._focusables.add(this.cancelButtonView);
  }
  /**
   * Creates bar containing "Save" and "Cancel" buttons.
   */
  _createActionBarView({ saveButtonView: e, cancelButtonView: t }) {
    const n = new T(), s = this.createCollection();
    return s.add(e), s.add(t), n.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-color-selector_action-bar"
        ]
      },
      children: s
    }), n;
  }
  /**
   * Creates "Save" and "Cancel" buttons.
   */
  _createActionButtons() {
    const e = this.locale, t = e.t, n = new P(e), s = new P(e);
    return n.set({
      icon: A.check,
      class: "ck-button-save",
      type: "button",
      withText: !1,
      label: t("Accept")
    }), s.set({
      icon: A.cancel,
      class: "ck-button-cancel",
      type: "button",
      withText: !1,
      label: t("Cancel")
    }), n.on("execute", () => {
      this.colorPickerView.isValid() && this.fire("execute", {
        source: "colorPickerSaveButton",
        value: this.selectedColor
      });
    }), s.on("execute", () => {
      this.fire("colorPicker:cancel");
    }), {
      saveButtonView: n,
      cancelButtonView: s
    };
  }
  /**
   * Fires the `execute` event if color in color picker has been changed
   * by the user.
   */
  _executeUponColorChange() {
    this.colorPickerView.on("colorSelected", (e, t) => {
      this.fire("execute", {
        value: t.color,
        source: "colorPicker"
      }), this.set("selectedColor", t.color);
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Vl extends T {
  /**
   * Creates a view to be inserted as a child of {@link module:ui/dropdown/dropdownview~DropdownView}.
   *
   * @param locale The localization services instance.
   * @param colors An array with definitions of colors to be displayed in the table.
   * @param columns The number of columns in the color grid.
   * @param removeButtonLabel The label of the button responsible for removing the color.
   * @param colorPickerLabel The label of the button responsible for color picker appearing.
   * @param documentColorsLabel The label for the section with the document colors.
   * @param documentColorsCount The number of colors in the document colors section inside the color dropdown.
   * @param colorPickerViewConfig The configuration of color picker feature. If set to `false`, the color picker will be hidden.
   */
  constructor(e, { colors: t, columns: n, removeButtonLabel: s, documentColorsLabel: o, documentColorsCount: r, colorPickerLabel: a, colorPickerViewConfig: l }) {
    super(e), this.items = this.createCollection(), this.focusTracker = new X(), this.keystrokes = new ie(), this._focusables = new ve(), this._colorPickerViewConfig = l, this._focusCycler = new ge({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate list items backwards using the <kbd>Shift</kbd> + <kbd>Tab</kbd> keystroke.
        focusPrevious: "shift + tab",
        // Navigate list items forwards using the <kbd>Tab</kbd> key.
        focusNext: "tab"
      }
    }), this.colorGridsFragmentView = new Qx(e, {
      colors: t,
      columns: n,
      removeButtonLabel: s,
      documentColorsLabel: o,
      documentColorsCount: r,
      colorPickerLabel: a,
      focusTracker: this.focusTracker,
      focusables: this._focusables
    }), this.colorPickerFragmentView = new Yx(e, {
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokes: this.keystrokes,
      colorPickerViewConfig: l
    }), this.set("_isColorGridsFragmentVisible", !0), this.set("_isColorPickerFragmentVisible", !1), this.set("selectedColor", void 0), this.colorGridsFragmentView.bind("isVisible").to(this, "_isColorGridsFragmentVisible"), this.colorPickerFragmentView.bind("isVisible").to(this, "_isColorPickerFragmentVisible"), this.on("change:selectedColor", (c, u, d) => {
      this.colorGridsFragmentView.set("selectedColor", d), this.colorPickerFragmentView.set("selectedColor", d);
    }), this.colorGridsFragmentView.on("change:selectedColor", (c, u, d) => {
      this.set("selectedColor", d);
    }), this.colorPickerFragmentView.on("change:selectedColor", (c, u, d) => {
      this.set("selectedColor", d);
    }), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-color-selector"
        ]
      },
      children: this.items
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.keystrokes.listenTo(this.element);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  /**
   * Renders the internals of the component on demand:
   * * {@link #colorPickerFragmentView},
   * * {@link #colorGridsFragmentView}.
   *
   * It allows for deferring component initialization to improve the performance.
   *
   * See {@link #showColorPickerFragment}, {@link #showColorGridsFragment}.
   */
  appendUI() {
    this._appendColorGridsFragment(), this._colorPickerViewConfig && this._appendColorPickerFragment();
  }
  /**
   * Shows the {@link #colorPickerFragmentView} and hides the {@link #colorGridsFragmentView}.
   *
   * **Note**: It requires {@link #appendUI} to be called first.
   *
   * See {@link #showColorGridsFragment}, {@link ~ColorSelectorView#event:colorPicker:show}.
   */
  showColorPickerFragment() {
    !this.colorPickerFragmentView.colorPickerView || this._isColorPickerFragmentVisible || (this._isColorPickerFragmentVisible = !0, this.colorPickerFragmentView.focus(), this.colorPickerFragmentView.resetValidationStatus(), this._isColorGridsFragmentVisible = !1);
  }
  /**
   * Shows the {@link #colorGridsFragmentView} and hides the {@link #colorPickerFragmentView}.
   *
   * See {@link #showColorPickerFragment}.
   *
   * **Note**: It requires {@link #appendUI} to be called first.
   */
  showColorGridsFragment() {
    this._isColorGridsFragmentVisible || (this._isColorGridsFragmentVisible = !0, this.colorGridsFragmentView.focus(), this._isColorPickerFragmentVisible = !1);
  }
  /**
   * Focuses the first focusable element in {@link #items}.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
   * Focuses the last focusable element in {@link #items}.
   */
  focusLast() {
    this._focusCycler.focusLast();
  }
  /**
   * Scans through the editor model and searches for text node attributes with the given `attributeName`.
   * Found entries are set as document colors in {@link #colorGridsFragmentView}.
   *
   * All the previously stored document colors will be lost in the process.
   *
   * @param model The model used as a source to obtain the document colors.
   * @param attributeName Determines the name of the related model's attribute for a given dropdown.
   */
  updateDocumentColors(e, t) {
    this.colorGridsFragmentView.updateDocumentColors(e, t);
  }
  /**
   * Refreshes the state of the selected color in one or both grids located in {@link #colorGridsFragmentView}.
   *
   * It guarantees that the selection will occur only in one of them.
   */
  updateSelectedColors() {
    this.colorGridsFragmentView.updateSelectedColors();
  }
  /**
   * Appends the view containing static and document color grid views.
   */
  _appendColorGridsFragment() {
    this.items.length || (this.items.add(this.colorGridsFragmentView), this.colorGridsFragmentView.delegate("execute").to(this), this.colorGridsFragmentView.delegate("colorPicker:show").to(this));
  }
  /**
   * Appends the view with the color picker.
   */
  _appendColorPickerFragment() {
    this.items.length !== 2 && (this.items.add(this.colorPickerFragmentView), this.colorGridsFragmentView.colorPickerButtonView && this.colorGridsFragmentView.colorPickerButtonView.on("execute", () => {
      this.showColorPickerFragment();
    }), this.colorGridsFragmentView.addColorPickerButton(), this.colorPickerFragmentView.delegate("execute").to(this), this.colorPickerFragmentView.delegate("colorPicker:cancel").to(this));
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class eI {
  /**
   * Creates an instance of the factory.
   *
   * @param editor The editor instance.
   */
  constructor(e) {
    this._components = /* @__PURE__ */ new Map(), this.editor = e;
  }
  /**
   * Returns an iterator of registered component names. Names are returned in lower case.
   */
  *names() {
    for (const e of this._components.values())
      yield e.originalName;
  }
  /**
   * Registers a component factory function that will be used by the
   * {@link #create create} method and called with the
   * {@link module:core/editor/editor~Editor#locale editor locale} as an argument,
   * allowing localization of the {@link module:ui/view~View view}.
   *
   * @param name The name of the component.
   * @param callback The callback that returns the component.
   */
  add(e, t) {
    this._components.set(Br(e), { callback: t, originalName: e });
  }
  /**
   * Creates an instance of a component registered in the factory under a specific name.
   *
   * When called, the {@link module:core/editor/editor~Editor#locale editor locale} is passed to
   * the previously {@link #add added} factory function, allowing localization of the
   * {@link module:ui/view~View view}.
   *
   * @param name The name of the component.
   * @returns The instantiated component view.
   */
  create(e) {
    if (!this.has(e))
      throw new g("componentfactory-item-missing", this, { name: e });
    return this._components.get(Br(e)).callback(this.editor.locale);
  }
  /**
   * Checks if a component of a given name is registered in the factory.
   *
   * @param name The name of the component.
   */
  has(e) {
    return this._components.has(Br(e));
  }
}
function Br(i) {
  return String(i).toLowerCase();
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class rr extends T {
  /**
   * Creates an instance of the form header class.
   *
   * @param locale The locale instance.
   * @param options.label A label.
   * @param options.class An additional class.
   */
  constructor(e, t = {}) {
    super(e);
    const n = this.bindTemplate;
    this.set("label", t.label || ""), this.set("class", t.class || null), this.children = this.createCollection(), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-form__header",
          n.to("class")
        ]
      },
      children: this.children
    }), t.icon && (this.iconView = new ut(), this.iconView.content = t.icon, this.children.add(this.iconView));
    const s = new T(e);
    s.setTemplate({
      tag: "h2",
      attributes: {
        class: [
          "ck",
          "ck-form__header__label"
        ],
        role: "presentation"
      },
      children: [
        { text: n.to("label") }
      ]
    }), this.children.add(s);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function tI(i) {
  class e extends i {
    /**
     * @inheritdoc
     */
    constructor(...n) {
      super(...n), this._onDragBound = this._onDrag.bind(this), this._onDragEndBound = this._onDragEnd.bind(this), this._lastDraggingCoordinates = { x: 0, y: 0 }, this.on("render", () => {
        this._attachListeners();
      }), this.set("isDragging", !1);
    }
    /**
     * Attaches the listeners for the drag start.
     */
    _attachListeners() {
      this.listenTo(this.element, "mousedown", this._onDragStart.bind(this)), this.listenTo(this.element, "touchstart", this._onDragStart.bind(this));
    }
    /**
     * Attaches the listeners for the dragging and drag end.
     */
    _attachDragListeners() {
      this.listenTo(E.document, "mouseup", this._onDragEndBound), this.listenTo(E.document, "touchend", this._onDragEndBound), this.listenTo(E.document, "mousemove", this._onDragBound), this.listenTo(E.document, "touchmove", this._onDragBound);
    }
    /**
     * Detaches the listeners after the drag end.
     */
    _detachDragListeners() {
      this.stopListening(E.document, "mouseup", this._onDragEndBound), this.stopListening(E.document, "touchend", this._onDragEndBound), this.stopListening(E.document, "mousemove", this._onDragBound), this.stopListening(E.document, "touchmove", this._onDragBound);
    }
    /**
     * Starts the dragging listeners and sets the initial view coordinates.
     */
    _onDragStart(n, s) {
      if (!this._isHandleElementPressed(s))
        return;
      this._attachDragListeners();
      let o = 0, r = 0;
      s instanceof MouseEvent ? (o = s.clientX, r = s.clientY) : (o = s.touches[0].clientX, r = s.touches[0].clientY), this._lastDraggingCoordinates = { x: o, y: r }, this.isDragging = !0;
    }
    /**
     * Updates the view coordinates and fires the `drag` event.
     */
    _onDrag(n, s) {
      if (!this.isDragging) {
        this._detachDragListeners();
        return;
      }
      let o = 0, r = 0;
      s instanceof MouseEvent ? (o = s.clientX, r = s.clientY) : (o = s.touches[0].clientX, r = s.touches[0].clientY), s.preventDefault(), this.fire("drag", {
        deltaX: Math.round(o - this._lastDraggingCoordinates.x),
        deltaY: Math.round(r - this._lastDraggingCoordinates.y)
      }), this._lastDraggingCoordinates = { x: o, y: r };
    }
    /**
     * Stops the dragging and detaches the listeners.
     */
    _onDragEnd() {
      this._detachDragListeners(), this.isDragging = !1;
    }
    /**
     * Checks if the drag handle element was pressed.
     */
    _isHandleElementPressed(n) {
      return this.dragHandleElement ? this.dragHandleElement === n.target || n.target instanceof HTMLElement && this.dragHandleElement.contains(n.target) : !1;
    }
  }
  return e;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class nI extends T {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.children = this.createCollection(), this.keystrokes = new ie(), this._focusTracker = new X(), this._focusables = new ve(), this.focusCycler = new ge({
      focusables: this._focusables,
      focusTracker: this._focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    }), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-dialog__actions"
        ]
      },
      children: this.children
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.keystrokes.listenTo(this.element);
  }
  /**
   * Creates the button views based on the given definitions.
   * Then adds them to the {@link #children} collection and to the focus cycler.
   */
  setButtons(e) {
    for (const t of e) {
      const n = new P(this.locale);
      let s;
      n.on("execute", () => t.onExecute()), t.onCreate && t.onCreate(n);
      for (s in t)
        s != "onExecute" && s != "onCreate" && n.set(s, t[s]);
      this.children.add(n);
    }
    this._updateFocusCyclableItems();
  }
  /**
   * @inheritDoc
   */
  focus(e) {
    e === -1 ? this.focusCycler.focusLast() : this.focusCycler.focusFirst();
  }
  /**
   * Adds all elements from the {@link #children} collection to the {@link #_focusables} collection
   * and to the {@link #_focusTracker} instance.
   */
  _updateFocusCyclableItems() {
    Array.from(this.children).forEach((e) => {
      this._focusables.add(e), this._focusTracker.add(e.element);
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class iI extends T {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.children = this.createCollection(), this.setTemplate({
      tag: "div",
      attributes: {
        class: ["ck", "ck-dialog__content"]
      },
      children: this.children
    });
  }
  /**
   * Removes all the child views.
   */
  reset() {
    for (; this.children.length; )
      this.children.remove(0);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Qe = {
  SCREEN_CENTER: "screen-center",
  EDITOR_CENTER: "editor-center",
  EDITOR_TOP_SIDE: "editor-top-side",
  EDITOR_TOP_CENTER: "editor-top-center",
  EDITOR_BOTTOM_CENTER: "editor-bottom-center",
  EDITOR_ABOVE_CENTER: "editor-above-center",
  EDITOR_BELOW_CENTER: "editor-below-center"
}, ld = di("px");
class si extends tI(T) {
  /**
   * @inheritDoc
   */
  constructor(e, { getCurrentDomRoot: t, getViewportOffset: n }) {
    super(e), this.wasMoved = !1;
    const s = this.bindTemplate, o = e.t;
    this.set("className", ""), this.set("ariaLabel", o("Editor dialog")), this.set("isModal", !1), this.set("position", Qe.SCREEN_CENTER), this.set("_isVisible", !1), this.set("_isTransparent", !1), this.set("_top", 0), this.set("_left", 0), this._getCurrentDomRoot = t, this._getViewportOffset = n, this.decorate("moveTo"), this.parts = this.createCollection(), this.keystrokes = new ie(), this.focusTracker = new X(), this._focusables = new ve(), this._focusCycler = new ge({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    }), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-dialog-overlay",
          s.if("isModal", "ck-dialog-overlay__transparent", (r) => !r),
          s.if("_isVisible", "ck-hidden", (r) => !r)
        ],
        // Prevent from editor losing focus when clicking on the modal overlay.
        tabindex: "-1"
      },
      children: [
        {
          tag: "div",
          attributes: {
            tabindex: "-1",
            class: [
              "ck",
              "ck-dialog",
              s.to("className")
            ],
            role: "dialog",
            "aria-label": s.to("ariaLabel"),
            style: {
              top: s.to("_top", (r) => ld(r)),
              left: s.to("_left", (r) => ld(r)),
              visibility: s.if("_isTransparent", "hidden")
            }
          },
          children: this.parts
        }
      ]
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.keystrokes.set("Esc", (e, t) => {
      this.fire("close", { source: "escKeyPress" }), t();
    }), this.on("drag", (e, { deltaX: t, deltaY: n }) => {
      this.wasMoved = !0, this.moveBy(t, n);
    }), this.listenTo(E.window, "resize", () => {
      this._isVisible && !this.wasMoved && this.updatePosition();
    }), this.listenTo(E.document, "scroll", () => {
      this._isVisible && !this.wasMoved && this.updatePosition();
    }), this.on("change:_isVisible", (e, t, n) => {
      n && (this._isTransparent = !0, setTimeout(() => {
        this.updatePosition(), this._isTransparent = !1, this.focus();
      }, 10));
    }), this.keystrokes.listenTo(this.element);
  }
  /**
   * Returns the element that should be used as a drag handle.
   */
  get dragHandleElement() {
    return this.headerView ? this.headerView.element : null;
  }
  /**
   * Creates the dialog parts. Which of them are created depends on the arguments passed to the method.
   * There are no rules regarding the dialog construction, that is, no part is mandatory.
   * Each part can only be created once.
   *
   * @internal
   */
  setupParts({ icon: e, title: t, hasCloseButton: n = !0, content: s, actionButtons: o }) {
    t && (this.headerView = new rr(this.locale, { icon: e }), n && (this.closeButtonView = this._createCloseButton(), this.headerView.children.add(this.closeButtonView)), this.headerView.label = t, this.ariaLabel = t, this.parts.add(this.headerView, 0)), s && (s instanceof T && (s = [s]), this.contentView = new iI(this.locale), this.contentView.children.addMany(s), this.parts.add(this.contentView)), o && (this.actionsView = new nI(this.locale), this.actionsView.setButtons(o), this.parts.add(this.actionsView)), this._updateFocusCyclableItems();
  }
  /**
   * Focuses the first focusable element inside the dialog.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
   * Normalizes the passed coordinates to make sure the dialog view
   * is displayed within the visible viewport and moves it there.
   *
   * @internal
   */
  moveTo(e, t) {
    const n = this._getViewportRect(), s = this._getDialogRect();
    e + s.width > n.right && (e = n.right - s.width), e < n.left && (e = n.left), t < n.top && (t = n.top), this._moveTo(e, t);
  }
  /**
   * Moves the dialog to the specified coordinates.
   */
  _moveTo(e, t) {
    this._left = e, this._top = t;
  }
  /**
   * Moves the dialog by the specified offset.
   *
   * @internal
   */
  moveBy(e, t) {
    this.moveTo(this._left + e, this._top + t);
  }
  /**
   * Moves the dialog view to the off-screen position.
   * Used when there is no space to display the dialog.
   */
  _moveOffScreen() {
    this._moveTo(-9999, -9999);
  }
  /**
   * Recalculates the dialog according to the set position and viewport,
   * and moves it to the new position.
   */
  updatePosition() {
    if (!this.element || !this.element.parentNode)
      return;
    const e = this._getViewportRect();
    let t = this.position, n;
    this._getCurrentDomRoot() ? n = this._getVisibleDomRootRect(e) : t = Qe.SCREEN_CENTER;
    const s = si.defaultOffset, o = this._getDialogRect();
    switch (t) {
      case Qe.EDITOR_TOP_SIDE: {
        if (n) {
          const r = this.locale.contentLanguageDirection === "ltr" ? n.right - o.width - s : n.left + s;
          this.moveTo(r, n.top + s);
        } else
          this._moveOffScreen();
        break;
      }
      case Qe.EDITOR_CENTER: {
        n ? this.moveTo(Math.round(n.left + n.width / 2 - o.width / 2), Math.round(n.top + n.height / 2 - o.height / 2)) : this._moveOffScreen();
        break;
      }
      case Qe.SCREEN_CENTER: {
        this.moveTo(Math.round((e.width - o.width) / 2), Math.round((e.height - o.height) / 2));
        break;
      }
      case Qe.EDITOR_TOP_CENTER: {
        n ? this.moveTo(Math.round(n.left + n.width / 2 - o.width / 2), n.top + s) : this._moveOffScreen();
        break;
      }
      case Qe.EDITOR_BOTTOM_CENTER: {
        n ? this.moveTo(Math.round(n.left + n.width / 2 - o.width / 2), n.bottom - o.height - s) : this._moveOffScreen();
        break;
      }
      case Qe.EDITOR_ABOVE_CENTER: {
        n ? this.moveTo(Math.round(n.left + n.width / 2 - o.width / 2), n.top - o.height - s) : this._moveOffScreen();
        break;
      }
      case Qe.EDITOR_BELOW_CENTER: {
        n ? this.moveTo(Math.round(n.left + n.width / 2 - o.width / 2), n.bottom + s) : this._moveOffScreen();
        break;
      }
    }
  }
  /**
   * Calculates the visible DOM root part.
   */
  _getVisibleDomRootRect(e) {
    let t = new B(this._getCurrentDomRoot()).getVisible();
    if (t) {
      if (t = e.getIntersection(t), !t)
        return null;
    } else
      return null;
    return t;
  }
  /**
   * Calculates the dialog element rect.
   */
  _getDialogRect() {
    return new B(this.element.firstElementChild);
  }
  /**
   * Calculates the viewport rect.
   */
  _getViewportRect() {
    return sI(this._getViewportOffset());
  }
  /**
   * Collects all focusable elements inside the dialog parts
   * and adds them to the focus tracker and focus cycler.
   */
  _updateFocusCyclableItems() {
    const e = [];
    if (this.contentView)
      for (const t of this.contentView.children)
        bs(t) && e.push(t);
    this.actionsView && e.push(this.actionsView), this.closeButtonView && e.push(this.closeButtonView), e.forEach((t) => {
      this._focusables.add(t), this.focusTracker.add(t.element), hx(t) && (this.listenTo(t.focusCycler, "forwardCycle", (n) => {
        this._focusCycler.focusNext(), this._focusCycler.next !== this._focusCycler.focusables.get(this._focusCycler.current) && n.stop();
      }), this.listenTo(t.focusCycler, "backwardCycle", (n) => {
        this._focusCycler.focusPrevious(), this._focusCycler.previous !== this._focusCycler.focusables.get(this._focusCycler.current) && n.stop();
      }));
    });
  }
  /**
   * Creates the close button view that is displayed in the header view corner.
   */
  _createCloseButton() {
    const e = new P(this.locale), t = this.locale.t;
    return e.set({
      label: t("Close"),
      tooltip: !0,
      icon: A.cancel
    }), e.on("execute", () => this.fire("close", { source: "closeButton" })), e;
  }
}
si.defaultOffset = 15;
function sI(i) {
  i = Object.assign({ top: 0, bottom: 0, left: 0, right: 0 }, i);
  const e = new B(E.window);
  return e.top += i.top, e.height -= i.top, e.bottom -= i.bottom, e.height -= i.bottom, e.left += i.left, e.right -= i.right, e.width -= i.left + i.right, e;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class kt extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Dialog";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e);
    const t = e.t;
    this._initShowHideListeners(), this._initFocusToggler(), this._initMultiRootIntegration(), this.set("id", null), e.accessibility.addKeystrokeInfos({
      categoryId: "navigation",
      keystrokes: [{
        label: t("Move focus in and out of an active dialog window"),
        keystroke: "Ctrl+F6",
        mayRequireFn: !0
      }]
    });
  }
  /**
   * Initiates listeners for the `show` and `hide` events emitted by this plugin.
   *
   * We could not simply decorate the {@link #show} and {@link #hide} methods to fire events,
   * because they would be fired in the wrong order &ndash; first would be `show` and then `hide`
   * (because showing the dialog actually starts with hiding the previously visible one).
   * Hence, we added private methods {@link #_show} and {@link #_hide} which are called on events
   * in the desired sequence.
   */
  _initShowHideListeners() {
    this.on("show", (e, t) => {
      this._show(t);
    }), this.on("show", (e, t) => {
      t.onShow && t.onShow(this);
    }, { priority: "low" }), this.on("hide", () => {
      kt._visibleDialogPlugin && kt._visibleDialogPlugin._hide();
    }), this.on("hide", () => {
      this._onHide && (this._onHide(this), this._onHide = void 0);
    }, { priority: "low" });
  }
  /**
   * Initiates keystroke handler for toggling the focus between the editor and the dialog view.
   */
  _initFocusToggler() {
    const e = this.editor;
    e.keystrokes.set("Ctrl+F6", (t, n) => {
      !this.isOpen || this.view.isModal || (this.view.focusTracker.isFocused ? e.editing.view.focus() : this.view.focus(), n());
    });
  }
  /**
   * Provides an integration between the root attaching and detaching and positioning of the view.
   */
  _initMultiRootIntegration() {
    const e = this.editor.model;
    e.document.on("change:data", () => {
      if (!this.view)
        return;
      const t = e.document.differ.getChangedRoots();
      for (const n of t)
        n.state && this.view.updatePosition();
    });
  }
  /**
   * Displays a dialog window.
   *
   * This method requires a {@link ~DialogDefinition} that defines the dialog's content, title, icon, action buttons, etc.
   *
   * For example, the following definition will create a dialog with:
   * * A header consisting of an icon, a title, and a "Close" button (it is added by default).
   * * A content consisting of a view with a single paragraph.
   * * A footer consisting of two buttons: "Yes" and "No".
   *
   * ```js
   * // Create the view that will be used as the dialog's content.
   * const textView = new View( locale );
   *
   * textView.setTemplate( {
   * 	tag: 'div',
   * 	attributes: {
   * 		style: {
   * 			padding: 'var(--ck-spacing-large)',
   * 			whiteSpace: 'initial',
   * 			width: '100%',
   * 			maxWidth: '500px'
   * 		},
   * 		tabindex: -1
   * 	},
   * 	children: [
   * 		'Lorem ipsum dolor sit amet...'
   * 	]
   * } );
   *
   * // Show the dialog.
   * editor.plugins.get( 'Dialog' ).show( {
   *	id: 'myDialog',
   * 	icon: 'myIcon', // This should be an SVG string.
   * 	title: 'My dialog',
   * 	content: textView,
   * 	actionButtons: [
   *		{
   *			label: t( 'Yes' ),
   *			class: 'ck-button-action',
   *			withText: true,
   *			onExecute: () => dialog.hide()
   *		},
   *		{
   *			label: t( 'No' ),
   *			withText: true,
   *			onExecute: () => dialog.hide()
   *		}
   *	]
   * } );
   * ```
   *
   * By specifying the {@link ~DialogDefinition#onShow} and {@link ~DialogDefinition#onHide} callbacks
   * it is also possible to add callbacks that will be called when the dialog is shown or hidden.
   *
   * For example, the callbacks in the following definition:
   * * Disable the default behavior of the <kbd>Esc</kbd> key.
   * * Fire a custom event when the dialog gets hidden.
   *
   * ```js
   * editor.plugins.get( 'Dialog' ).show( {
   * 	// ...
   * 	onShow: dialog => {
   * 		dialog.view.on( 'close', ( evt, data ) => {
   * 			// Only prevent the event from the "Esc" key - do not affect the other ways of closing the dialog.
   * 			if ( data.source === 'escKeyPress' ) {
   * 				evt.stop();
   * 			}
   * 		} );
   * 	},
   * 	onHide: dialog => {
   * 		dialog.fire( 'dialogDestroyed' );
   * 	}
   * } );
   * ```
   *
   * Internally, calling this method:
   * 1. Hides the currently visible dialog (if any) calling the {@link #hide} method
   * (fires the {@link ~DialogHideEvent hide event}).
   * 2. Fires the {@link ~DialogShowEvent show event} which allows for adding callbacks that customize the
   * behavior of the dialog.
   * 3. Shows the dialog.
   */
  show(e) {
    this.hide(), this.fire(`show:${e.id}`, e);
  }
  /**
   * Handles creating the {@link module:ui/dialog/dialogview~DialogView} instance and making it visible.
   */
  _show({ id: e, icon: t, title: n, hasCloseButton: s = !0, content: o, actionButtons: r, className: a, isModal: l, position: c, onHide: u }) {
    const d = this.editor;
    this.view = new si(d.locale, {
      getCurrentDomRoot: () => d.editing.view.getDomRoot(d.model.document.selection.anchor.root.rootName),
      getViewportOffset: () => d.ui.viewportOffset
    });
    const h = this.view;
    h.on("close", () => {
      this.hide();
    }), d.ui.view.body.add(h), d.ui.focusTracker.add(h.element), d.keystrokes.listenTo(h.element), c || (c = l ? Qe.SCREEN_CENTER : Qe.EDITOR_CENTER), h.set({
      position: c,
      _isVisible: !0,
      className: a,
      isModal: l
    }), h.setupParts({
      icon: t,
      title: n,
      hasCloseButton: s,
      content: o,
      actionButtons: r
    }), this.id = e, u && (this._onHide = u), this.isOpen = !0, kt._visibleDialogPlugin = this;
  }
  /**
   * Hides the dialog. This method is decorated to enable interacting on the {@link ~DialogHideEvent hide event}.
   *
   * See {@link #show}.
   */
  hide() {
    kt._visibleDialogPlugin && kt._visibleDialogPlugin.fire(`hide:${kt._visibleDialogPlugin.id}`);
  }
  /**
   * Destroys the {@link module:ui/dialog/dialogview~DialogView} and cleans up the stored dialog state.
   */
  _hide() {
    if (!this.view)
      return;
    const e = this.editor, t = this.view;
    t.contentView && t.contentView.reset(), e.ui.view.body.remove(t), e.ui.focusTracker.remove(t.element), e.keystrokes.stopListening(t.element), t.destroy(), e.editing.view.focus(), this.id = null, this.isOpen = !1, kt._visibleDialogPlugin = null;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const cd = di("px"), ud = E.document.body, oI = {
  top: -99999,
  left: -99999,
  name: "arrowless",
  config: {
    withArrow: !1
  }
};
class Ce extends T {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e);
    const t = this.bindTemplate;
    this.set("top", 0), this.set("left", 0), this.set("position", "arrow_nw"), this.set("isVisible", !1), this.set("withArrow", !0), this.set("class", void 0), this._pinWhenIsVisibleCallback = null, this.content = this.createCollection(), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-balloon-panel",
          t.to("position", (n) => `ck-balloon-panel_${n}`),
          t.if("isVisible", "ck-balloon-panel_visible"),
          t.if("withArrow", "ck-balloon-panel_with-arrow"),
          t.to("class")
        ],
        style: {
          top: t.to("top", cd),
          left: t.to("left", cd)
        }
      },
      children: this.content
    });
  }
  /**
   * Shows the panel.
   *
   * See {@link #isVisible}.
   */
  show() {
    this.isVisible = !0;
  }
  /**
   * Hides the panel.
   *
   * See {@link #isVisible}.
   */
  hide() {
    this.isVisible = !1;
  }
  /**
   * Attaches the panel to a specified {@link module:utils/dom/position~Options#target} with a
   * smart positioning heuristics that chooses from available positions to make sure the panel
   * is visible to the user i.e. within the limits of the viewport.
   *
   * This method accepts configuration {@link module:utils/dom/position~Options options}
   * to set the `target`, optional `limiter` and `positions` the balloon should choose from.
   *
   * ```ts
   * const panel = new BalloonPanelView( locale );
   * const positions = BalloonPanelView.defaultPositions;
   *
   * panel.render();
   *
   * // Attach the panel to an element with the "target" id DOM.
   * panel.attachTo( {
   * 	target: document.querySelector( '#target' ),
   * 	positions: [
   * 		positions.northArrowSouth,
   * 		positions.southArrowNorth
   * 	]
   * } );
   * ```
   *
   * **Note**: Attaching the panel will also automatically {@link #show} it.
   *
   * **Note**: An attached panel will not follow its target when the window is scrolled or resized.
   * See the {@link #pin} method for a more permanent positioning strategy.
   *
   * @param options Positioning options compatible with {@link module:utils/dom/position~getOptimalPosition}.
   * Default `positions` array is {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.
   */
  attachTo(e) {
    this.show();
    const t = Ce.defaultPositions, n = Object.assign({}, {
      element: this.element,
      positions: [
        t.southArrowNorth,
        t.southArrowNorthMiddleWest,
        t.southArrowNorthMiddleEast,
        t.southArrowNorthWest,
        t.southArrowNorthEast,
        t.northArrowSouth,
        t.northArrowSouthMiddleWest,
        t.northArrowSouthMiddleEast,
        t.northArrowSouthWest,
        t.northArrowSouthEast,
        t.viewportStickyNorth
      ],
      limiter: ud,
      fitInViewport: !0
    }, e), s = Ce._getOptimalPosition(n) || oI, o = parseInt(s.left), r = parseInt(s.top), a = s.name, l = s.config || {}, { withArrow: c = !0 } = l;
    this.top = r, this.left = o, this.position = a, this.withArrow = c;
  }
  /**
   * Works the same way as the {@link #attachTo} method except that the position of the panel is
   * continuously updated when:
   *
   * * any ancestor of the {@link module:utils/dom/position~Options#target}
   * or {@link module:utils/dom/position~Options#limiter} is scrolled,
   * * the browser window gets resized or scrolled.
   *
   * Thanks to that, the panel always sticks to the {@link module:utils/dom/position~Options#target}
   * and is immune to the changing environment.
   *
   * ```ts
   * const panel = new BalloonPanelView( locale );
   * const positions = BalloonPanelView.defaultPositions;
   *
   * panel.render();
   *
   * // Pin the panel to an element with the "target" id DOM.
   * panel.pin( {
   * 	target: document.querySelector( '#target' ),
   * 	positions: [
   * 		positions.northArrowSouth,
   * 		positions.southArrowNorth
   * 	]
   * } );
   * ```
   *
   * To leave the pinned state, use the {@link #unpin} method.
   *
   * **Note**: Pinning the panel will also automatically {@link #show} it.
   *
   * @param options Positioning options compatible with {@link module:utils/dom/position~getOptimalPosition}.
   * Default `positions` array is {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.
   */
  pin(e) {
    this.unpin(), this._pinWhenIsVisibleCallback = () => {
      this.isVisible ? this._startPinning(e) : this._stopPinning();
    }, this._startPinning(e), this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback);
  }
  /**
   * Stops pinning the panel, as set up by {@link #pin}.
   */
  unpin() {
    this._pinWhenIsVisibleCallback && (this._stopPinning(), this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback), this._pinWhenIsVisibleCallback = null, this.hide());
  }
  /**
   * Starts managing the pinned state of the panel. See {@link #pin}.
   *
   * @param options Positioning options compatible with {@link module:utils/dom/position~getOptimalPosition}.
   */
  _startPinning(e) {
    this.attachTo(e);
    const t = ya(e.target), n = e.limiter ? ya(e.limiter) : ud;
    this.listenTo(E.document, "scroll", (s, o) => {
      const r = o.target, a = t && r.contains(t), l = n && r.contains(n);
      (a || l || !t || !n) && this.attachTo(e);
    }, { useCapture: !0 }), this.listenTo(E.window, "resize", () => {
      this.attachTo(e);
    });
  }
  /**
   * Stops managing the pinned state of the panel. See {@link #pin}.
   */
  _stopPinning() {
    this.stopListening(E.document, "scroll"), this.stopListening(E.window, "resize");
  }
}
Ce.arrowSideOffset = 25;
Ce.arrowHeightOffset = 10;
Ce.stickyVerticalOffset = 20;
Ce._getOptimalPosition = Go;
Ce.defaultPositions = Wg();
function ya(i) {
  return fn(i) ? i : qo(i) ? i.commonAncestorContainer : typeof i == "function" ? ya(i()) : null;
}
function Wg(i = {}) {
  const { sideOffset: e = Ce.arrowSideOffset, heightOffset: t = Ce.arrowHeightOffset, stickyVerticalOffset: n = Ce.stickyVerticalOffset, config: s } = i;
  return {
    // ------- North west
    northWestArrowSouthWest: (a, l) => ({
      top: o(a, l),
      left: a.left - e,
      name: "arrow_sw",
      ...s && { config: s }
    }),
    northWestArrowSouthMiddleWest: (a, l) => ({
      top: o(a, l),
      left: a.left - l.width * 0.25 - e,
      name: "arrow_smw",
      ...s && { config: s }
    }),
    northWestArrowSouth: (a, l) => ({
      top: o(a, l),
      left: a.left - l.width / 2,
      name: "arrow_s",
      ...s && { config: s }
    }),
    northWestArrowSouthMiddleEast: (a, l) => ({
      top: o(a, l),
      left: a.left - l.width * 0.75 + e,
      name: "arrow_sme",
      ...s && { config: s }
    }),
    northWestArrowSouthEast: (a, l) => ({
      top: o(a, l),
      left: a.left - l.width + e,
      name: "arrow_se",
      ...s && { config: s }
    }),
    // ------- North
    northArrowSouthWest: (a, l) => ({
      top: o(a, l),
      left: a.left + a.width / 2 - e,
      name: "arrow_sw",
      ...s && { config: s }
    }),
    northArrowSouthMiddleWest: (a, l) => ({
      top: o(a, l),
      left: a.left + a.width / 2 - l.width * 0.25 - e,
      name: "arrow_smw",
      ...s && { config: s }
    }),
    northArrowSouth: (a, l) => ({
      top: o(a, l),
      left: a.left + a.width / 2 - l.width / 2,
      name: "arrow_s",
      ...s && { config: s }
    }),
    northArrowSouthMiddleEast: (a, l) => ({
      top: o(a, l),
      left: a.left + a.width / 2 - l.width * 0.75 + e,
      name: "arrow_sme",
      ...s && { config: s }
    }),
    northArrowSouthEast: (a, l) => ({
      top: o(a, l),
      left: a.left + a.width / 2 - l.width + e,
      name: "arrow_se",
      ...s && { config: s }
    }),
    // ------- North east
    northEastArrowSouthWest: (a, l) => ({
      top: o(a, l),
      left: a.right - e,
      name: "arrow_sw",
      ...s && { config: s }
    }),
    northEastArrowSouthMiddleWest: (a, l) => ({
      top: o(a, l),
      left: a.right - l.width * 0.25 - e,
      name: "arrow_smw",
      ...s && { config: s }
    }),
    northEastArrowSouth: (a, l) => ({
      top: o(a, l),
      left: a.right - l.width / 2,
      name: "arrow_s",
      ...s && { config: s }
    }),
    northEastArrowSouthMiddleEast: (a, l) => ({
      top: o(a, l),
      left: a.right - l.width * 0.75 + e,
      name: "arrow_sme",
      ...s && { config: s }
    }),
    northEastArrowSouthEast: (a, l) => ({
      top: o(a, l),
      left: a.right - l.width + e,
      name: "arrow_se",
      ...s && { config: s }
    }),
    // ------- South west
    southWestArrowNorthWest: (a) => ({
      top: r(a),
      left: a.left - e,
      name: "arrow_nw",
      ...s && { config: s }
    }),
    southWestArrowNorthMiddleWest: (a, l) => ({
      top: r(a),
      left: a.left - l.width * 0.25 - e,
      name: "arrow_nmw",
      ...s && { config: s }
    }),
    southWestArrowNorth: (a, l) => ({
      top: r(a),
      left: a.left - l.width / 2,
      name: "arrow_n",
      ...s && { config: s }
    }),
    southWestArrowNorthMiddleEast: (a, l) => ({
      top: r(a),
      left: a.left - l.width * 0.75 + e,
      name: "arrow_nme",
      ...s && { config: s }
    }),
    southWestArrowNorthEast: (a, l) => ({
      top: r(a),
      left: a.left - l.width + e,
      name: "arrow_ne",
      ...s && { config: s }
    }),
    // ------- South
    southArrowNorthWest: (a) => ({
      top: r(a),
      left: a.left + a.width / 2 - e,
      name: "arrow_nw",
      ...s && { config: s }
    }),
    southArrowNorthMiddleWest: (a, l) => ({
      top: r(a),
      left: a.left + a.width / 2 - l.width * 0.25 - e,
      name: "arrow_nmw",
      ...s && { config: s }
    }),
    southArrowNorth: (a, l) => ({
      top: r(a),
      left: a.left + a.width / 2 - l.width / 2,
      name: "arrow_n",
      ...s && { config: s }
    }),
    southArrowNorthMiddleEast: (a, l) => ({
      top: r(a),
      left: a.left + a.width / 2 - l.width * 0.75 + e,
      name: "arrow_nme",
      ...s && { config: s }
    }),
    southArrowNorthEast: (a, l) => ({
      top: r(a),
      left: a.left + a.width / 2 - l.width + e,
      name: "arrow_ne",
      ...s && { config: s }
    }),
    // ------- South east
    southEastArrowNorthWest: (a) => ({
      top: r(a),
      left: a.right - e,
      name: "arrow_nw",
      ...s && { config: s }
    }),
    southEastArrowNorthMiddleWest: (a, l) => ({
      top: r(a),
      left: a.right - l.width * 0.25 - e,
      name: "arrow_nmw",
      ...s && { config: s }
    }),
    southEastArrowNorth: (a, l) => ({
      top: r(a),
      left: a.right - l.width / 2,
      name: "arrow_n",
      ...s && { config: s }
    }),
    southEastArrowNorthMiddleEast: (a, l) => ({
      top: r(a),
      left: a.right - l.width * 0.75 + e,
      name: "arrow_nme",
      ...s && { config: s }
    }),
    southEastArrowNorthEast: (a, l) => ({
      top: r(a),
      left: a.right - l.width + e,
      name: "arrow_ne",
      ...s && { config: s }
    }),
    // ------- West
    westArrowEast: (a, l) => ({
      top: a.top + a.height / 2 - l.height / 2,
      left: a.left - l.width - t,
      name: "arrow_e",
      ...s && { config: s }
    }),
    // ------- East
    eastArrowWest: (a, l) => ({
      top: a.top + a.height / 2 - l.height / 2,
      left: a.right + t,
      name: "arrow_w",
      ...s && { config: s }
    }),
    // ------- Sticky
    viewportStickyNorth: (a, l, c, u) => {
      const d = u || c;
      return !a.getIntersection(d) || d.height - a.height > n ? null : {
        top: d.top + n,
        left: a.left + a.width / 2 - l.width / 2,
        name: "arrowless",
        config: {
          withArrow: !1,
          ...s
        }
      };
    }
  };
  function o(a, l) {
    return a.top - l.height - t;
  }
  function r(a) {
    return a.bottom + t;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const dd = "ck-tooltip";
class pe extends Le() {
  /**
   * Creates an instance of the tooltip manager.
   */
  constructor(e) {
    if (super(), this._currentElementWithTooltip = null, this._currentTooltipPosition = null, this._resizeObserver = null, this._mutationObserver = null, pe._editors.add(e), pe._instance)
      return pe._instance;
    pe._instance = this, this.tooltipTextView = new T(e.locale), this.tooltipTextView.set("text", ""), this.tooltipTextView.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-tooltip__text"
        ]
      },
      children: [
        {
          text: this.tooltipTextView.bindTemplate.to("text")
        }
      ]
    }), this.balloonPanelView = new Ce(e.locale), this.balloonPanelView.class = dd, this.balloonPanelView.content.add(this.tooltipTextView), this._mutationObserver = rI(() => {
      this._updateTooltipPosition();
    }), this._pinTooltipDebounced = Pt(this._pinTooltip, 600), this._unpinTooltipDebounced = Pt(this._unpinTooltip, 400), this.listenTo(E.document, "keydown", this._onKeyDown.bind(this), { useCapture: !0 }), this.listenTo(E.document, "mouseenter", this._onEnterOrFocus.bind(this), { useCapture: !0 }), this.listenTo(E.document, "mouseleave", this._onLeaveOrBlur.bind(this), { useCapture: !0 }), this.listenTo(E.document, "focus", this._onEnterOrFocus.bind(this), { useCapture: !0 }), this.listenTo(E.document, "blur", this._onLeaveOrBlur.bind(this), { useCapture: !0 }), this.listenTo(E.document, "scroll", this._onScroll.bind(this), { useCapture: !0 }), this._watchdogExcluded = !0;
  }
  /**
   * Destroys the tooltip manager.
   *
   * **Note**: The manager singleton cannot be destroyed until all editors that use it are destroyed.
   *
   * @param editor The editor the manager was created for.
   */
  destroy(e) {
    const t = e.ui.view && e.ui.view.body;
    pe._editors.delete(e), this.stopListening(e.ui), t && t.has(this.balloonPanelView) && t.remove(this.balloonPanelView), pe._editors.size || (this._unpinTooltip(), this.balloonPanelView.destroy(), this.stopListening(), pe._instance = null);
  }
  /**
   * Returns {@link #balloonPanelView} {@link module:utils/dom/position~PositioningFunction positioning functions} for a given position
   * name.
   *
   * @param position Name of the position (`s`, `se`, `sw`, `n`, `e`, or `w`).
   * @returns Positioning functions to be used by the {@link #balloonPanelView}.
   */
  static getPositioningFunctions(e) {
    const t = pe.defaultBalloonPositions;
    return {
      // South is most popular. We can use positioning heuristics to avoid clipping by the viewport with the sane fallback.
      s: [
        t.southArrowNorth,
        t.southArrowNorthEast,
        t.southArrowNorthWest
      ],
      n: [t.northArrowSouth],
      e: [t.eastArrowWest],
      w: [t.westArrowEast],
      sw: [t.southArrowNorthEast],
      se: [t.southArrowNorthWest]
    }[e];
  }
  /**
   * Handles hiding tooltips on `keydown` in DOM.
   *
   * @param evt An object containing information about the fired event.
   * @param domEvent The DOM event.
   */
  _onKeyDown(e, t) {
    t.key === "Escape" && this._currentElementWithTooltip && (this._unpinTooltip(), t.stopPropagation());
  }
  /**
   * Handles displaying tooltips on `mouseenter` and `focus` in DOM.
   *
   * @param evt An object containing information about the fired event.
   * @param domEvent The DOM event.
   */
  _onEnterOrFocus(e, { target: t }) {
    const n = Lr(t);
    if (!n) {
      e.name === "focus" && this._unpinTooltip();
      return;
    }
    n !== this._currentElementWithTooltip && (this._unpinTooltip(), this._pinTooltipDebounced(n, hd(n)));
  }
  /**
   * Handles hiding tooltips on `mouseleave` and `blur` in DOM.
   *
   * @param evt An object containing information about the fired event.
   * @param domEvent The DOM event.
   */
  _onLeaveOrBlur(e, { target: t, relatedTarget: n }) {
    if (e.name === "mouseleave") {
      if (!fn(t))
        return;
      const s = this.balloonPanelView.element, o = s && (s === n || s.contains(n)), r = !o && t === s;
      if (o) {
        this._unpinTooltipDebounced.cancel();
        return;
      }
      if (!r && this._currentElementWithTooltip && t !== this._currentElementWithTooltip)
        return;
      const a = Lr(t), l = Lr(n);
      (r || a && a !== l) && this._unpinTooltipDebounced();
    } else {
      if (this._currentElementWithTooltip && t !== this._currentElementWithTooltip)
        return;
      this._unpinTooltipDebounced();
    }
  }
  /**
   * Handles hiding tooltips on `scroll` in DOM.
   *
   * @param evt An object containing information about the fired event.
   * @param domEvent The DOM event.
   */
  _onScroll(e, { target: t }) {
    this._currentElementWithTooltip && (t.contains(this.balloonPanelView.element) && t.contains(this._currentElementWithTooltip) || this._unpinTooltip());
  }
  /**
   * Pins the tooltip to a specific DOM element.
   *
   * @param options.text Text of the tooltip to display.
   * @param options.position The position of the tooltip.
   * @param options.cssClass Additional CSS class of the balloon with the tooltip.
   */
  _pinTooltip(e, { text: t, position: n, cssClass: s }) {
    this._unpinTooltip();
    const o = me(pe._editors.values()).ui.view.body;
    o.has(this.balloonPanelView) || o.add(this.balloonPanelView), this.tooltipTextView.text = t, this.balloonPanelView.pin({
      target: e,
      positions: pe.getPositioningFunctions(n)
    }), this._resizeObserver = new Y(e, () => {
      mn(e) || this._unpinTooltip();
    }), this._mutationObserver.attach(e), this.balloonPanelView.class = [dd, s].filter((r) => r).join(" ");
    for (const r of pe._editors)
      this.listenTo(r.ui, "update", this._updateTooltipPosition.bind(this), { priority: "low" });
    this._currentElementWithTooltip = e, this._currentTooltipPosition = n;
  }
  /**
   * Unpins the tooltip and cancels all queued pinning.
   */
  _unpinTooltip() {
    this._unpinTooltipDebounced.cancel(), this._pinTooltipDebounced.cancel(), this.balloonPanelView.unpin();
    for (const e of pe._editors)
      this.stopListening(e.ui, "update");
    this._currentElementWithTooltip = null, this._currentTooltipPosition = null, this.tooltipTextView.text = "", this._resizeObserver && this._resizeObserver.destroy(), this._mutationObserver.detach();
  }
  /**
   * Updates the position of the tooltip so it stays in sync with the element it is pinned to.
   *
   * Hides the tooltip when the element is no longer visible in DOM or the tooltip text was removed.
   */
  _updateTooltipPosition() {
    if (!this._currentElementWithTooltip)
      return;
    const e = hd(this._currentElementWithTooltip);
    if (!mn(this._currentElementWithTooltip) || !e.text) {
      this._unpinTooltip();
      return;
    }
    this.balloonPanelView.pin({
      target: this._currentElementWithTooltip,
      positions: pe.getPositioningFunctions(e.position)
    });
  }
}
pe.defaultBalloonPositions = Wg({
  heightOffset: 5,
  sideOffset: 13
});
pe._editors = /* @__PURE__ */ new Set();
pe._instance = null;
function Lr(i) {
  return fn(i) ? i.closest("[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])") : null;
}
function hd(i) {
  return {
    text: i.dataset.ckeTooltipText,
    position: i.dataset.ckeTooltipPosition || "s",
    cssClass: i.dataset.ckeTooltipClass || ""
  };
}
function rI(i) {
  const e = new MutationObserver(() => {
    i();
  });
  return {
    attach(t) {
      e.observe(t, {
        attributes: !0,
        attributeFilter: ["data-cke-tooltip-text", "data-cke-tooltip-position"]
      });
    },
    detach() {
      e.disconnect();
    }
  };
}
const aI = `<svg xmlns="http://www.w3.org/2000/svg" width="53" height="10" viewBox="0 0 53 10"><path fill="#1C2331" d="M31.724 1.492a15.139 15.139 0 0 0 .045 1.16 2.434 2.434 0 0 0-.687-.34 3.68 3.68 0 0 0-1.103-.166 2.332 2.332 0 0 0-1.14.255 1.549 1.549 0 0 0-.686.87c-.15.41-.225.98-.225 1.712 0 .939.148 1.659.444 2.161.297.503.792.754 1.487.754.452.015.9-.094 1.294-.316.296-.174.557-.4.771-.669l.14.852h1.282V.007h-1.623v1.485ZM31 6.496a1.77 1.77 0 0 1-.494.061.964.964 0 0 1-.521-.127.758.758 0 0 1-.296-.466 3.984 3.984 0 0 1-.093-.992 4.208 4.208 0 0 1 .098-1.052.753.753 0 0 1 .307-.477 1.08 1.08 0 0 1 .55-.122c.233-.004.466.026.69.089l.483.144v2.553c-.11.076-.213.143-.307.2a1.73 1.73 0 0 1-.417.189ZM35.68 0l-.702.004c-.322.002-.482.168-.48.497l.004.581c.002.33.164.493.486.49l.702-.004c.322-.002.481-.167.48-.496L36.165.49c-.002-.33-.164-.493-.486-.491ZM36.145 2.313l-1.612.01.034 5.482 1.613-.01-.035-5.482ZM39.623.79 37.989.8 38 2.306l-.946.056.006 1.009.949-.006.024 2.983c.003.476.143.844.419 1.106.275.26.658.39 1.148.387.132 0 .293-.01.483-.03.19-.02.38-.046.57-.08.163-.028.324-.068.482-.119l-.183-1.095-.702.004a.664.664 0 0 1-.456-.123.553.553 0 0 1-.14-.422l-.016-2.621 1.513-.01-.006-1.064-1.514.01-.01-1.503ZM46.226 2.388c-.41-.184-.956-.274-1.636-.27-.673.004-1.215.101-1.627.29-.402.179-.72.505-.888.91-.18.419-.268.979-.264 1.68.004.688.1 1.24.285 1.655.172.404.495.724.9.894.414.18.957.268 1.63.264.68-.004 1.224-.099 1.632-.284.4-.176.714-.501.878-.905.176-.418.263-.971.258-1.658-.004-.702-.097-1.261-.28-1.677a1.696 1.696 0 0 0-.888-.9Zm-.613 3.607a.77.77 0 0 1-.337.501 1.649 1.649 0 0 1-1.317.009.776.776 0 0 1-.343-.497 4.066 4.066 0 0 1-.105-1.02 4.136 4.136 0 0 1 .092-1.03.786.786 0 0 1 .337-.507 1.59 1.59 0 0 1 1.316-.008.79.79 0 0 1 .344.502c.078.337.113.683.105 1.03.012.343-.019.685-.092 1.02ZM52.114 2.07a2.67 2.67 0 0 0-1.128.278c-.39.191-.752.437-1.072.73l-.157-.846-1.273.008.036 5.572 1.623-.01-.024-3.78c.35-.124.646-.22.887-.286.26-.075.53-.114.8-.118l.45-.003.144-1.546-.286.001ZM22.083 7.426l-1.576-2.532a2.137 2.137 0 0 0-.172-.253 1.95 1.95 0 0 0-.304-.29.138.138 0 0 1 .042-.04 1.7 1.7 0 0 0 .328-.374l1.75-2.71c.01-.015.025-.028.024-.048-.01-.01-.021-.007-.031-.007L20.49 1.17a.078.078 0 0 0-.075.045l-.868 1.384c-.23.366-.46.732-.688 1.099a.108.108 0 0 1-.112.06c-.098-.005-.196-.001-.294-.002-.018 0-.038.006-.055-.007.002-.02.002-.039.005-.058a4.6 4.6 0 0 0 .046-.701V1.203c0-.02-.009-.032-.03-.03h-.033L16.93 1.17c-.084 0-.073-.01-.073.076v6.491c-.001.018.006.028.025.027h1.494c.083 0 .072.007.072-.071v-2.19c0-.055-.003-.11-.004-.166a3.366 3.366 0 0 0-.05-.417h.06c.104 0 .209.002.313-.002a.082.082 0 0 1 .084.05c.535.913 1.07 1.824 1.607 2.736a.104.104 0 0 0 .103.062c.554-.003 1.107-.002 1.66-.002l.069-.003-.019-.032-.188-.304ZM27.112 6.555c-.005-.08-.004-.08-.082-.08h-2.414c-.053 0-.106-.003-.159-.011a.279.279 0 0 1-.246-.209.558.558 0 0 1-.022-.15c0-.382 0-.762-.002-1.143 0-.032.007-.049.042-.044h2.504c.029.003.037-.012.034-.038V3.814c0-.089.013-.078-.076-.078h-2.44c-.07 0-.062.003-.062-.06v-.837c0-.047.004-.093.013-.14a.283.283 0 0 1 .241-.246.717.717 0 0 1 .146-.011h2.484c.024.002.035-.009.036-.033l.003-.038.03-.496c.01-.183.024-.365.034-.548.005-.085.003-.087-.082-.094-.218-.018-.437-.038-.655-.05a17.845 17.845 0 0 0-.657-.026 72.994 72.994 0 0 0-1.756-.016 1.7 1.7 0 0 0-.471.064 1.286 1.286 0 0 0-.817.655c-.099.196-.149.413-.145.633v3.875c0 .072.003.144.011.216a1.27 1.27 0 0 0 .711 1.029c.228.113.48.167.734.158.757-.005 1.515.002 2.272-.042.274-.016.548-.034.82-.053.03-.002.043-.008.04-.041-.008-.104-.012-.208-.019-.312a69.964 69.964 0 0 1-.05-.768ZM16.14 7.415l-.127-1.075c-.004-.03-.014-.04-.044-.037a13.125 13.125 0 0 1-.998.073c-.336.01-.672.02-1.008.016-.116-.001-.233-.014-.347-.039a.746.746 0 0 1-.45-.262c-.075-.1-.132-.211-.167-.33a3.324 3.324 0 0 1-.126-.773 9.113 9.113 0 0 1-.015-.749c0-.285.022-.57.065-.852.023-.158.066-.312.127-.46a.728.728 0 0 1 .518-.443 1.64 1.64 0 0 1 .397-.048c.628-.001 1.255.003 1.882.05.022.001.033-.006.036-.026l.003-.031.06-.55c.019-.177.036-.355.057-.532.004-.034-.005-.046-.04-.056a5.595 5.595 0 0 0-1.213-.21 10.783 10.783 0 0 0-.708-.02c-.24-.003-.48.01-.719.041a3.477 3.477 0 0 0-.625.14 1.912 1.912 0 0 0-.807.497c-.185.2-.33.433-.424.688a4.311 4.311 0 0 0-.24 1.096c-.031.286-.045.572-.042.86-.006.43.024.86.091 1.286.04.25.104.497.193.734.098.279.26.53.473.734.214.205.473.358.756.446.344.11.702.17 1.063.177a8.505 8.505 0 0 0 1.578-.083 6.11 6.11 0 0 0 .766-.18c.03-.008.047-.023.037-.057a.157.157 0 0 1-.003-.025Z"/><path fill="#AFE229" d="M6.016 6.69a1.592 1.592 0 0 0-.614.21c-.23.132-.422.32-.56.546-.044.072-.287.539-.287.539l-.836 1.528.009.006c.038.025.08.046.123.063.127.046.26.07.395.073.505.023 1.011-.007 1.517-.003.29.009.58.002.869-.022a.886.886 0 0 0 .395-.116.962.962 0 0 0 .312-.286c.056-.083.114-.163.164-.249.24-.408.48-.816.718-1.226.075-.128.148-.257.222-.386l.112-.192a1.07 1.07 0 0 0 .153-.518l-1.304.023s-1.258-.005-1.388.01Z"/><path fill="#771BFF" d="m2.848 9.044.76-1.39.184-.352c-.124-.067-.245-.14-.367-.21-.346-.204-.706-.384-1.045-.6a.984.984 0 0 1-.244-.207c-.108-.134-.136-.294-.144-.46-.021-.409-.002-.818-.009-1.227-.003-.195 0-.39.003-.585.004-.322.153-.553.427-.713l.833-.488c.22-.13.44-.257.662-.385.05-.029.105-.052.158-.077.272-.128.519-.047.76.085l.044.028c.123.06.242.125.358.196.318.178.635.357.952.537.095.056.187.117.275.184.194.144.254.35.266.578.016.284.007.569.006.853-.001.28.004.558 0 .838.592-.003 1.259 0 1.259 0l.723-.013c-.003-.292-.007-.584-.007-.876 0-.524.015-1.048-.016-1.571-.024-.42-.135-.8-.492-1.067a5.02 5.02 0 0 0-.506-.339A400.52 400.52 0 0 0 5.94.787C5.722.664 5.513.524 5.282.423 5.255.406 5.228.388 5.2.373 4.758.126 4.305-.026 3.807.21c-.097.046-.197.087-.29.14A699.896 699.896 0 0 0 .783 1.948c-.501.294-.773.717-.778 1.31-.004.36-.009.718-.001 1.077.016.754-.017 1.508.024 2.261.016.304.07.6.269.848.127.15.279.28.448.382.622.4 1.283.734 1.92 1.11l.183.109Z"/></svg>
`;
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const lI = 53, cI = 10, uI = 50, dI = 350, hI = "Powered by";
class fI extends Le() {
  /**
   * Creates a "powered by" helper for a given editor. The feature is initialized on Editor#ready
   * event.
   *
   * @param editor
   */
  constructor(e) {
    super(), this.editor = e, this._balloonView = null, this._lastFocusedEditableElement = null, this._showBalloonThrottled = Xn(this._showBalloon.bind(this), 50, { leading: !0 }), e.on("ready", this._handleEditorReady.bind(this));
  }
  /**
   * Destroys the "powered by" helper along with its view.
   */
  destroy() {
    const e = this._balloonView;
    e && (e.unpin(), this._balloonView = null), this._showBalloonThrottled.cancel(), this.stopListening();
  }
  /**
   * Enables "powered by" label once the editor (ui) is ready.
   */
  _handleEditorReady() {
    const e = this.editor, t = !!e.config.get("ui.poweredBy.forceVisible");
    /* istanbul ignore next -- @preserve */
    !t && zC(e.config.get("licenseKey")) === "VALID" || e.ui.view && (e.ui.focusTracker.on("change:isFocused", (n, s, o) => {
      this._updateLastFocusedEditableElement(), o ? this._showBalloon() : this._hideBalloon();
    }), e.ui.focusTracker.on("change:focusedElement", (n, s, o) => {
      this._updateLastFocusedEditableElement(), o && this._showBalloon();
    }), e.ui.on("update", () => {
      this._showBalloonThrottled();
    }));
  }
  /**
   * Creates an instance of the {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView balloon panel}
   * with the "powered by" view inside ready for positioning.
   */
  _createBalloonView() {
    const e = this.editor, t = this._balloonView = new Ce(), n = Gg(e), s = new mI(e.locale, n.label);
    t.content.add(s), t.set({
      class: "ck-powered-by-balloon"
    }), e.ui.view.body.add(t), e.ui.focusTracker.add(t.element), this._balloonView = t;
  }
  /**
   * Attempts to display the balloon with the "powered by" view.
   */
  _showBalloon() {
    if (!this._lastFocusedEditableElement)
      return;
    const e = gI(this.editor, this._lastFocusedEditableElement);
    e && (this._balloonView || this._createBalloonView(), this._balloonView.pin(e));
  }
  /**
   * Hides the "powered by" balloon if already visible.
   */
  _hideBalloon() {
    this._balloonView && this._balloonView.unpin();
  }
  /**
   * Updates the {@link #_lastFocusedEditableElement} based on the state of the global focus tracker.
   */
  _updateLastFocusedEditableElement() {
    const e = this.editor, t = e.ui.focusTracker.isFocused, n = e.ui.focusTracker.focusedElement;
    if (!t || !n) {
      this._lastFocusedEditableElement = null;
      return;
    }
    const s = Array.from(e.ui.getEditableElementsNames()).map((o) => e.ui.getEditableElement(o));
    s.includes(n) ? this._lastFocusedEditableElement = n : this._lastFocusedEditableElement = s[0];
  }
}
class mI extends T {
  /**
   * Created an instance of the "powered by" view.
   *
   * @param locale The localization services instance.
   * @param label The label text.
   */
  constructor(e, t) {
    super(e);
    const n = new ut(), s = this.bindTemplate;
    n.set({
      content: aI,
      isColorInherited: !1
    }), n.extendTemplate({
      attributes: {
        style: {
          width: lI + "px",
          height: cI + "px"
        }
      }
    }), this.setTemplate({
      tag: "div",
      attributes: {
        class: ["ck", "ck-powered-by"],
        "aria-hidden": !0
      },
      children: [
        {
          tag: "a",
          attributes: {
            href: "https://ckeditor.com/?utm_source=ckeditor&utm_medium=referral&utm_campaign=701Dn000000hVgmIAE_powered_by_ckeditor_logo",
            target: "_blank",
            tabindex: "-1"
          },
          children: [
            ...t ? [
              {
                tag: "span",
                attributes: {
                  class: ["ck", "ck-powered-by__label"]
                },
                children: [t]
              }
            ] : [],
            n
          ],
          on: {
            dragstart: s.to((o) => o.preventDefault())
          }
        }
      ]
    });
  }
}
function gI(i, e) {
  const t = Gg(i), n = t.side === "right" ? pI(e, t) : bI(e, t);
  return {
    target: e,
    positions: [n]
  };
}
function pI(i, e) {
  return qg(i, e, (t, n) => t.left + t.width - n.width - e.horizontalOffset);
}
function bI(i, e) {
  return qg(i, e, (t) => t.left + e.horizontalOffset);
}
function qg(i, e, t) {
  return (n, s) => {
    const o = new B(i);
    if (o.width < dI || o.height < uI)
      return null;
    let r;
    e.position === "inside" ? r = o.bottom - s.height : r = o.bottom - s.height / 2, r -= e.verticalOffset;
    const a = t(o, s), c = n.clone().moveTo(a, r).getIntersection(s.clone().moveTo(a, r)).getVisible();
    return !c || c.getArea() < s.getArea() ? null : {
      top: r,
      left: a,
      name: `position_${e.position}-side_${e.side}`,
      config: {
        withArrow: !1
      }
    };
  };
}
function Gg(i) {
  const e = i.config.get("ui.poweredBy"), t = e && e.position || "border";
  return {
    position: t,
    label: hI,
    verticalOffset: t === "inside" ? 5 : 0,
    horizontalOffset: 5,
    side: i.locale.contentLanguageDirection === "ltr" ? "right" : "left",
    ...e
  };
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const fd = {
  POLITE: "polite",
  ASSERTIVE: "assertive"
};
class wI {
  /**
   * @inheritDoc
   */
  constructor(e) {
    this.editor = e, e.once("ready", () => {
      for (const t of Object.values(fd))
        this.announce("", t);
    });
  }
  /**
   * Sets an announcement text to an aria region that is then announced by a screen reader to the user.
   *
   * If the aria region of a specified politeness does not exist, it will be created and can be re-used later.
   *
   * The default announcement politeness level is `'polite'`.
   *
   * ```ts
   * // Most screen readers will queue announcements from multiple aria-live regions and read them out in the order they were emitted.
   * editor.ui.ariaLiveAnnouncer.announce( 'Image uploaded.' );
   * editor.ui.ariaLiveAnnouncer.announce( 'Connection lost. Reconnecting.' );
   * ```
   */
  announce(e, t = fd.POLITE) {
    const n = this.editor;
    if (!n.ui.view)
      return;
    this.view || (this.view = new _I(n.locale), n.ui.view.body.add(this.view));
    const { politeness: s, isUnsafeHTML: o } = typeof t == "string" ? {
      politeness: t
    } : t;
    let r = this.view.regionViews.find((a) => a.politeness === s);
    r || (r = new vI(n, s), this.view.regionViews.add(r)), r.announce({
      announcement: e,
      isUnsafeHTML: o
    });
  }
}
class _I extends T {
  constructor(e) {
    super(e), this.regionViews = this.createCollection(), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-aria-live-announcer"
        ]
      },
      children: this.regionViews
    });
  }
}
class vI extends T {
  constructor(e, t) {
    super(e.locale), this.setTemplate({
      tag: "div",
      attributes: {
        role: "region",
        "aria-live": t,
        "aria-relevant": "additions"
      },
      children: [
        {
          tag: "ul",
          attributes: {
            class: [
              "ck",
              "ck-aria-live-region-list"
            ]
          }
        }
      ]
    }), e.on("destroy", () => {
      this._pruneAnnouncementsInterval !== null && (clearInterval(this._pruneAnnouncementsInterval), this._pruneAnnouncementsInterval = null);
    }), this.politeness = t, this._domConverter = e.data.htmlProcessor.domConverter, this._pruneAnnouncementsInterval = setInterval(() => {
      this.element && this._listElement.firstChild && this._listElement.firstChild.remove();
    }, 5e3);
  }
  /**
   * Appends new announcement to region.
   */
  announce({ announcement: e, isUnsafeHTML: t }) {
    if (!e.trim().length)
      return;
    const n = document.createElement("li");
    t ? this._domConverter.setContentOf(n, e) : n.innerText = e, this._listElement.appendChild(n);
  }
  /**
   * Return current announcements list HTML element.
   */
  get _listElement() {
    return this.element.querySelector("ul");
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class yI extends U() {
  /**
   * Creates an instance of the editor UI class.
   *
   * @param editor The editor instance.
   */
  constructor(e) {
    super(), this.isReady = !1, this._editableElementsMap = /* @__PURE__ */ new Map(), this._focusableToolbarDefinitions = [];
    const t = e.editing.view;
    this.editor = e, this.componentFactory = new eI(e), this.focusTracker = new X(), this.tooltipManager = new pe(e), this.poweredBy = new fI(e), this.ariaLiveAnnouncer = new wI(e), this.set("viewportOffset", this._readViewportOffsetFromConfig()), this.once("ready", () => {
      this.isReady = !0;
    }), this.listenTo(t.document, "layoutChanged", this.update.bind(this)), this.listenTo(t, "scrollToTheSelection", this._handleScrollToTheSelection.bind(this)), this._initFocusTracking();
  }
  /**
   * The main (outermost) DOM element of the editor UI.
   *
   * For example, in {@link module:editor-classic/classiceditor~ClassicEditor} it is a `<div>` which
   * wraps the editable element and the toolbar. In {@link module:editor-inline/inlineeditor~InlineEditor}
   * it is the editable element itself (as there is no other wrapper). However, in
   * {@link module:editor-decoupled/decouplededitor~DecoupledEditor} it is set to `null` because this editor does not
   * come with a single "main" HTML element (its editable element and toolbar are separate).
   *
   * This property can be understood as a shorthand for retrieving the element that a specific editor integration
   * considers to be its main DOM element.
   */
  get element() {
    return null;
  }
  /**
   * Fires the {@link module:ui/editorui/editorui~EditorUI#event:update `update`} event.
   *
   * This method should be called when the editor UI (e.g. positions of its balloons) needs to be updated due to
   * some environmental change which CKEditor 5 is not aware of (e.g. resize of a container in which it is used).
   */
  update() {
    this.fire("update");
  }
  /**
   * Destroys the UI.
   */
  destroy() {
    this.stopListening(), this.focusTracker.destroy(), this.tooltipManager.destroy(this.editor), this.poweredBy.destroy();
    for (const e of this._editableElementsMap.values())
      e.ckeditorInstance = null, this.editor.keystrokes.stopListening(e);
    this._editableElementsMap = /* @__PURE__ */ new Map(), this._focusableToolbarDefinitions = [];
  }
  /**
   * Stores the native DOM editable element used by the editor under a unique name.
   *
   * Also, registers the element in the editor to maintain the accessibility of the UI. When the user is editing text in a focusable
   * editable area, they can use the <kbd>Alt</kbd> + <kbd>F10</kbd> keystroke to navigate over editor toolbars. See {@link #addToolbar}.
   *
   * @param rootName The unique name of the editable element.
   * @param domElement The native DOM editable element.
   */
  setEditableElement(e, t) {
    this._editableElementsMap.set(e, t), t.ckeditorInstance || (t.ckeditorInstance = this.editor), this.focusTracker.add(t);
    const n = () => {
      this.editor.editing.view.getDomRoot(e) || this.editor.keystrokes.listenTo(t);
    };
    this.isReady ? n() : this.once("ready", n);
  }
  /**
   * Removes the editable from the editor UI. Removes all handlers added by {@link #setEditableElement}.
   *
   * @param rootName The name of the editable element to remove.
   */
  removeEditableElement(e) {
    const t = this._editableElementsMap.get(e);
    t && (this._editableElementsMap.delete(e), this.editor.keystrokes.stopListening(t), this.focusTracker.remove(t), t.ckeditorInstance = null);
  }
  /**
   * Returns the editable editor element with the given name or null if editable does not exist.
   *
   * @param rootName The editable name.
   */
  getEditableElement(e = "main") {
    return this._editableElementsMap.get(e);
  }
  /**
   * Returns array of names of all editor editable elements.
   */
  getEditableElementsNames() {
    return this._editableElementsMap.keys();
  }
  /**
   * Adds a toolbar to the editor UI. Used primarily to maintain the accessibility of the UI.
   *
   * Focusable toolbars can be accessed (focused) by users by pressing the <kbd>Alt</kbd> + <kbd>F10</kbd> keystroke.
   * Successive keystroke presses navigate over available toolbars.
   *
   * @param toolbarView A instance of the toolbar to be registered.
   */
  addToolbar(e, t = {}) {
    e.isRendered ? (this.focusTracker.add(e.element), this.editor.keystrokes.listenTo(e.element)) : e.once("render", () => {
      this.focusTracker.add(e.element), this.editor.keystrokes.listenTo(e.element);
    }), this._focusableToolbarDefinitions.push({ toolbarView: e, options: t });
  }
  /**
   * Stores all editable elements used by the editor instance.
   *
   * @deprecated
   */
  get _editableElements() {
    return console.warn("editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", { editorUI: this }), this._editableElementsMap;
  }
  /**
   * Returns viewport offsets object:
   *
   * ```js
   * {
   * 	top: Number,
   * 	right: Number,
   * 	bottom: Number,
   * 	left: Number
   * }
   * ```
   *
   * Only top property is currently supported.
   */
  _readViewportOffsetFromConfig() {
    const e = this.editor, t = e.config.get("ui.viewportOffset");
    if (t)
      return t;
    const n = e.config.get("toolbar.viewportTopOffset");
    return n ? (console.warn("editor-ui-deprecated-viewport-offset-config: The `toolbar.vieportTopOffset` configuration option is deprecated. It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead."), { top: n }) : { top: 0 };
  }
  /**
   * Starts listening for <kbd>Alt</kbd> + <kbd>F10</kbd> and <kbd>Esc</kbd> keystrokes in the context of focusable
   * {@link #setEditableElement editable elements} and {@link #addToolbar toolbars}
   * to allow users navigate across the UI.
   */
  _initFocusTracking() {
    const e = this.editor, t = e.editing.view;
    let n, s;
    e.keystrokes.set("Alt+F10", (o, r) => {
      const a = this.focusTracker.focusedElement;
      Array.from(this._editableElementsMap.values()).includes(a) && !Array.from(t.domRoots.values()).includes(a) && (n = a);
      const l = this._getCurrentFocusedToolbarDefinition();
      (!l || !s) && (s = this._getFocusableCandidateToolbarDefinitions());
      for (let c = 0; c < s.length; c++) {
        const u = s.shift();
        if (s.push(u), u !== l && this._focusFocusableCandidateToolbar(u)) {
          l && l.options.afterBlur && l.options.afterBlur();
          break;
        }
      }
      r();
    }), e.keystrokes.set("Esc", (o, r) => {
      const a = this._getCurrentFocusedToolbarDefinition();
      a && (n ? (n.focus(), n = null) : e.editing.view.focus(), a.options.afterBlur && a.options.afterBlur(), r());
    });
  }
  /**
   * Returns definitions of toolbars that could potentially be focused, sorted by their importance for the user.
   *
   * Focusable toolbars candidates are either:
   * * already visible,
   * * have `beforeFocus()` set in their {@link module:ui/editorui/editorui~FocusableToolbarDefinition definition} that suggests that
   * they might show up when called. Keep in mind that determining whether a toolbar will show up (and become focusable) is impossible
   * at this stage because it depends on its implementation, that in turn depends on the editing context (selection).
   *
   * **Note**: Contextual toolbars take precedence over regular toolbars.
   */
  _getFocusableCandidateToolbarDefinitions() {
    const e = [];
    for (const t of this._focusableToolbarDefinitions) {
      const { toolbarView: n, options: s } = t;
      (mn(n.element) || s.beforeFocus) && e.push(t);
    }
    return e.sort((t, n) => md(t) - md(n)), e;
  }
  /**
   * Returns a definition of the toolbar that is currently visible and focused (one of its children has focus).
   *
   * `null` is returned when no toolbar is currently focused.
   */
  _getCurrentFocusedToolbarDefinition() {
    for (const e of this._focusableToolbarDefinitions)
      if (e.toolbarView.element && e.toolbarView.element.contains(this.focusTracker.focusedElement))
        return e;
    return null;
  }
  /**
   * Focuses a focusable toolbar candidate using its definition.
   *
   * @param candidateToolbarDefinition A definition of the toolbar to focus.
   * @returns `true` when the toolbar candidate was focused. `false` otherwise.
   */
  _focusFocusableCandidateToolbar(e) {
    const { toolbarView: t, options: { beforeFocus: n } } = e;
    return n && n(), mn(t.element) ? (t.focus(), !0) : !1;
  }
  /**
   * Provides an integration between {@link #viewportOffset} and {@link module:utils/dom/scroll~scrollViewportToShowTarget}.
   * It allows the UI-agnostic engine method to consider user-configured viewport offsets specific for the integration.
   *
   * @param evt The `scrollToTheSelection` event info.
   * @param data The payload carried by the `scrollToTheSelection` event.
   */
  _handleScrollToTheSelection(e, t) {
    const n = {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      ...this.viewportOffset
    };
    t.viewportOffset.top += n.top, t.viewportOffset.bottom += n.bottom, t.viewportOffset.left += n.left, t.viewportOffset.right += n.right;
  }
}
function md(i) {
  const { toolbarView: e, options: t } = i;
  let n = 10;
  return mn(e.element) && n--, t.isContextual && n--, n;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class CI extends T {
  /**
   * Creates an instance of the editor UI view class.
   *
   * @param locale The locale instance.
   */
  constructor(e) {
    super(e), this.body = new UA(e);
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.body.attachToDom();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    return this.body.detachFromDom(), super.destroy();
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class kI extends CI {
  /**
   * Creates an instance of the boxed editor UI view class.
   *
   * @param locale The locale instance..
   */
  constructor(e) {
    super(e), this.top = this.createCollection(), this.main = this.createCollection(), this._voiceLabelView = this._createVoiceLabel(), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-reset",
          "ck-editor",
          "ck-rounded-corners"
        ],
        role: "application",
        dir: e.uiLanguageDirection,
        lang: e.uiLanguage,
        "aria-labelledby": this._voiceLabelView.id
      },
      children: [
        this._voiceLabelView,
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-editor__top",
              "ck-reset_all"
            ],
            role: "presentation"
          },
          children: this.top
        },
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-editor__main"
            ],
            role: "presentation"
          },
          children: this.main
        }
      ]
    });
  }
  /**
   * Creates a voice label view instance.
   */
  _createVoiceLabel() {
    const e = this.t, t = new ze();
    return t.text = e("Rich Text Editor"), t.extendTemplate({
      attributes: {
        class: "ck-voice-label"
      }
    }), t;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class TI extends T {
  /**
   * Creates an instance of EditableUIView class.
   *
   * @param locale The locale instance.
   * @param editingView The editing view instance the editable is related to.
   * @param editableElement The editable element. If not specified, this view
   * should create it. Otherwise, the existing element should be used.
   */
  constructor(e, t, n) {
    super(e), this.name = null, this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-content",
          "ck-editor__editable",
          "ck-rounded-corners"
        ],
        lang: e.contentLanguage,
        dir: e.contentLanguageDirection
      }
    }), this.set("isFocused", !1), this._editableElement = n, this._hasExternalElement = !!this._editableElement, this._editingView = t;
  }
  /**
   * Renders the view by either applying the {@link #template} to the existing
   * {@link module:ui/editableui/editableuiview~EditableUIView#_editableElement} or assigning {@link #element}
   * as {@link module:ui/editableui/editableuiview~EditableUIView#_editableElement}.
   */
  render() {
    super.render(), this._hasExternalElement ? this.template.apply(this.element = this._editableElement) : this._editableElement = this.element, this.on("change:isFocused", () => this._updateIsFocusedClasses()), this._updateIsFocusedClasses();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    this._hasExternalElement && this.template.revert(this._editableElement), super.destroy();
  }
  /**
   * Whether an external {@link #_editableElement} was passed into the constructor, which also means
   * the view will not render its {@link #template}.
   */
  get hasExternalElement() {
    return this._hasExternalElement;
  }
  /**
   * Updates the `ck-focused` and `ck-blurred` CSS classes on the {@link #element} according to
   * the {@link #isFocused} property value using the {@link #_editingView editing view} API.
   */
  _updateIsFocusedClasses() {
    const e = this._editingView;
    e.isRenderingInProgress ? n(this) : t(this);
    function t(s) {
      e.change((o) => {
        const r = e.document.getRoot(s.name);
        o.addClass(s.isFocused ? "ck-focused" : "ck-blurred", r), o.removeClass(s.isFocused ? "ck-blurred" : "ck-focused", r);
      });
    }
    function n(s) {
      e.once("change:isRenderingInProgress", (o, r, a) => {
        a ? n(s) : t(s);
      });
    }
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class EI extends TI {
  /**
   * Creates an instance of the InlineEditableUIView class.
   *
   * @param locale The locale instance.
   * @param editingView The editing view instance the editable is related to.
   * @param editableElement The editable element. If not specified, the
   * {@link module:ui/editableui/editableuiview~EditableUIView}
   * will create it. Otherwise, the existing element will be used.
   * @param options Additional configuration of the view.
   * @param options.label A function that gets called with the instance of this view as an argument
   * and should return a string that represents the label of the editable for assistive technologies. If not provided,
   * a default label generator is used.
   */
  constructor(e, t, n, s = {}) {
    super(e, t, n);
    const o = e.t;
    this.extendTemplate({
      attributes: {
        role: "textbox",
        class: "ck-editor__editable_inline"
      }
    }), this._generateLabel = s.label || (() => o("Editor editing area: %0", this.name));
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    const e = this._editingView;
    e.change((t) => {
      const n = e.document.getRoot(this.name);
      t.setAttribute("aria-label", this._generateLabel(this), n);
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class gd extends jo {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Notification";
  }
  /**
   * @inheritDoc
   */
  init() {
    this.on("show:warning", (e, t) => {
      window.alert(t.message);
    }, { priority: "lowest" });
  }
  /**
   * Shows a success notification.
   *
   * By default, it fires the {@link #event:show:success `show:success` event} with the given `data`. The event namespace can be extended
   * using the `data.namespace` option. For example:
   *
   * ```ts
   * showSuccess( 'Image is uploaded.', {
   * 	namespace: 'upload:image'
   * } );
   * ```
   *
   * will fire the `show:success:upload:image` event.
   *
   * You can provide the title of the notification:
   *
   * ```ts
   * showSuccess( 'Image is uploaded.', {
   * 	title: 'Image upload success'
   * } );
   * ```
   *
   * @param message The content of the notification.
   * @param data Additional data.
   * @param data.namespace Additional event namespace.
   * @param data.title The title of the notification.
   */
  showSuccess(e, t = {}) {
    this._showNotification({
      message: e,
      type: "success",
      namespace: t.namespace,
      title: t.title
    });
  }
  /**
   * Shows an information notification.
   *
   * By default, it fires the {@link #event:show:info `show:info` event} with the given `data`. The event namespace can be extended
   * using the `data.namespace` option. For example:
   *
   * ```ts
   * showInfo( 'Editor is offline.', {
   * 	namespace: 'editor:status'
   * } );
   * ```
   *
   * will fire the `show:info:editor:status` event.
   *
   * You can provide the title of the notification:
   *
   * ```ts
   * showInfo( 'Editor is offline.', {
   * 	title: 'Network information'
   * } );
   * ```
   *
   * @param message The content of the notification.
   * @param data Additional data.
   * @param data.namespace Additional event namespace.
   * @param data.title The title of the notification.
   */
  showInfo(e, t = {}) {
    this._showNotification({
      message: e,
      type: "info",
      namespace: t.namespace,
      title: t.title
    });
  }
  /**
   * Shows a warning notification.
   *
   * By default, it fires the {@link #event:show:warning `show:warning` event}
   * with the given `data`. The event namespace can be extended using the `data.namespace` option. For example:
   *
   * ```ts
   * showWarning( 'Image upload error.', {
   * 	namespace: 'upload:image'
   * } );
   * ```
   *
   * will fire the `show:warning:upload:image` event.
   *
   * You can provide the title of the notification:
   *
   * ```ts
   * showWarning( 'Image upload error.', {
   * 	title: 'Upload failed'
   * } );
   * ```
   *
   * Note that each unhandled and not stopped `warning` notification will be displayed as a system alert.
   * The plugin responsible for displaying warnings should `stop()` the event to prevent displaying it as an alert:
   *
   * ```ts
   * notifications.on( 'show:warning', ( evt, data ) => {
   * 	// Do something with the data.
   *
   * 	// Stop this event to prevent displaying it as an alert.
   * 	evt.stop();
   * } );
   * ```
   *
   * You can attach many listeners to the same event and `stop()` this event in a listener with a low priority:
   *
   * ```ts
   * notifications.on( 'show:warning', ( evt, data ) => {
   * 	// Show the warning in the UI, but do not stop it.
   * } );
   *
   * notifications.on( 'show:warning', ( evt, data ) => {
   * 	// Log the warning to some error tracker.
   *
   * 	// Stop this event to prevent displaying it as an alert.
   * 	evt.stop();
   * }, { priority: 'low' } );
   * ```
   *
   * @param message The content of the notification.
   * @param data Additional data.
   * @param data.namespace Additional event namespace.
   * @param data.title The title of the notification.
   */
  showWarning(e, t = {}) {
    this._showNotification({
      message: e,
      type: "warning",
      namespace: t.namespace,
      title: t.title
    });
  }
  /**
   * Fires the `show` event with the specified type, namespace and message.
   *
   * @param data The message data.
   * @param data.message The content of the notification.
   * @param data.type The type of the message.
   * @param data.namespace Additional event namespace.
   * @param data.title The title of the notification.
   */
  _showNotification(e) {
    const t = e.namespace ? `show:${e.type}:${e.namespace}` : `show:${e.type}`;
    this.fire(t, {
      message: e.message,
      type: e.type,
      title: e.title || ""
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class $t extends U() {
  /**
   * Creates a new Model instance.
   *
   * @param attributes The model state attributes to be defined during the instance creation.
   * @param properties The (out of state) properties to be appended to the instance during creation.
   */
  constructor(e, t) {
    super(), t && kf(this, t), e && this.set(e);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Ds = di("px");
class Rt extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ContextualBalloon";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this._viewToStack = /* @__PURE__ */ new Map(), this._idToStack = /* @__PURE__ */ new Map(), this._view = null, this._rotatorView = null, this._fakePanelsView = null, this.positionLimiter = () => {
      const t = this.editor.editing.view, s = t.document.selection.editableElement;
      return s ? t.domConverter.mapViewToDom(s.root) : null;
    }, this.set("visibleView", null), this.set("_numberOfStacks", 0), this.set("_singleViewMode", !1);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this._view && this._view.destroy(), this._rotatorView && this._rotatorView.destroy(), this._fakePanelsView && this._fakePanelsView.destroy();
  }
  /**
   * The common balloon panel view.
   */
  get view() {
    return this._view || this._createPanelView(), this._view;
  }
  /**
   * Returns `true` when the given view is in one of the stacks. Otherwise returns `false`.
   */
  hasView(e) {
    return Array.from(this._viewToStack.keys()).includes(e);
  }
  /**
   * Adds a new view to the stack and makes it visible if the current stack is visible
   * or it is the first view in the balloon.
   *
   * @param data The configuration of the view.
   * @param data.stackId The ID of the stack that the view is added to. Defaults to `'main'`.
   * @param data.view The content of the balloon.
   * @param data.position Positioning options.
   * @param data.balloonClassName An additional CSS class added to the {@link #view balloon} when visible.
   * @param data.withArrow Whether the {@link #view balloon} should be rendered with an arrow. Defaults to `true`.
   * @param data.singleViewMode Whether the view should be the only visible view even if other stacks were added. Defaults to `false`.
   */
  add(e) {
    if (this._view || this._createPanelView(), this.hasView(e.view))
      throw new g("contextualballoon-add-view-exist", [this, e]);
    const t = e.stackId || "main";
    if (!this._idToStack.has(t)) {
      this._idToStack.set(t, /* @__PURE__ */ new Map([[e.view, e]])), this._viewToStack.set(e.view, this._idToStack.get(t)), this._numberOfStacks = this._idToStack.size, (!this._visibleStack || e.singleViewMode) && this.showStack(t);
      return;
    }
    const n = this._idToStack.get(t);
    e.singleViewMode && this.showStack(t), n.set(e.view, e), this._viewToStack.set(e.view, n), n === this._visibleStack && this._showView(e);
  }
  /**
   * Removes the given view from the stack. If the removed view was visible,
   * the view preceding it in the stack will become visible instead.
   * When there is no view in the stack, the next stack will be displayed.
   * When there are no more stacks, the balloon will hide.
   *
   * @param view A view to be removed from the balloon.
   */
  remove(e) {
    if (!this.hasView(e))
      throw new g("contextualballoon-remove-view-not-exist", [this, e]);
    const t = this._viewToStack.get(e);
    this._singleViewMode && this.visibleView === e && (this._singleViewMode = !1), this.visibleView === e && (t.size === 1 ? this._idToStack.size > 1 ? this._showNextStack() : (this.view.hide(), this.visibleView = null, this._rotatorView.hideView()) : this._showView(Array.from(t.values())[t.size - 2])), t.size === 1 ? (this._idToStack.delete(this._getStackId(t)), this._numberOfStacks = this._idToStack.size) : t.delete(e), this._viewToStack.delete(e);
  }
  /**
   * Updates the position of the balloon using the position data of the first visible view in the stack.
   * When new position data is given, the position data of the currently visible view will be updated.
   *
   * @param position Position options.
   */
  updatePosition(e) {
    e && (this._visibleStack.get(this.visibleView).position = e), this.view.pin(this._getBalloonPosition()), this._fakePanelsView.updatePosition();
  }
  /**
   * Shows the last view from the stack of a given ID.
   */
  showStack(e) {
    this.visibleStack = e;
    const t = this._idToStack.get(e);
    if (!t)
      throw new g("contextualballoon-showstack-stack-not-exist", this);
    this._visibleStack !== t && this._showView(Array.from(t.values()).pop());
  }
  /**
   * Initializes view instances.
   */
  _createPanelView() {
    this._view = new Ce(this.editor.locale), this.editor.ui.view.body.add(this._view), this.editor.ui.focusTracker.add(this._view.element), this._rotatorView = this._createRotatorView(), this._fakePanelsView = this._createFakePanelsView();
  }
  /**
   * Returns the stack of the currently visible view.
   */
  get _visibleStack() {
    return this._viewToStack.get(this.visibleView);
  }
  /**
   * Returns the ID of the given stack.
   */
  _getStackId(e) {
    return Array.from(this._idToStack.entries()).find((n) => n[1] === e)[0];
  }
  /**
   * Shows the last view from the next stack.
   */
  _showNextStack() {
    const e = Array.from(this._idToStack.values());
    let t = e.indexOf(this._visibleStack) + 1;
    e[t] || (t = 0), this.showStack(this._getStackId(e[t]));
  }
  /**
   * Shows the last view from the previous stack.
   */
  _showPrevStack() {
    const e = Array.from(this._idToStack.values());
    let t = e.indexOf(this._visibleStack) - 1;
    e[t] || (t = e.length - 1), this.showStack(this._getStackId(e[t]));
  }
  /**
   * Creates a rotator view.
   */
  _createRotatorView() {
    const e = new AI(this.editor.locale), t = this.editor.locale.t;
    return this.view.content.add(e), e.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", (n, s) => !s && n > 1), e.on("change:isNavigationVisible", () => this.updatePosition(), { priority: "low" }), e.bind("counter").to(this, "visibleView", this, "_numberOfStacks", (n, s) => {
      if (s < 2)
        return "";
      const o = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
      return t("%0 of %1", [o, s]);
    }), e.buttonNextView.on("execute", () => {
      e.focusTracker.isFocused && this.editor.editing.view.focus(), this._showNextStack();
    }), e.buttonPrevView.on("execute", () => {
      e.focusTracker.isFocused && this.editor.editing.view.focus(), this._showPrevStack();
    }), e;
  }
  /**
   * Creates a fake panels view.
   */
  _createFakePanelsView() {
    const e = new xI(this.editor.locale, this.view);
    return e.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", (t, n) => !n && t >= 2 ? Math.min(t - 1, 2) : 0), e.listenTo(this.view, "change:top", () => e.updatePosition()), e.listenTo(this.view, "change:left", () => e.updatePosition()), this.editor.ui.view.body.add(e), e;
  }
  /**
   * Sets the view as the content of the balloon and attaches the balloon using position
   * options of the first view.
   *
   * @param data Configuration.
   * @param data.view The view to show in the balloon.
   * @param data.balloonClassName Additional class name which will be added to the {@link #view balloon}.
   * @param data.withArrow Whether the {@link #view balloon} should be rendered with an arrow.
   */
  _showView({ view: e, balloonClassName: t = "", withArrow: n = !0, singleViewMode: s = !1 }) {
    this.view.class = t, this.view.withArrow = n, this._rotatorView.showView(e), this.visibleView = e, this.view.pin(this._getBalloonPosition()), this._fakePanelsView.updatePosition(), s && (this._singleViewMode = !0);
  }
  /**
   * Returns position options of the last view in the stack.
   * This keeps the balloon in the same position when the view is changed.
   */
  _getBalloonPosition() {
    let e = Array.from(this._visibleStack.values()).pop().position;
    return e && (e.limiter || (e = Object.assign({}, e, {
      limiter: this.positionLimiter
    })), e = Object.assign({}, e, {
      viewportOffsetConfig: this.editor.ui.viewportOffset
    })), e;
  }
}
class AI extends T {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e);
    const t = e.t, n = this.bindTemplate;
    this.set("isNavigationVisible", !0), this.focusTracker = new X(), this.buttonPrevView = this._createButtonView(t("Previous"), A.previousArrow), this.buttonNextView = this._createButtonView(t("Next"), A.nextArrow), this.content = this.createCollection(), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-balloon-rotator"
        ],
        "z-index": "-1"
      },
      children: [
        {
          tag: "div",
          attributes: {
            class: [
              "ck-balloon-rotator__navigation",
              n.to("isNavigationVisible", (s) => s ? "" : "ck-hidden")
            ]
          },
          children: [
            this.buttonPrevView,
            {
              tag: "span",
              attributes: {
                class: [
                  "ck-balloon-rotator__counter"
                ]
              },
              children: [
                {
                  text: n.to("counter")
                }
              ]
            },
            this.buttonNextView
          ]
        },
        {
          tag: "div",
          attributes: {
            class: "ck-balloon-rotator__content"
          },
          children: this.content
        }
      ]
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.focusTracker.add(this.element);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.focusTracker.destroy();
  }
  /**
   * Shows a given view.
   *
   * @param view The view to show.
   */
  showView(e) {
    this.hideView(), this.content.add(e);
  }
  /**
   * Hides the currently displayed view.
   */
  hideView() {
    this.content.clear();
  }
  /**
   * Creates a navigation button view.
   *
   * @param label The button label.
   * @param icon The button icon.
   */
  _createButtonView(e, t) {
    const n = new P(this.locale);
    return n.set({
      label: e,
      icon: t,
      tooltip: !0
    }), n;
  }
}
class xI extends T {
  /**
   * @inheritDoc
   */
  constructor(e, t) {
    super(e);
    const n = this.bindTemplate;
    this.set("top", 0), this.set("left", 0), this.set("height", 0), this.set("width", 0), this.set("numberOfPanels", 0), this.content = this.createCollection(), this._balloonPanelView = t, this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck-fake-panel",
          n.to("numberOfPanels", (s) => s ? "" : "ck-hidden")
        ],
        style: {
          top: n.to("top", Ds),
          left: n.to("left", Ds),
          width: n.to("width", Ds),
          height: n.to("height", Ds)
        }
      },
      children: this.content
    }), this.on("change:numberOfPanels", (s, o, r, a) => {
      r > a ? this._addPanels(r - a) : this._removePanels(a - r), this.updatePosition();
    });
  }
  _addPanels(e) {
    for (; e--; ) {
      const t = new T();
      t.setTemplate({ tag: "div" }), this.content.add(t), this.registerChild(t);
    }
  }
  _removePanels(e) {
    for (; e--; ) {
      const t = this.content.last;
      this.content.remove(t), this.deregisterChild(t), t.destroy();
    }
  }
  /**
   * Updates coordinates of fake panels.
   */
  updatePosition() {
    if (this.numberOfPanels) {
      const { top: e, left: t } = this._balloonPanelView, { width: n, height: s } = new B(this._balloonPanelView.element);
      Object.assign(this, { top: e, left: t, width: n, height: s });
    }
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Ln = di("px");
class II extends T {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e);
    const t = this.bindTemplate;
    this.set("isActive", !1), this.set("isSticky", !1), this.set("limiterElement", null), this.set("limiterBottomOffset", 50), this.set("viewportTopOffset", 0), this.set("_marginLeft", null), this.set("_isStickyToTheBottomOfLimiter", !1), this.set("_stickyTopOffset", null), this.set("_stickyBottomOffset", null), this.content = this.createCollection(), this._contentPanelPlaceholder = new Me({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-sticky-panel__placeholder"
        ],
        style: {
          display: t.to("isSticky", (n) => n ? "block" : "none"),
          height: t.to("isSticky", (n) => n ? Ln(this._contentPanelRect.height) : null)
        }
      }
    }).render(), this.contentPanelElement = new Me({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-sticky-panel__content",
          // Toggle class of the panel when "sticky" state changes in the view.
          t.if("isSticky", "ck-sticky-panel__content_sticky"),
          t.if("_isStickyToTheBottomOfLimiter", "ck-sticky-panel__content_sticky_bottom-limit")
        ],
        style: {
          width: t.to("isSticky", (n) => n ? Ln(this._contentPanelPlaceholder.getBoundingClientRect().width) : null),
          top: t.to("_stickyTopOffset", (n) => n && Ln(n)),
          bottom: t.to("_stickyBottomOffset", (n) => n && Ln(n)),
          marginLeft: t.to("_marginLeft")
        }
      },
      children: this.content
    }).render(), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-sticky-panel"
        ]
      },
      children: [
        this._contentPanelPlaceholder,
        this.contentPanelElement
      ]
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.checkIfShouldBeSticky(), this.listenTo(E.document, "scroll", () => {
      this.checkIfShouldBeSticky();
    }, { useCapture: !0 }), this.listenTo(this, "change:isActive", () => {
      this.checkIfShouldBeSticky();
    });
  }
  /**
   * Analyzes the environment to decide whether the panel should be sticky or not.
   * Then handles the positioning of the panel.
   */
  checkIfShouldBeSticky() {
    if (!this.limiterElement || !this.isActive) {
      this._unstick();
      return;
    }
    const e = new B(this.limiterElement);
    let t = e.getVisible();
    if (t) {
      const n = new B(E.window);
      n.top += this.viewportTopOffset, n.height -= this.viewportTopOffset, t = t.getIntersection(n);
    }
    if (t && e.top < t.top) {
      const n = t.top;
      if (n + this._contentPanelRect.height + this.limiterBottomOffset > t.bottom) {
        const s = Math.max(e.bottom - t.bottom, 0) + this.limiterBottomOffset;
        e.bottom - s > e.top + this._contentPanelRect.height ? this._stickToBottomOfLimiter(s) : this._unstick();
      } else
        this._contentPanelRect.height + this.limiterBottomOffset < e.height ? this._stickToTopOfAncestors(n) : this._unstick();
    } else
      this._unstick();
  }
  /**
   * Sticks the panel at the given CSS `top` offset.
   *
   * @private
   * @param topOffset
   */
  _stickToTopOfAncestors(e) {
    this.isSticky = !0, this._isStickyToTheBottomOfLimiter = !1, this._stickyTopOffset = e, this._stickyBottomOffset = null, this._marginLeft = Ln(-E.window.scrollX);
  }
  /**
   * Sticks the panel at the bottom of the limiter with a given CSS `bottom` offset.
   *
   * @private
   * @param stickyBottomOffset
   */
  _stickToBottomOfLimiter(e) {
    this.isSticky = !0, this._isStickyToTheBottomOfLimiter = !0, this._stickyTopOffset = null, this._stickyBottomOffset = e, this._marginLeft = Ln(-E.window.scrollX);
  }
  /**
   * Unsticks the panel putting it back to its original position.
   *
   * @private
   */
  _unstick() {
    this.isSticky = !1, this._isStickyToTheBottomOfLimiter = !1, this._stickyTopOffset = null, this._stickyBottomOffset = null, this._marginLeft = null;
  }
  /**
   * Returns the bounding rect of the {@link #contentPanelElement}.
   *
   * @private
   */
  get _contentPanelRect() {
    return new B(this.contentPanelElement);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class SI extends ue {
  /**
   * @inheritDoc
   */
  constructor(e, t) {
    const n = e.t, s = Object.assign({}, {
      showResetButton: !0,
      showIcon: !0,
      creator: He
    }, t);
    super(e, s.creator), this.label = t.label, this._viewConfig = s, this._viewConfig.showIcon && (this.iconView = new ut(), this.iconView.content = A.loupe, this.fieldWrapperChildren.add(this.iconView, 0), this.extendTemplate({
      attributes: {
        class: "ck-search__query_with-icon"
      }
    })), this._viewConfig.showResetButton && (this.resetButtonView = new P(e), this.resetButtonView.set({
      label: n("Clear"),
      icon: A.cancel,
      class: "ck-search__reset",
      isVisible: !1,
      tooltip: !0
    }), this.resetButtonView.on("execute", () => {
      this.reset(), this.focus(), this.fire("reset");
    }), this.resetButtonView.bind("isVisible").to(this.fieldView, "isEmpty", (o) => !o), this.fieldWrapperChildren.add(this.resetButtonView), this.extendTemplate({
      attributes: {
        class: "ck-search__query_with-reset"
      }
    }));
  }
  /**
   * Resets the search field to its default state.
   */
  reset() {
    this.fieldView.reset(), this._viewConfig.showResetButton && (this.resetButtonView.isVisible = !1);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class PI extends T {
  /**
   * @inheritDoc
   */
  constructor() {
    super();
    const e = this.bindTemplate;
    this.set({
      isVisible: !1,
      primaryText: "",
      secondaryText: ""
    }), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-search__info",
          e.if("isVisible", "ck-hidden", (t) => !t)
        ],
        tabindex: -1
      },
      children: [
        {
          tag: "span",
          children: [
            {
              text: [e.to("primaryText")]
            }
          ]
        },
        {
          tag: "span",
          children: [
            {
              text: [e.to("secondaryText")]
            }
          ]
        }
      ]
    });
  }
  /**
   * Focuses the view
   */
  focus() {
    this.element.focus();
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class RI extends T {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.children = this.createCollection(), this.focusTracker = new X(), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-search__results"
        ],
        tabindex: -1
      },
      children: this.children
    }), this._focusCycler = new ge({
      focusables: this.children,
      focusTracker: this.focusTracker
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    for (const e of this.children)
      this.focusTracker.add(e.element);
  }
  /**
   * Focuses the view.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
   * Focuses the first child view.
   */
  focusFirst() {
    this._focusCycler.focusFirst();
  }
  /**
   * Focuses the last child view.
   */
  focusLast() {
    this._focusCycler.focusLast();
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class VI extends T {
  /**
   * Creates an instance of the {@link module:ui/search/text/searchtextview~SearchTextView} class.
   *
   * @param locale The localization services instance.
   * @param config Configuration of the view.
   */
  constructor(e, t) {
    super(e), this._config = t, this.filteredView = t.filteredView, this.queryView = this._createSearchTextQueryView(), this.focusTracker = new X(), this.keystrokes = new ie(), this.resultsView = new RI(e), this.children = this.createCollection(), this.focusableChildren = this.createCollection([this.queryView, this.resultsView]), this.set("isEnabled", !0), this.set("resultsCount", 0), this.set("totalItemsCount", 0), t.infoView && t.infoView.instance ? this.infoView = t.infoView.instance : (this.infoView = new PI(), this._enableDefaultInfoViewBehavior(), this.on("render", () => {
      this.search("");
    })), this.resultsView.children.addMany([this.infoView, this.filteredView]), this.focusCycler = new ge({
      focusables: this.focusableChildren,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    }), this.on("search", (n, { resultsCount: s, totalItemsCount: o }) => {
      this.resultsCount = s, this.totalItemsCount = o;
    }), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-search",
          t.class || null
        ],
        tabindex: "-1"
      },
      children: this.children
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.children.addMany([
      this.queryView,
      this.resultsView
    ]);
    const e = (t) => t.stopPropagation();
    for (const t of this.focusableChildren)
      this.focusTracker.add(t.element);
    this.keystrokes.listenTo(this.element), this.keystrokes.set("arrowright", e), this.keystrokes.set("arrowleft", e), this.keystrokes.set("arrowup", e), this.keystrokes.set("arrowdown", e);
  }
  /**
   * Focuses the {@link #queryView}.
   */
  focus() {
    this.queryView.focus();
  }
  /**
   * Resets the component to its initial state.
   */
  reset() {
    this.queryView.reset(), this.search("");
  }
  /**
   * Searches the {@link #filteredView} for the given query.
   *
   * @internal
   * @param query The search query string.
   */
  search(e) {
    const t = e ? new RegExp(Yf(e), "ig") : null, n = this.filteredView.filter(t);
    this.fire("search", { query: e, ...n });
  }
  /**
   * Creates a search field view based on configured creator..
   */
  _createSearchTextQueryView() {
    const e = new SI(this.locale, this._config.queryView);
    return this.listenTo(e.fieldView, "input", () => {
      this.search(e.fieldView.element.value);
    }), e.on("reset", () => this.reset()), e.bind("isEnabled").to(this), e;
  }
  /**
   * Initializes the default {@link #infoView} behavior with default text labels when no custom info view
   * was specified in the view config.
   */
  _enableDefaultInfoViewBehavior() {
    const e = this.locale.t, t = this.infoView;
    this.on("search", (s, o) => {
      if (o.resultsCount)
        t.set({
          isVisible: !1
        });
      else {
        const r = this._config.infoView && this._config.infoView.text;
        let a, l;
        o.totalItemsCount ? r && r.notFound ? (a = r.notFound.primary, l = r.notFound.secondary) : (a = e("No results found"), l = "") : r && r.noSearchableItems ? (a = r.noSearchableItems.primary, l = r.noSearchableItems.secondary) : (a = e("No searchable items"), l = ""), t.set({
          primaryText: n(a, o),
          secondaryText: n(l, o),
          isVisible: !0
        });
      }
    });
    function n(s, { query: o, resultsCount: r, totalItemsCount: a }) {
      return typeof s == "function" ? s(o, r, a) : s;
    }
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ls extends VI {
  /**
   * @inheritDoc
   */
  constructor(e, t) {
    super(e, t), this._config = t;
    const n = di("px");
    this.extendTemplate({
      attributes: {
        class: ["ck-autocomplete"]
      }
    });
    const s = this.resultsView.bindTemplate;
    this.resultsView.set("isVisible", !1), this.resultsView.set("_position", "s"), this.resultsView.set("_width", 0), this.resultsView.extendTemplate({
      attributes: {
        class: [
          s.if("isVisible", "ck-hidden", (o) => !o),
          s.to("_position", (o) => `ck-search__results_${o}`)
        ],
        style: {
          width: s.to("_width", n)
        }
      }
    }), this.focusTracker.on("change:isFocused", (o, r, a) => {
      this._updateResultsVisibility(), a ? this.resultsView.element.scrollTop = 0 : t.resetOnBlur && this.queryView.reset();
    }), this.on("search", () => {
      this._updateResultsVisibility(), this._updateResultsViewWidthAndPosition();
    }), this.keystrokes.set("esc", (o, r) => {
      this.resultsView.isVisible && (this.queryView.focus(), this.resultsView.isVisible = !1, r());
    }), this.listenTo(E.document, "scroll", () => {
      this._updateResultsViewWidthAndPosition();
    }), this.on("change:isEnabled", () => {
      this._updateResultsVisibility();
    }), this.filteredView.on("execute", (o, { value: r }) => {
      this.focus(), this.reset(), this.queryView.fieldView.value = this.queryView.fieldView.element.value = r, this.resultsView.isVisible = !1;
    }), this.resultsView.on("change:isVisible", () => {
      this._updateResultsViewWidthAndPosition();
    });
  }
  /**
   * Updates the position of the results view on demand.
   */
  _updateResultsViewWidthAndPosition() {
    if (!this.resultsView.isVisible)
      return;
    this.resultsView._width = new B(this.queryView.fieldView.element).width;
    const e = ls._getOptimalPosition({
      element: this.resultsView.element,
      target: this.queryView.element,
      fitInViewport: !0,
      positions: ls.defaultResultsPositions
    });
    this.resultsView._position = e ? e.name : "s";
  }
  /**
   * Updates the visibility of the results view on demand.
   */
  _updateResultsVisibility() {
    const e = typeof this._config.queryMinChars == "undefined" ? 0 : this._config.queryMinChars, t = this.queryView.fieldView.element.value.length;
    this.resultsView.isVisible = this.focusTracker.isFocused && this.isEnabled && t >= e;
  }
}
ls.defaultResultsPositions = [
  (i) => ({
    top: i.bottom,
    left: i.left,
    name: "s"
  }),
  (i, e) => ({
    top: i.top - e.height,
    left: i.left,
    name: "n"
  })
];
ls._getOptimalPosition = Go;
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class MI extends P {
  /**
   * Creates an instance of the menu bar button view.
   *
   * @param locale The localization services instance.
   */
  constructor(e) {
    super(e);
    const t = this.bindTemplate;
    this.set({
      withText: !0,
      role: "menuitem"
    }), this.arrowView = this._createArrowView(), this.extendTemplate({
      attributes: {
        class: [
          "ck-menu-bar__menu__button"
        ],
        "aria-haspopup": !0,
        "aria-expanded": this.bindTemplate.to("isOn", (n) => String(n)),
        "data-cke-tooltip-disabled": t.to("isOn")
      },
      on: {
        mouseenter: t.to("mouseenter")
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.children.add(this.arrowView);
  }
  /**
   * Creates the {@link #arrowView} instance.
   */
  _createArrowView() {
    const e = new ut();
    return e.content = ir, e.extendTemplate({
      attributes: {
        class: "ck-menu-bar__menu__button__arrow"
      }
    }), e;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class fi extends ii {
  /**
   * Creates an instance of the list item view.
   *
   * @param locale The localization services instance.
   */
  constructor(e, t) {
    super(e);
    const n = this.bindTemplate;
    this.extendTemplate({
      attributes: {
        class: [
          "ck-menu-bar__menu__item"
        ]
      },
      on: {
        mouseenter: n.to("mouseenter")
      }
    }), this.delegate("mouseenter").to(t);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const zs = 5, ki = {
  /**
   * When the bar is already open:
   * * Opens the menu when the user hovers over its button.
   * * Closes open menu when another menu's button gets hovered.
   */
  toggleMenusAndFocusItemsOnHover(i) {
    i.on("menu:mouseenter", (e) => {
      if (i.isOpen) {
        for (const t of i.menus) {
          const n = e.path[0], s = n instanceof fi && n.children.first === t;
          t.isOpen = (e.path.includes(t) || s) && t.isEnabled;
        }
        e.source.focus();
      }
    });
  },
  /**
   * Moves between top-level menus using the arrow left and right keys.
   *
   * If the menubar has already been open, the arrow keys move focus between top-level menu buttons and open them.
   * If the menubar is closed, the arrow keys only move focus between top-level menu buttons.
   */
  focusCycleMenusOnArrows(i) {
    const e = i.locale.uiLanguageDirection === "rtl";
    i.on("menu:arrowright", (n) => {
      t(n.source, e ? -1 : 1);
    }), i.on("menu:arrowleft", (n) => {
      t(n.source, e ? 1 : -1);
    });
    function t(n, s) {
      const o = i.children.getIndex(n), r = n.isOpen, a = i.children.length, l = i.children.get((o + a + s) % a);
      n.isOpen = !1, r && (l.isOpen = !0), l.buttonView.focus();
    }
  },
  /**
   * Closes the entire sub-menu structure when the bar is closed. This prevents sub-menus from being open if the user
   * closes the entire bar, and then re-opens some top-level menu.
   */
  closeMenusWhenTheBarCloses(i) {
    i.on("change:isOpen", () => {
      i.isOpen || i.menus.forEach((e) => {
        e.isOpen = !1;
      });
    });
  },
  /**
   * Handles the following case:
   * 1. Hover to open a sub-menu (A). The button has focus.
   * 2. Press arrow up/down to move focus to another sub-menu (B) button.
   * 3. Press arrow right to open the sub-menu (B).
   * 4. The sub-menu (A) should close as it would with `toggleMenusAndFocusItemsOnHover()`.
   */
  closeMenuWhenAnotherOnTheSameLevelOpens(i) {
    i.on("menu:change:isOpen", (e, t, n) => {
      n && i.menus.filter((s) => e.source.parentMenuView === s.parentMenuView && e.source !== s && s.isOpen).forEach((s) => {
        s.isOpen = !1;
      });
    });
  },
  /**
   * Closes the bar when the user clicked outside of it (page body, editor root, etc.).
   */
  closeOnClickOutside(i) {
    yn({
      emitter: i,
      activator: () => i.isOpen,
      callback: () => i.close(),
      contextElements: () => i.children.map((e) => e.element)
    });
  }
}, Yt = {
  /**
   * If the button of the menu is focused, pressing the arrow down key should open the panel and focus it.
   * This is analogous to the {@link module:ui/dropdown/dropdownview~DropdownView}.
   */
  openAndFocusPanelOnArrowDownKey(i) {
    i.keystrokes.set("arrowdown", (e, t) => {
      i.focusTracker.focusedElement === i.buttonView.element && (i.isOpen || (i.isOpen = !0), i.panelView.focus(), t());
    });
  },
  /**
   * Open the menu on the right arrow key press. This allows for navigating to sub-menus using the keyboard.
   */
  openOnArrowRightKey(i) {
    const e = i.locale.uiLanguageDirection === "rtl" ? "arrowleft" : "arrowright";
    i.keystrokes.set(e, (t, n) => {
      i.focusTracker.focusedElement !== i.buttonView.element || !i.isEnabled || (i.isOpen || (i.isOpen = !0), i.panelView.focus(), n());
    });
  },
  /**
   * Opens the menu on its button click. Note that this behavior only opens but never closes the menu (unlike
   * {@link module:ui/dropdown/dropdownview~DropdownView}).
   */
  openOnButtonClick(i) {
    i.buttonView.on("execute", () => {
      i.isOpen = !0, i.panelView.focus();
    });
  },
  /**
   * Toggles the menu on its button click. This behavior is analogous to {@link module:ui/dropdown/dropdownview~DropdownView}.
   */
  toggleOnButtonClick(i) {
    i.buttonView.on("execute", () => {
      i.isOpen = !i.isOpen, i.isOpen && i.panelView.focus();
    });
  },
  /**
   * Closes the menu on the right left key press. This allows for navigating to sub-menus using the keyboard.
   */
  closeOnArrowLeftKey(i) {
    const e = i.locale.uiLanguageDirection === "rtl" ? "arrowright" : "arrowleft";
    i.keystrokes.set(e, (t, n) => {
      i.isOpen && (i.isOpen = !1, i.focus(), n());
    });
  },
  /**
   * Closes the menu on the esc key press. This allows for navigating to sub-menus using the keyboard.
   */
  closeOnEscKey(i) {
    i.keystrokes.set("esc", (e, t) => {
      i.isOpen && (i.isOpen = !1, i.focus(), t());
    });
  },
  /**
   * Closes the menu when its parent menu also closed. This prevents from orphaned open menus when the parent menu re-opens.
   */
  closeOnParentClose(i) {
    i.parentMenuView.on("change:isOpen", (e, t, n) => {
      !n && e.source === i.parentMenuView && (i.isOpen = !1);
    });
  }
}, BI = {
  southEast: (i) => ({
    top: i.bottom,
    left: i.left,
    name: "se"
  }),
  southWest: (i, e) => ({
    top: i.bottom,
    left: i.left - e.width + i.width,
    name: "sw"
  }),
  northEast: (i, e) => ({
    top: i.top - e.height,
    left: i.left,
    name: "ne"
  }),
  northWest: (i, e) => ({
    top: i.top - e.height,
    left: i.left - e.width + i.width,
    name: "nw"
  }),
  eastSouth: (i) => ({
    top: i.top,
    left: i.right - zs,
    name: "es"
  }),
  eastNorth: (i, e) => ({
    top: i.top - e.height,
    left: i.right - zs,
    name: "en"
  }),
  westSouth: (i, e) => ({
    top: i.top,
    left: i.left - e.width + zs,
    name: "ws"
  }),
  westNorth: (i, e) => ({
    top: i.top - e.height,
    left: i.left - e.width + zs,
    name: "wn"
  })
}, LI = [
  {
    menuId: "file",
    label: "File",
    groups: [
      {
        groupId: "export",
        items: [
          "menuBar:exportPdf",
          "menuBar:exportWord"
        ]
      },
      {
        groupId: "import",
        items: [
          "menuBar:importWord"
        ]
      },
      {
        groupId: "revisionHistory",
        items: [
          "menuBar:revisionHistory"
        ]
      }
    ]
  },
  {
    menuId: "edit",
    label: "Edit",
    groups: [
      {
        groupId: "undo",
        items: [
          "menuBar:undo",
          "menuBar:redo"
        ]
      },
      {
        groupId: "selectAll",
        items: [
          "menuBar:selectAll"
        ]
      },
      {
        groupId: "findAndReplace",
        items: [
          "menuBar:findAndReplace"
        ]
      }
    ]
  },
  {
    menuId: "view",
    label: "View",
    groups: [
      {
        groupId: "sourceEditing",
        items: [
          "menuBar:sourceEditing"
        ]
      },
      {
        groupId: "showBlocks",
        items: [
          "menuBar:showBlocks"
        ]
      },
      {
        groupId: "restrictedEditingException",
        items: [
          "menuBar:restrictedEditingException"
        ]
      }
    ]
  },
  {
    menuId: "insert",
    label: "Insert",
    groups: [
      {
        groupId: "insertMainWidgets",
        items: [
          "menuBar:uploadImage",
          "menuBar:ckbox",
          "menuBar:ckfinder",
          "menuBar:insertTable"
        ]
      },
      {
        groupId: "insertInline",
        items: [
          "menuBar:link",
          "menuBar:comment"
        ]
      },
      {
        groupId: "insertMinorWidgets",
        items: [
          "menuBar:insertTemplate",
          "menuBar:blockQuote",
          "menuBar:codeBlock",
          "menuBar:htmlEmbed"
        ]
      },
      {
        groupId: "insertStructureWidgets",
        items: [
          "menuBar:horizontalLine",
          "menuBar:pageBreak",
          "menuBar:tableOfContents"
        ]
      },
      {
        groupId: "restrictedEditing",
        items: [
          "menuBar:restrictedEditing"
        ]
      }
    ]
  },
  {
    menuId: "format",
    label: "Format",
    groups: [
      {
        groupId: "textAndFont",
        items: [
          {
            menuId: "text",
            label: "Text",
            groups: [
              {
                groupId: "basicStyles",
                items: [
                  "menuBar:bold",
                  "menuBar:italic",
                  "menuBar:underline",
                  "menuBar:strikethrough",
                  "menuBar:superscript",
                  "menuBar:subscript",
                  "menuBar:code"
                ]
              },
              {
                groupId: "textPartLanguage",
                items: [
                  "menuBar:textPartLanguage"
                ]
              }
            ]
          },
          {
            menuId: "font",
            label: "Font",
            groups: [
              {
                groupId: "fontProperties",
                items: [
                  "menuBar:fontSize",
                  "menuBar:fontFamily"
                ]
              },
              {
                groupId: "fontColors",
                items: [
                  "menuBar:fontColor",
                  "menuBar:fontBackgroundColor"
                ]
              },
              {
                groupId: "highlight",
                items: [
                  "menuBar:highlight"
                ]
              }
            ]
          },
          "menuBar:heading"
        ]
      },
      {
        groupId: "list",
        items: [
          "menuBar:bulletedList",
          "menuBar:numberedList",
          "menuBar:todoList"
        ]
      },
      {
        groupId: "indent",
        items: [
          "menuBar:alignment",
          "menuBar:indent",
          "menuBar:outdent"
        ]
      },
      {
        groupId: "caseChange",
        items: [
          "menuBar:caseChange"
        ]
      },
      {
        groupId: "removeFormat",
        items: [
          "menuBar:removeFormat"
        ]
      }
    ]
  },
  {
    menuId: "tools",
    label: "Tools",
    groups: [
      {
        groupId: "aiTools",
        items: [
          "menuBar:aiAssistant",
          "menuBar:aiCommands"
        ]
      },
      {
        groupId: "tools",
        items: [
          "menuBar:trackChanges",
          "menuBar:commentsArchive"
        ]
      }
    ]
  },
  {
    menuId: "help",
    label: "Help",
    groups: [
      {
        groupId: "help",
        items: [
          "menuBar:accessibilityHelp"
        ]
      }
    ]
  }
];
function OI(i) {
  let e;
  return !("items" in i) || !i.items ? e = {
    items: ct(LI),
    addItems: [],
    removeItems: [],
    isVisible: !0,
    isUsingDefaultConfig: !0,
    ...i
  } : e = {
    items: i.items,
    removeItems: [],
    addItems: [],
    isVisible: !0,
    isUsingDefaultConfig: !1,
    ...i
  }, e;
}
function FI({ normalizedConfig: i, locale: e, componentFactory: t }) {
  const n = ct(i);
  return NI(i, n), DI(i, n), zI(i, n, t), jg(i, n), HI(n, e), n;
}
function NI(i, e) {
  const t = e.removeItems, n = [];
  e.items = e.items.filter(({ menuId: s }) => t.includes(s) ? (n.push(s), !1) : !0), mi(e.items, (s) => {
    s.groups = s.groups.filter(({ groupId: o }) => t.includes(o) ? (n.push(o), !1) : !0);
    for (const o of s.groups)
      o.items = o.items.filter((r) => {
        const a = Kg(r);
        return t.includes(a) ? (n.push(a), !1) : !0;
      });
  });
  for (const s of t)
    n.includes(s) || D("menu-bar-item-could-not-be-removed", {
      menuBarConfig: i,
      itemName: s
    });
}
function DI(i, e) {
  const t = e.addItems, n = [];
  for (const s of t) {
    const o = WI(s.position), r = qI(s.position);
    if (UI(s))
      if (!r)
        o === "start" ? (e.items.unshift(s.menu), n.push(s)) : o === "end" && (e.items.push(s.menu), n.push(s));
      else {
        const a = e.items.findIndex((l) => l.menuId === r);
        a != -1 ? o === "before" ? (e.items.splice(a, 0, s.menu), n.push(s)) : o === "after" && (e.items.splice(a + 1, 0, s.menu), n.push(s)) : pd(e, s.menu, r, o) && n.push(s);
      }
    else $I(s) ? mi(e.items, (a) => {
      if (a.menuId === r)
        o === "start" ? (a.groups.unshift(s.group), n.push(s)) : o === "end" && (a.groups.push(s.group), n.push(s));
      else {
        const l = a.groups.findIndex((c) => c.groupId === r);
        l !== -1 && (o === "before" ? (a.groups.splice(l, 0, s.group), n.push(s)) : o === "after" && (a.groups.splice(l + 1, 0, s.group), n.push(s)));
      }
    }) : pd(e, s.item, r, o) && n.push(s);
  }
  for (const s of t)
    n.includes(s) || D("menu-bar-item-could-not-be-added", {
      menuBarConfig: i,
      addedItemConfig: s
    });
}
function pd(i, e, t, n) {
  let s = !1;
  return mi(i.items, (o) => {
    for (const { groupId: r, items: a } of o.groups) {
      if (s)
        return;
      if (r === t)
        n === "start" ? (a.unshift(e), s = !0) : n === "end" && (a.push(e), s = !0);
      else {
        const l = a.findIndex((c) => Kg(c) === t);
        l !== -1 && (n === "before" ? (a.splice(l, 0, e), s = !0) : n === "after" && (a.splice(l + 1, 0, e), s = !0));
      }
    }
  }), s;
}
function zI(i, e, t) {
  mi(e.items, (n) => {
    for (const s of n.groups)
      s.items = s.items.filter((o) => {
        const r = typeof o == "string" && !t.has(o);
        return r && !e.isUsingDefaultConfig && D("menu-bar-item-unavailable", {
          menuBarConfig: i,
          parentMenuConfig: ct(n),
          componentName: o
        }), !r;
      });
  });
}
function jg(i, e) {
  const t = e.isUsingDefaultConfig;
  let n = !1;
  if (e.items = e.items.filter((s) => s.groups.length ? !0 : (Or(i, s, t), !1)), !e.items.length) {
    Or(i, i, t);
    return;
  }
  mi(e.items, (s) => {
    s.groups = s.groups.filter((o) => o.items.length ? !0 : (n = !0, !1));
    for (const o of s.groups)
      o.items = o.items.filter((r) => Zg(r) && !r.groups.length ? (Or(i, r, t), n = !0, !1) : !0);
  }), n && jg(i, e);
}
function Or(i, e, t) {
  t || D("menu-bar-menu-empty", {
    menuBarConfig: i,
    emptyMenuConfig: e
  });
}
function HI(i, e) {
  const t = e.t, n = {
    // Top-level categories.
    File: t({
      string: "File",
      id: "MENU_BAR_MENU_FILE"
    }),
    Edit: t({
      string: "Edit",
      id: "MENU_BAR_MENU_EDIT"
    }),
    View: t({
      string: "View",
      id: "MENU_BAR_MENU_VIEW"
    }),
    Insert: t({
      string: "Insert",
      id: "MENU_BAR_MENU_INSERT"
    }),
    Format: t({
      string: "Format",
      id: "MENU_BAR_MENU_FORMAT"
    }),
    Tools: t({
      string: "Tools",
      id: "MENU_BAR_MENU_TOOLS"
    }),
    Help: t({
      string: "Help",
      id: "MENU_BAR_MENU_HELP"
    }),
    // Sub-menus.
    Text: t({
      string: "Text",
      id: "MENU_BAR_MENU_TEXT"
    }),
    Font: t({
      string: "Font",
      id: "MENU_BAR_MENU_FONT"
    })
  };
  mi(i.items, (s) => {
    s.label in n && (s.label = n[s.label]);
  });
}
function mi(i, e) {
  if (Array.isArray(i))
    for (const n of i)
      t(n);
  function t(n) {
    e(n);
    for (const s of n.groups)
      for (const o of s.items)
        Zg(o) && t(o);
  }
}
function UI(i) {
  return typeof i == "object" && "menu" in i;
}
function $I(i) {
  return typeof i == "object" && "group" in i;
}
function WI(i) {
  return i.startsWith("start") ? "start" : i.startsWith("end") ? "end" : i.startsWith("after") ? "after" : "before";
}
function qI(i) {
  const e = i.match(/^[^:]+:(.+)/);
  return e ? e[1] : null;
}
function Kg(i) {
  return typeof i == "string" ? i : i.menuId;
}
function Zg(i) {
  return typeof i == "object" && "menuId" in i;
}
function GI(i, e) {
  const t = e.element;
  i.ui.focusTracker.add(t), i.keystrokes.listenTo(t);
  const n = OI(i.config.get("menuBar") || {});
  e.fillFromConfig(n, i.ui.componentFactory), i.keystrokes.set("Esc", (s, o) => {
    t.contains(i.ui.focusTracker.focusedElement) && (i.editing.view.focus(), o());
  }), i.keystrokes.set("Alt+F9", (s, o) => {
    t.contains(i.ui.focusTracker.focusedElement) || (e.focus(), o());
  });
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class jI extends T {
  /**
   * Creates an instance of the menu panel view.
   *
   * @param locale The localization services instance.
   */
  constructor(e) {
    super(e);
    const t = this.bindTemplate;
    this.set("isVisible", !1), this.set("position", "se"), this.children = this.createCollection(), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-reset",
          "ck-menu-bar__menu__panel",
          t.to("position", (n) => `ck-menu-bar__menu__panel_position_${n}`),
          t.if("isVisible", "ck-hidden", (n) => !n)
        ],
        tabindex: "-1"
      },
      children: this.children,
      on: {
        // Drag and drop in the panel should not break the selection in the editor.
        // https://github.com/ckeditor/ckeditor5-ui/issues/228
        selectstart: t.to((n) => {
          n.target.tagName.toLocaleLowerCase() !== "input" && n.preventDefault();
        })
      }
    });
  }
  /**
   * Focuses the first child of the panel (default) or the last one if the `direction` is `-1`.
   */
  focus(e = 1) {
    this.children.length && (e === 1 ? this.children.first.focus() : this.children.last.focus());
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Ge extends T {
  /**
   * Creates an instance of the menu view.
   *
   * @param locale The localization services instance.
   */
  constructor(e) {
    super(e);
    const t = this.bindTemplate;
    this.buttonView = new MI(e), this.buttonView.delegate("mouseenter").to(this), this.buttonView.bind("isOn", "isEnabled").to(this, "isOpen", "isEnabled"), this.panelView = new jI(e), this.panelView.bind("isVisible").to(this, "isOpen"), this.keystrokes = new ie(), this.focusTracker = new X(), this.set("isOpen", !1), this.set("isEnabled", !0), this.set("panelPosition", "w"), this.set("class", void 0), this.set("parentMenuView", null), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-menu-bar__menu",
          t.to("class"),
          t.if("isEnabled", "ck-disabled", (n) => !n),
          t.if("parentMenuView", "ck-menu-bar__menu_top-level", (n) => !n)
        ]
      },
      children: [
        this.buttonView,
        this.panelView
      ]
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.focusTracker.add(this.buttonView.element), this.focusTracker.add(this.panelView.element), this.keystrokes.listenTo(this.element), Yt.closeOnEscKey(this), this._repositionPanelOnOpen();
  }
  // For now, this method cannot be called in the render process because the `parentMenuView` may be assigned
  // after the rendering process.
  //
  // TODO: We should reconsider the way we handle this logic.
  /**
   * Attach all keyboard behaviors for the menu bar view.
   *
   * @internal
   */
  _attachBehaviors() {
    this.parentMenuView ? (Yt.openOnButtonClick(this), Yt.openOnArrowRightKey(this), Yt.closeOnArrowLeftKey(this), Yt.closeOnParentClose(this)) : (this._propagateArrowKeystrokeEvents(), Yt.openAndFocusPanelOnArrowDownKey(this), Yt.toggleOnButtonClick(this));
  }
  /**
   * Fires `arrowright` and `arrowleft` events when the user pressed corresponding arrow keys.
   */
  _propagateArrowKeystrokeEvents() {
    this.keystrokes.set("arrowright", (e, t) => {
      this.fire("arrowright"), t();
    }), this.keystrokes.set("arrowleft", (e, t) => {
      this.fire("arrowleft"), t();
    });
  }
  /**
   * Sets the position of the panel when the menu opens. The panel is positioned
   * so that it optimally uses the available space in the viewport.
   */
  _repositionPanelOnOpen() {
    this.on("change:isOpen", (e, t, n) => {
      if (!n)
        return;
      const s = Ge._getOptimalPosition({
        element: this.panelView.element,
        target: this.buttonView.element,
        fitInViewport: !0,
        positions: this._panelPositions
      });
      this.panelView.position = s ? s.name : this._panelPositions[0].name;
    });
  }
  /**
   * @inheritDoc
   */
  focus() {
    this.buttonView.focus();
  }
  /**
   * Positioning functions for the {@link #panelView} . They change depending on the role of the menu (top-level vs sub-menu) in
   * the {@link module:ui/menubar/menubarview~MenuBarView menu bar} and the UI language direction.
   */
  get _panelPositions() {
    const { southEast: e, southWest: t, northEast: n, northWest: s, westSouth: o, eastSouth: r, westNorth: a, eastNorth: l } = BI;
    return this.locale.uiLanguageDirection === "ltr" ? this.parentMenuView ? [r, l, o, a] : [e, t, n, s] : this.parentMenuView ? [o, a, r, l] : [t, e, s, n];
  }
}
Ge._getOptimalPosition = Go;
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class oi extends Sl {
  /**
   * Creates an instance of the list view.
   *
   * @param locale The localization services instance.
   */
  constructor(e) {
    super(e), this.role = "menu";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class de extends P {
  /**
   * Creates an instance of the menu bar list button view.
   *
   * @param locale The localization services instance.
   */
  constructor(e) {
    super(e), this.set({
      withText: !0,
      withKeystroke: !0,
      tooltip: !1,
      role: "menuitem"
    }), this.extendTemplate({
      attributes: {
        class: ["ck-menu-bar__menu__item__button"]
      }
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Jg extends kg {
  /**
   * Creates an instance of the menu bar list button view.
   *
   * @param locale The localization services instance.
   */
  constructor(e) {
    super(e), this.set({
      withText: !0,
      withKeystroke: !0,
      tooltip: !1,
      role: "menuitem"
    }), this.extendTemplate({
      attributes: {
        class: ["ck-menu-bar__menu__item__button"]
      }
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const bd = ["mouseenter", "arrowleft", "arrowright", "change:isOpen"];
class KI extends T {
  /**
   * Creates an instance of the menu bar view.
   *
   * @param locale The localization services instance.
   */
  constructor(e) {
    super(e), this.menus = [];
    const t = e.t;
    this.set("isOpen", !1), this._setupIsOpenUpdater(), this.children = this.createCollection(), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-menu-bar"
        ],
        "aria-label": t("Editor menu bar"),
        role: "menubar"
      },
      children: this.children
    });
  }
  /**
   * A utility that expands a plain menu bar configuration into a structure of menus (also: sub-menus)
   * and items using a given {@link module:ui/componentfactory~ComponentFactory component factory}.
   *
   * See the {@link module:core/editor/editorconfig~EditorConfig#menuBar menu bar} in the editor
   * configuration reference to learn how to configure the menu bar.
   */
  fillFromConfig(e, t) {
    const n = this.locale, o = FI({
      normalizedConfig: e,
      locale: n,
      componentFactory: t
    }).items.map((r) => this._createMenu({
      componentFactory: t,
      menuDefinition: r
    }));
    this.children.addMany(o);
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), ki.toggleMenusAndFocusItemsOnHover(this), ki.closeMenusWhenTheBarCloses(this), ki.closeMenuWhenAnotherOnTheSameLevelOpens(this), ki.focusCycleMenusOnArrows(this), ki.closeOnClickOutside(this);
  }
  /**
   * Focuses the menu bar.
   */
  focus() {
    this.children.first && this.children.first.focus();
  }
  /**
   * Closes all menus in the bar.
   */
  close() {
    for (const e of this.children)
      e.isOpen = !1;
  }
  /**
   * Registers a menu view in the menu bar. Every {@link module:ui/menubar/menubarmenuview~MenuBarMenuView} instance must be registered
   * in the menu bar to be properly managed.
   */
  registerMenu(e, t = null) {
    t ? (e.delegate(...bd).to(t), e.parentMenuView = t) : e.delegate(...bd).to(this, (n) => "menu:" + n), e._attachBehaviors(), this.menus.push(e);
  }
  /**
   * Creates a {@link module:ui/menubar/menubarmenuview~MenuBarMenuView} based on the given definition.
   */
  _createMenu({ componentFactory: e, menuDefinition: t, parentMenuView: n }) {
    const s = this.locale, o = new Ge(s);
    return this.registerMenu(o, n), o.buttonView.set({
      label: t.label
    }), o.once("change:isOpen", () => {
      const r = new oi(s);
      r.ariaLabel = t.label, o.panelView.children.add(r), r.items.addMany(this._createMenuItems({ menuDefinition: t, parentMenuView: o, componentFactory: e }));
    }), o;
  }
  /**
   * Creates a {@link module:ui/menubar/menubarmenuview~MenuBarMenuView} items based on the given definition.
   */
  _createMenuItems({ menuDefinition: e, parentMenuView: t, componentFactory: n }) {
    const s = this.locale, o = [];
    for (const r of e.groups) {
      for (const a of r.items) {
        const l = new fi(s, t);
        if (J(a))
          l.children.add(this._createMenu({
            componentFactory: n,
            menuDefinition: a,
            parentMenuView: t
          }));
        else {
          const c = this._createMenuItemContentFromFactory({
            componentName: a,
            componentFactory: n,
            parentMenuView: t
          });
          if (!c)
            continue;
          l.children.add(c);
        }
        o.push(l);
      }
      r !== e.groups[e.groups.length - 1] && o.push(new Il(s));
    }
    return o;
  }
  /**
   * Uses the component factory to create a content of the menu item (a button or a sub-menu).
   */
  _createMenuItemContentFromFactory({ componentName: e, parentMenuView: t, componentFactory: n }) {
    const s = n.create(e);
    return s instanceof Ge || s instanceof de || s instanceof Jg ? (this._registerMenuTree(s, t), s.on("execute", () => {
      this.close();
    }), s) : (D("menu-bar-component-unsupported", {
      componentName: e,
      componentView: s
    }), null);
  }
  /**
   * Checks component and its children recursively and calls {@link #registerMenu}
   * for each item that is {@link module:ui/menubar/menubarmenuview~MenuBarMenuView}.
   *
   * @internal
   */
  _registerMenuTree(e, t) {
    if (!(e instanceof Ge)) {
      e.delegate("mouseenter").to(t);
      return;
    }
    this.registerMenu(e, t);
    const n = e.panelView.children.filter((o) => o instanceof oi)[0];
    if (!n) {
      e.delegate("mouseenter").to(t);
      return;
    }
    const s = n.items.filter((o) => o instanceof ii);
    for (const o of s)
      this._registerMenuTree(o.children.get(0), e);
  }
  /**
   * Manages the state of the {@link #isOpen} property of the menu bar. Because the state is a sum of individual
   * top-level menus' states, it's necessary to listen to their changes and update the state accordingly.
   *
   * Additionally, it prevents from unnecessary changes of `isOpen` when one top-level menu opens and another closes
   * (regardless of in which order), maintaining a stable `isOpen === true` in that situation.
   */
  _setupIsOpenUpdater() {
    let e;
    this.on("menu:change:isOpen", (t, n, s) => {
      clearTimeout(e), s ? this.isOpen = !0 : e = setTimeout(() => {
        this.isOpen = Array.from(this.children).some((o) => o.isOpen);
      }, 0);
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function* Xg(i, e) {
  for (const t of e)
    t && i.getAttributeProperties(t[0]).copyOnEnter && (yield t);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ZI extends V {
  /**
   * @inheritDoc
   */
  execute() {
    this.editor.model.change((e) => {
      this.enterBlock(e), this.fire("afterExecute", { writer: e });
    });
  }
  /**
   * Splits a block where the document selection is placed, in the way how the <kbd>Enter</kbd> key is expected to work:
   *
   * ```
   * <p>Foo[]bar</p>   ->   <p>Foo</p><p>[]bar</p>
   * <p>Foobar[]</p>   ->   <p>Foobar</p><p>[]</p>
   * <p>Fo[ob]ar</p>   ->   <p>Fo</p><p>[]ar</p>
   * ```
   *
   * In some cases, the split will not happen:
   *
   * ```
   * // The selection parent is a limit element:
   * <figcaption>A[bc]d</figcaption>   ->   <figcaption>A[]d</figcaption>
   *
   * // The selection spans over multiple elements:
   * <h>x[x</h><p>y]y<p>   ->   <h>x</h><p>[]y</p>
   * ```
   *
   * @param writer Writer to use when performing the enter action.
   * @returns Boolean indicating if the block was split.
   */
  enterBlock(e) {
    const t = this.editor.model, n = t.document.selection, s = t.schema, o = n.isCollapsed, r = n.getFirstRange(), a = r.start.parent, l = r.end.parent;
    if (s.isLimit(a) || s.isLimit(l))
      return !o && a == l && t.deleteContent(n), !1;
    if (o) {
      const c = Xg(e.model.schema, n.getAttributes());
      return wd(e, r.start), e.setSelectionAttribute(c), !0;
    } else {
      const c = !(r.start.isAtStart && r.end.isAtEnd), u = a == l;
      if (t.deleteContent(n, { leaveUnmerged: c }), c) {
        if (u)
          return wd(e, n.focus), !0;
        e.setSelection(l, 0);
      }
    }
    return !1;
  }
}
function wd(i, e) {
  i.split(e), i.setSelection(e.parent.nextSibling, 0);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const JI = {
  insertParagraph: { isSoft: !1 },
  insertLineBreak: { isSoft: !0 }
};
class Qg extends wt {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e);
    const t = this.document;
    let n = !1;
    t.on("keydown", (s, o) => {
      n = o.shiftKey;
    }), t.on("beforeinput", (s, o) => {
      if (!this.isEnabled)
        return;
      let r = o.inputType;
      M.isSafari && n && r == "insertParagraph" && (r = "insertLineBreak");
      const a = o.domEvent, l = JI[r];
      if (!l)
        return;
      const c = new hi(t, "enter", o.targetRanges[0]);
      t.fire(c, new Yn(e, a, {
        isSoft: l.isSoft
      })), c.stop.called && s.stop();
    });
  }
  /**
   * @inheritDoc
   */
  observe() {
  }
  /**
   * @inheritDoc
   */
  stopObserving() {
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ar extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Enter";
  }
  init() {
    const e = this.editor, t = e.editing.view, n = t.document, s = this.editor.t;
    t.addObserver(Qg), e.commands.add("enter", new ZI(e)), this.listenTo(n, "enter", (o, r) => {
      n.isComposing || r.preventDefault(), !r.isSoft && (e.execute("enter"), t.scrollToTheSelection());
    }, { priority: "low" }), e.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: s("Insert a hard break (a new paragraph)"),
          keystroke: "Enter"
        }
      ]
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class XI extends V {
  /**
   * @inheritDoc
   */
  execute() {
    const e = this.editor.model, t = e.document;
    e.change((n) => {
      YI(e, n, t.selection), this.fire("afterExecute", { writer: n });
    });
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor.model, t = e.document;
    this.isEnabled = QI(e.schema, t.selection);
  }
}
function QI(i, e) {
  if (e.rangeCount > 1)
    return !1;
  const t = e.anchor;
  if (!t || !i.checkChild(t, "softBreak"))
    return !1;
  const n = e.getFirstRange(), s = n.start.parent, o = n.end.parent;
  return !((Ca(s, i) || Ca(o, i)) && s !== o);
}
function YI(i, e, t) {
  const n = t.isCollapsed, s = t.getFirstRange(), o = s.start.parent, r = s.end.parent, a = o == r;
  if (n) {
    const l = Xg(i.schema, t.getAttributes());
    _d(i, e, s.end), e.removeSelectionAttribute(t.getAttributeKeys()), e.setSelectionAttribute(l);
  } else {
    const l = !(s.start.isAtStart && s.end.isAtEnd);
    i.deleteContent(t, { leaveUnmerged: l }), a ? _d(i, e, t.focus) : l && e.setSelection(r, 0);
  }
}
function _d(i, e, t) {
  const n = e.createElement("softBreak");
  i.insertContent(n, t), e.setSelection(n, "after");
}
function Ca(i, e) {
  return i.is("rootElement") ? !1 : e.isLimit(i) || Ca(i.parent, e);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class eS extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ShiftEnter";
  }
  init() {
    const e = this.editor, t = e.model.schema, n = e.conversion, s = e.editing.view, o = s.document, r = this.editor.t;
    t.register("softBreak", {
      allowWhere: "$text",
      isInline: !0
    }), n.for("upcast").elementToElement({
      model: "softBreak",
      view: "br"
    }), n.for("downcast").elementToElement({
      model: "softBreak",
      view: (a, { writer: l }) => l.createEmptyElement("br")
    }), s.addObserver(Qg), e.commands.add("shiftEnter", new XI(e)), this.listenTo(o, "enter", (a, l) => {
      o.isComposing || l.preventDefault(), l.isSoft && (e.execute("shiftEnter"), s.scrollToTheSelection());
    }, { priority: "low" }), e.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: r("Insert a soft break (a <code>&lt;br&gt;</code> element)"),
          keystroke: "Shift+Enter"
        }
      ]
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class tS extends G() {
  constructor() {
    super(...arguments), this._stack = [];
  }
  /**
   * Adds highlight descriptor to the stack.
   *
   * @fires change:top
   */
  add(e, t) {
    const n = this._stack, s = n[0];
    this._insertDescriptor(e);
    const o = n[0];
    s !== o && !Fr(s, o) && this.fire("change:top", {
      oldDescriptor: s,
      newDescriptor: o,
      writer: t
    });
  }
  /**
   * Removes highlight descriptor from the stack.
   *
   * @fires change:top
   * @param id Id of the descriptor to remove.
   */
  remove(e, t) {
    const n = this._stack, s = n[0];
    this._removeDescriptor(e);
    const o = n[0];
    s !== o && !Fr(s, o) && this.fire("change:top", {
      oldDescriptor: s,
      newDescriptor: o,
      writer: t
    });
  }
  /**
   * Inserts a given descriptor in correct place in the stack. It also takes care about updating information
   * when descriptor with same id is already present.
   */
  _insertDescriptor(e) {
    const t = this._stack, n = t.findIndex((o) => o.id === e.id);
    if (Fr(e, t[n]))
      return;
    n > -1 && t.splice(n, 1);
    let s = 0;
    for (; t[s] && nS(t[s], e); )
      s++;
    t.splice(s, 0, e);
  }
  /**
   * Removes descriptor with given id from the stack.
   *
   * @param id Descriptor's id.
   */
  _removeDescriptor(e) {
    const t = this._stack, n = t.findIndex((s) => s.id === e);
    n > -1 && t.splice(n, 1);
  }
}
function Fr(i, e) {
  return i && e && i.priority == e.priority && Io(i.classes) == Io(e.classes);
}
function nS(i, e) {
  return i.priority > e.priority ? !0 : i.priority < e.priority ? !1 : Io(i.classes) > Io(e.classes);
}
function Io(i) {
  return Array.isArray(i) ? i.sort().join(",") : i;
}
const iS = '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>';
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const sS = "ck-widget", vd = "ck-widget_selected";
function ae(i) {
  return i.is("element") ? !!i.getCustomProperty("widget") : !1;
}
function lr(i, e, t = {}) {
  if (!i.is("containerElement"))
    throw new g("widget-to-widget-wrong-element-type", null, { element: i });
  return e.setAttribute("contenteditable", "false", i), e.addClass(sS, i), e.setCustomProperty("widget", !0, i), i.getFillerOffset = cS, e.setCustomProperty("widgetLabel", [], i), t.label && aS(i, t.label), t.hasSelectionHandle && uS(i, e), Yg(i, e), i;
}
function oS(i, e, t) {
  if (e.classes && t.addClass(Z(e.classes), i), e.attributes)
    for (const n in e.attributes)
      t.setAttribute(n, e.attributes[n], i);
}
function rS(i, e, t) {
  if (e.classes && t.removeClass(Z(e.classes), i), e.attributes)
    for (const n in e.attributes)
      t.removeAttribute(n, i);
}
function Yg(i, e, t = oS, n = rS) {
  const s = new tS();
  s.on("change:top", (a, l) => {
    l.oldDescriptor && n(i, l.oldDescriptor, l.writer), l.newDescriptor && t(i, l.newDescriptor, l.writer);
  });
  const o = (a, l, c) => s.add(l, c), r = (a, l, c) => s.remove(l, c);
  e.setCustomProperty("addHighlight", o, i), e.setCustomProperty("removeHighlight", r, i);
}
function aS(i, e) {
  i.getCustomProperty("widgetLabel").push(e);
}
function lS(i) {
  return i.getCustomProperty("widgetLabel").reduce((t, n) => typeof n == "function" ? t ? t + ". " + n() : n() : t ? t + ". " + n : n, "");
}
function Ml(i, e, t = {}) {
  return e.addClass(["ck-editor__editable", "ck-editor__nested-editable"], i), e.setAttribute("role", "textbox", i), e.setAttribute("tabindex", "-1", i), t.label && e.setAttribute("aria-label", t.label, i), e.setAttribute("contenteditable", i.isReadOnly ? "false" : "true", i), i.on("change:isReadOnly", (n, s, o) => {
    e.setAttribute("contenteditable", o ? "false" : "true", i);
  }), i.on("change:isFocused", (n, s, o) => {
    o ? e.addClass("ck-editor__nested-editable_focused", i) : e.removeClass("ck-editor__nested-editable_focused", i);
  }), Yg(i, e), i;
}
function Bl(i, e) {
  const t = i.getSelectedElement();
  if (t) {
    const n = Nt(i);
    if (n)
      return e.createRange(e.createPositionAt(t, n));
  }
  return e.schema.findOptimalInsertionRange(i);
}
function cS() {
  return null;
}
function uS(i, e) {
  const t = e.createUIElement("div", { class: "ck ck-widget__selection-handle" }, function(n) {
    const s = this.toDomElement(n), o = new ut();
    return o.set("content", iS), o.render(), s.appendChild(o.element), s;
  });
  e.insert(e.createPositionAt(i, 0), t), e.addClass(["ck-widget_with-selection-handle"], i);
}
function Ll(i) {
  const e = (a) => {
    const { width: l, paddingLeft: c, paddingRight: u } = a.ownerDocument.defaultView.getComputedStyle(a);
    return parseFloat(l) - (parseFloat(c) || 0) - (parseFloat(u) || 0);
  }, t = i.parentElement;
  if (!t)
    return 0;
  let n = e(t);
  const s = 5;
  let o = 0, r = t;
  for (; isNaN(n); ) {
    if (r = r.parentElement, ++o > s)
      return 0;
    n = e(r);
  }
  return n;
}
function dS(i, e = new B(i)) {
  const t = Ll(i);
  return t ? e.width / t * 100 : 0;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Ct = "widget-type-around";
function en(i, e, t) {
  return !!i && ae(i) && !t.isInline(e);
}
function hS(i) {
  return i.closest(".ck-widget__type-around__button");
}
function fS(i) {
  return i.classList.contains("ck-widget__type-around__button_before") ? "before" : "after";
}
function mS(i, e) {
  const t = i.closest(".ck-widget");
  return e.mapDomToView(t);
}
function Nt(i) {
  return i.getAttribute(Ct);
}
const gS = '<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>';
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const ep = ["before", "after"], pS = new DOMParser().parseFromString(gS, "image/svg+xml").firstChild, yd = "ck-widget__type-around_disabled";
class bS extends b {
  constructor() {
    super(...arguments), this._currentFakeCaretModelElement = null;
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "WidgetTypeAround";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ar, bt];
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.editing.view;
    this.on("change:isEnabled", (n, s, o) => {
      t.change((r) => {
        for (const a of t.document.roots)
          o ? r.removeClass(yd, a) : r.addClass(yd, a);
      }), o || e.model.change((r) => {
        r.removeSelectionAttribute(Ct);
      });
    }), this._enableTypeAroundUIInjection(), this._enableInsertingParagraphsOnButtonClick(), this._enableInsertingParagraphsOnEnterKeypress(), this._enableInsertingParagraphsOnTypingKeystroke(), this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows(), this._enableDeleteIntegration(), this._enableInsertContentIntegration(), this._enableInsertObjectIntegration(), this._enableDeleteContentIntegration();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this._currentFakeCaretModelElement = null;
  }
  /**
   * Inserts a new paragraph next to a widget element with the selection anchored in it.
   *
   * **Note**: This method is heavily user-oriented and will both focus the editing view and scroll
   * the viewport to the selection in the inserted paragraph.
   *
   * @param widgetModelElement The model widget element next to which a paragraph is inserted.
   * @param position The position where the paragraph is inserted. Either `'before'` or `'after'` the widget.
   */
  _insertParagraph(e, t) {
    const n = this.editor, s = n.editing.view, o = n.model.schema.getAttributesWithProperty(e, "copyOnReplace", !0);
    n.execute("insertParagraph", {
      position: n.model.createPositionAt(e, t),
      attributes: o
    }), s.focus(), s.scrollToTheSelection();
  }
  /**
   * A wrapper for the {@link module:utils/emittermixin~Emitter#listenTo} method that executes the callbacks only
   * when the plugin {@link #isEnabled is enabled}.
   *
   * @param emitter The object that fires the event.
   * @param event The name of the event.
   * @param callback The function to be called on event.
   * @param options Additional options.
   * @param options.priority The priority of this event callback. The higher the priority value the sooner
   * the callback will be fired. Events having the same priority are called in the order they were added.
   */
  _listenToIfEnabled(e, t, n, s) {
    this.listenTo(e, t, (...o) => {
      this.isEnabled && n(...o);
    }, s);
  }
  /**
   * Similar to {@link #_insertParagraph}, this method inserts a paragraph except that it
   * does not expect a position. Instead, it performs the insertion next to a selected widget
   * according to the `widget-type-around` model selection attribute value (fake caret position).
   *
   * Because this method requires the `widget-type-around` attribute to be set,
   * the insertion can only happen when the widget's fake caret is active (e.g. activated
   * using the keyboard).
   *
   * @returns Returns `true` when the paragraph was inserted (the attribute was present) and `false` otherwise.
   */
  _insertParagraphAccordingToFakeCaretPosition() {
    const n = this.editor.model.document.selection, s = Nt(n);
    if (!s)
      return !1;
    const o = n.getSelectedElement();
    return this._insertParagraph(o, s), !0;
  }
  /**
   * Creates a listener in the editing conversion pipeline that injects the widget type around
   * UI into every single widget instance created in the editor.
   *
   * The UI is delivered as a {@link module:engine/view/uielement~UIElement}
   * wrapper which renders DOM buttons that users can use to insert paragraphs.
   */
  _enableTypeAroundUIInjection() {
    const e = this.editor, t = e.model.schema, n = e.locale.t, s = {
      before: n("Insert paragraph before block"),
      after: n("Insert paragraph after block")
    };
    e.editing.downcastDispatcher.on("insert", (o, r, a) => {
      const l = a.mapper.toViewElement(r.item);
      l && en(l, r.item, t) && (wS(a.writer, s, l), l.getCustomProperty("widgetLabel").push(() => this.isEnabled ? n("Press Enter to type after or press Shift + Enter to type before the widget") : ""));
    }, { priority: "low" });
  }
  /**
   * Brings support for the fake caret that appears when either:
   *
   * * the selection moves to a widget from a position next to it using arrow keys,
   * * the arrow key is pressed when the widget is already selected.
   *
   * The fake caret lets the user know that they can start typing or just press
   * <kbd>Enter</kbd> to insert a paragraph at the position next to a widget as suggested by the fake caret.
   *
   * The fake caret disappears when the user changes the selection or the editor
   * gets blurred.
   *
   * The whole idea is as follows:
   *
   * 1. A user does one of the 2 scenarios described at the beginning.
   * 2. The "keydown" listener is executed and the decision is made whether to show or hide the fake caret.
   * 3. If it should show up, the `widget-type-around` model selection attribute is set indicating
   *    on which side of the widget it should appear.
   * 4. The selection dispatcher reacts to the selection attribute and sets CSS classes responsible for the
   *    fake caret on the view widget.
   * 5. If the fake caret should disappear, the selection attribute is removed and the dispatcher
   *    does the CSS class clean-up in the view.
   * 6. Additionally, `change:range` and `FocusTracker#isFocused` listeners also remove the selection
   *    attribute (the former also removes widget CSS classes).
   */
  _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
    const e = this.editor, t = e.model, n = t.document.selection, s = t.schema, o = e.editing.view;
    this._listenToIfEnabled(o.document, "arrowKey", (a, l) => {
      this._handleArrowKeyPress(a, l);
    }, { context: [ae, "$text"], priority: "high" }), this._listenToIfEnabled(n, "change:range", (a, l) => {
      l.directChange && e.model.change((c) => {
        c.removeSelectionAttribute(Ct);
      });
    }), this._listenToIfEnabled(t.document, "change:data", () => {
      const a = n.getSelectedElement();
      if (a) {
        const l = e.editing.mapper.toViewElement(a);
        if (en(l, a, s))
          return;
      }
      e.model.change((l) => {
        l.removeSelectionAttribute(Ct);
      });
    }), this._listenToIfEnabled(e.editing.downcastDispatcher, "selection", (a, l, c) => {
      const u = c.writer;
      if (this._currentFakeCaretModelElement) {
        const m = c.mapper.toViewElement(this._currentFakeCaretModelElement);
        m && (u.removeClass(ep.map(r), m), this._currentFakeCaretModelElement = null);
      }
      const d = l.selection.getSelectedElement();
      if (!d)
        return;
      const h = c.mapper.toViewElement(d);
      if (!en(h, d, s))
        return;
      const f = Nt(l.selection);
      f && (u.addClass(r(f), h), this._currentFakeCaretModelElement = d);
    }), this._listenToIfEnabled(e.ui.focusTracker, "change:isFocused", (a, l, c) => {
      c || e.model.change((u) => {
        u.removeSelectionAttribute(Ct);
      });
    });
    function r(a) {
      return `ck-widget_type-around_show-fake-caret_${a}`;
    }
  }
  /**
   * A listener executed on each "keydown" in the view document, a part of
   * {@link #_enableTypeAroundFakeCaretActivationUsingKeyboardArrows}.
   *
   * It decides whether the arrow keypress should activate the fake caret or not (also whether it should
   * be deactivated).
   *
   * The fake caret activation is done by setting the `widget-type-around` model selection attribute
   * in this listener, and stopping and preventing the event that would normally be handled by the widget
   * plugin that is responsible for the regular keyboard navigation near/across all widgets (that
   * includes inline widgets, which are ignored by the widget type around plugin).
   */
  _handleArrowKeyPress(e, t) {
    const n = this.editor, s = n.model, o = s.document.selection, r = s.schema, a = n.editing.view, l = t.keyCode, c = xC(l, n.locale.contentLanguageDirection), u = a.document.selection.getSelectedElement(), d = n.editing.mapper.toModelElement(u);
    let h;
    en(u, d, r) ? h = this._handleArrowKeyPressOnSelectedWidget(c) : o.isCollapsed ? h = this._handleArrowKeyPressWhenSelectionNextToAWidget(c) : t.shiftKey || (h = this._handleArrowKeyPressWhenNonCollapsedSelection(c)), h && (t.preventDefault(), e.stop());
  }
  /**
   * Handles the keyboard navigation on "keydown" when a widget is currently selected and activates or deactivates
   * the fake caret for that widget, depending on the current value of the `widget-type-around` model
   * selection attribute and the direction of the pressed arrow key.
   *
   * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement
   * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.
   * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should
   * process the event any further. Returns `false` otherwise.
   */
  _handleArrowKeyPressOnSelectedWidget(e) {
    const n = this.editor.model, s = n.document.selection, o = Nt(s);
    return n.change((r) => {
      if (o) {
        if (!(o === (e ? "after" : "before")))
          return r.removeSelectionAttribute(Ct), !0;
      } else
        return r.setSelectionAttribute(Ct, e ? "after" : "before"), !0;
      return !1;
    });
  }
  /**
   * Handles the keyboard navigation on "keydown" when **no** widget is selected but the selection is **directly** next
   * to one and upon the fake caret should become active for this widget upon arrow keypress
   * (AKA entering/selecting the widget).
   *
   * **Note**: This code mirrors the implementation from the widget plugin but also adds the selection attribute.
   * Unfortunately, there is no safe way to let the widget plugin do the selection part first and then just set the
   * selection attribute here in the widget type around plugin. This is why this code must duplicate some from the widget plugin.
   *
   * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement
   * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.
   * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should
   * process the event any further. Returns `false` otherwise.
   */
  _handleArrowKeyPressWhenSelectionNextToAWidget(e) {
    const t = this.editor, n = t.model, s = n.schema, o = t.plugins.get("Widget"), r = o._getObjectElementNextToSelection(e), a = t.editing.mapper.toViewElement(r);
    return en(a, r, s) ? (n.change((l) => {
      o._setSelectionOverElement(r), l.setSelectionAttribute(Ct, e ? "before" : "after");
    }), !0) : !1;
  }
  /**
   * Handles the keyboard navigation on "keydown" when a widget is currently selected (together with some other content)
   * and the widget is the first or last element in the selection. It activates or deactivates the fake caret for that widget.
   *
   * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement
   * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.
   * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should
   * process the event any further. Returns `false` otherwise.
   */
  _handleArrowKeyPressWhenNonCollapsedSelection(e) {
    const t = this.editor, n = t.model, s = n.schema, o = t.editing.mapper, r = n.document.selection, a = e ? r.getLastPosition().nodeBefore : r.getFirstPosition().nodeAfter, l = o.toViewElement(a);
    return en(l, a, s) ? (n.change((c) => {
      c.setSelection(a, "on"), c.setSelectionAttribute(Ct, e ? "after" : "before");
    }), !0) : !1;
  }
  /**
   * Registers a `mousedown` listener for the view document which intercepts events
   * coming from the widget type around UI, which happens when a user clicks one of the buttons
   * that insert a paragraph next to a widget.
   */
  _enableInsertingParagraphsOnButtonClick() {
    const e = this.editor, t = e.editing.view;
    this._listenToIfEnabled(t.document, "mousedown", (n, s) => {
      const o = hS(s.domTarget);
      if (!o)
        return;
      const r = fS(o), a = mS(o, t.domConverter), l = e.editing.mapper.toModelElement(a);
      this._insertParagraph(l, r), s.preventDefault(), n.stop();
    });
  }
  /**
   * Creates the <kbd>Enter</kbd> key listener on the view document that allows the user to insert a paragraph
   * near the widget when either:
   *
   * * The fake caret was first activated using the arrow keys,
   * * The entire widget is selected in the model.
   *
   * In the first case, the new paragraph is inserted according to the `widget-type-around` selection
   * attribute (see {@link #_handleArrowKeyPress}).
   *
   * In the second case, the new paragraph is inserted based on whether a soft (<kbd>Shift</kbd>+<kbd>Enter</kbd>) keystroke
   * was pressed or not.
   */
  _enableInsertingParagraphsOnEnterKeypress() {
    const e = this.editor, t = e.model.document.selection, n = e.editing.view;
    this._listenToIfEnabled(n.document, "enter", (s, o) => {
      if (s.eventPhase != "atTarget")
        return;
      const r = t.getSelectedElement(), a = e.editing.mapper.toViewElement(r), l = e.model.schema;
      let c;
      this._insertParagraphAccordingToFakeCaretPosition() ? c = !0 : en(a, r, l) && (this._insertParagraph(r, o.isSoft ? "before" : "after"), c = !0), c && (o.preventDefault(), s.stop());
    }, { context: ae });
  }
  /**
   * Similar to the {@link #_enableInsertingParagraphsOnEnterKeypress}, it allows the user
   * to insert a paragraph next to a widget when the fake caret was activated using arrow
   * keys but it responds to typing instead of <kbd>Enter</kbd>.
   *
   * Listener enabled by this method will insert a new paragraph according to the `widget-type-around`
   * model selection attribute as the user simply starts typing, which creates the impression that the fake caret
   * behaves like a real one rendered by the browser (AKA your text appears where the caret was).
   *
   * **Note**: At the moment this listener creates 2 undo steps: one for the `insertParagraph` command
   * and another one for actual typing. It is not a disaster but this may need to be fixed
   * sooner or later.
   */
  _enableInsertingParagraphsOnTypingKeystroke() {
    const t = this.editor.editing.view.document;
    this._listenToIfEnabled(t, "insertText", (n, s) => {
      this._insertParagraphAccordingToFakeCaretPosition() && (s.selection = t.selection);
    }, { priority: "high" }), M.isAndroid ? this._listenToIfEnabled(t, "keydown", (n, s) => {
      s.keyCode == 229 && this._insertParagraphAccordingToFakeCaretPosition();
    }) : this._listenToIfEnabled(t, "compositionstart", () => {
      this._insertParagraphAccordingToFakeCaretPosition();
    }, { priority: "high" });
  }
  /**
   * It creates a "delete" event listener on the view document to handle cases when the <kbd>Delete</kbd> or <kbd>Backspace</kbd>
   * is pressed and the fake caret is currently active.
   *
   * The fake caret should create an illusion of a real browser caret so that when it appears before or after
   * a widget, pressing <kbd>Delete</kbd> or <kbd>Backspace</kbd> should remove a widget or delete the content
   * before or after a widget (depending on the content surrounding the widget).
   */
  _enableDeleteIntegration() {
    const e = this.editor, t = e.editing.view, n = e.model, s = n.schema;
    this._listenToIfEnabled(t.document, "delete", (o, r) => {
      if (o.eventPhase != "atTarget")
        return;
      const a = Nt(n.document.selection);
      if (!a)
        return;
      const l = r.direction, c = n.document.selection.getSelectedElement(), u = a === "before", d = l == "forward";
      if (u === d)
        e.execute("delete", {
          selection: n.createSelection(c, "on")
        });
      else {
        const f = s.getNearestSelectionRange(n.createPositionAt(c, a), l);
        if (f)
          if (!f.isCollapsed)
            n.change((m) => {
              m.setSelection(f), e.execute(d ? "deleteForward" : "delete");
            });
          else {
            const m = n.createSelection(f.start);
            if (n.modifySelection(m, { direction: l }), !m.focus.isEqual(f.start))
              n.change((p) => {
                p.setSelection(f), e.execute(d ? "deleteForward" : "delete");
              });
            else {
              const p = yS(s, f.start.parent);
              n.deleteContent(n.createSelection(p, "on"), {
                doNotAutoparagraph: !0
              });
            }
          }
      }
      r.preventDefault(), o.stop();
    }, { context: ae });
  }
  /**
   * Attaches the {@link module:engine/model/model~Model#event:insertContent} event listener that, for instance, allows the user to paste
   * content near a widget when the fake caret is first activated using the arrow keys.
   *
   * The content is inserted according to the `widget-type-around` selection attribute (see {@link #_handleArrowKeyPress}).
   */
  _enableInsertContentIntegration() {
    const e = this.editor, t = this.editor.model, n = t.document.selection;
    this._listenToIfEnabled(e.model, "insertContent", (s, [o, r]) => {
      if (r && !r.is("documentSelection"))
        return;
      const a = Nt(n);
      if (a)
        return s.stop(), t.change((l) => {
          const c = n.getSelectedElement(), u = t.createPositionAt(c, a), d = l.createSelection(u), h = t.insertContent(o, d);
          return l.setSelection(d), h;
        });
    }, { priority: "high" });
  }
  /**
   * Attaches the {@link module:engine/model/model~Model#event:insertObject} event listener that modifies the
   * `options.findOptimalPosition`parameter to position of fake caret in relation to selected element
   * to reflect user's intent of desired insertion position.
   *
   * The object is inserted according to the `widget-type-around` selection attribute (see {@link #_handleArrowKeyPress}).
   */
  _enableInsertObjectIntegration() {
    const e = this.editor, n = this.editor.model.document.selection;
    this._listenToIfEnabled(e.model, "insertObject", (s, o) => {
      const [, r, a = {}] = o;
      if (r && !r.is("documentSelection"))
        return;
      const l = Nt(n);
      l && (a.findOptimalPosition = l, o[3] = a);
    }, { priority: "high" });
  }
  /**
   * Attaches the {@link module:engine/model/model~Model#event:deleteContent} event listener to block the event when the fake
   * caret is active.
   *
   * This is required for cases that trigger {@link module:engine/model/model~Model#deleteContent `model.deleteContent()`}
   * before calling {@link module:engine/model/model~Model#insertContent `model.insertContent()`} like, for instance,
   * plain text pasting.
   */
  _enableDeleteContentIntegration() {
    const e = this.editor, n = this.editor.model.document.selection;
    this._listenToIfEnabled(e.model, "deleteContent", (s, [o]) => {
      if (o && !o.is("documentSelection"))
        return;
      Nt(n) && s.stop();
    }, { priority: "high" });
  }
}
function wS(i, e, t) {
  const n = i.createUIElement("div", {
    class: "ck ck-reset_all ck-widget__type-around"
  }, function(s) {
    const o = this.toDomElement(s);
    return _S(o, e), vS(o), o;
  });
  i.insert(i.createPositionAt(t, "end"), n);
}
function _S(i, e) {
  for (const t of ep) {
    const n = new Me({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-widget__type-around__button",
          `ck-widget__type-around__button_${t}`
        ],
        title: e[t],
        "aria-hidden": "true"
      },
      children: [
        i.ownerDocument.importNode(pS, !0)
      ]
    });
    i.appendChild(n.render());
  }
}
function vS(i) {
  const e = new Me({
    tag: "div",
    attributes: {
      class: [
        "ck",
        "ck-widget__type-around__fake-caret"
      ]
    }
  });
  i.appendChild(e.render());
}
function yS(i, e) {
  let t = e;
  for (const n of e.getAncestors({ parentFirst: !0 })) {
    if (n.childCount > 1 || i.isLimit(n))
      break;
    t = n;
  }
  return t;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function CS(i) {
  const e = i.model;
  return (t, n) => {
    const s = n.keyCode == N.arrowup, o = n.keyCode == N.arrowdown, r = n.shiftKey, a = e.document.selection;
    if (!s && !o)
      return;
    const l = o;
    if (r && ES(a, l))
      return;
    const c = kS(i, a, l);
    if (c) {
      if (c.isCollapsed) {
        if (a.isCollapsed)
          return;
        if (r)
          return;
      }
      (c.isCollapsed || TS(i, c, l)) && (e.change((u) => {
        const d = l ? c.end : c.start;
        if (r) {
          const h = e.createSelection(a.anchor);
          h.setFocus(d), u.setSelection(h);
        } else
          u.setSelection(d);
      }), t.stop(), n.preventDefault(), n.stopPropagation());
    }
  };
}
function kS(i, e, t) {
  const n = i.model;
  if (t) {
    const s = e.isCollapsed ? e.focus : e.getLastPosition(), o = Cd(n, s, "forward");
    if (!o)
      return null;
    const r = n.createRange(s, o), a = kd(n.schema, r, "backward");
    return a ? n.createRange(s, a) : null;
  } else {
    const s = e.isCollapsed ? e.focus : e.getFirstPosition(), o = Cd(n, s, "backward");
    if (!o)
      return null;
    const r = n.createRange(o, s), a = kd(n.schema, r, "forward");
    return a ? n.createRange(a, s) : null;
  }
}
function Cd(i, e, t) {
  const n = i.schema, s = i.createRangeIn(e.root), o = t == "forward" ? "elementStart" : "elementEnd";
  for (const { previousPosition: r, item: a, type: l } of s.getWalker({ startPosition: e, direction: t })) {
    if (n.isLimit(a) && !n.isInline(a))
      return r;
    if (l == o && n.isBlock(a))
      return null;
  }
  return null;
}
function kd(i, e, t) {
  const n = t == "backward" ? e.end : e.start;
  if (i.checkChild(n, "$text"))
    return n;
  for (const { nextPosition: s } of e.getWalker({ direction: t }))
    if (i.checkChild(s, "$text"))
      return s;
  return null;
}
function TS(i, e, t) {
  const n = i.model, s = i.view.domConverter;
  if (t) {
    const c = n.createSelection(e.start);
    n.modifySelection(c), !c.focus.isAtEnd && !e.start.isEqual(c.focus) && (e = n.createRange(c.focus, e.end));
  }
  const o = i.mapper.toViewRange(e), r = s.viewRangeToDom(o), a = B.getDomRangeRects(r);
  let l;
  for (const c of a) {
    if (l === void 0) {
      l = Math.round(c.bottom);
      continue;
    }
    if (Math.round(c.top) >= l)
      return !1;
    l = Math.max(l, Math.round(c.bottom));
  }
  return !0;
}
function ES(i, e) {
  return !i.isCollapsed && i.isBackward == e;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class gi extends b {
  constructor() {
    super(...arguments), this._previouslySelected = /* @__PURE__ */ new Set();
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Widget";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [bS, bt];
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.editing.view, n = t.document, s = e.t;
    this.editor.editing.downcastDispatcher.on("selection", (o, r, a) => {
      const l = a.writer, c = r.selection;
      if (c.isCollapsed)
        return;
      const u = c.getSelectedElement();
      if (!u)
        return;
      const d = e.editing.mapper.toViewElement(u);
      ae(d) && a.consumable.consume(c, "selection") && l.setSelection(l.createRangeOn(d), {
        fake: !0,
        label: lS(d)
      });
    }), this.editor.editing.downcastDispatcher.on("selection", (o, r, a) => {
      this._clearPreviouslySelectedWidgets(a.writer);
      const l = a.writer, c = l.document.selection;
      let u = null;
      for (const d of c.getRanges())
        for (const h of d) {
          const f = h.item;
          ae(f) && !xS(f, u) && (l.addClass(vd, f), this._previouslySelected.add(f), u = f);
        }
    }, { priority: "low" }), t.addObserver(Qo), this.listenTo(n, "mousedown", (...o) => this._onMousedown(...o)), this.listenTo(n, "arrowKey", (...o) => {
      this._handleSelectionChangeOnArrowKeyPress(...o);
    }, { context: [ae, "$text"] }), this.listenTo(n, "arrowKey", (...o) => {
      this._preventDefaultOnArrowKeyPress(...o);
    }, { context: "$root" }), this.listenTo(n, "arrowKey", CS(this.editor.editing), { context: "$text" }), this.listenTo(n, "delete", (o, r) => {
      this._handleDelete(r.direction == "forward") && (r.preventDefault(), o.stop());
    }, { context: "$root" }), this.listenTo(n, "tab", (o, r) => {
      o.eventPhase == "atTarget" && (r.shiftKey || this._selectFirstNestedEditable() && (r.preventDefault(), o.stop()));
    }, { context: ae, priority: "low" }), this.listenTo(n, "tab", (o, r) => {
      r.shiftKey && this._selectAncestorWidget() && (r.preventDefault(), o.stop());
    }, { priority: "low" }), this.listenTo(n, "keydown", (o, r) => {
      r.keystroke == N.esc && this._selectAncestorWidget() && (r.preventDefault(), o.stop());
    }, { priority: "low" }), e.accessibility.addKeystrokeInfoGroup({
      id: "widget",
      label: s("Keystrokes that can be used when a widget is selected (for example: image, table, etc.)"),
      keystrokes: [
        {
          label: s("Insert a new paragraph directly after a widget"),
          keystroke: "Enter"
        },
        {
          label: s("Insert a new paragraph directly before a widget"),
          keystroke: "Shift+Enter"
        },
        {
          label: s("Move the caret to allow typing directly before a widget"),
          keystroke: [["arrowup"], ["arrowleft"]]
        },
        {
          label: s("Move the caret to allow typing directly after a widget"),
          keystroke: [["arrowdown"], ["arrowright"]]
        }
      ]
    });
  }
  /**
   * Handles {@link module:engine/view/document~Document#event:mousedown mousedown} events on widget elements.
   */
  _onMousedown(e, t) {
    const n = this.editor, s = n.editing.view, o = s.document;
    let r = t.target;
    if (t.domEvent.detail >= 3) {
      this._selectBlockContent(r) && t.preventDefault();
      return;
    }
    if (AS(r) || !ae(r) && (r = r.findAncestor(ae), !r))
      return;
    M.isAndroid && t.preventDefault(), o.isFocused || s.focus();
    const a = n.editing.mapper.toModelElement(r);
    this._setSelectionOverElement(a);
  }
  /**
   * Selects entire block content, e.g. on triple click it selects entire paragraph.
   */
  _selectBlockContent(e) {
    const t = this.editor, n = t.model, s = t.editing.mapper, o = n.schema, r = s.findMappedViewAncestor(this.editor.editing.view.createPositionAt(e, 0)), a = IS(s.toModelElement(r), n.schema);
    return a ? (n.change((l) => {
      const c = o.isLimit(a) ? null : SS(l.createPositionAfter(a), o), u = l.createPositionAt(a, 0), d = c ? l.createPositionAt(c, 0) : l.createPositionAt(a, "end");
      l.setSelection(l.createRange(u, d));
    }), !0) : !1;
  }
  /**
   * Handles {@link module:engine/view/document~Document#event:keydown keydown} events and changes
   * the model selection when:
   *
   * * arrow key is pressed when the widget is selected,
   * * the selection is next to a widget and the widget should become selected upon the arrow key press.
   *
   * See {@link #_preventDefaultOnArrowKeyPress}.
   */
  _handleSelectionChangeOnArrowKeyPress(e, t) {
    const n = t.keyCode, s = this.editor.model, o = s.schema, r = s.document.selection, a = r.getSelectedElement(), l = ll(n, this.editor.locale.contentLanguageDirection), c = l == "down" || l == "right", u = l == "up" || l == "down";
    if (a && o.isObject(a)) {
      const h = c ? r.getLastPosition() : r.getFirstPosition(), f = o.getNearestSelectionRange(h, c ? "forward" : "backward");
      f && (s.change((m) => {
        m.setSelection(f);
      }), t.preventDefault(), e.stop());
      return;
    }
    if (!r.isCollapsed && !t.shiftKey) {
      const h = r.getFirstPosition(), f = r.getLastPosition(), m = h.nodeAfter, p = f.nodeBefore;
      (m && o.isObject(m) || p && o.isObject(p)) && (s.change((w) => {
        w.setSelection(c ? f : h);
      }), t.preventDefault(), e.stop());
      return;
    }
    if (!r.isCollapsed)
      return;
    const d = this._getObjectElementNextToSelection(c);
    if (d && o.isObject(d)) {
      if (o.isInline(d) && u)
        return;
      this._setSelectionOverElement(d), t.preventDefault(), e.stop();
    }
  }
  /**
   * Handles {@link module:engine/view/document~Document#event:keydown keydown} events and prevents
   * the default browser behavior to make sure the fake selection is not being moved from a fake selection
   * container.
   *
   * See {@link #_handleSelectionChangeOnArrowKeyPress}.
   */
  _preventDefaultOnArrowKeyPress(e, t) {
    const n = this.editor.model, s = n.schema, o = n.document.selection.getSelectedElement();
    o && s.isObject(o) && (t.preventDefault(), e.stop());
  }
  /**
   * Handles delete keys: backspace and delete.
   *
   * @param isForward Set to true if delete was performed in forward direction.
   * @returns Returns `true` if keys were handled correctly.
   */
  _handleDelete(e) {
    const n = this.editor.model.document.selection;
    if (!this.editor.model.canEditAt(n) || !n.isCollapsed)
      return;
    const s = this._getObjectElementNextToSelection(e);
    if (s)
      return this.editor.model.change((o) => {
        let r = n.anchor.parent;
        for (; r.isEmpty; ) {
          const a = r;
          r = a.parent, o.remove(a);
        }
        this._setSelectionOverElement(s);
      }), !0;
  }
  /**
   * Sets {@link module:engine/model/selection~Selection document's selection} over given element.
   *
   * @internal
   */
  _setSelectionOverElement(e) {
    this.editor.model.change((t) => {
      t.setSelection(t.createRangeOn(e));
    });
  }
  /**
   * Checks if {@link module:engine/model/element~Element element} placed next to the current
   * {@link module:engine/model/selection~Selection model selection} exists and is marked in
   * {@link module:engine/model/schema~Schema schema} as `object`.
   *
   * @internal
   * @param forward Direction of checking.
   */
  _getObjectElementNextToSelection(e) {
    const t = this.editor.model, n = t.schema, s = t.document.selection, o = t.createSelection(s);
    if (t.modifySelection(o, { direction: e ? "forward" : "backward" }), o.isEqual(s))
      return null;
    const r = e ? o.focus.nodeBefore : o.focus.nodeAfter;
    return r && n.isObject(r) ? r : null;
  }
  /**
   * Removes CSS class from previously selected widgets.
   */
  _clearPreviouslySelectedWidgets(e) {
    for (const t of this._previouslySelected)
      e.removeClass(vd, t);
    this._previouslySelected.clear();
  }
  /**
   * Moves the document selection into the first nested editable.
   */
  _selectFirstNestedEditable() {
    const e = this.editor, n = this.editor.editing.view.document;
    for (const s of n.selection.getFirstRange().getItems())
      if (s.is("editableElement")) {
        const o = e.editing.mapper.toModelElement(s);
        /* istanbul ignore next -- @preserve */
        if (!o)
          continue;
        const r = e.model.createPositionAt(o, 0), a = e.model.schema.getNearestSelectionRange(r, "forward");
        return e.model.change((l) => {
          l.setSelection(a);
        }), !0;
      }
    return !1;
  }
  /**
   * Updates the document selection so that it selects first ancestor widget.
   */
  _selectAncestorWidget() {
    const e = this.editor, t = e.editing.mapper, s = e.editing.view.document.selection.getFirstPosition().parent, r = (s.is("$text") ? s.parent : s).findAncestor(ae);
    if (!r)
      return !1;
    const a = t.toModelElement(r);
    /* istanbul ignore next -- @preserve */
    return a ? (e.model.change((l) => {
      l.setSelection(a, "on");
    }), !0) : !1;
  }
}
function AS(i) {
  let e = i;
  for (; e; ) {
    if (e.is("editableElement") && !e.is("rootElement"))
      return !0;
    if (ae(e))
      return !1;
    e = e.parent;
  }
  return !1;
}
function xS(i, e) {
  return e ? Array.from(i.getAncestors()).includes(e) : !1;
}
function IS(i, e) {
  for (const t of i.getAncestors({ includeSelf: !0, parentFirst: !0 })) {
    if (e.checkChild(t, "$text"))
      return t;
    if (e.isLimit(t) && !e.isObject(t))
      break;
  }
  return null;
}
function SS(i, e) {
  const t = new At({ startPosition: i });
  for (const { item: n } of t) {
    if (e.isLimit(n) || !n.is("element"))
      return null;
    if (e.checkChild(n, "$text"))
      return n;
  }
  return null;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class So extends b {
  constructor() {
    super(...arguments), this._toolbarDefinitions = /* @__PURE__ */ new Map();
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Rt];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "WidgetToolbarRepository";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor;
    if (e.plugins.has("BalloonToolbar")) {
      const t = e.plugins.get("BalloonToolbar");
      this.listenTo(t, "show", (n) => {
        PS(e.editing.view.document.selection) && n.stop();
      }, { priority: "high" });
    }
    this._balloon = this.editor.plugins.get("ContextualBalloon"), this.on("change:isEnabled", () => {
      this._updateToolbarsVisibility();
    }), this.listenTo(e.ui, "update", () => {
      this._updateToolbarsVisibility();
    }), this.listenTo(e.ui.focusTracker, "change:isFocused", () => {
      this._updateToolbarsVisibility();
    }, { priority: "low" });
  }
  destroy() {
    super.destroy();
    for (const e of this._toolbarDefinitions.values())
      e.view.destroy();
  }
  /**
   * Registers toolbar in the WidgetToolbarRepository. It renders it in the `ContextualBalloon` based on the value of the invoked
   * `getRelatedElement` function. Toolbar items are gathered from `items` array.
   * The balloon's CSS class is by default `ck-toolbar-container` and may be override with the `balloonClassName` option.
   *
   * Note: This method should be called in the {@link module:core/plugin~PluginInterface#afterInit `Plugin#afterInit()`}
   * callback (or later) to make sure that the given toolbar items were already registered by other plugins.
   *
   * @param toolbarId An id for the toolbar. Used to
   * @param options.ariaLabel Label used by assistive technologies to describe this toolbar element.
   * @param options.items Array of toolbar items.
   * @param options.getRelatedElement Callback which returns an element the toolbar should be attached to.
   * @param options.balloonClassName CSS class for the widget balloon.
   */
  register(e, { ariaLabel: t, items: n, getRelatedElement: s, balloonClassName: o = "ck-toolbar-container" }) {
    if (!n.length) {
      D("widget-toolbar-no-items", { toolbarId: e });
      return;
    }
    const r = this.editor, a = r.t, l = new ni(r.locale);
    if (l.ariaLabel = t || a("Widget toolbar"), this._toolbarDefinitions.has(e))
      throw new g("widget-toolbar-duplicated", this, { toolbarId: e });
    const c = {
      view: l,
      getRelatedElement: s,
      balloonClassName: o,
      itemsConfig: n,
      initialized: !1
    };
    r.ui.addToolbar(l, {
      isContextual: !0,
      beforeFocus: () => {
        const u = s(r.editing.view.document.selection);
        u && this._showToolbar(c, u);
      },
      afterBlur: () => {
        this._hideToolbar(c);
      }
    }), this._toolbarDefinitions.set(e, c);
  }
  /**
   * Iterates over stored toolbars and makes them visible or hidden.
   */
  _updateToolbarsVisibility() {
    let e = 0, t = null, n = null;
    for (const s of this._toolbarDefinitions.values()) {
      const o = s.getRelatedElement(this.editor.editing.view.document.selection);
      if (!this.isEnabled || !o)
        this._isToolbarInBalloon(s) && this._hideToolbar(s);
      else if (!this.editor.ui.focusTracker.isFocused)
        this._isToolbarVisible(s) && this._hideToolbar(s);
      else {
        const r = o.getAncestors().length;
        r > e && (e = r, t = o, n = s);
      }
    }
    n && this._showToolbar(n, t);
  }
  /**
   * Hides the given toolbar.
   */
  _hideToolbar(e) {
    this._balloon.remove(e.view), this.stopListening(this._balloon, "change:visibleView");
  }
  /**
   * Shows up the toolbar if the toolbar is not visible.
   * Otherwise, repositions the toolbar's balloon when toolbar's view is the most top view in balloon stack.
   *
   * It might happen here that the toolbar's view is under another view. Then do nothing as the other toolbar view
   * should be still visible after the {@link module:ui/editorui/editorui~EditorUI#event:update}.
   */
  _showToolbar(e, t) {
    this._isToolbarVisible(e) ? Td(this.editor, t) : this._isToolbarInBalloon(e) || (e.initialized || (e.initialized = !0, e.view.fillFromConfig(e.itemsConfig, this.editor.ui.componentFactory)), this._balloon.add({
      view: e.view,
      position: tp(this.editor, t),
      balloonClassName: e.balloonClassName
    }), this.listenTo(this._balloon, "change:visibleView", () => {
      for (const n of this._toolbarDefinitions.values())
        if (this._isToolbarVisible(n)) {
          const s = n.getRelatedElement(this.editor.editing.view.document.selection);
          Td(this.editor, s);
        }
    }));
  }
  _isToolbarVisible(e) {
    return this._balloon.visibleView === e.view;
  }
  _isToolbarInBalloon(e) {
    return this._balloon.hasView(e.view);
  }
}
function Td(i, e) {
  const t = i.plugins.get("ContextualBalloon"), n = tp(i, e);
  t.updatePosition(n);
}
function tp(i, e) {
  const t = i.editing.view, n = Ce.defaultPositions;
  return {
    target: t.domConverter.mapViewToDom(e),
    positions: [
      n.northArrowSouth,
      n.northArrowSouthWest,
      n.northArrowSouthEast,
      n.southArrowNorth,
      n.southArrowNorthWest,
      n.southArrowNorthEast,
      n.viewportStickyNorth
    ]
  };
}
function PS(i) {
  const e = i.getSelectedElement();
  return !!(e && ae(e));
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class RS extends U() {
  /**
   * @param options Resizer options.
   */
  constructor(e) {
    super(), this.set("activeHandlePosition", null), this.set("proposedWidthPercents", null), this.set("proposedWidth", null), this.set("proposedHeight", null), this.set("proposedHandleHostWidth", null), this.set("proposedHandleHostHeight", null), this._options = e, this._referenceCoordinates = null;
  }
  /**
   * The original width (pixels) of the resized object when the resize process was started.
   */
  get originalWidth() {
    return this._originalWidth;
  }
  /**
   * The original height (pixels) of the resized object when the resize process was started.
   */
  get originalHeight() {
    return this._originalHeight;
  }
  /**
   * The original width (percents) of the resized object when the resize process was started.
   */
  get originalWidthPercents() {
    return this._originalWidthPercents;
  }
  /**
   * A width to height ratio of the resized image.
   */
  get aspectRatio() {
    return this._aspectRatio;
  }
  /**
   *
   * @param domResizeHandle The handle used to calculate the reference point.
   */
  begin(e, t, n) {
    const s = new B(t);
    this.activeHandlePosition = BS(e), this._referenceCoordinates = VS(t, LS(this.activeHandlePosition)), this._originalWidth = s.width, this._originalHeight = s.height, this._aspectRatio = s.width / s.height;
    const o = n.style.width;
    o && o.match(/^\d+(\.\d*)?%$/) ? this._originalWidthPercents = parseFloat(o) : this._originalWidthPercents = dS(n, s);
  }
  update(e) {
    this.proposedWidth = e.width, this.proposedHeight = e.height, this.proposedWidthPercents = e.widthPercents, this.proposedHandleHostWidth = e.handleHostWidth, this.proposedHandleHostHeight = e.handleHostHeight;
  }
}
function VS(i, e) {
  const t = new B(i), n = e.split("-"), s = {
    x: n[1] == "right" ? t.right : t.left,
    y: n[0] == "bottom" ? t.bottom : t.top
  };
  return s.x += i.ownerDocument.defaultView.scrollX, s.y += i.ownerDocument.defaultView.scrollY, s;
}
function MS(i) {
  return `ck-widget__resizer__handle-${i}`;
}
function BS(i) {
  const e = ["top-left", "top-right", "bottom-right", "bottom-left"];
  for (const t of e)
    if (i.classList.contains(MS(t)))
      return t;
}
function LS(i) {
  const e = i.split("-"), t = {
    top: "bottom",
    bottom: "top",
    left: "right",
    right: "left"
  };
  return `${t[e[0]]}-${t[e[1]]}`;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class OS extends T {
  constructor() {
    super();
    const e = this.bindTemplate;
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-size-view",
          e.to("_viewPosition", (t) => t ? `ck-orientation-${t}` : "")
        ],
        style: {
          display: e.if("_isVisible", "none", (t) => !t)
        }
      },
      children: [{
        text: e.to("_label")
      }]
    });
  }
  /**
   * A method used for binding the `SizeView` instance properties to the `ResizeState` instance observable properties.
   *
   * @internal
   * @param options An object defining the resizer options, used for setting the proper size label.
   * @param resizeState The `ResizeState` class instance, used for keeping the `SizeView` state up to date.
   */
  _bindToState(e, t) {
    this.bind("_isVisible").to(t, "proposedWidth", t, "proposedHeight", (n, s) => n !== null && s !== null), this.bind("_label").to(t, "proposedHandleHostWidth", t, "proposedHandleHostHeight", t, "proposedWidthPercents", (n, s, o) => e.unit === "px" ? `${n}×${s}` : `${o}%`), this.bind("_viewPosition").to(
      t,
      "activeHandlePosition",
      t,
      "proposedHandleHostWidth",
      t,
      "proposedHandleHostHeight",
      // If the widget is too small to contain the size label, display the label above.
      (n, s, o) => s < 50 || o < 50 ? "above-center" : n
    );
  }
  /**
   * A method used for cleaning up. It removes the bindings and hides the view.
   *
   * @internal
   */
  _dismiss() {
    this.unbind(), this._isVisible = !1;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Ed extends U() {
  /**
   * @param options Resizer options.
   */
  constructor(e) {
    super(), this._viewResizerWrapper = null, this._options = e, this.set("isEnabled", !0), this.set("isSelected", !1), this.bind("isVisible").to(this, "isEnabled", this, "isSelected", (t, n) => t && n), this.decorate("begin"), this.decorate("cancel"), this.decorate("commit"), this.decorate("updateSize"), this.on("commit", (t) => {
      !this.state.proposedWidth && !this.state.proposedWidthPercents && (this._cleanup(), t.stop());
    }, { priority: "high" });
  }
  /**
   * Stores the state of the resizable host geometry, such as the original width, the currently proposed height, etc.
   *
   * Note that a new state is created for each resize transaction.
   */
  get state() {
    return this._state;
  }
  /**
   * Makes resizer visible in the UI.
   */
  show() {
    this._options.editor.editing.view.change((t) => {
      t.removeClass("ck-hidden", this._viewResizerWrapper);
    });
  }
  /**
   * Hides resizer in the UI.
   */
  hide() {
    this._options.editor.editing.view.change((t) => {
      t.addClass("ck-hidden", this._viewResizerWrapper);
    });
  }
  /**
   * Attaches the resizer to the DOM.
   */
  attach() {
    const e = this, t = this._options.viewElement;
    this._options.editor.editing.view.change((s) => {
      const o = s.createUIElement("div", {
        class: "ck ck-reset_all ck-widget__resizer"
      }, function(r) {
        const a = this.toDomElement(r);
        return e._appendHandles(a), e._appendSizeUI(a), a;
      });
      s.insert(s.createPositionAt(t, "end"), o), s.addClass("ck-widget_with-resizer", t), this._viewResizerWrapper = o, this.isVisible || this.hide();
    }), this.on("change:isVisible", () => {
      this.isVisible ? (this.show(), this.redraw()) : this.hide();
    });
  }
  /**
   * Starts the resizing process.
   *
   * Creates a new {@link #state} for the current process.
   *
   * @fires begin
   * @param domResizeHandle Clicked handle.
   */
  begin(e) {
    this._state = new RS(this._options), this._sizeView._bindToState(this._options, this.state), this._initialViewWidth = this._options.viewElement.getStyle("width"), this.state.begin(e, this._getHandleHost(), this._getResizeHost());
  }
  /**
   * Updates the proposed size based on `domEventData`.
   *
   * @fires updateSize
   */
  updateSize(e) {
    const t = this._proposeNewSize(e);
    this._options.editor.editing.view.change((c) => {
      const u = this._options.unit || "%", d = (u === "%" ? t.widthPercents : t.width) + u;
      c.setStyle("width", d, this._options.viewElement);
    });
    const s = this._getHandleHost(), o = new B(s), r = Math.round(o.width), a = Math.round(o.height), l = new B(s);
    t.width = Math.round(l.width), t.height = Math.round(l.height), this.redraw(o), this.state.update({
      ...t,
      handleHostWidth: r,
      handleHostHeight: a
    });
  }
  /**
   * Applies the geometry proposed with the resizer.
   *
   * @fires commit
   */
  commit() {
    const e = this._options.unit || "%", t = (e === "%" ? this.state.proposedWidthPercents : this.state.proposedWidth) + e;
    this._options.editor.editing.view.change(() => {
      this._cleanup(), this._options.onCommit(t);
    });
  }
  /**
   * Cancels and rejects the proposed resize dimensions, hiding the UI.
   *
   * @fires cancel
   */
  cancel() {
    this._cleanup();
  }
  /**
   * Destroys the resizer.
   */
  destroy() {
    this.cancel();
  }
  /**
   * Redraws the resizer.
   *
   * @param handleHostRect Handle host rectangle might be given to improve performance.
   */
  redraw(e) {
    const t = this._domResizerWrapper;
    if (!DS(t))
      return;
    const n = t.parentElement, s = this._getHandleHost(), o = this._viewResizerWrapper, r = [
      o.getStyle("width"),
      o.getStyle("height"),
      o.getStyle("left"),
      o.getStyle("top")
    ];
    let a;
    if (n.isSameNode(s)) {
      const l = e || new B(s);
      a = [
        l.width + "px",
        l.height + "px",
        void 0,
        void 0
      ];
    } else
      a = [
        s.offsetWidth + "px",
        s.offsetHeight + "px",
        s.offsetLeft + "px",
        s.offsetTop + "px"
      ];
    Ee(r, a) !== "same" && this._options.editor.editing.view.change((l) => {
      l.setStyle({
        width: a[0],
        height: a[1],
        left: a[2],
        top: a[3]
      }, o);
    });
  }
  containsHandle(e) {
    return this._domResizerWrapper.contains(e);
  }
  static isResizeHandle(e) {
    return e.classList.contains("ck-widget__resizer__handle");
  }
  /**
   * Cleans up the context state.
   */
  _cleanup() {
    this._sizeView._dismiss(), this._options.editor.editing.view.change((t) => {
      t.setStyle("width", this._initialViewWidth, this._options.viewElement);
    });
  }
  /**
   * Calculates the proposed size as the resize handles are dragged.
   *
   * @param domEventData Event data that caused the size update request. It should be used to calculate the proposed size.
   */
  _proposeNewSize(e) {
    const t = this.state, n = NS(e), s = this._options.isCentered ? this._options.isCentered(this) : !0, o = {
      x: t._referenceCoordinates.x - (n.x + t.originalWidth),
      y: n.y - t.originalHeight - t._referenceCoordinates.y
    };
    s && t.activeHandlePosition.endsWith("-right") && (o.x = n.x - (t._referenceCoordinates.x + t.originalWidth)), s && (o.x *= 2);
    let r = Math.abs(t.originalWidth + o.x), a = Math.abs(t.originalHeight + o.y);
    return (r / t.aspectRatio > a ? "width" : "height") == "width" ? a = r / t.aspectRatio : r = a * t.aspectRatio, {
      width: Math.round(r),
      height: Math.round(a),
      widthPercents: Math.min(Math.round(t.originalWidthPercents / t.originalWidth * r * 100) / 100, 100)
    };
  }
  /**
   * Obtains the resize host.
   *
   * Resize host is an object that receives dimensions which are the result of resizing.
   */
  _getResizeHost() {
    const e = this._domResizerWrapper.parentElement;
    return this._options.getResizeHost(e);
  }
  /**
   * Obtains the handle host.
   *
   * Handle host is an object that the handles are aligned to.
   *
   * Handle host will not always be an entire widget itself. Take an image as an example. The image widget
   * contains an image and a caption. Only the image should be surrounded with handles.
   */
  _getHandleHost() {
    const e = this._domResizerWrapper.parentElement;
    return this._options.getHandleHost(e);
  }
  /**
   * DOM container of the entire resize UI.
   *
   * Note that this property will have a value only after the element bound with the resizer is rendered
   * (otherwise `null`).
   */
  get _domResizerWrapper() {
    return this._options.editor.editing.view.domConverter.mapViewToDom(this._viewResizerWrapper);
  }
  /**
   * Renders the resize handles in the DOM.
   *
   * @param domElement The resizer wrapper.
   */
  _appendHandles(e) {
    const t = ["top-left", "top-right", "bottom-right", "bottom-left"];
    for (const n of t)
      e.appendChild(new Me({
        tag: "div",
        attributes: {
          class: `ck-widget__resizer__handle ${FS(n)}`
        }
      }).render());
  }
  /**
   * Sets up the {@link #_sizeView} property and adds it to the passed `domElement`.
   */
  _appendSizeUI(e) {
    this._sizeView = new OS(), this._sizeView.render(), e.appendChild(this._sizeView.element);
  }
}
function FS(i) {
  return `ck-widget__resizer__handle-${i}`;
}
function NS(i) {
  return {
    x: i.pageX,
    y: i.pageY
  };
}
function DS(i) {
  return i && i.ownerDocument && i.ownerDocument.contains(i);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Nr extends b {
  constructor() {
    super(...arguments), this._resizers = /* @__PURE__ */ new Map();
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "WidgetResize";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor.editing, t = E.window.document;
    this.set("selectedResizer", null), this.set("_activeResizer", null), e.view.addObserver(Qo), this._observer = new (Le())(), this.listenTo(e.view.document, "mousedown", this._mouseDownListener.bind(this), { priority: "high" }), this._observer.listenTo(t, "mousemove", this._mouseMoveListener.bind(this)), this._observer.listenTo(t, "mouseup", this._mouseUpListener.bind(this)), this._redrawSelectedResizerThrottled = Xn(() => this.redrawSelectedResizer(), 200), this.editor.ui.on("update", this._redrawSelectedResizerThrottled), this.editor.model.document.on("change", () => {
      for (const [s, o] of this._resizers)
        s.isAttached() || (this._resizers.delete(s), o.destroy());
    }, { priority: "lowest" }), this._observer.listenTo(E.window, "resize", this._redrawSelectedResizerThrottled);
    const n = this.editor.editing.view.document.selection;
    n.on("change", () => {
      const s = n.getSelectedElement(), o = this.getResizerByViewElement(s) || null;
      o ? this.select(o) : this.deselect();
    });
  }
  /**
   * Redraws the selected resizer if there is any selected resizer and if it is visible.
   */
  redrawSelectedResizer() {
    this.selectedResizer && this.selectedResizer.isVisible && this.selectedResizer.redraw();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this._observer.stopListening();
    for (const e of this._resizers.values())
      e.destroy();
    this._redrawSelectedResizerThrottled.cancel();
  }
  /**
   * Marks resizer as selected.
   */
  select(e) {
    this.deselect(), this.selectedResizer = e, this.selectedResizer.isSelected = !0;
  }
  /**
   * Deselects currently set resizer.
   */
  deselect() {
    this.selectedResizer && (this.selectedResizer.isSelected = !1), this.selectedResizer = null;
  }
  /**
   * @param options Resizer options.
   */
  attachTo(e) {
    const t = new Ed(e), n = this.editor.plugins;
    if (t.attach(), n.has("WidgetToolbarRepository")) {
      const r = n.get("WidgetToolbarRepository");
      t.on("begin", () => {
        r.forceDisabled("resize");
      }, { priority: "lowest" }), t.on("cancel", () => {
        r.clearForceDisabled("resize");
      }, { priority: "highest" }), t.on("commit", () => {
        r.clearForceDisabled("resize");
      }, { priority: "highest" });
    }
    this._resizers.set(e.viewElement, t);
    const o = this.editor.editing.view.document.selection.getSelectedElement();
    return this.getResizerByViewElement(o) == t && this.select(t), t;
  }
  /**
   * Returns a resizer created for a given view element (widget element).
   *
   * @param viewElement View element associated with the resizer.
   */
  getResizerByViewElement(e) {
    return this._resizers.get(e);
  }
  /**
   * Returns a resizer that contains a given resize handle.
   */
  _getResizerByHandle(e) {
    for (const t of this._resizers.values())
      if (t.containsHandle(e))
        return t;
  }
  /**
   * @param domEventData Native DOM event.
   */
  _mouseDownListener(e, t) {
    const n = t.domTarget;
    Ed.isResizeHandle(n) && (this._activeResizer = this._getResizerByHandle(n) || null, this._activeResizer && (this._activeResizer.begin(n), e.stop(), t.preventDefault()));
  }
  /**
   * @param domEventData Native DOM event.
   */
  _mouseMoveListener(e, t) {
    this._activeResizer && this._activeResizer.updateSize(t);
  }
  _mouseUpListener() {
    this._activeResizer && (this._activeResizer.commit(), this._activeResizer = null);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
/* istanbul ignore file -- @preserve */
const Dr = di("px");
class zS extends T {
  /**
   * @inheritDoc
   */
  constructor() {
    super();
    const e = this.bindTemplate;
    this.set({
      isVisible: !1,
      left: null,
      top: null,
      width: null
    }), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-clipboard-drop-target-line",
          e.if("isVisible", "ck-hidden", (t) => !t)
        ],
        style: {
          left: e.to("left", (t) => Dr(t)),
          top: e.to("top", (t) => Dr(t)),
          width: e.to("width", (t) => Dr(t))
        }
      }
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Hs extends b {
  constructor() {
    super(...arguments), this.removeDropMarkerDelayed = cl(() => this.removeDropMarker(), 40), this._updateDropMarkerThrottled = Xn((e) => this._updateDropMarker(e), 40), this._reconvertMarkerThrottled = Xn(() => {
      this.editor.model.markers.has("drop-target") && this.editor.editing.reconvertMarker("drop-target");
    }, 0), this._dropTargetLineView = new zS(), this._domEmitter = new (Le())(), this._scrollables = /* @__PURE__ */ new Map();
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "DragDropTarget";
  }
  /**
   * @inheritDoc
   */
  init() {
    this._setupDropMarker();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    this._domEmitter.stopListening();
    for (const { resizeObserver: e } of this._scrollables.values())
      e.destroy();
    return this._updateDropMarkerThrottled.cancel(), this.removeDropMarkerDelayed.cancel(), this._reconvertMarkerThrottled.cancel(), super.destroy();
  }
  /**
   * Finds the drop target range and updates the drop marker.
   *
   * @internal
   */
  updateDropMarker(e, t, n, s, o, r) {
    this.removeDropMarkerDelayed.cancel();
    const a = Ad(this.editor, e, t, n, s, o, r);
    /* istanbul ignore next -- @preserve */
    if (a) {
      if (r && r.containsRange(a))
        return this.removeDropMarker();
      this._updateDropMarkerThrottled(a);
    }
  }
  /**
   * Finds the final drop target range.
   *
   * @internal
   */
  getFinalDropRange(e, t, n, s, o, r) {
    const a = Ad(this.editor, e, t, n, s, o, r);
    return this.removeDropMarker(), a;
  }
  /**
   * Removes the drop target marker.
   *
   * @internal
   */
  removeDropMarker() {
    const e = this.editor.model;
    this.removeDropMarkerDelayed.cancel(), this._updateDropMarkerThrottled.cancel(), this._dropTargetLineView.isVisible = !1, e.markers.has("drop-target") && e.change((t) => {
      t.removeMarker("drop-target");
    });
  }
  /**
   * Creates downcast conversion for the drop target marker.
   */
  _setupDropMarker() {
    const e = this.editor;
    e.ui.view.body.add(this._dropTargetLineView), e.conversion.for("editingDowncast").markerToHighlight({
      model: "drop-target",
      view: {
        classes: ["ck-clipboard-drop-target-range"]
      }
    }), e.conversion.for("editingDowncast").markerToElement({
      model: "drop-target",
      view: (t, { writer: n }) => {
        if (e.model.schema.checkChild(t.markerRange.start, "$text"))
          return this._dropTargetLineView.isVisible = !1, this._createDropTargetPosition(n);
        t.markerRange.isCollapsed ? this._updateDropTargetLine(t.markerRange) : this._dropTargetLineView.isVisible = !1;
      }
    });
  }
  /**
   * Updates the drop target marker to the provided range.
   *
   * @param targetRange The range to set the marker to.
   */
  _updateDropMarker(e) {
    const t = this.editor, n = t.model.markers;
    t.model.change((s) => {
      n.has("drop-target") ? n.get("drop-target").getRange().isEqual(e) || s.updateMarker("drop-target", { range: e }) : s.addMarker("drop-target", {
        range: e,
        usingOperation: !1,
        affectsData: !1
      });
    });
  }
  /**
   * Creates the UI element for vertical (in-line) drop target.
   */
  _createDropTargetPosition(e) {
    return e.createUIElement("span", { class: "ck ck-clipboard-drop-target-position" }, function(t) {
      const n = this.toDomElement(t);
      return n.append("⁠", t.createElement("span"), "⁠"), n;
    });
  }
  /**
   * Updates the horizontal drop target line.
   */
  _updateDropTargetLine(e) {
    const t = this.editor.editing, n = e.start.nodeBefore, s = e.start.nodeAfter, o = e.start.parent, r = n ? t.mapper.toViewElement(n) : null, a = r ? t.view.domConverter.mapViewToDom(r) : null, l = s ? t.mapper.toViewElement(s) : null, c = l ? t.view.domConverter.mapViewToDom(l) : null, u = t.mapper.toViewElement(o);
    if (!u)
      return;
    const d = t.view.domConverter.mapViewToDom(u), h = this._getScrollableRect(u), { scrollX: f, scrollY: m } = E.window, p = a ? new B(a) : null, w = c ? new B(c) : null, v = new B(d).excludeScrollbarsAndBorders(), C = p ? p.bottom : v.top, L = w ? w.top : v.bottom, F = E.window.getComputedStyle(d), q = C <= L ? (C + L) / 2 : L;
    if (h.top < q && q < h.bottom) {
      const x = v.left + parseFloat(F.paddingLeft), R = v.right - parseFloat(F.paddingRight), S = Math.max(x + f, h.left), ee = Math.min(R + f, h.right);
      this._dropTargetLineView.set({
        isVisible: !0,
        left: S,
        top: q + m,
        width: ee - S
      });
    } else
      this._dropTargetLineView.isVisible = !1;
  }
  /**
   * Finds the closest scrollable element rect for the given view element.
   */
  _getScrollableRect(e) {
    const t = e.root.rootName;
    let n;
    if (this._scrollables.has(t))
      n = this._scrollables.get(t).domElement;
    else {
      const s = this.editor.editing.view.domConverter.mapViewToDom(e);
      n = US(s), this._domEmitter.listenTo(n, "scroll", this._reconvertMarkerThrottled, { usePassive: !0 });
      const o = new Y(n, this._reconvertMarkerThrottled);
      this._scrollables.set(t, {
        domElement: n,
        resizeObserver: o
      });
    }
    return new B(n).excludeScrollbarsAndBorders();
  }
}
function Ad(i, e, t, n, s, o, r) {
  const a = i.model, l = i.editing.mapper;
  let u = xd(i, e);
  for (; u; ) {
    if (!o) {
      if (a.schema.checkChild(u, "$text")) {
        if (t) {
          const d = t[0].start, h = l.toModelPosition(d);
          if (!r || Array.from(r.getItems()).every((m) => a.schema.checkChild(h, m))) {
            if (a.schema.checkChild(h, "$text"))
              return a.createRange(h);
            if (d)
              return Us(i, xd(i, d.parent), n, s);
          }
        }
      } else if (a.schema.isInline(u))
        return Us(i, u, n, s);
    }
    if (a.schema.isBlock(u))
      return Us(i, u, n, s);
    if (a.schema.checkChild(u, "$block")) {
      const d = Array.from(u.getChildren()).filter((m) => m.is("element") && !HS(i, m));
      let h = 0, f = d.length;
      if (f == 0)
        return a.createRange(a.createPositionAt(u, "end"));
      for (; h < f - 1; ) {
        const m = Math.floor((h + f) / 2);
        np(i, d[m], n, s) == "before" ? f = m : h = m;
      }
      return Us(i, d[h], n, s);
    }
    u = u.parent;
  }
  return null;
}
function HS(i, e) {
  const t = i.editing.mapper, n = i.editing.view.domConverter, s = t.toViewElement(e);
  if (!s)
    return !0;
  const o = n.mapViewToDom(s);
  return E.window.getComputedStyle(o).float != "none";
}
function Us(i, e, t, n) {
  const s = i.model;
  return s.createRange(s.createPositionAt(e, np(i, e, t, n)));
}
function np(i, e, t, n) {
  const s = i.editing.mapper, o = i.editing.view.domConverter, r = s.toViewElement(e), a = o.mapViewToDom(r), l = new B(a);
  return i.model.schema.isInline(e) ? t < (l.left + l.right) / 2 ? "before" : "after" : n < (l.top + l.bottom) / 2 ? "before" : "after";
}
function xd(i, e) {
  const t = i.editing.mapper, n = i.editing.view, s = t.toModelElement(e);
  if (s)
    return s;
  const o = n.createPositionBefore(e), r = t.findMappedViewAncestor(o);
  return t.toModelElement(r);
}
function US(i) {
  let e = i;
  do {
    e = e.parentElement;
    const t = E.window.getComputedStyle(e).overflowY;
    if (t == "auto" || t == "scroll")
      break;
  } while (e.tagName != "BODY");
  return e;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class $S extends b {
  constructor() {
    super(...arguments), this._isBlockDragging = !1, this._domEmitter = new (Le())();
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "DragDropBlockToolbar";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor;
    if (this.listenTo(e, "change:isReadOnly", (t, n, s) => {
      s ? (this.forceDisabled("readOnlyMode"), this._isBlockDragging = !1) : this.clearForceDisabled("readOnlyMode");
    }), M.isAndroid && this.forceDisabled("noAndroidSupport"), e.plugins.has("BlockToolbar")) {
      const n = e.plugins.get("BlockToolbar").buttonView.element;
      this._domEmitter.listenTo(n, "dragstart", (s, o) => this._handleBlockDragStart(o)), this._domEmitter.listenTo(E.document, "dragover", (s, o) => this._handleBlockDragging(o)), this._domEmitter.listenTo(E.document, "drop", (s, o) => this._handleBlockDragging(o)), this._domEmitter.listenTo(E.document, "dragend", () => this._handleBlockDragEnd(), { useCapture: !0 }), this.isEnabled && n.setAttribute("draggable", "true"), this.on("change:isEnabled", (s, o, r) => {
        n.setAttribute("draggable", r ? "true" : "false");
      });
    }
  }
  /**
   * @inheritDoc
   */
  destroy() {
    return this._domEmitter.stopListening(), super.destroy();
  }
  /**
   * The `dragstart` event handler.
   */
  _handleBlockDragStart(e) {
    if (!this.isEnabled)
      return;
    const t = this.editor.model, n = t.document.selection, s = this.editor.editing.view, o = Array.from(n.getSelectedBlocks()), r = t.createRange(t.createPositionBefore(o[0]), t.createPositionAfter(o[o.length - 1]));
    t.change((a) => a.setSelection(r)), this._isBlockDragging = !0, s.focus(), s.getObserver(is).onDomEvent(e);
  }
  /**
   * The `dragover` and `drop` event handler.
   */
  _handleBlockDragging(e) {
    if (!this.isEnabled || !this._isBlockDragging)
      return;
    const t = e.clientX + (this.editor.locale.contentLanguageDirection == "ltr" ? 100 : -100), n = e.clientY, s = document.elementFromPoint(t, n), o = this.editor.editing.view;
    !s || !s.closest(".ck-editor__editable") || o.getObserver(is).onDomEvent({
      ...e,
      type: e.type,
      dataTransfer: e.dataTransfer,
      target: s,
      clientX: t,
      clientY: n,
      preventDefault: () => e.preventDefault(),
      stopPropagation: () => e.stopPropagation()
    });
  }
  /**
   * The `dragend` event handler.
   */
  _handleBlockDragEnd() {
    this._isBlockDragging = !1;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class WS extends b {
  constructor() {
    super(...arguments), this._clearDraggableAttributesDelayed = cl(() => this._clearDraggableAttributes(), 40), this._blockMode = !1, this._domEmitter = new (Le())();
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "DragDrop";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Ze, gi, Hs, $S];
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.editing.view;
    this._draggedRange = null, this._draggingUid = "", this._draggableElement = null, t.addObserver(is), t.addObserver(Qo), this._setupDragging(), this._setupContentInsertionIntegration(), this._setupClipboardInputIntegration(), this._setupDraggableAttributeHandling(), this.listenTo(e, "change:isReadOnly", (n, s, o) => {
      o ? this.forceDisabled("readOnlyMode") : this.clearForceDisabled("readOnlyMode");
    }), this.on("change:isEnabled", (n, s, o) => {
      o || this._finalizeDragging(!1);
    }), M.isAndroid && this.forceDisabled("noAndroidSupport");
  }
  /**
   * @inheritDoc
   */
  destroy() {
    return this._draggedRange && (this._draggedRange.detach(), this._draggedRange = null), this._previewContainer && this._previewContainer.remove(), this._domEmitter.stopListening(), this._clearDraggableAttributesDelayed.cancel(), super.destroy();
  }
  /**
   * Drag and drop events handling.
   */
  _setupDragging() {
    const e = this.editor, t = e.model, n = e.editing.view, s = n.document, o = e.plugins.get(Hs);
    this.listenTo(s, "dragstart", (r, a) => {
      if (a.target && a.target.is("editableElement")) {
        a.preventDefault();
        return;
      }
      if (this._prepareDraggedRange(a.target), !this._draggedRange) {
        a.preventDefault();
        return;
      }
      this._draggingUid = je(), a.dataTransfer.effectAllowed = this.isEnabled ? "copyMove" : "copy", a.dataTransfer.setData("application/ckeditor5-dragging-uid", this._draggingUid);
      const l = t.createSelection(this._draggedRange.toRange());
      this.editor.plugins.get("ClipboardPipeline")._fireOutputTransformationEvent(a.dataTransfer, l, "dragstart");
      const { dataTransfer: u, domTarget: d, domEvent: h } = a, { clientX: f } = h;
      this._updatePreview({ dataTransfer: u, domTarget: d, clientX: f }), a.stopPropagation(), this.isEnabled || (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = "");
    }, { priority: "low" }), this.listenTo(s, "dragend", (r, a) => {
      this._finalizeDragging(!a.dataTransfer.isCanceled && a.dataTransfer.dropEffect == "move");
    }, { priority: "low" }), this._domEmitter.listenTo(E.document, "dragend", () => {
      this._blockMode = !1;
    }, { useCapture: !0 }), this.listenTo(s, "dragenter", () => {
      this.isEnabled && n.focus();
    }), this.listenTo(s, "dragleave", () => {
      o.removeDropMarkerDelayed();
    }), this.listenTo(s, "dragging", (r, a) => {
      if (!this.isEnabled) {
        a.dataTransfer.dropEffect = "none";
        return;
      }
      const { clientX: l, clientY: c } = a.domEvent;
      o.updateDropMarker(a.target, a.targetRanges, l, c, this._blockMode, this._draggedRange), this._draggedRange || (a.dataTransfer.dropEffect = "copy"), M.isGecko || (a.dataTransfer.effectAllowed == "copy" ? a.dataTransfer.dropEffect = "copy" : ["all", "copyMove"].includes(a.dataTransfer.effectAllowed) && (a.dataTransfer.dropEffect = "move")), r.stop();
    }, { priority: "low" });
  }
  /**
   * Integration with the `clipboardInput` event.
   */
  _setupClipboardInputIntegration() {
    const e = this.editor, n = e.editing.view.document, s = e.plugins.get(Hs);
    this.listenTo(n, "clipboardInput", (o, r) => {
      if (r.method != "drop")
        return;
      const { clientX: a, clientY: l } = r.domEvent, c = s.getFinalDropRange(r.target, r.targetRanges, a, l, this._blockMode, this._draggedRange);
      if (!c) {
        this._finalizeDragging(!1), o.stop();
        return;
      }
      if (this._draggedRange && this._draggingUid != r.dataTransfer.getData("application/ckeditor5-dragging-uid") && (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = ""), Id(r.dataTransfer) == "move" && this._draggedRange && this._draggedRange.containsRange(c, !0)) {
        this._finalizeDragging(!1), o.stop();
        return;
      }
      r.targetRanges = [e.editing.mapper.toViewRange(c)];
    }, { priority: "high" });
  }
  /**
   * Integration with the `contentInsertion` event of the clipboard pipeline.
   */
  _setupContentInsertionIntegration() {
    const e = this.editor.plugins.get(Ze);
    e.on("contentInsertion", (t, n) => {
      if (!this.isEnabled || n.method !== "drop")
        return;
      const s = n.targetRanges.map((o) => this.editor.editing.mapper.toModelRange(o));
      this.editor.model.change((o) => o.setSelection(s));
    }, { priority: "high" }), e.on("contentInsertion", (t, n) => {
      if (!this.isEnabled || n.method !== "drop")
        return;
      const s = Id(n.dataTransfer) == "move", o = !n.resultRange || !n.resultRange.isCollapsed;
      this._finalizeDragging(o && s);
    }, { priority: "lowest" });
  }
  /**
   * Adds listeners that add the `draggable` attribute to the elements while the mouse button is down so the dragging could start.
   */
  _setupDraggableAttributeHandling() {
    const e = this.editor, t = e.editing.view, n = t.document;
    this.listenTo(n, "mousedown", (s, o) => {
      if (M.isAndroid || !o)
        return;
      this._clearDraggableAttributesDelayed.cancel();
      let r = Sd(o.target);
      if (M.isBlink && !e.isReadOnly && !r && !n.selection.isCollapsed) {
        const a = n.selection.getSelectedElement();
        (!a || !ae(a)) && (r = n.selection.editableElement);
      }
      r && (t.change((a) => {
        a.setAttribute("draggable", "true", r);
      }), this._draggableElement = e.editing.mapper.toModelElement(r));
    }), this.listenTo(n, "mouseup", () => {
      M.isAndroid || this._clearDraggableAttributesDelayed();
    });
  }
  /**
   * Removes the `draggable` attribute from the element that was used for dragging.
   */
  _clearDraggableAttributes() {
    const e = this.editor.editing;
    e.view.change((t) => {
      this._draggableElement && this._draggableElement.root.rootName != "$graveyard" && t.removeAttribute("draggable", e.mapper.toViewElement(this._draggableElement)), this._draggableElement = null;
    });
  }
  /**
   * Deletes the dragged content from its original range and clears the dragging state.
   *
   * @param moved Whether the move succeeded.
   */
  _finalizeDragging(e) {
    const t = this.editor, n = t.model;
    t.plugins.get(Hs).removeDropMarker(), this._clearDraggableAttributes(), t.plugins.has("WidgetToolbarRepository") && t.plugins.get("WidgetToolbarRepository").clearForceDisabled("dragDrop"), this._draggingUid = "", this._previewContainer && (this._previewContainer.remove(), this._previewContainer = void 0), this._draggedRange && (e && this.isEnabled && n.change((o) => {
      const r = n.createSelection(this._draggedRange);
      n.deleteContent(r, { doNotAutoparagraph: !0 });
      const a = r.getFirstPosition().parent;
      a.isEmpty && !n.schema.checkChild(a, "$text") && n.schema.checkChild(a, "paragraph") && o.insertElement("paragraph", a, 0);
    }), this._draggedRange.detach(), this._draggedRange = null);
  }
  /**
   * Sets the dragged source range based on event target and document selection.
   */
  _prepareDraggedRange(e) {
    const t = this.editor, n = t.model, s = n.document.selection, o = e ? Sd(e) : null;
    if (o) {
      const c = t.editing.mapper.toModelElement(o);
      this._draggedRange = Pe.fromRange(n.createRangeOn(c)), this._blockMode = n.schema.isBlock(c), t.plugins.has("WidgetToolbarRepository") && t.plugins.get("WidgetToolbarRepository").forceDisabled("dragDrop");
      return;
    }
    if (s.isCollapsed && !s.getFirstPosition().parent.isEmpty)
      return;
    const r = Array.from(s.getSelectedBlocks()), a = s.getFirstRange();
    if (r.length == 0) {
      this._draggedRange = Pe.fromRange(a);
      return;
    }
    const l = ip(n, r);
    if (r.length > 1)
      this._draggedRange = Pe.fromRange(l), this._blockMode = !0;
    else if (r.length == 1) {
      const c = a.start.isTouching(l.start) && a.end.isTouching(l.end);
      this._draggedRange = Pe.fromRange(c ? l : a), this._blockMode = c;
    }
    n.change((c) => c.setSelection(this._draggedRange.toRange()));
  }
  /**
   * Updates the dragged preview image.
   */
  _updatePreview({ dataTransfer: e, domTarget: t, clientX: n }) {
    const s = this.editor.editing.view, o = s.document.selection.editableElement, r = s.domConverter.mapViewToDom(o), a = E.window.getComputedStyle(r);
    this._previewContainer ? this._previewContainer.firstElementChild && this._previewContainer.removeChild(this._previewContainer.firstElementChild) : (this._previewContainer = Ye(E.document, "div", {
      style: "position: fixed; left: -999999px;"
    }), E.document.body.appendChild(this._previewContainer));
    const l = new B(r);
    if (r.contains(t))
      return;
    const c = parseFloat(a.paddingLeft), u = Ye(E.document, "div");
    u.className = "ck ck-content", u.style.width = a.width, u.style.paddingLeft = `${l.left - n + c}px`, M.isiOS && (u.style.backgroundColor = "white"), u.innerHTML = e.getData("text/html"), e.setDragImage(u, 0, 0), this._previewContainer.appendChild(u);
  }
}
function Id(i) {
  return M.isGecko ? i.dropEffect : ["all", "copyMove"].includes(i.effectAllowed) ? "move" : "copy";
}
function Sd(i) {
  if (i.is("editableElement"))
    return null;
  if (i.hasClass("ck-widget__selection-handle"))
    return i.findAncestor(ae);
  if (ae(i))
    return i;
  const e = i.findAncestor((t) => ae(t) || t.is("editableElement"));
  return ae(e) ? e : null;
}
function ip(i, e) {
  const t = e[0], n = e[e.length - 1], s = t.getCommonAncestor(n), o = i.createPositionBefore(t), r = i.createPositionAfter(n);
  if (s && s.is("element") && !i.schema.isLimit(s)) {
    const a = i.createRangeOn(s), l = o.isTouching(a.start), c = r.isTouching(a.end);
    if (l && c)
      return ip(i, [s]);
  }
  return i.createRange(o, r);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class qS extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "PastePlainText";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Ze];
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model, n = e.editing.view, s = n.document, o = t.document.selection;
    let r = !1;
    n.addObserver(is), this.listenTo(s, "keydown", (a, l) => {
      r = l.shiftKey;
    }), e.plugins.get(Ze).on("contentInsertion", (a, l) => {
      !r && !GS(l.content, t.schema) || t.change((c) => {
        const u = Array.from(o.getAttributes()).filter(([h]) => t.schema.getAttributeProperties(h).isFormatting);
        o.isCollapsed || t.deleteContent(o, { doNotAutoparagraph: !0 }), u.push(...o.getAttributes());
        const d = c.createRangeIn(l.content);
        for (const h of d.getItems())
          h.is("$textProxy") && c.setAttributes(u, h);
      });
    });
  }
}
function GS(i, e) {
  if (i.childCount > 1)
    return !1;
  const t = i.getChild(0);
  return e.isObject(t) ? !1 : Array.from(t.getAttributeKeys()).length == 0;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Ol extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Clipboard";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Ui, Ze, WS, qS];
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = this.editor.t;
    e.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: t("Copy selected content"),
          keystroke: "CTRL+C"
        },
        {
          label: t("Paste content"),
          keystroke: "CTRL+V"
        },
        {
          label: t("Paste content as plain text"),
          keystroke: "CTRL+SHIFT+V"
        }
      ]
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class jS extends V {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.affectsData = !1;
  }
  /**
   * @inheritDoc
   */
  execute() {
    const e = this.editor.model, t = e.document.selection;
    let n = e.schema.getLimitElement(t);
    if (t.containsEntireContent(n) || !Pd(e.schema, n))
      do
        if (n = n.parent, !n)
          return;
      while (!Pd(e.schema, n));
    e.change((s) => {
      s.setSelection(n, "in");
    });
  }
}
function Pd(i, e) {
  return i.isLimit(e) && (i.checkChild(e, "$text") || i.checkChild(e, "paragraph"));
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const KS = gs("Ctrl+A");
class ZS extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "SelectAllEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.t, s = e.editing.view.document;
    e.commands.add("selectAll", new jS(e)), this.listenTo(s, "keydown", (o, r) => {
      Qn(r) === KS && (e.execute("selectAll"), r.preventDefault());
    }), e.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: t("Select all"),
          keystroke: "CTRL+A"
        }
      ]
    });
  }
}
const JS = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>';
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class XS extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "SelectAllUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor;
    e.ui.componentFactory.add("selectAll", () => {
      const t = this._createButton(P);
      return t.set({
        tooltip: !0
      }), t;
    }), e.ui.componentFactory.add("menuBar:selectAll", () => this._createButton(de));
  }
  /**
   * Creates a button for select all command to use either in toolbar or in menu bar.
   */
  _createButton(e) {
    const t = this.editor, n = t.locale, s = t.commands.get("selectAll"), o = new e(t.locale), r = n.t;
    return o.set({
      label: r("Select all"),
      icon: JS,
      keystroke: "Ctrl+A"
    }), o.bind("isEnabled").to(s, "isEnabled"), this.listenTo(o, "execute", () => {
      t.execute("selectAll"), t.editing.view.focus();
    }), o;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class QS extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ZS, XS];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "SelectAll";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class sp extends V {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this._stack = [], this._createdBatches = /* @__PURE__ */ new WeakSet(), this.refresh(), this._isEnabledBasedOnSelection = !1, this.listenTo(e.data, "set", (t, n) => {
      n[1] = { ...n[1] };
      const s = n[1];
      s.batchType || (s.batchType = { isUndoable: !1 });
    }, { priority: "high" }), this.listenTo(e.data, "set", (t, n) => {
      n[1].batchType.isUndoable || this.clearStack();
    });
  }
  /**
   * @inheritDoc
   */
  refresh() {
    this.isEnabled = this._stack.length > 0;
  }
  /**
   * Returns all batches created by this command.
   */
  get createdBatches() {
    return this._createdBatches;
  }
  /**
   * Stores a batch in the command, together with the selection state of the {@link module:engine/model/document~Document document}
   * created by the editor which this command is registered to.
   *
   * @param batch The batch to add.
   */
  addBatch(e) {
    const t = this.editor.model.document.selection, n = {
      ranges: t.hasOwnRange ? Array.from(t.getRanges()) : [],
      isBackward: t.isBackward
    };
    this._stack.push({ batch: e, selection: n }), this.refresh();
  }
  /**
   * Removes all items from the stack.
   */
  clearStack() {
    this._stack = [], this.refresh();
  }
  /**
   * Restores the {@link module:engine/model/document~Document#selection document selection} state after a batch was undone.
   *
   * @param ranges Ranges to be restored.
   * @param isBackward A flag describing whether the restored range was selected forward or backward.
   * @param operations Operations which has been applied since selection has been stored.
   */
  _restoreSelection(e, t, n) {
    const s = this.editor.model, o = s.document, r = [], a = e.map((c) => c.getTransformedByOperations(n)), l = a.flat();
    for (const c of a) {
      const u = c.filter((d) => d.root != o.graveyard).filter((d) => !eP(d, l));
      u.length && (YS(u), r.push(u[0]));
    }
    r.length && s.change((c) => {
      c.setSelection(r, { backward: t });
    });
  }
  /**
   * Undoes a batch by reversing that batch, transforming reversed batch and finally applying it.
   * This is a helper method for {@link #execute}.
   *
   * @param batchToUndo The batch to be undone.
   * @param undoingBatch The batch that will contain undoing changes.
   */
  _undo(e, t) {
    const n = this.editor.model, s = n.document;
    this._createdBatches.add(t);
    const o = e.operations.slice().filter((r) => r.isDocumentOperation);
    o.reverse();
    for (const r of o) {
      const a = r.baseVersion + 1, l = Array.from(s.history.getOperations(a)), u = B2([r.getReversed()], l, {
        useRelations: !0,
        document: this.editor.model.document,
        padWithNoOps: !1,
        forceWeakRemove: !0
      }).operationsA;
      for (let d of u) {
        const h = d.affectedSelectable;
        h && !n.canEditAt(h) && (d = new he(d.baseVersion)), t.addOperation(d), n.applyOperation(d), s.history.setOperationAsUndone(r, d);
      }
    }
  }
}
function YS(i) {
  i.sort((e, t) => e.start.isBefore(t.start) ? -1 : 1);
  for (let e = 1; e < i.length; e++) {
    const n = i[e - 1].getJoined(i[e], !0);
    n && (e--, i.splice(e, 2, n));
  }
}
function eP(i, e) {
  return e.some((t) => t !== i && t.containsRange(i, !0));
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class tP extends sp {
  /**
   * Executes the command. This method reverts a {@link module:engine/model/batch~Batch batch} added to the command's stack, transforms
   * and applies the reverted version on the {@link module:engine/model/document~Document document} and removes the batch from the stack.
   * Then, it restores the {@link module:engine/model/document~Document#selection document selection}.
   *
   * @fires execute
   * @fires revert
   * @param batch A batch that should be undone. If not set, the last added batch will be undone.
   */
  execute(e = null) {
    const t = e ? this._stack.findIndex((o) => o.batch == e) : this._stack.length - 1, n = this._stack.splice(t, 1)[0], s = this.editor.model.createBatch({ isUndo: !0 });
    this.editor.model.enqueueChange(s, () => {
      this._undo(n.batch, s);
      const o = this.editor.model.document.history.getOperations(n.batch.baseVersion);
      this._restoreSelection(n.selection.ranges, n.selection.isBackward, o);
    }), this.fire("revert", n.batch, s), this.refresh();
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class nP extends sp {
  /**
   * Executes the command. This method reverts the last {@link module:engine/model/batch~Batch batch} added to
   * the command's stack, applies the reverted and transformed version on the
   * {@link module:engine/model/document~Document document} and removes the batch from the stack.
   * Then, it restores the {@link module:engine/model/document~Document#selection document selection}.
   *
   * @fires execute
   */
  execute() {
    const e = this._stack.pop(), t = this.editor.model.createBatch({ isUndo: !0 });
    this.editor.model.enqueueChange(t, () => {
      const s = e.batch.operations[e.batch.operations.length - 1].baseVersion + 1, o = this.editor.model.document.history.getOperations(s);
      this._restoreSelection(e.selection.ranges, e.selection.isBackward, o), this._undo(e.batch, t);
    }), this.refresh();
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class iP extends b {
  constructor() {
    super(...arguments), this._batchRegistry = /* @__PURE__ */ new WeakSet();
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "UndoEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.t;
    this._undoCommand = new tP(e), this._redoCommand = new nP(e), e.commands.add("undo", this._undoCommand), e.commands.add("redo", this._redoCommand), this.listenTo(e.model, "applyOperation", (n, s) => {
      const o = s[0];
      if (!o.isDocumentOperation)
        return;
      const r = o.batch, a = this._redoCommand.createdBatches.has(r), l = this._undoCommand.createdBatches.has(r);
      this._batchRegistry.has(r) || (this._batchRegistry.add(r), r.isUndoable && (a ? this._undoCommand.addBatch(r) : l || (this._undoCommand.addBatch(r), this._redoCommand.clearStack())));
    }, { priority: "highest" }), this.listenTo(this._undoCommand, "revert", (n, s, o) => {
      this._redoCommand.addBatch(o);
    }), e.keystrokes.set("CTRL+Z", "undo"), e.keystrokes.set("CTRL+Y", "redo"), e.keystrokes.set("CTRL+SHIFT+Z", "redo"), e.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: t("Undo"),
          keystroke: "CTRL+Z"
        },
        {
          label: t("Redo"),
          keystroke: [["CTRL+Y"], ["CTRL+SHIFT+Z"]]
        }
      ]
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class sP extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "UndoUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.locale, n = e.t, s = t.uiLanguageDirection == "ltr" ? A.undo : A.redo, o = t.uiLanguageDirection == "ltr" ? A.redo : A.undo;
    this._addButtonsToFactory("undo", n("Undo"), "CTRL+Z", s), this._addButtonsToFactory("redo", n("Redo"), "CTRL+Y", o);
  }
  /**
   * Creates a button for the specified command.
   *
   * @param name Command name.
   * @param label Button label.
   * @param keystroke Command keystroke.
   * @param Icon Source of the icon.
   */
  _addButtonsToFactory(e, t, n, s) {
    const o = this.editor;
    o.ui.componentFactory.add(e, () => {
      const r = this._createButton(P, e, t, n, s);
      return r.set({
        tooltip: !0
      }), r;
    }), o.ui.componentFactory.add("menuBar:" + e, () => this._createButton(de, e, t, n, s));
  }
  /**
   * TODO
   */
  _createButton(e, t, n, s, o) {
    const r = this.editor, a = r.locale, l = r.commands.get(t), c = new e(a);
    return c.set({
      label: n,
      icon: o,
      keystroke: s
    }), c.bind("isEnabled").to(l, "isEnabled"), this.listenTo(c, "execute", () => {
      r.execute(t), r.editing.view.focus();
    }), c;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Fl extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [iP, sP];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Undo";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class oP extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [HA, Ol, ar, QS, eS, mg, Fl];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Essentials";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class rP extends V {
  constructor(e) {
    super(e), this._isEnabledBasedOnSelection = !1;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor.model, t = e.document, n = me(t.selection.getSelectedBlocks());
    this.value = !!n && n.is("element", "paragraph"), this.isEnabled = !!n && Rd(n, e.schema);
  }
  /**
   * Executes the command. All the blocks (see {@link module:engine/model/schema~Schema}) in the selection
   * will be turned to paragraphs.
   *
   * @fires execute
   * @param options Options for the executed command.
   * @param options.selection The selection that the command should be applied to. By default,
   * if not provided, the command is applied to the {@link module:engine/model/document~Document#selection}.
   */
  execute(e = {}) {
    const t = this.editor.model, n = t.document, s = e.selection || n.selection;
    t.canEditAt(s) && t.change((o) => {
      const r = s.getSelectedBlocks();
      for (const a of r)
        !a.is("element", "paragraph") && Rd(a, t.schema) && o.rename(a, "paragraph");
    });
  }
}
function Rd(i, e) {
  return e.checkChild(i.parent, "paragraph") && !e.isObject(i);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class aP extends V {
  constructor(e) {
    super(e), this._isEnabledBasedOnSelection = !1;
  }
  /**
   * Executes the command.
   *
   * @param options Options for the executed command.
   * @param options.position The model position at which the new paragraph will be inserted.
   * @param options.attributes Attributes keys and values to set on a inserted paragraph.
   * @fires execute
   */
  execute(e) {
    const t = this.editor.model, n = e.attributes;
    let s = e.position;
    t.canEditAt(s) && t.change((o) => {
      if (s = this._findPositionToInsertParagraph(s, o), !s)
        return;
      const r = o.createElement("paragraph");
      n && t.schema.setAllowedAttributes(r, n, o), t.insertContent(r, s), o.setSelection(r, "in");
    });
  }
  /**
   * Returns the best position to insert a new paragraph.
   */
  _findPositionToInsertParagraph(e, t) {
    const n = this.editor.model;
    if (n.schema.checkChild(e, "paragraph"))
      return e;
    const s = n.schema.findAllowedParent(e, "paragraph");
    if (!s)
      return null;
    const o = e.parent, r = n.schema.checkChild(o, "$text");
    return o.isEmpty || r && e.isAtEnd ? n.createPositionAfter(o) : !o.isEmpty && r && e.isAtStart ? n.createPositionBefore(o) : t.split(e, s).position;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ws extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Paragraph";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model;
    e.commands.add("paragraph", new rP(e)), e.commands.add("insertParagraph", new aP(e)), t.schema.register("paragraph", { inheritAllFrom: "$block" }), e.conversion.elementToElement({ model: "paragraph", view: "p" }), e.conversion.for("upcast").elementToElement({
      model: (n, { writer: s }) => !ws.paragraphLikeElements.has(n.name) || n.isEmpty ? null : s.createElement("paragraph"),
      view: /.+/,
      converterPriority: "low"
    });
  }
}
ws.paragraphLikeElements = /* @__PURE__ */ new Set([
  "blockquote",
  "dd",
  "div",
  "dt",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "li",
  "p",
  "td",
  "th"
]);
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Nl = ["left", "right", "center", "justify"];
function op(i) {
  return Nl.includes(i);
}
function rp(i, e) {
  return e.contentLanguageDirection == "rtl" ? i === "right" : i === "left";
}
function ap(i) {
  const e = i.map((n) => {
    let s;
    return typeof n == "string" ? s = { name: n } : s = n, s;
  }).filter((n) => {
    const s = Nl.includes(n.name);
    return s || D("alignment-config-name-not-recognized", { option: n }), s;
  }), t = e.filter((n) => !!n.className).length;
  if (t && t < e.length)
    throw new g("alignment-config-classnames-are-missing", { configuredOptions: i });
  return e.forEach((n, s, o) => {
    const r = o.slice(s + 1);
    if (r.some((l) => l.name == n.name))
      throw new g("alignment-config-name-already-defined", { option: n, configuredOptions: i });
    if (n.className && r.some((c) => c.className == n.className))
      throw new g("alignment-config-classname-already-defined", { option: n, configuredOptions: i });
  }), e;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Dl = "alignment";
class lP extends V {
  /**
   * @inheritDoc
   */
  refresh() {
    const t = this.editor.locale, n = me(this.editor.model.document.selection.getSelectedBlocks());
    this.isEnabled = !!n && this._canBeAligned(n), this.isEnabled && n.hasAttribute("alignment") ? this.value = n.getAttribute("alignment") : this.value = t.contentLanguageDirection === "rtl" ? "right" : "left";
  }
  /**
   * Executes the command. Applies the alignment `value` to the selected blocks.
   * If no `value` is passed, the `value` is the default one or it is equal to the currently selected block's alignment attribute,
   * the command will remove the attribute from the selected blocks.
   *
   * @param options Options for the executed command.
   * @param options.value The value to apply.
   * @fires execute
   */
  execute(e = {}) {
    const t = this.editor, n = t.locale, s = t.model, o = s.document, r = e.value;
    s.change((a) => {
      const l = Array.from(o.selection.getSelectedBlocks()).filter((d) => this._canBeAligned(d)), c = l[0].getAttribute("alignment");
      rp(r, n) || c === r || !r ? cP(l, a) : uP(l, a, r);
    });
  }
  /**
   * Checks whether a block can have alignment set.
   *
   * @param block The block to be checked.
   */
  _canBeAligned(e) {
    return this.editor.model.schema.checkAttribute(e, Dl);
  }
}
function cP(i, e) {
  for (const t of i)
    e.removeAttribute(Dl, t);
}
function uP(i, e, t) {
  for (const n of i)
    e.setAttribute(Dl, t, n);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class dP extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "AlignmentEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), e.config.define("alignment", {
      options: Nl.map((t) => ({ name: t }))
    });
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.locale, n = e.model.schema, o = ap(e.config.get("alignment.options")).filter((c) => op(c.name) && !rp(c.name, t)), r = o.some((c) => !!c.className);
    n.extend("$block", { allowAttributes: "alignment" }), e.model.schema.setAttributeProperties("alignment", { isFormatting: !0 }), r ? e.conversion.attributeToAttribute(gP(o)) : e.conversion.for("downcast").attributeToAttribute(hP(o));
    const a = fP(o);
    for (const c of a)
      e.conversion.for("upcast").attributeToAttribute(c);
    const l = mP(o);
    for (const c of l)
      e.conversion.for("upcast").attributeToAttribute(c);
    e.commands.add("alignment", new lP(e));
  }
}
function hP(i) {
  const e = {};
  for (const { name: n } of i)
    e[n] = {
      key: "style",
      value: {
        "text-align": n
      }
    };
  return {
    model: {
      key: "alignment",
      values: i.map((n) => n.name)
    },
    view: e
  };
}
function fP(i) {
  const e = [];
  for (const { name: t } of i)
    e.push({
      view: {
        key: "style",
        value: {
          "text-align": t
        }
      },
      model: {
        key: "alignment",
        value: t
      }
    });
  return e;
}
function mP(i) {
  const e = [];
  for (const { name: t } of i)
    e.push({
      view: {
        key: "align",
        value: t
      },
      model: {
        key: "alignment",
        value: t
      }
    });
  return e;
}
function gP(i) {
  const e = {};
  for (const n of i)
    e[n.name] = {
      key: "class",
      value: n.className
    };
  return {
    model: {
      key: "alignment",
      values: i.map((n) => n.name)
    },
    view: e
  };
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Ti = /* @__PURE__ */ new Map([
  ["left", A.alignLeft],
  ["right", A.alignRight],
  ["center", A.alignCenter],
  ["justify", A.alignJustify]
]);
class pP extends b {
  /**
   * Returns the localized option titles provided by the plugin.
   *
   * The following localized titles corresponding with
   * {@link module:alignment/alignmentconfig~AlignmentConfig#options} are available:
   *
   * * `'left'`,
   * * `'right'`,
   * * `'center'`,
   * * `'justify'`.
   *
   * @readonly
   */
  get localizedOptionTitles() {
    const e = this.editor.t;
    return {
      left: e("Align left"),
      right: e("Align right"),
      center: e("Align center"),
      justify: e("Justify")
    };
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "AlignmentUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = ap(e.config.get("alignment.options"));
    t.map((n) => n.name).filter(op).forEach((n) => this._addButton(n)), this._addToolbarDropdown(t), this._addMenuBarMenu(t);
  }
  /**
   * Helper method for initializing the button and linking it with an appropriate command.
   *
   * @param option The name of the alignment option for which the button is added.
   */
  _addButton(e) {
    this.editor.ui.componentFactory.add(`alignment:${e}`, (n) => this._createButton(n, e));
  }
  /**
   * Helper method for creating the button view element.
   *
   * @param locale Editor locale.
   * @param option The name of the alignment option for which the button is added.
   * @param buttonAttrs Optional parameters passed to button view instance.
   */
  _createButton(e, t, n = {}) {
    const s = this.editor, o = s.commands.get("alignment"), r = new P(e);
    return r.set({
      label: this.localizedOptionTitles[t],
      icon: Ti.get(t),
      tooltip: !0,
      isToggleable: !0,
      ...n
    }), r.bind("isEnabled").to(o), r.bind("isOn").to(o, "value", (a) => a === t), this.listenTo(r, "execute", () => {
      s.execute("alignment", { value: t }), s.editing.view.focus();
    }), r;
  }
  /**
   * Helper method for initializing the toolnar dropdown and linking it with an appropriate command.
   *
   * @param option The name of the alignment option for which the button is added.
   */
  _addToolbarDropdown(e) {
    const t = this.editor;
    t.ui.componentFactory.add("alignment", (s) => {
      const o = we(s), r = s.uiLanguageDirection === "rtl" ? "w" : "e", a = s.t;
      or(o, () => e.map((u) => this._createButton(s, u.name, { tooltipPosition: r })), {
        enableActiveItemFocusOnDropdownOpen: !0,
        isVertical: !0,
        ariaLabel: a("Text alignment toolbar")
      }), o.buttonView.set({
        label: a("Text alignment"),
        tooltip: !0
      }), o.extendTemplate({
        attributes: {
          class: "ck-alignment-dropdown"
        }
      });
      const l = s.contentLanguageDirection === "rtl" ? Ti.get("right") : Ti.get("left"), c = t.commands.get("alignment");
      return o.buttonView.bind("icon").to(c, "value", (u) => Ti.get(u) || l), o.bind("isEnabled").to(c, "isEnabled"), this.listenTo(o, "execute", () => {
        t.editing.view.focus();
      }), o;
    });
  }
  /**
   * Creates a menu for all alignment options to use either in menu bar.
   *
   * @param options Normalized alignment options from config.
   */
  _addMenuBarMenu(e) {
    const t = this.editor;
    t.ui.componentFactory.add("menuBar:alignment", (n) => {
      const s = t.commands.get("alignment"), o = n.t, r = new Ge(n), a = new oi(n);
      r.bind("isEnabled").to(s), a.set({
        ariaLabel: o("Text alignment"),
        role: "menu"
      }), r.buttonView.set({
        label: o("Text alignment")
      });
      for (const l of e) {
        const c = new fi(n, r), u = new de(n);
        u.extendTemplate({
          attributes: {
            "aria-checked": u.bindTemplate.to("isOn")
          }
        }), u.delegate("execute").to(r), u.set({
          label: this.localizedOptionTitles[l.name],
          icon: Ti.get(l.name)
        }), u.on("execute", () => {
          t.execute("alignment", { value: l.name }), t.editing.view.focus();
        }), u.bind("isOn").to(s, "value", (d) => d === l.name), u.bind("isEnabled").to(s, "isEnabled"), c.children.add(u), a.items.add(c);
      }
      return r.panelView.children.add(a), r;
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class bP extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [dP, pP];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Alignment";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class cr extends V {
  /**
   * Creates an instance of the command.
   *
   * @param editor Editor instance.
   * @param attributeKey The name of a model attribute on which this command operates.
   */
  constructor(e, t) {
    super(e), this.attributeKey = t;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor.model, t = e.document;
    this.value = t.selection.getAttribute(this.attributeKey), this.isEnabled = e.schema.checkAttributeInSelection(t.selection, this.attributeKey);
  }
  /**
   * Executes the command. Applies the `value` of the {@link #attributeKey} to the selection.
   * If no `value` is passed, it removes the attribute from the selection.
   *
   * @param options Options for the executed command.
   * @param options.value The value to apply.
   * @fires execute
   */
  execute(e = {}) {
    const t = this.editor.model, s = t.document.selection, o = e.value, r = e.batch, a = (l) => {
      if (s.isCollapsed)
        o ? l.setSelectionAttribute(this.attributeKey, o) : l.removeSelectionAttribute(this.attributeKey);
      else {
        const c = t.schema.getValidRanges(s.getRanges(), this.attributeKey);
        for (const u of c)
          o ? l.setAttribute(this.attributeKey, o, u) : l.removeAttribute(this.attributeKey, u);
      }
    };
    r ? t.enqueueChange(r, (l) => {
      a(l);
    }) : t.change((l) => {
      a(l);
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const xe = "fontSize", Ie = "fontFamily", ft = "fontColor", Et = "fontBackgroundColor";
function lp(i, e) {
  const t = {
    model: {
      key: i,
      values: []
    },
    view: {},
    upcastAlso: {}
  };
  for (const n of e)
    t.model.values.push(n.model), t.view[n.model] = n.view, n.upcastAlso && (t.upcastAlso[n.model] = n.upcastAlso);
  return t;
}
function cp(i) {
  return (e) => _P(e.getStyle(i));
}
function up(i) {
  return (e, { writer: t }) => t.createAttributeElement("span", {
    style: `${i}:${e}`
  }, { priority: 7 });
}
function wP({ dropdownView: i, colors: e, columns: t, removeButtonLabel: n, colorPickerLabel: s, documentColorsLabel: o, documentColorsCount: r, colorPickerViewConfig: a }) {
  const l = i.locale, c = new Vl(l, {
    colors: e,
    columns: t,
    removeButtonLabel: n,
    colorPickerLabel: s,
    documentColorsLabel: o,
    documentColorsCount: r,
    colorPickerViewConfig: a
  });
  return i.colorSelectorView = c, i.panelView.children.add(c), c;
}
function _P(i) {
  return i.replace(/\s/g, "");
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class vP extends cr {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e, Ie);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function dp(i) {
  return i.map(yP).filter((e) => e !== void 0);
}
function yP(i) {
  if (typeof i == "object")
    return i;
  if (i === "default")
    return {
      title: "Default",
      model: void 0
    };
  if (typeof i == "string")
    return CP(i);
}
function CP(i) {
  const e = i.replace(/"|'/g, "").split(","), t = e[0], n = e.map(kP).join(", ");
  return {
    title: t,
    model: n,
    view: {
      name: "span",
      styles: {
        "font-family": n
      },
      priority: 7
    }
  };
}
function kP(i) {
  return i = i.trim(), i.indexOf(" ") > 0 && (i = `'${i}'`), i;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class TP extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "FontFamilyEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), e.config.define(Ie, {
      options: [
        "default",
        "Arial, Helvetica, sans-serif",
        "Courier New, Courier, monospace",
        "Georgia, serif",
        "Lucida Sans Unicode, Lucida Grande, sans-serif",
        "Tahoma, Geneva, sans-serif",
        "Times New Roman, Times, serif",
        "Trebuchet MS, Helvetica, sans-serif",
        "Verdana, Geneva, sans-serif"
      ],
      supportAllValues: !1
    });
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor;
    e.model.schema.extend("$text", { allowAttributes: Ie }), e.model.schema.setAttributeProperties(Ie, {
      isFormatting: !0,
      copyOnEnter: !0
    });
    const t = dp(e.config.get("fontFamily.options")).filter((s) => s.model), n = lp(Ie, t);
    e.config.get("fontFamily.supportAllValues") ? (this._prepareAnyValueConverters(), this._prepareCompatibilityConverter()) : e.conversion.attributeToElement(n), e.commands.add(Ie, new vP(e));
  }
  /**
   * These converters enable keeping any value found as `style="font-family: *"` as a value of an attribute on a text even
   * if it is not defined in the plugin configuration.
   */
  _prepareAnyValueConverters() {
    const e = this.editor;
    e.conversion.for("downcast").attributeToElement({
      model: Ie,
      view: (t, { writer: n }) => n.createAttributeElement("span", { style: "font-family:" + t }, { priority: 7 })
    }), e.conversion.for("upcast").elementToAttribute({
      model: {
        key: Ie,
        value: (t) => t.getStyle("font-family")
      },
      view: {
        name: "span",
        styles: {
          "font-family": /.*/
        }
      }
    });
  }
  /**
   * Adds support for legacy `<font face="..">` formatting.
   */
  _prepareCompatibilityConverter() {
    this.editor.conversion.for("upcast").elementToAttribute({
      view: {
        name: "font",
        attributes: {
          face: /.*/
        }
      },
      model: {
        key: Ie,
        value: (t) => t.getAttribute("face")
      }
    });
  }
}
const Vd = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.03 3h6.149a.75.75 0 1 1 0 1.5h-5.514L11.03 3zm1.27 3h4.879a.75.75 0 1 1 0 1.5h-4.244L12.3 6zm1.27 3h3.609a.75.75 0 1 1 0 1.5h-2.973L13.57 9zm-2.754 2.5L8.038 4.785 5.261 11.5h5.555zm.62 1.5H4.641l-1.666 4.028H1.312l5.789-14h1.875l5.789 14h-1.663L11.436 13z"/></svg>';
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class EP extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "FontFamilyUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.t, n = this._getLocalizedOptions(), s = e.commands.get(Ie), o = t("Font Family"), r = AP(n, s);
    e.ui.componentFactory.add(Ie, (a) => {
      const l = we(a);
      return Kt(l, r, {
        role: "menu",
        ariaLabel: o
      }), l.buttonView.set({
        label: o,
        icon: Vd,
        tooltip: !0
      }), l.extendTemplate({
        attributes: {
          class: "ck-font-family-dropdown"
        }
      }), l.bind("isEnabled").to(s), this.listenTo(l, "execute", (c) => {
        e.execute(c.source.commandName, { value: c.source.commandParam }), e.editing.view.focus();
      }), l;
    }), e.ui.componentFactory.add(`menuBar:${Ie}`, (a) => {
      const l = new Ge(a);
      l.buttonView.set({
        label: o,
        icon: Vd
      }), l.bind("isEnabled").to(s);
      const c = new oi(a);
      for (const u of r) {
        const d = new fi(a, l), h = new de(a);
        h.bind(...Object.keys(u.model)).to(u.model), h.bind("ariaChecked").to(h, "isOn"), h.delegate("execute").to(l), h.on("execute", () => {
          e.execute(u.model.commandName, {
            value: u.model.commandParam
          }), e.editing.view.focus();
        }), d.children.add(h), c.items.add(d);
      }
      return l.panelView.children.add(c), l;
    });
  }
  /**
   * Returns options as defined in `config.fontFamily.options` but processed to account for
   * editor localization, i.e. to display {@link module:font/fontconfig~FontFamilyOption}
   * in the correct language.
   *
   * Note: The reason behind this method is that there is no way to use {@link module:utils/locale~Locale#t}
   * when the user configuration is defined because the editor does not exist yet.
   */
  _getLocalizedOptions() {
    const e = this.editor, t = e.t;
    return dp(e.config.get(Ie).options).map((s) => (s.title === "Default" && (s.title = t("Default")), s));
  }
}
function AP(i, e) {
  const t = new ke();
  for (const n of i) {
    const s = {
      type: "button",
      model: new $t({
        commandName: Ie,
        commandParam: n.model,
        label: n.title,
        role: "menuitemradio",
        withText: !0
      })
    };
    s.model.bind("isOn").to(e, "value", (o) => o === n.model ? !0 : !o || !n.model ? !1 : o.split(",")[0].replace(/'/g, "").toLowerCase() === n.model.toLowerCase()), n.view && typeof n.view != "string" && n.view.styles && s.model.set("labelStyle", `font-family: ${n.view.styles["font-family"]}`), t.add(s);
  }
  return t;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class hp extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [TP, EP];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "FontFamily";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class xP extends cr {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e, xe);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function zl(i) {
  return i.map((e) => IP(e)).filter((e) => e !== void 0);
}
const Md = {
  get tiny() {
    return {
      title: "Tiny",
      model: "tiny",
      view: {
        name: "span",
        classes: "text-tiny",
        priority: 7
      }
    };
  },
  get small() {
    return {
      title: "Small",
      model: "small",
      view: {
        name: "span",
        classes: "text-small",
        priority: 7
      }
    };
  },
  get big() {
    return {
      title: "Big",
      model: "big",
      view: {
        name: "span",
        classes: "text-big",
        priority: 7
      }
    };
  },
  get huge() {
    return {
      title: "Huge",
      model: "huge",
      view: {
        name: "span",
        classes: "text-huge",
        priority: 7
      }
    };
  }
};
function IP(i) {
  if (typeof i == "number" && (i = String(i)), typeof i == "object" && RP(i))
    return ka(i);
  const e = PP(i);
  if (e)
    return ka(e);
  if (i === "default")
    return {
      model: void 0,
      title: "Default"
    };
  if (!VP(i))
    return SP(i);
}
function SP(i) {
  return typeof i == "string" && (i = {
    title: i,
    model: `${parseFloat(i)}px`
  }), i.view = {
    name: "span",
    styles: {
      "font-size": i.model
    }
  }, ka(i);
}
function ka(i) {
  return i.view && typeof i.view != "string" && !i.view.priority && (i.view.priority = 7), i;
}
function PP(i) {
  return typeof i == "string" ? Md[i] : Md[i.model];
}
function RP(i) {
  return i.title && i.model && i.view;
}
function VP(i) {
  let e;
  if (typeof i == "object")
    if (i.model)
      e = parseFloat(i.model);
    else
      throw new g("font-size-invalid-definition", null, i);
  else
    e = parseFloat(i);
  return isNaN(e);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Bd = [
  "x-small",
  "x-small",
  "small",
  "medium",
  "large",
  "x-large",
  "xx-large",
  "xxx-large"
];
class MP extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "FontSizeEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), e.config.define(xe, {
      options: [
        "tiny",
        "small",
        "default",
        "big",
        "huge"
      ],
      supportAllValues: !1
    });
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor;
    e.model.schema.extend("$text", { allowAttributes: xe }), e.model.schema.setAttributeProperties(xe, {
      isFormatting: !0,
      copyOnEnter: !0
    });
    const t = e.config.get("fontSize.supportAllValues"), n = zl(this.editor.config.get("fontSize.options")).filter((o) => o.model), s = lp(xe, n);
    t ? (this._prepareAnyValueConverters(s), this._prepareCompatibilityConverter()) : e.conversion.attributeToElement(s), e.commands.add(xe, new xP(e));
  }
  /**
   * These converters enable keeping any value found as `style="font-size: *"` as a value of an attribute on a text even
   * if it is not defined in the plugin configuration.
   *
   * @param definition Converter definition out of input data.
   */
  _prepareAnyValueConverters(e) {
    const t = this.editor, n = e.model.values.filter((s) => !Yo(String(s)) && !rg(String(s)));
    if (n.length)
      throw new g("font-size-invalid-use-of-named-presets", null, { presets: n });
    t.conversion.for("downcast").attributeToElement({
      model: xe,
      view: (s, { writer: o }) => {
        if (s)
          return o.createAttributeElement("span", { style: "font-size:" + s }, { priority: 7 });
      }
    }), t.conversion.for("upcast").elementToAttribute({
      model: {
        key: xe,
        value: (s) => s.getStyle("font-size")
      },
      view: {
        name: "span",
        styles: {
          "font-size": /.*/
        }
      }
    });
  }
  /**
   * Adds support for legacy `<font size="..">` formatting.
   */
  _prepareCompatibilityConverter() {
    this.editor.conversion.for("upcast").elementToAttribute({
      view: {
        name: "font",
        attributes: {
          // Documentation mentions sizes from 1 to 7. To handle old content we support all values
          // up to 999 but clamp it to the valid range. Why 999? It should cover accidental values
          // similar to percentage, e.g. 100%, 200% which could be the usual mistake for font size.
          size: /^[+-]?\d{1,3}$/
        }
      },
      model: {
        key: xe,
        value: (t) => {
          const n = t.getAttribute("size"), s = n[0] === "-" || n[0] === "+";
          let o = parseInt(n, 10);
          s && (o = 3 + o);
          const r = Bd.length - 1, a = Math.min(Math.max(o, 0), r);
          return Bd[a];
        }
      }
    });
  }
}
const Ld = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13zm7.55 2.279.779-.779.707.707-2.265 2.265-2.193-2.265.707-.707.765.765V4.825c0-.042 0-.083.002-.123l-.77.77-.707-.707L17.207 2.5l2.265 2.265-.707.707-.782-.782c.002.043.003.089.003.135v10.454z"/></svg>';
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class BP extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "FontSizeUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.t, n = this._getLocalizedOptions(), s = e.commands.get(xe), o = t("Font Size"), r = LP(n, s);
    e.ui.componentFactory.add(xe, (a) => {
      const l = we(a);
      return Kt(l, r, {
        role: "menu",
        ariaLabel: o
      }), l.buttonView.set({
        label: o,
        icon: Ld,
        tooltip: !0
      }), l.extendTemplate({
        attributes: {
          class: [
            "ck-font-size-dropdown"
          ]
        }
      }), l.bind("isEnabled").to(s), this.listenTo(l, "execute", (c) => {
        e.execute(c.source.commandName, { value: c.source.commandParam }), e.editing.view.focus();
      }), l;
    }), e.ui.componentFactory.add(`menuBar:${xe}`, (a) => {
      const l = new Ge(a);
      l.buttonView.set({
        label: o,
        icon: Ld
      }), l.bind("isEnabled").to(s);
      const c = new oi(a);
      for (const u of r) {
        const d = new fi(a, l), h = new de(a);
        h.bind(...Object.keys(u.model)).to(u.model), h.bind("ariaChecked").to(h, "isOn"), h.delegate("execute").to(l), h.on("execute", () => {
          e.execute(u.model.commandName, {
            value: u.model.commandParam
          }), e.editing.view.focus();
        }), d.children.add(h), c.items.add(d);
      }
      return l.panelView.children.add(c), l;
    });
  }
  /**
   * Returns options as defined in `config.fontSize.options` but processed to account for
   * editor localization, i.e. to display {@link module:font/fontconfig~FontSizeOption}
   * in the correct language.
   *
   * Note: The reason behind this method is that there is no way to use {@link module:utils/locale~Locale#t}
   * when the user configuration is defined because the editor does not exist yet.
   */
  _getLocalizedOptions() {
    const e = this.editor, t = e.t, n = {
      Default: t("Default"),
      Tiny: t("Tiny"),
      Small: t("Small"),
      Big: t("Big"),
      Huge: t("Huge")
    };
    return zl(e.config.get(xe).options).map((o) => {
      const r = n[o.title];
      return r && r != o.title && (o = Object.assign({}, o, { title: r })), o;
    });
  }
}
function LP(i, e) {
  const t = new ke();
  for (const n of i) {
    const s = {
      type: "button",
      model: new $t({
        commandName: xe,
        commandParam: n.model,
        label: n.title,
        class: "ck-fontsize-option",
        role: "menuitemradio",
        withText: !0
      })
    };
    n.view && typeof n.view != "string" && (n.view.styles && s.model.set("labelStyle", `font-size:${n.view.styles["font-size"]}`), n.view.classes && s.model.set("class", `${s.model.class} ${n.view.classes}`)), s.model.bind("isOn").to(e, "value", (o) => o === n.model), t.add(s);
  }
  return t;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class OP extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [MP, BP];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "FontSize";
  }
  /**
   * Normalizes and translates the {@link module:font/fontconfig~FontSizeConfig#options configuration options}
   * to the {@link module:font/fontconfig~FontSizeOption} format.
   *
   * @param configuredOptions An array of options taken from the configuration.
   */
  normalizeSizeOptions(e) {
    return zl(e);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class FP extends cr {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e, ft);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class NP extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "FontColorEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), e.config.define(ft, {
      colors: [
        {
          color: "hsl(0, 0%, 0%)",
          label: "Black"
        },
        {
          color: "hsl(0, 0%, 30%)",
          label: "Dim grey"
        },
        {
          color: "hsl(0, 0%, 60%)",
          label: "Grey"
        },
        {
          color: "hsl(0, 0%, 90%)",
          label: "Light grey"
        },
        {
          color: "hsl(0, 0%, 100%)",
          label: "White",
          hasBorder: !0
        },
        {
          color: "hsl(0, 75%, 60%)",
          label: "Red"
        },
        {
          color: "hsl(30, 75%, 60%)",
          label: "Orange"
        },
        {
          color: "hsl(60, 75%, 60%)",
          label: "Yellow"
        },
        {
          color: "hsl(90, 75%, 60%)",
          label: "Light green"
        },
        {
          color: "hsl(120, 75%, 60%)",
          label: "Green"
        },
        {
          color: "hsl(150, 75%, 60%)",
          label: "Aquamarine"
        },
        {
          color: "hsl(180, 75%, 60%)",
          label: "Turquoise"
        },
        {
          color: "hsl(210, 75%, 60%)",
          label: "Light blue"
        },
        {
          color: "hsl(240, 75%, 60%)",
          label: "Blue"
        },
        {
          color: "hsl(270, 75%, 60%)",
          label: "Purple"
        }
      ],
      columns: 5
    }), e.conversion.for("upcast").elementToAttribute({
      view: {
        name: "span",
        styles: {
          color: /[\s\S]+/
        }
      },
      model: {
        key: ft,
        value: cp("color")
      }
    }), e.conversion.for("upcast").elementToAttribute({
      view: {
        name: "font",
        attributes: {
          color: /^#?\w+$/
        }
      },
      model: {
        key: ft,
        value: (t) => t.getAttribute("color")
      }
    }), e.conversion.for("downcast").attributeToElement({
      model: ft,
      view: up("color")
    }), e.commands.add(ft, new FP(e)), e.model.schema.extend("$text", { allowAttributes: ft }), e.model.schema.setAttributeProperties(ft, {
      isFormatting: !0,
      copyOnEnter: !0
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class fp extends b {
  /**
   * Creates a plugin which introduces a dropdown with a pre–configured
   * {@link module:ui/colorselector/colorselectorview~ColorSelectorView}.
   *
   * @param config The configuration object.
   * @param config.commandName The name of the command which will be executed when a color tile is clicked.
   * @param config.componentName The name of the dropdown in the {@link module:ui/componentfactory~ComponentFactory}
   * and the configuration scope name in `editor.config`.
   * @param config.icon The SVG icon used by the dropdown.
   * @param config.dropdownLabel The label used by the dropdown.
   */
  constructor(e, { commandName: t, componentName: n, icon: s, dropdownLabel: o }) {
    super(e), this.commandName = t, this.componentName = n, this.icon = s, this.dropdownLabel = o, this.columns = e.config.get(`${this.componentName}.columns`);
  }
  /**
  * @inheritDoc
  */
  init() {
    const e = this.editor, t = e.locale, n = t.t, s = e.commands.get(this.commandName), o = e.config.get(this.componentName), r = os(o.colors), a = ss(t, r), l = o.documentColors, c = o.colorPicker !== !1;
    e.ui.componentFactory.add(this.componentName, (u) => {
      const d = we(u);
      let h = !1;
      const f = wP({
        dropdownView: d,
        colors: a.map((m) => ({
          label: m.label,
          color: m.model,
          options: {
            hasBorder: m.hasBorder
          }
        })),
        columns: this.columns,
        removeButtonLabel: n("Remove color"),
        colorPickerLabel: n("Color picker"),
        documentColorsLabel: l !== 0 ? n("Document colors") : "",
        documentColorsCount: l === void 0 ? this.columns : l,
        colorPickerViewConfig: c ? o.colorPicker || {} : !1
      });
      return f.bind("selectedColor").to(s, "value"), d.buttonView.set({
        label: this.dropdownLabel,
        icon: this.icon,
        tooltip: !0
      }), d.extendTemplate({
        attributes: {
          class: "ck-color-ui-dropdown"
        }
      }), d.bind("isEnabled").to(s), f.on("execute", (m, p) => {
        d.isOpen && e.execute(this.commandName, {
          value: p.value,
          batch: this._undoStepBatch
        }), p.source !== "colorPicker" && e.editing.view.focus(), p.source === "colorPickerSaveButton" && (d.isOpen = !1);
      }), f.on("colorPicker:show", () => {
        this._undoStepBatch = e.model.createBatch();
      }), f.on("colorPicker:cancel", () => {
        this._undoStepBatch.operations.length && (d.isOpen = !1, e.execute("undo", this._undoStepBatch)), e.editing.view.focus();
      }), d.on("change:isOpen", (m, p, w) => {
        h || (h = !0, d.colorSelectorView.appendUI()), w && (l !== 0 && f.updateDocumentColors(e.model, this.componentName), f.updateSelectedColors(), f.showColorGridsFragment());
      }), Pl(d, () => d.colorSelectorView.colorGridsFragmentView.staticColorsGrid.items.find((m) => m.isOn)), d;
    }), e.ui.componentFactory.add(`menuBar:${this.componentName}`, (u) => {
      const d = new Ge(u);
      d.buttonView.set({
        label: this.dropdownLabel,
        icon: this.icon
      }), d.bind("isEnabled").to(s);
      let h = !1;
      const f = new Vl(u, {
        colors: a.map((m) => ({
          label: m.label,
          color: m.model,
          options: {
            hasBorder: m.hasBorder
          }
        })),
        columns: this.columns,
        removeButtonLabel: n("Remove color"),
        colorPickerLabel: n("Color picker"),
        documentColorsLabel: l !== 0 ? n("Document colors") : "",
        documentColorsCount: l === void 0 ? this.columns : l,
        colorPickerViewConfig: !1
      });
      return f.bind("selectedColor").to(s, "value"), f.delegate("execute").to(d), f.on("execute", (m, p) => {
        e.execute(this.commandName, {
          value: p.value,
          batch: this._undoStepBatch
        }), e.editing.view.focus();
      }), d.on("change:isOpen", (m, p, w) => {
        h || (h = !0, f.appendUI()), w && (l !== 0 && f.updateDocumentColors(e.model, this.componentName), f.updateSelectedColors(), f.showColorGridsFragment());
      }), d.panelView.children.add(f), d;
    });
  }
}
const DP = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.4 10.3 10 4.5l-2.4 5.8h4.8zm.5 1.2H7.1L5.7 15H4.2l5-12h1.6l5 12h-1.5L13 11.5zm3.1 7H4a1 1 0 0 1 0-2h12a1 1 0 0 1 0 2z"/></svg>';
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class zP extends fp {
  /**
   * @inheritDoc
   */
  constructor(e) {
    const t = e.locale.t;
    super(e, {
      commandName: ft,
      componentName: ft,
      icon: DP,
      dropdownLabel: t("Font Color")
    });
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "FontColorUI";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class HP extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [NP, zP];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "FontColor";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class UP extends cr {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e, Et);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class $P extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "FontBackgroundColorEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), e.config.define(Et, {
      colors: [
        {
          color: "hsl(0, 0%, 0%)",
          label: "Black"
        },
        {
          color: "hsl(0, 0%, 30%)",
          label: "Dim grey"
        },
        {
          color: "hsl(0, 0%, 60%)",
          label: "Grey"
        },
        {
          color: "hsl(0, 0%, 90%)",
          label: "Light grey"
        },
        {
          color: "hsl(0, 0%, 100%)",
          label: "White",
          hasBorder: !0
        },
        {
          color: "hsl(0, 75%, 60%)",
          label: "Red"
        },
        {
          color: "hsl(30, 75%, 60%)",
          label: "Orange"
        },
        {
          color: "hsl(60, 75%, 60%)",
          label: "Yellow"
        },
        {
          color: "hsl(90, 75%, 60%)",
          label: "Light green"
        },
        {
          color: "hsl(120, 75%, 60%)",
          label: "Green"
        },
        {
          color: "hsl(150, 75%, 60%)",
          label: "Aquamarine"
        },
        {
          color: "hsl(180, 75%, 60%)",
          label: "Turquoise"
        },
        {
          color: "hsl(210, 75%, 60%)",
          label: "Light blue"
        },
        {
          color: "hsl(240, 75%, 60%)",
          label: "Blue"
        },
        {
          color: "hsl(270, 75%, 60%)",
          label: "Purple"
        }
      ],
      columns: 5
    }), e.data.addStyleProcessorRules(kl), e.conversion.for("upcast").elementToAttribute({
      view: {
        name: "span",
        styles: {
          "background-color": /[\s\S]+/
        }
      },
      model: {
        key: Et,
        value: cp("background-color")
      }
    }), e.conversion.for("downcast").attributeToElement({
      model: Et,
      view: up("background-color")
    }), e.commands.add(Et, new UP(e)), e.model.schema.extend("$text", { allowAttributes: Et }), e.model.schema.setAttributeProperties(Et, {
      isFormatting: !0,
      copyOnEnter: !0
    });
  }
}
const WP = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M4 2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2zm8.38 9.262H7.62L10 5.506l2.38 5.756zm.532 1.285L14.34 16h1.426L10.804 4H9.196L4.234 16H5.66l1.428-3.453h5.824z"/></svg>';
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class qP extends fp {
  /**
   * @inheritDoc
   */
  constructor(e) {
    const t = e.locale.t;
    super(e, {
      commandName: Et,
      componentName: Et,
      icon: WP,
      dropdownLabel: t("Font Background Color")
    });
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "FontBackgroundColorUI";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class mp extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [$P, qP];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "FontBackgroundColor";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class GP extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [hp, OP, HP, mp];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Font";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class kn extends V {
  /**
   * @param attributeKey Attribute that will be set by the command.
   */
  constructor(e, t) {
    super(e), this.attributeKey = t;
  }
  /**
   * Updates the command's {@link #value} and {@link #isEnabled} based on the current selection.
   */
  refresh() {
    const e = this.editor.model, t = e.document;
    this.value = this._getValueFromFirstAllowedNode(), this.isEnabled = e.schema.checkAttributeInSelection(t.selection, this.attributeKey);
  }
  /**
   * Executes the command &ndash; applies the attribute to the selection or removes it from the selection.
   *
   * If the command is active (`value == true`), it will remove attributes. Otherwise, it will set attributes.
   *
   * The execution result differs, depending on the {@link module:engine/model/document~Document#selection}:
   *
   * * If the selection is on a range, the command applies the attribute to all nodes in that range
   * (if they are allowed to have this attribute by the {@link module:engine/model/schema~Schema schema}).
   * * If the selection is collapsed in a non-empty node, the command applies the attribute to the
   * {@link module:engine/model/document~Document#selection} itself (note that typed characters copy attributes from the selection).
   * * If the selection is collapsed in an empty node, the command applies the attribute to the parent node of the selection (note
   * that the selection inherits all attributes from a node if it is in an empty node).
   *
   * @fires execute
   * @param options Command options.
   * @param options.forceValue If set, it will force the command behavior. If `true`,
   * the command will apply the attribute, otherwise the command will remove the attribute.
   * If not set, the command will look for its current value to decide what it should do.
   */
  execute(e = {}) {
    const t = this.editor.model, s = t.document.selection, o = e.forceValue === void 0 ? !this.value : e.forceValue;
    t.change((r) => {
      if (s.isCollapsed)
        o ? r.setSelectionAttribute(this.attributeKey, !0) : r.removeSelectionAttribute(this.attributeKey);
      else {
        const a = t.schema.getValidRanges(s.getRanges(), this.attributeKey);
        for (const l of a)
          o ? r.setAttribute(this.attributeKey, o, l) : r.removeAttribute(this.attributeKey, l);
      }
    });
  }
  /**
   * Checks the attribute value of the first node in the selection that allows the attribute.
   * For the collapsed selection returns the selection attribute.
   *
   * @returns The attribute value.
   */
  _getValueFromFirstAllowedNode() {
    const e = this.editor.model, t = e.schema, n = e.document.selection;
    if (n.isCollapsed)
      return n.hasAttribute(this.attributeKey);
    for (const s of n.getRanges())
      for (const o of s.getItems())
        if (t.checkAttribute(o, this.attributeKey))
          return o.hasAttribute(this.attributeKey);
    return !1;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const On = "bold";
class jP extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "BoldEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = this.editor.t;
    e.model.schema.extend("$text", { allowAttributes: On }), e.model.schema.setAttributeProperties(On, {
      isFormatting: !0,
      copyOnEnter: !0
    }), e.conversion.attributeToElement({
      model: On,
      view: "strong",
      upcastAlso: [
        "b",
        (n) => {
          const s = n.getStyle("font-weight");
          return s && (s == "bold" || Number(s) >= 600) ? {
            name: !0,
            styles: ["font-weight"]
          } : null;
        }
      ]
    }), e.commands.add(On, new kn(e, On)), e.keystrokes.set("CTRL+B", On), e.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: t("Bold text"),
          keystroke: "CTRL+B"
        }
      ]
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Tn({ editor: i, commandName: e, plugin: t, icon: n, label: s, keystroke: o }) {
  return (r) => {
    const a = i.commands.get(e), l = new r(i.locale);
    return l.set({
      label: s,
      icon: n,
      keystroke: o,
      isToggleable: !0
    }), l.bind("isEnabled").to(a, "isEnabled"), t.listenTo(l, "execute", () => {
      i.execute(e), i.editing.view.focus();
    }), l;
  };
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const $s = "bold";
class KP extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "BoldUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.locale.t, n = e.commands.get($s), s = Tn({
      editor: e,
      commandName: $s,
      plugin: this,
      icon: A.bold,
      label: t("Bold"),
      keystroke: "CTRL+B"
    });
    e.ui.componentFactory.add($s, () => {
      const o = s(P);
      return o.set({
        tooltip: !0
      }), o.bind("isOn").to(n, "value"), o;
    }), e.ui.componentFactory.add("menuBar:" + $s, () => s(de));
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ZP extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [jP, KP];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Bold";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const tn = "code", JP = "ck-code_selected";
class XP extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "CodeEditing";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Eo];
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = this.editor.t;
    e.model.schema.extend("$text", { allowAttributes: tn }), e.model.schema.setAttributeProperties(tn, {
      isFormatting: !0,
      copyOnEnter: !1
    }), e.conversion.attributeToElement({
      model: tn,
      view: "code",
      upcastAlso: {
        styles: {
          "word-wrap": "break-word"
        }
      }
    }), e.commands.add(tn, new kn(e, tn)), e.plugins.get(Eo).registerAttribute(tn), bg(e, tn, "code", JP), e.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: t("Move out of an inline code style"),
          keystroke: [
            ["arrowleft", "arrowleft"],
            ["arrowright", "arrowright"]
          ]
        }
      ]
    });
  }
}
const QP = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m12.5 5.7 5.2 3.9v1.3l-5.6 4c-.1.2-.3.2-.5.2-.3-.1-.6-.7-.6-1l.3-.4 4.7-3.5L11.5 7l-.2-.2c-.1-.3-.1-.6 0-.8.2-.2.5-.4.8-.4a.8.8 0 0 1 .4.1zm-5.2 0L2 9.6v1.3l5.6 4c.1.2.3.2.5.2.3-.1.7-.7.6-1 0-.1 0-.3-.2-.4l-5-3.5L8.2 7l.2-.2c.1-.3.1-.6 0-.8-.2-.2-.5-.4-.8-.4a.8.8 0 0 0-.3.1z"/></svg>';
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Ws = "code";
class YP extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "CodeUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.locale.t, n = Tn({
      editor: e,
      commandName: Ws,
      plugin: this,
      icon: QP,
      label: t("Code")
    });
    e.ui.componentFactory.add(Ws, () => {
      const s = n(P), o = e.commands.get(Ws);
      return s.set({
        tooltip: !0
      }), s.bind("isOn").to(o, "value"), s;
    }), e.ui.componentFactory.add("menuBar:" + Ws, () => n(de));
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class eR extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [XP, YP];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Code";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Fn = "italic";
class tR extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ItalicEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = this.editor.t;
    e.model.schema.extend("$text", { allowAttributes: Fn }), e.model.schema.setAttributeProperties(Fn, {
      isFormatting: !0,
      copyOnEnter: !0
    }), e.conversion.attributeToElement({
      model: Fn,
      view: "i",
      upcastAlso: [
        "em",
        {
          styles: {
            "font-style": "italic"
          }
        }
      ]
    }), e.commands.add(Fn, new kn(e, Fn)), e.keystrokes.set("CTRL+I", Fn), e.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: t("Italic text"),
          keystroke: "CTRL+I"
        }
      ]
    });
  }
}
const nR = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>';
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const qs = "italic";
class iR extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ItalicUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.commands.get(qs), n = e.locale.t, s = Tn({
      editor: e,
      commandName: qs,
      plugin: this,
      icon: nR,
      keystroke: "CTRL+I",
      label: n("Italic")
    });
    e.ui.componentFactory.add(qs, () => {
      const o = s(P);
      return o.set({
        tooltip: !0
      }), o.bind("isOn").to(t, "value"), o;
    }), e.ui.componentFactory.add("menuBar:" + qs, () => s(de));
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class sR extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [tR, iR];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Italic";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Ei = "strikethrough";
class oR extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "StrikethroughEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = this.editor.t;
    e.model.schema.extend("$text", { allowAttributes: Ei }), e.model.schema.setAttributeProperties(Ei, {
      isFormatting: !0,
      copyOnEnter: !0
    }), e.conversion.attributeToElement({
      model: Ei,
      view: "s",
      upcastAlso: [
        "del",
        "strike",
        {
          styles: {
            "text-decoration": "line-through"
          }
        }
      ]
    }), e.commands.add(Ei, new kn(e, Ei)), e.keystrokes.set("CTRL+SHIFT+X", "strikethrough"), e.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: t("Strikethrough text"),
          keystroke: "CTRL+SHIFT+X"
        }
      ]
    });
  }
}
const rR = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 16.4c-.8-.4-1.5-.9-2.2-1.5a.6.6 0 0 1-.2-.5l.3-.6h1c1 1.2 2.1 1.7 3.7 1.7 1 0 1.8-.3 2.3-.6.6-.4.6-1.2.6-1.3.2-1.2-.9-2.1-.9-2.1h2.1c.3.7.4 1.2.4 1.7v.8l-.6 1.2c-.6.8-1.1 1-1.6 1.2a6 6 0 0 1-2.4.6c-1 0-1.8-.3-2.5-.6zM6.8 9 6 8.3c-.4-.5-.5-.8-.5-1.6 0-.7.1-1.3.5-1.8.4-.6 1-1 1.6-1.3a6.3 6.3 0 0 1 4.7 0 4 4 0 0 1 1.7 1l.3.7c0 .1.2.4-.2.7-.4.2-.9.1-1 0a3 3 0 0 0-1.2-1c-.4-.2-1-.3-2-.4-.7 0-1.4.2-2 .6-.8.6-1 .8-1 1.5 0 .8.5 1 1.2 1.5.6.4 1.1.7 1.9 1H6.8z"/><path d="M3 10.5V9h14v1.5z"/></svg>';
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Gs = "strikethrough";
class aR extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "StrikethroughUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.locale.t, n = Tn({
      editor: e,
      commandName: Gs,
      plugin: this,
      icon: rR,
      keystroke: "CTRL+SHIFT+X",
      label: t("Strikethrough")
    });
    e.ui.componentFactory.add(Gs, () => {
      const s = n(P), o = e.commands.get(Gs);
      return s.set({
        tooltip: !0
      }), s.bind("isOn").to(o, "value"), s;
    }), e.ui.componentFactory.add("menuBar:" + Gs, () => n(de));
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class lR extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [oR, aR];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Strikethrough";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Ai = "subscript";
class cR extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "SubscriptEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor;
    e.model.schema.extend("$text", { allowAttributes: Ai }), e.model.schema.setAttributeProperties(Ai, {
      isFormatting: !0,
      copyOnEnter: !0
    }), e.conversion.attributeToElement({
      model: Ai,
      view: "sub",
      upcastAlso: [
        {
          styles: {
            "vertical-align": "sub"
          }
        }
      ]
    }), e.commands.add(Ai, new kn(e, Ai));
  }
}
const uR = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.03 10.349 3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82zm8.147 7.829h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309z"/></svg>';
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const js = "subscript";
class dR extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "SubscriptUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.locale.t, n = Tn({
      editor: e,
      commandName: js,
      plugin: this,
      icon: uR,
      label: t("Subscript")
    });
    e.ui.componentFactory.add(js, () => {
      const s = n(P), o = e.commands.get(js);
      return s.set({
        tooltip: !0
      }), s.bind("isOn").to(o, "value"), s;
    }), e.ui.componentFactory.add("menuBar:" + js, () => n(de));
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class hR extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [cR, dR];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Subscript";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const xi = "superscript";
class fR extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "SuperscriptEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor;
    e.model.schema.extend("$text", { allowAttributes: xi }), e.model.schema.setAttributeProperties(xi, {
      isFormatting: !0,
      copyOnEnter: !0
    }), e.conversion.attributeToElement({
      model: xi,
      view: "sup",
      upcastAlso: [
        {
          styles: {
            "vertical-align": "super"
          }
        }
      ]
    }), e.commands.add(xi, new kn(e, xi));
  }
}
const mR = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M15.677 8.678h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309zM7.03 10.349l3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82z"/></svg>';
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Ks = "superscript";
class gR extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "SuperscriptUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.locale.t, n = Tn({
      editor: e,
      commandName: Ks,
      plugin: this,
      icon: mR,
      label: t("Superscript")
    });
    e.ui.componentFactory.add(Ks, () => {
      const s = n(P), o = e.commands.get(Ks);
      return s.set({
        tooltip: !0
      }), s.bind("isOn").to(o, "value"), s;
    }), e.ui.componentFactory.add("menuBar:" + Ks, () => n(de));
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class pR extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [fR, gR];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Superscript";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Ii = "underline";
class bR extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "UnderlineEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = this.editor.t;
    e.model.schema.extend("$text", { allowAttributes: Ii }), e.model.schema.setAttributeProperties(Ii, {
      isFormatting: !0,
      copyOnEnter: !0
    }), e.conversion.attributeToElement({
      model: Ii,
      view: "u",
      upcastAlso: {
        styles: {
          "text-decoration": "underline"
        }
      }
    }), e.commands.add(Ii, new kn(e, Ii)), e.keystrokes.set("CTRL+U", "underline"), e.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: t("Underline text"),
          keystroke: "CTRL+U"
        }
      ]
    });
  }
}
const wR = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 18v-1.5h14V18zm2.2-8V3.6c0-.4.4-.6.8-.6.3 0 .7.2.7.6v6.2c0 2 1.3 2.8 3.2 2.8 1.9 0 3.4-.9 3.4-2.9V3.6c0-.3.4-.5.8-.5.3 0 .7.2.7.5V10c0 2.7-2.2 4-4.9 4-2.6 0-4.7-1.2-4.7-4z"/></svg>';
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Zs = "underline";
class _R extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "UnderlineUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.commands.get(Zs), n = e.locale.t, s = Tn({
      editor: e,
      commandName: Zs,
      plugin: this,
      icon: wR,
      label: n("Underline"),
      keystroke: "CTRL+U"
    });
    e.ui.componentFactory.add(Zs, () => {
      const o = s(P);
      return o.set({
        tooltip: !0
      }), o.bind("isOn").to(t, "value"), o;
    }), e.ui.componentFactory.add("menuBar:" + Zs, () => s(de));
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class vR extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [bR, _R];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Underline";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class yR extends V {
  /**
   * Creates an instance of the command.
   *
   * @param editor Editor instance.
   * @param modelElements Names of the element which this command can apply in the model.
   */
  constructor(e, t) {
    super(e), this.modelElements = t;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const e = me(this.editor.model.document.selection.getSelectedBlocks());
    this.value = !!e && this.modelElements.includes(e.name) && e.name, this.isEnabled = !!e && this.modelElements.some((t) => Od(e, t, this.editor.model.schema));
  }
  /**
   * Executes the command. Applies the heading to the selected blocks or, if the first selected
   * block is a heading already, turns selected headings (of this level only) to paragraphs.
   *
   * @param options.value Name of the element which this command will apply in the model.
   * @fires execute
   */
  execute(e) {
    const t = this.editor.model, n = t.document, s = e.value;
    t.change((o) => {
      const r = Array.from(n.selection.getSelectedBlocks()).filter((a) => Od(a, s, t.schema));
      for (const a of r)
        a.is("element", s) || o.rename(a, s);
    });
  }
}
function Od(i, e, t) {
  return t.checkChild(i.parent, e) && !t.isObject(i);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Fd = "paragraph";
class CR extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "HeadingEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), e.config.define("heading", {
      options: [
        { model: "paragraph", title: "Paragraph", class: "ck-heading_paragraph" },
        { model: "heading1", view: "h2", title: "Heading 1", class: "ck-heading_heading1" },
        { model: "heading2", view: "h3", title: "Heading 2", class: "ck-heading_heading2" },
        { model: "heading3", view: "h4", title: "Heading 3", class: "ck-heading_heading3" }
      ]
    });
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ws];
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.config.get("heading.options"), n = [];
    for (const s of t)
      s.model !== "paragraph" && (e.model.schema.register(s.model, {
        inheritAllFrom: "$block"
      }), e.conversion.elementToElement(s), n.push(s.model));
    this._addDefaultH1Conversion(e), e.commands.add("heading", new yR(e, n));
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    const e = this.editor, t = e.commands.get("enter"), n = e.config.get("heading.options");
    t && this.listenTo(t, "afterExecute", (s, o) => {
      const r = e.model.document.selection.getFirstPosition().parent;
      n.some((l) => r.is("element", l.model)) && !r.is("element", Fd) && r.childCount === 0 && o.writer.rename(r, Fd);
    });
  }
  /**
   * Adds default conversion for `h1` -> `heading1` with a low priority.
   *
   * @param editor Editor instance on which to add the `h1` conversion.
   */
  _addDefaultH1Conversion(e) {
    e.conversion.for("upcast").elementToElement({
      model: "heading1",
      view: "h1",
      // With a `low` priority, `paragraph` plugin autoparagraphing mechanism is executed. Make sure
      // this listener is called before it. If not, `h1` will be transformed into a paragraph.
      converterPriority: Ht.low + 1
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function kR(i) {
  const e = i.t, t = {
    Paragraph: e("Paragraph"),
    "Heading 1": e("Heading 1"),
    "Heading 2": e("Heading 2"),
    "Heading 3": e("Heading 3"),
    "Heading 4": e("Heading 4"),
    "Heading 5": e("Heading 5"),
    "Heading 6": e("Heading 6")
  };
  return i.config.get("heading.options").map((n) => {
    const s = t[n.title];
    return s && s != n.title && (n.title = s), n;
  });
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class TR extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "HeadingUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.t, n = kR(e), s = t("Choose heading"), o = t("Heading");
    e.ui.componentFactory.add("heading", (r) => {
      const a = {}, l = new ke(), c = e.commands.get("heading"), u = e.commands.get("paragraph"), d = [c];
      for (const f of n) {
        const m = {
          type: "button",
          model: new $t({
            label: f.title,
            class: f.class,
            role: "menuitemradio",
            withText: !0
          })
        };
        f.model === "paragraph" ? (m.model.bind("isOn").to(u, "value"), m.model.set("commandName", "paragraph"), d.push(u)) : (m.model.bind("isOn").to(c, "value", (p) => p === f.model), m.model.set({
          commandName: "heading",
          commandValue: f.model
        })), l.add(m), a[f.model] = f.title;
      }
      const h = we(r);
      return Kt(h, l, {
        ariaLabel: o,
        role: "menu"
      }), h.buttonView.set({
        ariaLabel: o,
        ariaLabelledBy: void 0,
        isOn: !1,
        withText: !0,
        tooltip: o
      }), h.extendTemplate({
        attributes: {
          class: [
            "ck-heading-dropdown"
          ]
        }
      }), h.bind("isEnabled").toMany(d, "isEnabled", (...f) => f.some((m) => m)), h.buttonView.bind("label").to(c, "value", u, "value", (f, m) => {
        const p = m ? "paragraph" : f;
        return typeof p == "boolean" || !a[p] ? s : a[p];
      }), h.buttonView.bind("ariaLabel").to(c, "value", u, "value", (f, m) => {
        const p = m ? "paragraph" : f;
        return typeof p == "boolean" || !a[p] ? o : `${a[p]}, ${o}`;
      }), this.listenTo(h, "execute", (f) => {
        const { commandName: m, commandValue: p } = f.source;
        e.execute(m, p ? { value: p } : void 0), e.editing.view.focus();
      }), h;
    }), e.ui.componentFactory.add("menuBar:heading", (r) => {
      const a = new Ge(r), l = e.commands.get("heading"), c = e.commands.get("paragraph"), u = [l], d = new oi(r);
      a.set({
        class: "ck-heading-dropdown"
      }), d.set({
        ariaLabel: t("Heading"),
        role: "menu"
      }), a.buttonView.set({
        label: t("Heading")
      }), a.panelView.children.add(d);
      for (const h of n) {
        const f = new fi(r, a), m = new de(r);
        f.children.add(m), d.items.add(f), m.set({
          label: h.title,
          role: "menuitemradio",
          class: h.class
        }), m.bind("ariaChecked").to(m, "isOn"), m.delegate("execute").to(a), m.on("execute", () => {
          const p = h.model === "paragraph" ? "paragraph" : "heading";
          e.execute(p, { value: h.model }), e.editing.view.focus();
        }), h.model === "paragraph" ? (m.bind("isOn").to(c, "value"), u.push(c)) : m.bind("isOn").to(l, "value", (p) => p === h.model);
      }
      return a.bind("isEnabled").toMany(u, "isEnabled", (...h) => h.some((f) => f)), a;
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ER extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [CR, TR];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Heading";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class AR extends rr {
  /**
   * Creates an instance of the {@link module:special-characters/ui/specialcharactersnavigationview~SpecialCharactersNavigationView}
   * class.
   *
   * @param locale The localization services instance.
   * @param groupNames The names of the character groups and their displayed labels.
   */
  constructor(e, t) {
    super(e);
    const n = e.t;
    this.set("class", "ck-special-characters-navigation"), this.groupDropdownView = this._createGroupDropdown(t), this.groupDropdownView.panelPosition = e.uiLanguageDirection === "rtl" ? "se" : "sw", this.label = n("Special characters"), this.children.add(this.groupDropdownView);
  }
  /**
   * Returns the name of the character group currently selected in the {@link #groupDropdownView}.
   */
  get currentGroupName() {
    return this.groupDropdownView.value;
  }
  /**
   * Focuses the character categories dropdown.
   */
  focus() {
    this.groupDropdownView.focus();
  }
  /**
   * Returns a dropdown that allows selecting character groups.
   *
   * @param groupNames The names of the character groups and their displayed labels.
   */
  _createGroupDropdown(e) {
    const t = this.locale, n = t.t, s = we(t), o = this._getCharacterGroupListItemDefinitions(s, e), r = n("Character categories");
    return s.set("value", o.first.model.name), s.buttonView.bind("label").to(s, "value", (a) => e.get(a)), s.buttonView.set({
      isOn: !1,
      withText: !0,
      tooltip: r,
      class: ["ck-dropdown__button_label-width_auto"],
      ariaLabel: r,
      ariaLabelledBy: void 0
    }), s.on("execute", (a) => {
      s.value = a.source.name;
    }), s.delegate("execute").to(this), Kt(s, o, {
      ariaLabel: r,
      role: "menu"
    }), s;
  }
  /**
   * Returns list item definitions to be used in the character group dropdown
   * representing specific character groups.
   *
   * @param dropdown Dropdown view element
   * @param groupNames The names of the character groups and their displayed labels.
   */
  _getCharacterGroupListItemDefinitions(e, t) {
    const n = new ke();
    for (const [s, o] of t) {
      const r = new $t({
        name: s,
        label: o,
        withText: !0,
        role: "menuitemradio"
      });
      r.bind("isOn").to(e, "value", (a) => a === r.name), n.add({ type: "button", model: r });
    }
    return n;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class xR extends T {
  /**
   * Creates an instance of a character grid containing tiles representing special characters.
   *
   * @param locale The localization services instance.
   */
  constructor(e) {
    super(e), this.tiles = this.createCollection(), this.setTemplate({
      tag: "div",
      children: [
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-character-grid__tiles"
            ]
          },
          children: this.tiles
        }
      ],
      attributes: {
        class: [
          "ck",
          "ck-character-grid"
        ]
      }
    }), this.focusTracker = new X(), this.keystrokes = new ie(), Al({
      keystrokeHandler: this.keystrokes,
      focusTracker: this.focusTracker,
      gridItems: this.tiles,
      numberOfColumns: () => E.window.getComputedStyle(this.element.firstChild).getPropertyValue("grid-template-columns").split(" ").length,
      uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
    });
  }
  /**
   * Creates a new tile for the grid.
   *
   * @param character A human-readable character displayed as the label (e.g. "ε").
   * @param name The name of the character (e.g. "greek small letter epsilon").
   */
  createTile(e, t) {
    const n = new P(this.locale);
    return n.set({
      label: e,
      withText: !0,
      class: "ck-character-grid__tile"
    }), n.extendTemplate({
      attributes: {
        title: t
      },
      on: {
        mouseover: n.bindTemplate.to("mouseover"),
        focus: n.bindTemplate.to("focus")
      }
    }), n.on("mouseover", () => {
      this.fire("tileHover", { name: t, character: e });
    }), n.on("focus", () => {
      this.fire("tileFocus", { name: t, character: e });
    }), n.on("execute", () => {
      this.fire("execute", { name: t, character: e });
    }), n;
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    for (const e of this.tiles)
      this.focusTracker.add(e.element);
    this.tiles.on("change", (e, { added: t, removed: n }) => {
      if (t.length > 0)
        for (const s of t)
          this.focusTracker.add(s.element);
      if (n.length > 0)
        for (const s of n)
          this.focusTracker.remove(s.element);
    }), this.keystrokes.listenTo(this.element);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.keystrokes.destroy();
  }
  /**
   * Focuses the first focusable in {@link ~CharacterGridView#tiles}.
   */
  focus() {
    this.tiles.first.focus();
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class IR extends T {
  constructor(e) {
    super(e);
    const t = this.bindTemplate;
    this.set("character", null), this.set("name", null), this.bind("code").to(this, "character", SR), this.setTemplate({
      tag: "div",
      children: [
        {
          tag: "span",
          attributes: {
            class: [
              "ck-character-info__name"
            ]
          },
          children: [
            {
              // Note: ZWSP to prevent vertical collapsing.
              text: t.to("name", (n) => n || "​")
            }
          ]
        },
        {
          tag: "span",
          attributes: {
            class: [
              "ck-character-info__code"
            ]
          },
          children: [
            {
              text: t.to("code")
            }
          ]
        }
      ],
      attributes: {
        class: [
          "ck",
          "ck-character-info"
        ]
      }
    });
  }
}
function SR(i) {
  return i === null ? "" : "U+" + ("0000" + i.codePointAt(0).toString(16)).slice(-4);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class PR extends T {
  /**
   * Creates an instance of the `SpecialCharactersView`.
   */
  constructor(e, t, n, s) {
    super(e), this.navigationView = t, this.gridView = n, this.infoView = s, this.items = this.createCollection(), this.focusTracker = new X(), this.keystrokes = new ie(), this._focusCycler = new ge({
      focusables: this.items,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        focusPrevious: "shift + tab",
        focusNext: "tab"
      }
    }), this.setTemplate({
      tag: "div",
      children: [
        this.navigationView,
        this.gridView,
        this.infoView
      ],
      attributes: {
        // Avoid focus loss when the user clicks the area of the grid that is not a button.
        // https://github.com/ckeditor/ckeditor5/pull/12319#issuecomment-1231779819
        tabindex: "-1"
      }
    }), this.items.add(this.navigationView.groupDropdownView.buttonView), this.items.add(this.gridView);
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.focusTracker.add(this.navigationView.groupDropdownView.buttonView.element), this.focusTracker.add(this.gridView.element), this.keystrokes.listenTo(this.element);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  /**
   * Focuses the first focusable in {@link #items}.
   */
  focus() {
    this.navigationView.focus();
  }
}
const RR = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2.5a7.47 7.47 0 0 1 4.231 1.31 7.268 7.268 0 0 1 2.703 3.454 7.128 7.128 0 0 1 .199 4.353c-.39 1.436-1.475 2.72-2.633 3.677h2.013c0-.226.092-.443.254-.603a.876.876 0 0 1 1.229 0c.163.16.254.377.254.603v.853c0 .209-.078.41-.22.567a.873.873 0 0 1-.547.28l-.101.006h-4.695a.517.517 0 0 1-.516-.518v-1.265c0-.21.128-.398.317-.489a5.601 5.601 0 0 0 2.492-2.371 5.459 5.459 0 0 0 .552-3.693 5.53 5.53 0 0 0-1.955-3.2A5.71 5.71 0 0 0 10 4.206 5.708 5.708 0 0 0 6.419 5.46 5.527 5.527 0 0 0 4.46 8.663a5.457 5.457 0 0 0 .554 3.695 5.6 5.6 0 0 0 2.497 2.37.55.55 0 0 1 .317.49v1.264c0 .286-.23.518-.516.518H2.618a.877.877 0 0 1-.614-.25.845.845 0 0 1-.254-.603v-.853c0-.226.091-.443.254-.603a.876.876 0 0 1 1.228 0c.163.16.255.377.255.603h1.925c-1.158-.958-2.155-2.241-2.545-3.678a7.128 7.128 0 0 1 .199-4.352 7.268 7.268 0 0 1 2.703-3.455A7.475 7.475 0 0 1 10 2.5z"/></svg>';
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const zr = "All";
class VR extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [mg];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "SpecialCharacters";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e);
    const t = e.t;
    this._characters = /* @__PURE__ */ new Map(), this._groups = /* @__PURE__ */ new Map(), this._allSpecialCharactersGroupLabel = t("All");
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.t, n = e.commands.get("insertText");
    e.ui.componentFactory.add("specialCharacters", (s) => {
      const o = we(s);
      let r;
      return o.buttonView.set({
        label: t("Special characters"),
        icon: RR,
        tooltip: !0
      }), o.bind("isEnabled").to(n), o.on("execute", (a, l) => {
        e.execute("insertText", { text: l.character }), e.editing.view.focus();
      }), o.on("change:isOpen", () => {
        if (!r) {
          r = this._createDropdownPanelContent(s, o);
          const a = new PR(s, r.navigationView, r.gridView, r.infoView);
          o.panelView.children.add(a);
        }
        r.infoView.set({
          character: null,
          name: null
        });
      }), o;
    });
  }
  /**
   * Adds a collection of special characters to the specified group. The title of a special character must be unique.
   *
   * **Note:** The "All" category name is reserved by the plugin and cannot be used as a new name for a special
   * characters category.
   */
  addItems(e, t, n = { label: e }) {
    if (e === zr)
      throw new g("special-character-invalid-group-name", null);
    const s = this._getGroup(e, n.label);
    for (const o of t)
      s.items.add(o.title), this._characters.set(o.title, o.character);
  }
  /**
   * Returns special character groups in an order determined based on configuration and registration sequence.
   */
  getGroups() {
    const e = Array.from(this._groups.keys()), t = this.editor.config.get("specialCharacters.order") || [], n = t.find((s) => !e.includes(s));
    if (n)
      throw new g("special-character-invalid-order-group-name", null, { invalidGroup: n });
    return /* @__PURE__ */ new Set([
      ...t,
      ...e
    ]);
  }
  /**
   * Returns a collection of special characters symbol names (titles).
   */
  getCharactersForGroup(e) {
    if (e === zr)
      return new Set(this._characters.keys());
    const t = this._groups.get(e);
    if (t)
      return t.items;
  }
  /**
   * Returns the symbol of a special character for the specified name. If the special character could not be found, `undefined`
   * is returned.
   *
   * @param title The title of a special character.
   */
  getCharacter(e) {
    return this._characters.get(e);
  }
  /**
   * Returns a group of special characters. If the group with the specified name does not exist, it will be created.
   *
   * @param groupName The name of the group to create.
   * @param label The label describing the new group.
   */
  _getGroup(e, t) {
    return this._groups.has(e) || this._groups.set(e, {
      items: /* @__PURE__ */ new Set(),
      label: t
    }), this._groups.get(e);
  }
  /**
   * Updates the symbol grid depending on the currently selected character group.
   */
  _updateGrid(e, t) {
    t.tiles.clear();
    const n = this.getCharactersForGroup(e);
    for (const s of n) {
      const o = this.getCharacter(s);
      t.tiles.add(t.createTile(o, s));
    }
  }
  /**
   * Initializes the dropdown, used for lazy loading.
   *
   * @returns An object with `navigationView`, `gridView` and `infoView` properties, containing UI parts.
   */
  _createDropdownPanelContent(e, t) {
    const n = Array.from(this.getGroups()).map((l) => [l, this._groups.get(l).label]), s = new Map([
      // Add a special group that shows all available special characters.
      [zr, this._allSpecialCharactersGroupLabel],
      ...n
    ]), o = new AR(e, s), r = new xR(e), a = new IR(e);
    return r.delegate("execute").to(t), r.on("tileHover", (l, c) => {
      a.set(c);
    }), r.on("tileFocus", (l, c) => {
      a.set(c);
    }), o.on("execute", () => {
      this._updateGrid(o.currentGroupName, r);
    }), this._updateGrid(o.currentGroupName, r), { navigationView: o, gridView: r, infoView: a };
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class gp extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "SpecialCharactersArrows";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.t;
    e.plugins.get("SpecialCharacters").addItems("Arrows", [
      { title: t("leftwards simple arrow"), character: "←" },
      { title: t("rightwards simple arrow"), character: "→" },
      { title: t("upwards simple arrow"), character: "↑" },
      { title: t("downwards simple arrow"), character: "↓" },
      { title: t("leftwards double arrow"), character: "⇐" },
      { title: t("rightwards double arrow"), character: "⇒" },
      { title: t("upwards double arrow"), character: "⇑" },
      { title: t("downwards double arrow"), character: "⇓" },
      { title: t("leftwards dashed arrow"), character: "⇠" },
      { title: t("rightwards dashed arrow"), character: "⇢" },
      { title: t("upwards dashed arrow"), character: "⇡" },
      { title: t("downwards dashed arrow"), character: "⇣" },
      { title: t("leftwards arrow to bar"), character: "⇤" },
      { title: t("rightwards arrow to bar"), character: "⇥" },
      { title: t("upwards arrow to bar"), character: "⤒" },
      { title: t("downwards arrow to bar"), character: "⤓" },
      { title: t("up down arrow with base"), character: "↨" },
      { title: t("back with leftwards arrow above"), character: "🔙" },
      { title: t("end with leftwards arrow above"), character: "🔚" },
      { title: t("on with exclamation mark with left right arrow above"), character: "🔛" },
      { title: t("soon with rightwards arrow above"), character: "🔜" },
      { title: t("top with upwards arrow above"), character: "🔝" }
    ], { label: t("Arrows") });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class pp extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "SpecialCharactersText";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.t;
    e.plugins.get("SpecialCharacters").addItems("Text", [
      { character: "‹", title: t("Single left-pointing angle quotation mark") },
      { character: "›", title: t("Single right-pointing angle quotation mark") },
      { character: "«", title: t("Left-pointing double angle quotation mark") },
      { character: "»", title: t("Right-pointing double angle quotation mark") },
      { character: "‘", title: t("Left single quotation mark") },
      { character: "’", title: t("Right single quotation mark") },
      { character: "“", title: t("Left double quotation mark") },
      { character: "”", title: t("Right double quotation mark") },
      { character: "‚", title: t("Single low-9 quotation mark") },
      { character: "„", title: t("Double low-9 quotation mark") },
      { character: "¡", title: t("Inverted exclamation mark") },
      { character: "¿", title: t("Inverted question mark") },
      { character: "‥", title: t("Two dot leader") },
      { character: "…", title: t("Horizontal ellipsis") },
      { character: "‡", title: t("Double dagger") },
      { character: "‰", title: t("Per mille sign") },
      { character: "‱", title: t("Per ten thousand sign") },
      { character: "‼", title: t("Double exclamation mark") },
      { character: "⁈", title: t("Question exclamation mark") },
      { character: "⁉", title: t("Exclamation question mark") },
      { character: "⁇", title: t("Double question mark") },
      { character: "©", title: t("Copyright sign") },
      { character: "®", title: t("Registered sign") },
      { character: "™", title: t("Trade mark sign") },
      { character: "§", title: t("Section sign") },
      { character: "¶", title: t("Paragraph sign") },
      { character: "⁋", title: t("Reversed paragraph sign") }
    ], { label: t("Text") });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class bp extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "SpecialCharactersMathematical";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.t;
    e.plugins.get("SpecialCharacters").addItems("Mathematical", [
      { character: "<", title: t("Less-than sign") },
      { character: ">", title: t("Greater-than sign") },
      { character: "≤", title: t("Less-than or equal to") },
      { character: "≥", title: t("Greater-than or equal to") },
      { character: "–", title: t("En dash") },
      { character: "—", title: t("Em dash") },
      { character: "¯", title: t("Macron") },
      { character: "‾", title: t("Overline") },
      { character: "°", title: t("Degree sign") },
      { character: "−", title: t("Minus sign") },
      { character: "±", title: t("Plus-minus sign") },
      { character: "÷", title: t("Division sign") },
      { character: "⁄", title: t("Fraction slash") },
      { character: "×", title: t("Multiplication sign") },
      { character: "ƒ", title: t("Latin small letter f with hook") },
      { character: "∫", title: t("Integral") },
      { character: "∑", title: t("N-ary summation") },
      { character: "∞", title: t("Infinity") },
      { character: "√", title: t("Square root") },
      { character: "∼", title: t("Tilde operator") },
      { character: "≅", title: t("Approximately equal to") },
      { character: "≈", title: t("Almost equal to") },
      { character: "≠", title: t("Not equal to") },
      { character: "≡", title: t("Identical to") },
      { character: "∈", title: t("Element of") },
      { character: "∉", title: t("Not an element of") },
      { character: "∋", title: t("Contains as member") },
      { character: "∏", title: t("N-ary product") },
      { character: "∧", title: t("Logical and") },
      { character: "∨", title: t("Logical or") },
      { character: "¬", title: t("Not sign") },
      { character: "∩", title: t("Intersection") },
      { character: "∪", title: t("Union") },
      { character: "∂", title: t("Partial differential") },
      { character: "∀", title: t("For all") },
      { character: "∃", title: t("There exists") },
      { character: "∅", title: t("Empty set") },
      { character: "∇", title: t("Nabla") },
      { character: "∗", title: t("Asterisk operator") },
      { character: "∝", title: t("Proportional to") },
      { character: "∠", title: t("Angle") },
      { character: "¼", title: t("Vulgar fraction one quarter") },
      { character: "½", title: t("Vulgar fraction one half") },
      { character: "¾", title: t("Vulgar fraction three quarters") }
    ], { label: t("Mathematical") });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class wp extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "SpecialCharactersLatin";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.t;
    e.plugins.get("SpecialCharacters").addItems("Latin", [
      { character: "Ā", title: t("Latin capital letter a with macron") },
      { character: "ā", title: t("Latin small letter a with macron") },
      { character: "Ă", title: t("Latin capital letter a with breve") },
      { character: "ă", title: t("Latin small letter a with breve") },
      { character: "Ą", title: t("Latin capital letter a with ogonek") },
      { character: "ą", title: t("Latin small letter a with ogonek") },
      { character: "Ć", title: t("Latin capital letter c with acute") },
      { character: "ć", title: t("Latin small letter c with acute") },
      { character: "Ĉ", title: t("Latin capital letter c with circumflex") },
      { character: "ĉ", title: t("Latin small letter c with circumflex") },
      { character: "Ċ", title: t("Latin capital letter c with dot above") },
      { character: "ċ", title: t("Latin small letter c with dot above") },
      { character: "Č", title: t("Latin capital letter c with caron") },
      { character: "č", title: t("Latin small letter c with caron") },
      { character: "Ď", title: t("Latin capital letter d with caron") },
      { character: "ď", title: t("Latin small letter d with caron") },
      { character: "Đ", title: t("Latin capital letter d with stroke") },
      { character: "đ", title: t("Latin small letter d with stroke") },
      { character: "Ē", title: t("Latin capital letter e with macron") },
      { character: "ē", title: t("Latin small letter e with macron") },
      { character: "Ĕ", title: t("Latin capital letter e with breve") },
      { character: "ĕ", title: t("Latin small letter e with breve") },
      { character: "Ė", title: t("Latin capital letter e with dot above") },
      { character: "ė", title: t("Latin small letter e with dot above") },
      { character: "Ę", title: t("Latin capital letter e with ogonek") },
      { character: "ę", title: t("Latin small letter e with ogonek") },
      { character: "Ě", title: t("Latin capital letter e with caron") },
      { character: "ě", title: t("Latin small letter e with caron") },
      { character: "Ĝ", title: t("Latin capital letter g with circumflex") },
      { character: "ĝ", title: t("Latin small letter g with circumflex") },
      { character: "Ğ", title: t("Latin capital letter g with breve") },
      { character: "ğ", title: t("Latin small letter g with breve") },
      { character: "Ġ", title: t("Latin capital letter g with dot above") },
      { character: "ġ", title: t("Latin small letter g with dot above") },
      { character: "Ģ", title: t("Latin capital letter g with cedilla") },
      { character: "ģ", title: t("Latin small letter g with cedilla") },
      { character: "Ĥ", title: t("Latin capital letter h with circumflex") },
      { character: "ĥ", title: t("Latin small letter h with circumflex") },
      { character: "Ħ", title: t("Latin capital letter h with stroke") },
      { character: "ħ", title: t("Latin small letter h with stroke") },
      { character: "Ĩ", title: t("Latin capital letter i with tilde") },
      { character: "ĩ", title: t("Latin small letter i with tilde") },
      { character: "Ī", title: t("Latin capital letter i with macron") },
      { character: "ī", title: t("Latin small letter i with macron") },
      { character: "Ĭ", title: t("Latin capital letter i with breve") },
      { character: "ĭ", title: t("Latin small letter i with breve") },
      { character: "Į", title: t("Latin capital letter i with ogonek") },
      { character: "į", title: t("Latin small letter i with ogonek") },
      { character: "İ", title: t("Latin capital letter i with dot above") },
      { character: "ı", title: t("Latin small letter dotless i") },
      { character: "Ĳ", title: t("Latin capital ligature ij") },
      { character: "ĳ", title: t("Latin small ligature ij") },
      { character: "Ĵ", title: t("Latin capital letter j with circumflex") },
      { character: "ĵ", title: t("Latin small letter j with circumflex") },
      { character: "Ķ", title: t("Latin capital letter k with cedilla") },
      { character: "ķ", title: t("Latin small letter k with cedilla") },
      { character: "ĸ", title: t("Latin small letter kra") },
      { character: "Ĺ", title: t("Latin capital letter l with acute") },
      { character: "ĺ", title: t("Latin small letter l with acute") },
      { character: "Ļ", title: t("Latin capital letter l with cedilla") },
      { character: "ļ", title: t("Latin small letter l with cedilla") },
      { character: "Ľ", title: t("Latin capital letter l with caron") },
      { character: "ľ", title: t("Latin small letter l with caron") },
      { character: "Ŀ", title: t("Latin capital letter l with middle dot") },
      { character: "ŀ", title: t("Latin small letter l with middle dot") },
      { character: "Ł", title: t("Latin capital letter l with stroke") },
      { character: "ł", title: t("Latin small letter l with stroke") },
      { character: "Ń", title: t("Latin capital letter n with acute") },
      { character: "ń", title: t("Latin small letter n with acute") },
      { character: "Ņ", title: t("Latin capital letter n with cedilla") },
      { character: "ņ", title: t("Latin small letter n with cedilla") },
      { character: "Ň", title: t("Latin capital letter n with caron") },
      { character: "ň", title: t("Latin small letter n with caron") },
      { character: "ŉ", title: t("Latin small letter n preceded by apostrophe") },
      { character: "Ŋ", title: t("Latin capital letter eng") },
      { character: "ŋ", title: t("Latin small letter eng") },
      { character: "Ō", title: t("Latin capital letter o with macron") },
      { character: "ō", title: t("Latin small letter o with macron") },
      { character: "Ŏ", title: t("Latin capital letter o with breve") },
      { character: "ŏ", title: t("Latin small letter o with breve") },
      { character: "Ő", title: t("Latin capital letter o with double acute") },
      { character: "ő", title: t("Latin small letter o with double acute") },
      { character: "Œ", title: t("Latin capital ligature oe") },
      { character: "œ", title: t("Latin small ligature oe") },
      { character: "Ŕ", title: t("Latin capital letter r with acute") },
      { character: "ŕ", title: t("Latin small letter r with acute") },
      { character: "Ŗ", title: t("Latin capital letter r with cedilla") },
      { character: "ŗ", title: t("Latin small letter r with cedilla") },
      { character: "Ř", title: t("Latin capital letter r with caron") },
      { character: "ř", title: t("Latin small letter r with caron") },
      { character: "Ś", title: t("Latin capital letter s with acute") },
      { character: "ś", title: t("Latin small letter s with acute") },
      { character: "Ŝ", title: t("Latin capital letter s with circumflex") },
      { character: "ŝ", title: t("Latin small letter s with circumflex") },
      { character: "Ş", title: t("Latin capital letter s with cedilla") },
      { character: "ş", title: t("Latin small letter s with cedilla") },
      { character: "Š", title: t("Latin capital letter s with caron") },
      { character: "š", title: t("Latin small letter s with caron") },
      { character: "Ţ", title: t("Latin capital letter t with cedilla") },
      { character: "ţ", title: t("Latin small letter t with cedilla") },
      { character: "Ť", title: t("Latin capital letter t with caron") },
      { character: "ť", title: t("Latin small letter t with caron") },
      { character: "Ŧ", title: t("Latin capital letter t with stroke") },
      { character: "ŧ", title: t("Latin small letter t with stroke") },
      { character: "Ũ", title: t("Latin capital letter u with tilde") },
      { character: "ũ", title: t("Latin small letter u with tilde") },
      { character: "Ū", title: t("Latin capital letter u with macron") },
      { character: "ū", title: t("Latin small letter u with macron") },
      { character: "Ŭ", title: t("Latin capital letter u with breve") },
      { character: "ŭ", title: t("Latin small letter u with breve") },
      { character: "Ů", title: t("Latin capital letter u with ring above") },
      { character: "ů", title: t("Latin small letter u with ring above") },
      { character: "Ű", title: t("Latin capital letter u with double acute") },
      { character: "ű", title: t("Latin small letter u with double acute") },
      { character: "Ų", title: t("Latin capital letter u with ogonek") },
      { character: "ų", title: t("Latin small letter u with ogonek") },
      { character: "Ŵ", title: t("Latin capital letter w with circumflex") },
      { character: "ŵ", title: t("Latin small letter w with circumflex") },
      { character: "Ŷ", title: t("Latin capital letter y with circumflex") },
      { character: "ŷ", title: t("Latin small letter y with circumflex") },
      { character: "Ÿ", title: t("Latin capital letter y with diaeresis") },
      { character: "Ź", title: t("Latin capital letter z with acute") },
      { character: "ź", title: t("Latin small letter z with acute") },
      { character: "Ż", title: t("Latin capital letter z with dot above") },
      { character: "ż", title: t("Latin small letter z with dot above") },
      { character: "Ž", title: t("Latin capital letter z with caron") },
      { character: "ž", title: t("Latin small letter z with caron") },
      { character: "ſ", title: t("Latin small letter long s") }
    ], { label: t("Latin") });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class _p extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "SpecialCharactersCurrency";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.t;
    e.plugins.get("SpecialCharacters").addItems("Currency", [
      { character: "$", title: t("Dollar sign") },
      { character: "€", title: t("Euro sign") },
      { character: "¥", title: t("Yen sign") },
      { character: "£", title: t("Pound sign") },
      { character: "¢", title: t("Cent sign") },
      { character: "₠", title: t("Euro-currency sign") },
      { character: "₡", title: t("Colon sign") },
      { character: "₢", title: t("Cruzeiro sign") },
      { character: "₣", title: t("French franc sign") },
      { character: "₤", title: t("Lira sign") },
      { character: "¤", title: t("Currency sign") },
      { character: "₿", title: t("Bitcoin sign") },
      { character: "₥", title: t("Mill sign") },
      { character: "₦", title: t("Naira sign") },
      { character: "₧", title: t("Peseta sign") },
      { character: "₨", title: t("Rupee sign") },
      { character: "₩", title: t("Won sign") },
      { character: "₪", title: t("New sheqel sign") },
      { character: "₫", title: t("Dong sign") },
      { character: "₭", title: t("Kip sign") },
      { character: "₮", title: t("Tugrik sign") },
      { character: "₯", title: t("Drachma sign") },
      { character: "₰", title: t("German penny sign") },
      { character: "₱", title: t("Peso sign") },
      { character: "₲", title: t("Guarani sign") },
      { character: "₳", title: t("Austral sign") },
      { character: "₴", title: t("Hryvnia sign") },
      { character: "₵", title: t("Cedi sign") },
      { character: "₶", title: t("Livre tournois sign") },
      { character: "₷", title: t("Spesmilo sign") },
      { character: "₸", title: t("Tenge sign") },
      { character: "₹", title: t("Indian rupee sign") },
      { character: "₺", title: t("Turkish lira sign") },
      { character: "₻", title: t("Nordic mark sign") },
      { character: "₼", title: t("Manat sign") },
      { character: "₽", title: t("Ruble sign") }
    ], { label: t("Currency") });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class MR extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "SpecialCharactersEssentials";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [
      _p,
      pp,
      bp,
      gp,
      wp
    ];
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Je {
  /**
   * Creates a document list iterator.
   *
   * @param startElement The start list item block element.
   * @param options.direction The iterating direction.
   * @param options.includeSelf Whether start block should be included in the result (if it's matching other criteria).
   * @param options.sameAttributes Additional attributes that must be the same for each block.
   * @param options.sameIndent Whether blocks with the same indent level as the start block should be included
   * in the result.
   * @param options.lowerIndent Whether blocks with a lower indent level than the start block should be included
   * in the result.
   * @param options.higherIndent Whether blocks with a higher indent level than the start block should be included
   * in the result.
   */
  constructor(e, t) {
    this._startElement = e, this._referenceIndent = e.getAttribute("listIndent"), this._isForward = t.direction == "forward", this._includeSelf = !!t.includeSelf, this._sameAttributes = Z(t.sameAttributes || []), this._sameIndent = !!t.sameIndent, this._lowerIndent = !!t.lowerIndent, this._higherIndent = !!t.higherIndent;
  }
  /**
   * Performs only first step of iteration and returns the result.
   *
   * @param startElement The start list item block element.
   * @param options.direction The iterating direction.
   * @param options.includeSelf Whether start block should be included in the result (if it's matching other criteria).
   * @param options.sameAttributes Additional attributes that must be the same for each block.
   * @param options.sameIndent Whether blocks with the same indent level as the start block should be included
   * in the result.
   * @param options.lowerIndent Whether blocks with a lower indent level than the start block should be included
   * in the result.
   * @param options.higherIndent Whether blocks with a higher indent level than the start block should be included
   * in the result.
   */
  static first(e, t) {
    const s = new this(e, t)[Symbol.iterator]();
    return me(s);
  }
  /**
   * Iterable interface.
   */
  *[Symbol.iterator]() {
    const e = [];
    for (const { node: t } of _s(this._getStartNode(), this._isForward ? "forward" : "backward")) {
      const n = t.getAttribute("listIndent");
      if (n < this._referenceIndent) {
        if (!this._lowerIndent)
          break;
        this._referenceIndent = n;
      } else if (n > this._referenceIndent) {
        if (!this._higherIndent)
          continue;
        if (!this._isForward) {
          e.push(t);
          continue;
        }
      } else {
        if (!this._sameIndent) {
          if (this._higherIndent) {
            e.length && (yield* e, e.length = 0);
            break;
          }
          continue;
        }
        if (this._sameAttributes.some((s) => t.getAttribute(s) !== this._startElement.getAttribute(s)))
          break;
      }
      e.length && (yield* e, e.length = 0), yield t;
    }
  }
  /**
   * Returns the model element to start iterating.
   */
  _getStartNode() {
    return this._includeSelf ? this._startElement : this._isForward ? this._startElement.nextSibling : this._startElement.previousSibling;
  }
}
function* _s(i, e = "forward") {
  const t = e == "forward", n = [];
  let s = null;
  for (; fe(i); ) {
    let o = null;
    if (s) {
      const r = i.getAttribute("listIndent"), a = s.getAttribute("listIndent");
      r > a ? n[a] = s : r < a ? (o = n[r], n.length = r) : o = s;
    }
    yield { node: i, previous: s, previousNodeInList: o }, s = i, i = t ? i.nextSibling : i.previousSibling;
  }
}
class BR {
  /**
   * @param listHead The head element of a list.
   */
  constructor(e) {
    this._listHead = e;
  }
  /**
   * List blocks iterator.
   *
   * Iterates over all blocks of a list.
   */
  [Symbol.iterator]() {
    return _s(this._listHead, "forward");
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ri {
  /**
   * Returns the next ID.
   *
   * @internal
   */
  /* istanbul ignore next: static function definition -- @preserve */
  static next() {
    return je();
  }
}
function fe(i) {
  return !!i && i.is("element") && i.hasAttribute("listItemId");
}
function Hl(i, e = {}) {
  return [
    ...Wt(i, { ...e, direction: "backward" }),
    ...Wt(i, { ...e, direction: "forward" })
  ];
}
function Wt(i, e = {}) {
  const t = e.direction == "forward", n = Array.from(new Je(i, {
    ...e,
    includeSelf: t,
    sameIndent: !0,
    sameAttributes: "listItemId"
  }));
  return t ? n : n.reverse();
}
function LR(i) {
  return Array.from(new Je(i, {
    direction: "forward",
    higherIndent: !0
  }));
}
function vp(i, e) {
  const t = new Je(i, {
    sameIndent: !0,
    sameAttributes: "listType",
    ...e
  }), n = new Je(i, {
    sameIndent: !0,
    sameAttributes: "listType",
    includeSelf: !0,
    direction: "forward",
    ...e
  });
  return [
    ...Array.from(t).reverse(),
    ...n
  ];
}
function gn(i) {
  return !Je.first(i, {
    sameIndent: !0,
    sameAttributes: "listItemId"
  });
}
function Nd(i) {
  return !Je.first(i, {
    direction: "forward",
    sameIndent: !0,
    sameAttributes: "listItemId"
  });
}
function vs(i, e = {}) {
  i = Z(i);
  const t = e.withNested !== !1, n = /* @__PURE__ */ new Set();
  for (const s of i)
    for (const o of Hl(s, { higherIndent: t }))
      n.add(o);
  return En(n);
}
function OR(i) {
  i = Z(i);
  const e = /* @__PURE__ */ new Set();
  for (const t of i)
    for (const n of vp(t))
      e.add(n);
  return En(e);
}
function Ul(i, e) {
  const t = Wt(i, { direction: "forward" }), n = ri.next();
  for (const s of t)
    e.setAttribute("listItemId", n, s);
  return t;
}
function Ta(i, e, t) {
  const n = {};
  for (const [o, r] of e.getAttributes())
    o.startsWith("list") && (n[o] = r);
  const s = Wt(i, { direction: "forward" });
  for (const o of s)
    t.setAttributes(n, o);
  return s;
}
function Ea(i, e, { expand: t, indentBy: n = 1 } = {}) {
  i = Z(i);
  const s = t ? vs(i) : i;
  for (const o of s) {
    const r = o.getAttribute("listIndent") + n;
    r < 0 ? ur(o, e) : e.setAttribute("listIndent", r, o);
  }
  return s;
}
function FR(i, e) {
  i = Z(i);
  const t = vs(i), n = /* @__PURE__ */ new Set(), s = Math.min(...t.map((r) => r.getAttribute("listIndent"))), o = /* @__PURE__ */ new Map();
  for (const r of t)
    o.set(r, Je.first(r, { lowerIndent: !0 }));
  for (const r of t) {
    if (n.has(r))
      continue;
    n.add(r);
    const a = r.getAttribute("listIndent") - 1;
    if (a < 0) {
      ur(r, e);
      continue;
    }
    if (r.getAttribute("listIndent") == s) {
      const l = zR(r, o.get(r), e);
      for (const c of l)
        n.add(c);
      if (l.length)
        continue;
    }
    e.setAttribute("listIndent", a, r);
  }
  return En(n);
}
function ur(i, e) {
  i = Z(i);
  for (const t of i)
    t.is("element", "listItem") && e.rename(t, "paragraph");
  for (const t of i)
    for (const n of t.getAttributeKeys())
      n.startsWith("list") && e.removeAttribute(n, t);
  return i;
}
function cs(i) {
  if (!i.length)
    return !1;
  const e = i[0].getAttribute("listItemId");
  return e ? !i.some((t) => t.getAttribute("listItemId") != e) : !1;
}
function NR(i, e) {
  const t = [];
  let n = Number.POSITIVE_INFINITY;
  for (const { node: s } of _s(i.nextSibling, "forward")) {
    const o = s.getAttribute("listIndent");
    if (o == 0)
      break;
    o < n && (n = o);
    const r = o - n;
    e.setAttribute("listIndent", r, s), t.push(s);
  }
  return t;
}
function En(i) {
  return Array.from(i).filter((e) => e.root.rootName !== "$graveyard").sort((e, t) => e.index - t.index);
}
function us(i) {
  const e = i.document.selection.getSelectedElement();
  return e && i.schema.isObject(e) && i.schema.isBlock(e) ? e : null;
}
function Hr(i, e) {
  return e.checkChild(i.parent, "listItem") && e.checkChild(i, "$text") && !e.isObject(i);
}
function DR(i) {
  return i == "numbered" || i == "customNumbered";
}
function zR(i, e, t) {
  return Wt(e, { direction: "forward" }).pop().index > i.index ? Ta(i, e, t) : [];
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Dd extends V {
  /**
   * Creates an instance of the command.
   *
   * @param editor The editor instance.
   * @param indentDirection The direction of indent. If it is equal to `backward`, the command
   * will outdent a list item.
   */
  constructor(e, t) {
    super(e), this._direction = t;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    this.isEnabled = this._checkEnabled();
  }
  /**
   * Indents or outdents (depending on the {@link #constructor}'s `indentDirection` parameter) selected list items.
   *
   * @fires execute
   * @fires afterExecute
   */
  execute() {
    const e = this.editor.model, t = zd(e.document.selection);
    e.change((n) => {
      const s = [];
      cs(t) && !gn(t[0]) ? (this._direction == "forward" && s.push(...Ea(t, n)), s.push(...Ul(t[0], n))) : this._direction == "forward" ? s.push(...Ea(t, n, { expand: !0 })) : s.push(...FR(t, n));
      for (const o of s) {
        if (!o.hasAttribute("listType"))
          continue;
        const r = Je.first(o, { sameIndent: !0 });
        r && n.setAttribute("listType", r.getAttribute("listType"), o);
      }
      this._fireAfterExecute(s);
    });
  }
  /**
   * Fires the `afterExecute` event.
   *
   * @param changedBlocks The changed list elements.
   */
  _fireAfterExecute(e) {
    this.fire("afterExecute", En(new Set(e)));
  }
  /**
   * Checks whether the command can be enabled in the current context.
   *
   * @returns Whether the command should be enabled.
   */
  _checkEnabled() {
    let e = zd(this.editor.model.document.selection), t = e[0];
    if (!t)
      return !1;
    if (this._direction == "backward" || cs(e) && !gn(e[0]))
      return !0;
    e = vs(e), t = e[0];
    const n = Je.first(t, { sameIndent: !0 });
    return n ? n.getAttribute("listType") == t.getAttribute("listType") : !1;
  }
}
function zd(i) {
  const e = Array.from(i.getSelectedBlocks()), t = e.findIndex((n) => !fe(n));
  return t != -1 && (e.length = t), e;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Js extends V {
  /**
   * Creates an instance of the command.
   *
   * @param editor The editor instance.
   * @param type List type that will be handled by this command.
   */
  constructor(e, t, n = {}) {
    super(e), this.type = t, this._listWalkerOptions = n.multiLevel ? {
      higherIndent: !0,
      lowerIndent: !0,
      sameAttributes: []
    } : void 0;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    this.value = this._getValue(), this.isEnabled = this._checkEnabled();
  }
  /**
   * Executes the list command.
   *
   * @fires execute
   * @fires afterExecute
   * @param options Command options.
   * @param options.forceValue If set, it will force the command behavior. If `true`, the command will try to convert the
   * selected items and potentially the neighbor elements to the proper list items. If set to `false` it will convert selected elements
   * to paragraphs. If not set, the command will toggle selected elements to list items or paragraphs, depending on the selection.
   * @param options.additionalAttributes Additional attributes that are set for list items when the command is executed.
   */
  execute(e = {}) {
    const t = this.editor.model, n = t.document, s = us(t), o = Array.from(n.selection.getSelectedBlocks()).filter((a) => t.schema.checkAttribute(a, "listType") || Hr(a, t.schema)), r = e.forceValue !== void 0 ? !e.forceValue : this.value;
    t.change((a) => {
      if (r) {
        const l = o[o.length - 1], c = Wt(l, { direction: "forward" }), u = [];
        c.length > 1 && u.push(...Ul(c[1], a)), u.push(...ur(o, a)), u.push(...NR(l, a)), this._fireAfterExecute(u);
      } else if ((s || n.selection.isCollapsed) && fe(o[0])) {
        const l = vp(s || o[0], this._listWalkerOptions);
        for (const c of l)
          a.setAttributes({
            ...e.additionalAttributes,
            listType: this.type
          }, c);
        this._fireAfterExecute(l);
      } else {
        const l = [];
        for (const c of o)
          if (!c.hasAttribute("listType"))
            !c.is("element", "listItem") && Hr(c, t.schema) && a.rename(c, "listItem"), a.setAttributes({
              ...e.additionalAttributes,
              listIndent: 0,
              listItemId: ri.next(),
              listType: this.type
            }, c), l.push(c);
          else
            for (const u of vs(c, { withNested: !1 }))
              u.getAttribute("listType") != this.type && (a.setAttributes({
                ...e.additionalAttributes,
                listType: this.type
              }, u), l.push(u));
        this._fireAfterExecute(l);
      }
    });
  }
  /**
   * Fires the `afterExecute` event.
   *
   * @param changedBlocks The changed list elements.
   */
  _fireAfterExecute(e) {
    this.fire("afterExecute", En(new Set(e)));
  }
  /**
   * Checks the command's {@link #value}.
   *
   * @returns The current value.
   */
  _getValue() {
    const e = this.editor.model.document.selection, t = Array.from(e.getSelectedBlocks());
    if (!t.length)
      return !1;
    for (const n of t)
      if (n.getAttribute("listType") != this.type)
        return !1;
    return !0;
  }
  /**
   * Checks whether the command can be enabled in the current context.
   *
   * @returns Whether the command should be enabled.
   */
  _checkEnabled() {
    const e = this.editor.model, t = e.schema, n = e.document.selection, s = Array.from(n.getSelectedBlocks());
    if (!s.length)
      return !1;
    if (this.value)
      return !0;
    for (const o of s)
      if (t.checkAttribute(o, "listType") || Hr(o, t))
        return !0;
    return !1;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Hd extends V {
  /**
   * Creates an instance of the command.
   *
   * @param editor The editor instance.
   * @param direction Whether list item should be merged before or after the selected block.
   */
  constructor(e, t) {
    super(e), this._direction = t;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    this.isEnabled = this._checkEnabled();
  }
  /**
   * Merges list blocks together (depending on the {@link #constructor}'s `direction` parameter).
   *
   * @fires execute
   * @fires afterExecute
   * @param options Command options.
   * @param options.shouldMergeOnBlocksContentLevel When set `true`, merging will be performed together
   * with {@link module:engine/model/model~Model#deleteContent} to get rid of the inline content in the selection or take advantage
   * of the heuristics in `deleteContent()` that helps convert lists into paragraphs in certain cases.
   */
  execute({ shouldMergeOnBlocksContentLevel: e = !1 } = {}) {
    const t = this.editor.model, n = t.document.selection, s = [];
    t.change((o) => {
      const { firstElement: r, lastElement: a } = this._getMergeSubjectElements(n, e), l = r.getAttribute("listIndent") || 0, c = a.getAttribute("listIndent"), u = a.getAttribute("listItemId");
      if (l != c) {
        const d = LR(a);
        s.push(...Ea([a, ...d], o, {
          indentBy: l - c,
          // If outdenting, the entire sub-tree that follows must be included.
          expand: l < c
        }));
      }
      if (e) {
        let d = n;
        n.isCollapsed && (d = o.createSelection(o.createRange(o.createPositionAt(r, "end"), o.createPositionAt(a, 0)))), t.deleteContent(d, { doNotResetEntireContent: n.isCollapsed });
        const h = d.getLastPosition().parent, f = h.nextSibling;
        s.push(h), f && f !== a && f.getAttribute("listItemId") == u && s.push(...Ta(f, h, o));
      } else
        s.push(...Ta(a, r, o));
      this._fireAfterExecute(s);
    });
  }
  /**
   * Fires the `afterExecute` event.
   *
   * @param changedBlocks The changed list elements.
   */
  _fireAfterExecute(e) {
    this.fire("afterExecute", En(new Set(e)));
  }
  /**
   * Checks whether the command can be enabled in the current context.
   *
   * @returns Whether the command should be enabled.
   */
  _checkEnabled() {
    const e = this.editor.model, t = e.document.selection, n = us(e);
    if (t.isCollapsed || n) {
      const s = n || t.getFirstPosition().parent;
      if (!fe(s))
        return !1;
      const o = this._direction == "backward" ? s.previousSibling : s.nextSibling;
      if (!o || cs([s, o]))
        return !1;
    } else {
      const s = t.getLastPosition(), o = t.getFirstPosition();
      if (s.parent === o.parent || !fe(s.parent))
        return !1;
    }
    return !0;
  }
  /**
   * Returns the boundary elements the merge should be executed for. These are not necessarily selection's first
   * and last position parents but sometimes sibling or even further blocks depending on the context.
   *
   * @param selection The selection the merge is executed for.
   * @param shouldMergeOnBlocksContentLevel When `true`, merge is performed together with
   * {@link module:engine/model/model~Model#deleteContent} to remove the inline content within the selection.
   */
  _getMergeSubjectElements(e, t) {
    const n = this.editor.model, s = us(n);
    let o, r;
    if (e.isCollapsed || s) {
      const a = s || e.getFirstPosition().parent, l = gn(a);
      this._direction == "backward" ? (r = a, l && !t ? o = Je.first(a, { sameIndent: !0, lowerIndent: !0 }) : o = a.previousSibling) : (o = a, r = a.nextSibling);
    } else
      o = e.getFirstPosition().parent, r = e.getLastPosition().parent;
    return {
      firstElement: o,
      lastElement: r
    };
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Ud extends V {
  /**
   * Creates an instance of the command.
   *
   * @param editor The editor instance.
   * @param direction Whether list item should be split before or after the selected block.
   */
  constructor(e, t) {
    super(e), this._direction = t;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    this.isEnabled = this._checkEnabled();
  }
  /**
   * Splits the list item at the selection.
   *
   * @fires execute
   * @fires afterExecute
   */
  execute() {
    this.editor.model.change((t) => {
      const n = Ul(this._getStartBlock(), t);
      this._fireAfterExecute(n);
    });
  }
  /**
   * Fires the `afterExecute` event.
   *
   * @param changedBlocks The changed list elements.
   */
  _fireAfterExecute(e) {
    this.fire("afterExecute", En(new Set(e)));
  }
  /**
   * Checks whether the command can be enabled in the current context.
   *
   * @returns Whether the command should be enabled.
   */
  _checkEnabled() {
    const e = this.editor.model.document.selection, t = this._getStartBlock();
    return e.isCollapsed && fe(t) && !gn(t);
  }
  /**
   * Returns the model element that is the main focus of the command (according to the current selection and command direction).
   */
  _getStartBlock() {
    const t = this.editor.model.document.selection.getFirstPosition().parent;
    return this._direction == "before" ? t : t.nextSibling;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class HR extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ListUtils";
  }
  /**
   * Expands the given list of selected blocks to include all the items of the lists they're in.
   *
   * @param blocks The list of selected blocks.
   */
  expandListBlocksToCompleteList(e) {
    return OR(e);
  }
  /**
   * Check if the given block is the first in the list item.
   *
   * @param listBlock The list block element.
   */
  isFirstBlockOfListItem(e) {
    return gn(e);
  }
  /**
   * Returns true if the given model node is a list item block.
   *
   * @param node A model node.
   */
  isListItemBlock(e) {
    return fe(e);
  }
  /**
   * Expands the given list of selected blocks to include the leading and tailing blocks of partially selected list items.
   *
   * @param blocks The list of selected blocks.
   * @param options.withNested Whether should include nested list items.
   */
  expandListBlocksToCompleteItems(e, t = {}) {
    return vs(e, t);
  }
  /**
   * Returns true if listType is of type `numbered` or `customNumbered`.
   */
  isNumberedListType(e) {
    return DR(e);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function yp(i) {
  return i.is("element", "ol") || i.is("element", "ul");
}
function Po(i) {
  return i.is("element", "li");
}
function UR(i) {
  let e = 0, t = i.parent;
  for (; t; ) {
    if (Po(t))
      e++;
    else {
      const n = t.previousSibling;
      n && Po(n) && e++;
    }
    t = t.parent;
  }
  return e;
}
function $R(i, e, t, n = kp(t, e)) {
  return i.createAttributeElement(Cp(t), null, {
    priority: 2 * e / 100 - 100,
    id: n
  });
}
function WR(i, e, t) {
  return i.createAttributeElement("li", null, {
    priority: (2 * e + 1) / 100 - 100,
    id: t
  });
}
function Cp(i) {
  return i == "numbered" || i == "customNumbered" ? "ol" : "ul";
}
function kp(i, e) {
  return `list-${i}-${e}`;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function tt(i, e) {
  const t = i.nodeBefore;
  if (fe(t)) {
    let n = t;
    for (const { node: s } of _s(n, "backward"))
      if (n = s, e.has(n))
        return;
    e.set(t, n);
  } else {
    const n = i.nodeAfter;
    fe(n) && e.set(n, n);
  }
}
function qR(i, e) {
  let t = 0, n = -1, s = null, o = !1;
  for (const { node: r } of i) {
    const a = r.getAttribute("listIndent");
    if (a > t) {
      let l;
      s === null ? (s = a - t, l = t) : (s > a && (s = a), l = a - s), l > n + 1 && (l = n + 1), e.setAttribute("listIndent", l, r), o = !0, n = l;
    } else
      s = null, t = a + 1, n = a;
  }
  return o;
}
function GR(i, e, t) {
  const n = /* @__PURE__ */ new Set();
  let s = !1;
  for (const { node: o } of i) {
    if (n.has(o))
      continue;
    let r = o.getAttribute("listType"), a = o.getAttribute("listItemId");
    if (e.has(a) && (a = ri.next()), e.add(a), o.is("element", "listItem")) {
      o.getAttribute("listItemId") != a && (t.setAttribute("listItemId", a, o), s = !0);
      continue;
    }
    for (const l of Wt(o, { direction: "forward" }))
      n.add(l), l.getAttribute("listType") != r && (a = ri.next(), r = l.getAttribute("listType")), l.getAttribute("listItemId") != a && (t.setAttribute("listItemId", a, l), s = !0);
  }
  return s;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function jR() {
  return (i, e, t) => {
    const { writer: n, schema: s } = t;
    if (!e.modelRange)
      return;
    const o = Array.from(e.modelRange.getItems({ shallow: !0 })).filter((d) => s.checkAttribute(d, "listItemId"));
    if (!o.length)
      return;
    const r = ri.next(), a = UR(e.viewItem);
    let l = e.viewItem.parent && e.viewItem.parent.is("element", "ol") ? "numbered" : "bulleted";
    const c = o[0].getAttribute("listType");
    c && (l = c);
    const u = {
      listItemId: r,
      listIndent: a,
      listType: l
    };
    for (const d of o)
      d.hasAttribute("listItemId") || n.setAttributes(u, d);
    o.length > 1 && o[1].getAttribute("listItemId") != u.listItemId && t.keepEmptyElement(o[0]);
  };
}
function $d() {
  return (i, e, t) => {
    if (!t.consumable.test(e.viewItem, { name: !0 }))
      return;
    const n = new Bt(e.viewItem.document);
    for (const s of Array.from(e.viewItem.getChildren()))
      !Po(s) && !yp(s) && n.remove(s);
  };
}
function KR(i, e, t, n) {
  return () => {
    const a = i.document.differ.getChanges(), l = [], c = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Set();
    for (const d of a)
      if (d.type == "insert" && d.name != "$text")
        tt(d.position, c), d.attributes.has("listItemId") ? u.add(d.position.nodeAfter) : tt(d.position.getShiftedBy(d.length), c);
      else if (d.type == "remove" && d.attributes.has("listItemId"))
        tt(d.position, c);
      else if (d.type == "attribute") {
        const h = d.range.start.nodeAfter;
        t.includes(d.attributeKey) ? (tt(d.range.start, c), d.attributeNewValue === null ? (tt(d.range.start.getShiftedBy(1), c), o(h) && l.push(h)) : u.add(h)) : fe(h) && o(h) && l.push(h);
      }
    for (const d of c.values())
      l.push(...s(d, u));
    for (const d of new Set(l))
      e.reconvertItem(d);
  };
  function s(a, l) {
    const c = [], u = /* @__PURE__ */ new Set(), d = [];
    for (const { node: h, previous: f } of _s(a, "forward")) {
      if (u.has(h))
        continue;
      const m = h.getAttribute("listIndent");
      f && m < f.getAttribute("listIndent") && (d.length = m + 1), d[m] = Object.fromEntries(Array.from(h.getAttributes()).filter(([w]) => t.includes(w)));
      const p = Wt(h, { direction: "forward" });
      for (const w of p)
        u.add(w), (o(w, p) || r(w, d, l)) && c.push(w);
    }
    return c;
  }
  function o(a, l) {
    const c = e.mapper.toViewElement(a);
    if (!c)
      return !1;
    if (n.fire("checkElement", {
      modelElement: a,
      viewElement: c
    }))
      return !0;
    if (!a.is("element", "paragraph") && !a.is("element", "listItem"))
      return !1;
    const d = Ep(a, t, l);
    return d && c.is("element", "p") ? !0 : !!(!d && c.is("element", "span"));
  }
  function r(a, l, c) {
    if (c.has(a))
      return !1;
    const u = e.mapper.toViewElement(a);
    let d = l.length - 1;
    for (let h = u.parent; !h.is("editableElement"); h = h.parent) {
      const f = Po(h), m = yp(h);
      if (!m && !f)
        continue;
      const p = `checkAttributes:${f ? "item" : "list"}`;
      if (n.fire(p, {
        viewElement: h,
        modelAttributes: l[d]
      }))
        break;
      if (m && (d--, d < 0))
        return !1;
    }
    return !0;
  }
}
function Wd(i, e, t, { dataPipeline: n } = {}) {
  const s = t3(i);
  return (o, r, a) => {
    const { writer: l, mapper: c, consumable: u } = a, d = r.item;
    if (!i.includes(r.attributeKey) || !s(d, u))
      return;
    const h = JR(d, c, t);
    Tp(h, l, c), YR(h, l);
    const f = QR(d, h, e, l, { dataPipeline: n });
    e3(d, f, e, l);
  };
}
function ZR(i) {
  return (e, t, n) => {
    const { writer: s, mapper: o } = n, r = e.name.split(":")[1];
    if (!i.checkAttribute(r, "listItemId"))
      return;
    const a = o.toViewPosition(t.position), l = t.position.getShiftedBy(t.length), c = o.toViewPosition(l, { isPhantom: !0 }), d = s.createRange(a, c).getTrimmed().end.nodeBefore;
    /* istanbul ignore next -- @preserve */
    d && Tp(d, s, o);
  };
}
function qd(i, { dataPipeline: e } = {}) {
  return (t, { writer: n }) => {
    if (!Ep(t, i))
      return null;
    if (!e)
      return n.createContainerElement("span", { class: "ck-list-bogus-paragraph" });
    const s = n.createContainerElement("p");
    return n.setCustomProperty("dataPipeline:transparentRendering", !0, s), s;
  };
}
function JR(i, e, t) {
  const n = t.createRangeOn(i);
  return e.toViewRange(n).getTrimmed().end.nodeBefore;
}
function XR(i, e) {
  return (t, n) => {
    if (n.modelPosition.offset > 0)
      return;
    const s = n.modelPosition.parent;
    if (!fe(s) || !i.some((c) => c.scope == "itemMarker" && c.canInjectMarkerIntoElement && c.canInjectMarkerIntoElement(s)))
      return;
    const o = n.mapper.toViewElement(s), r = e.createRangeIn(o), a = r.getWalker();
    let l = r.start;
    for (const { item: c } of a) {
      if (c.is("element") && n.mapper.toModelElement(c) || c.is("$textProxy"))
        break;
      c.is("element") && c.getCustomProperty("listItemMarker") && (l = e.createPositionAfter(c), a.skip(({ previousPosition: u }) => !u.isEqual(l)));
    }
    n.viewPosition = l;
  };
}
function Tp(i, e, t) {
  for (; i.parent.is("attributeElement") && i.parent.getCustomProperty("listItemWrapper"); )
    e.unwrap(e.createRangeOn(i), i.parent);
  const n = [];
  s(e.createPositionBefore(i).getWalker({ direction: "backward" })), s(e.createRangeIn(i).getWalker());
  for (const o of n)
    e.remove(o);
  function s(o) {
    for (const { item: r } of o) {
      if (r.is("element") && t.toModelElement(r))
        break;
      r.is("element") && r.getCustomProperty("listItemMarker") && n.push(r);
    }
  }
}
function QR(i, e, t, n, { dataPipeline: s }) {
  let o = n.createRangeOn(e);
  if (!gn(i))
    return o;
  for (const r of t) {
    if (r.scope != "itemMarker")
      continue;
    const a = r.createElement(n, i, { dataPipeline: s });
    if (!a || (n.setCustomProperty("listItemMarker", !0, a), r.canInjectMarkerIntoElement && r.canInjectMarkerIntoElement(i) ? n.insert(n.createPositionAt(e, 0), a) : (n.insert(o.start, a), o = n.createRange(n.createPositionBefore(a), n.createPositionAfter(e))), !r.createWrapperElement || !r.canWrapElement))
      continue;
    const l = r.createWrapperElement(n, i, { dataPipeline: s });
    n.setCustomProperty("listItemWrapper", !0, l), r.canWrapElement(i) ? o = n.wrap(o, l) : (o = n.wrap(n.createRangeOn(a), l), o = n.createRange(o.start, n.createPositionAfter(e)));
  }
  return o;
}
function YR(i, e) {
  let t = i.parent;
  for (; t.is("attributeElement") && ["ul", "ol", "li"].includes(t.name); ) {
    const n = t.parent;
    e.unwrap(e.createRangeOn(i), t), t = n;
  }
}
function e3(i, e, t, n) {
  if (!i.hasAttribute("listIndent"))
    return;
  const s = i.getAttribute("listIndent");
  let o = i;
  for (let r = s; r >= 0; r--) {
    const a = WR(n, r, o.getAttribute("listItemId")), l = $R(n, r, o.getAttribute("listType"));
    for (const c of t)
      (c.scope == "list" || c.scope == "item") && o.hasAttribute(c.attributeName) && c.setAttributeOnDowncast(n, o.getAttribute(c.attributeName), c.scope == "list" ? l : a);
    if (e = n.wrap(e, a), e = n.wrap(e, l), r == 0 || (o = Je.first(o, { lowerIndent: !0 }), !o))
      break;
  }
}
function t3(i) {
  return (e, t) => {
    const n = [];
    for (const s of i)
      e.hasAttribute(s) && n.push(`attribute:${s}`);
    return n.every((s) => t.test(e, s) !== !1) ? (n.forEach((s) => t.consume(e, s)), !0) : !1;
  };
}
function Ep(i, e, t = Hl(i)) {
  if (!fe(i))
    return !1;
  for (const n of i.getAttributeKeys())
    if (!n.startsWith("selection:") && !e.includes(n))
      return !1;
  return t.length < 2;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const ao = ["listType", "listIndent", "listItemId"];
class n3 extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ListEditing";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ar, bt, HR, Ze];
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this._downcastStrategies = [], e.config.define("list.multiBlock", !0);
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model, n = e.config.get("list.multiBlock");
    if (e.plugins.has("LegacyListEditing"))
      throw new g("list-feature-conflict", this, { conflictPlugin: "LegacyListEditing" });
    t.schema.register("$listItem", { allowAttributes: ao }), n ? (t.schema.extend("$container", { allowAttributesOf: "$listItem" }), t.schema.extend("$block", { allowAttributesOf: "$listItem" }), t.schema.extend("$blockObject", { allowAttributesOf: "$listItem" })) : t.schema.register("listItem", {
      inheritAllFrom: "$block",
      allowAttributesOf: "$listItem"
    });
    for (const s of ao)
      t.schema.setAttributeProperties(s, {
        copyOnReplace: !0
      });
    e.commands.add("numberedList", new Js(e, "numbered")), e.commands.add("bulletedList", new Js(e, "bulleted")), e.commands.add("customNumberedList", new Js(e, "customNumbered", { multiLevel: !0 })), e.commands.add("customBulletedList", new Js(e, "customBulleted", { multiLevel: !0 })), e.commands.add("indentList", new Dd(e, "forward")), e.commands.add("outdentList", new Dd(e, "backward")), e.commands.add("splitListItemBefore", new Ud(e, "before")), e.commands.add("splitListItemAfter", new Ud(e, "after")), n && (e.commands.add("mergeListItemBackward", new Hd(e, "backward")), e.commands.add("mergeListItemForward", new Hd(e, "forward"))), this._setupDeleteIntegration(), this._setupEnterIntegration(), this._setupTabIntegration(), this._setupClipboardIntegration(), this._setupAccessibilityIntegration();
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    const t = this.editor.commands, n = t.get("indent"), s = t.get("outdent");
    n && n.registerChildCommand(t.get("indentList"), { priority: "high" }), s && s.registerChildCommand(t.get("outdentList"), { priority: "lowest" }), this._setupModelPostFixing(), this._setupConversion();
  }
  /**
   * Registers a downcast strategy.
   *
   * **Note**: Strategies must be registered in the `Plugin#init()` phase so that it can be applied
   * in the `ListEditing#afterInit()`.
   *
   * @param strategy The downcast strategy to register.
   */
  registerDowncastStrategy(e) {
    this._downcastStrategies.push(e);
  }
  /**
   * Returns list of model attribute names that should affect downcast conversion.
   */
  getListAttributeNames() {
    return [
      ...ao,
      ...this._downcastStrategies.map((e) => e.attributeName)
    ];
  }
  /**
   * Attaches the listener to the {@link module:engine/view/document~Document#event:delete} event and handles backspace/delete
   * keys in and around document lists.
   */
  _setupDeleteIntegration() {
    const e = this.editor, t = e.commands.get("mergeListItemBackward"), n = e.commands.get("mergeListItemForward");
    this.listenTo(e.editing.view.document, "delete", (s, o) => {
      const r = e.model.document.selection;
      us(e.model) || e.model.change(() => {
        const a = r.getFirstPosition();
        if (r.isCollapsed && o.direction == "backward") {
          if (!a.isAtStart)
            return;
          const l = a.parent;
          if (!fe(l))
            return;
          if (!Je.first(l, {
            sameAttributes: "listType",
            sameIndent: !0
          }) && l.getAttribute("listIndent") === 0)
            Nd(l) || e.execute("splitListItemAfter"), e.execute("outdentList");
          else {
            if (!t || !t.isEnabled)
              return;
            t.execute({
              shouldMergeOnBlocksContentLevel: Gd(e.model, "backward")
            });
          }
          o.preventDefault(), s.stop();
        } else {
          if (r.isCollapsed && !r.getLastPosition().isAtEnd || !n || !n.isEnabled)
            return;
          n.execute({
            shouldMergeOnBlocksContentLevel: Gd(e.model, "forward")
          }), o.preventDefault(), s.stop();
        }
      });
    }, { context: "li" });
  }
  /**
   * Attaches a listener to the {@link module:engine/view/document~Document#event:enter} event and handles enter key press
   * in document lists.
   */
  _setupEnterIntegration() {
    const e = this.editor, t = e.model, n = e.commands, s = n.get("enter");
    this.listenTo(e.editing.view.document, "enter", (o, r) => {
      const a = t.document, l = a.selection.getFirstPosition().parent;
      if (a.selection.isCollapsed && fe(l) && l.isEmpty && !r.isSoft) {
        const c = gn(l), u = Nd(l);
        c && u ? (e.execute("outdentList"), r.preventDefault(), o.stop()) : c && !u ? (e.execute("splitListItemAfter"), r.preventDefault(), o.stop()) : u && (e.execute("splitListItemBefore"), r.preventDefault(), o.stop());
      }
    }, { context: "li" }), this.listenTo(s, "afterExecute", () => {
      const o = n.get("splitListItemBefore");
      if (o.refresh(), !o.isEnabled)
        return;
      const a = e.model.document.selection.getLastPosition().parent;
      Hl(a).length === 2 && o.execute();
    });
  }
  /**
   * Attaches a listener to the {@link module:engine/view/document~Document#event:tab} event and handles tab key and tab+shift keys
   * presses in document lists.
   */
  _setupTabIntegration() {
    const e = this.editor;
    this.listenTo(e.editing.view.document, "tab", (t, n) => {
      const s = n.shiftKey ? "outdentList" : "indentList";
      this.editor.commands.get(s).isEnabled && (e.execute(s), n.stopPropagation(), n.preventDefault(), t.stop());
    }, { context: "li" });
  }
  /**
   * Registers the conversion helpers for the document-list feature.
   */
  _setupConversion() {
    const e = this.editor, t = e.model, n = this.getListAttributeNames(), s = e.config.get("list.multiBlock"), o = s ? "paragraph" : "listItem";
    e.conversion.for("upcast").elementToElement({
      view: "li",
      model: (a, { writer: l }) => l.createElement(o, { listType: "" })
    }).elementToElement({
      view: "p",
      model: (a, { writer: l }) => a.parent && a.parent.is("element", "li") ? l.createElement(o, { listType: "" }) : null,
      converterPriority: "high"
    }).add((a) => {
      a.on("element:li", jR()), a.on("element:ul", $d(), { priority: "high" }), a.on("element:ol", $d(), { priority: "high" });
    }), s || e.conversion.for("downcast").elementToElement({
      model: "listItem",
      view: "p"
    }), e.conversion.for("editingDowncast").elementToElement({
      model: o,
      view: qd(n),
      converterPriority: "high"
    }).add((a) => {
      a.on("attribute", Wd(n, this._downcastStrategies, t)), a.on("remove", ZR(t.schema));
    }), e.conversion.for("dataDowncast").elementToElement({
      model: o,
      view: qd(n, { dataPipeline: !0 }),
      converterPriority: "high"
    }).add((a) => {
      a.on("attribute", Wd(n, this._downcastStrategies, t, { dataPipeline: !0 }));
    });
    const r = XR(this._downcastStrategies, e.editing.view);
    e.editing.mapper.on("modelToViewPosition", r), e.data.mapper.on("modelToViewPosition", r), this.listenTo(t.document, "change:data", KR(t, e.editing, n, this), { priority: "high" }), this.on("checkAttributes:item", (a, { viewElement: l, modelAttributes: c }) => {
      l.id != c.listItemId && (a.return = !0, a.stop());
    }), this.on("checkAttributes:list", (a, { viewElement: l, modelAttributes: c }) => {
      (l.name != Cp(c.listType) || l.id != kp(c.listType, c.listIndent)) && (a.return = !0, a.stop());
    });
  }
  /**
   * Registers model post-fixers.
   */
  _setupModelPostFixing() {
    const e = this.editor.model, t = this.getListAttributeNames();
    e.document.registerPostFixer((n) => i3(e, n, t, this)), this.on("postFixer", (n, { listNodes: s, writer: o }) => {
      n.return = qR(s, o) || n.return;
    }, { priority: "high" }), this.on("postFixer", (n, { listNodes: s, writer: o, seenIds: r }) => {
      n.return = GR(s, r, o) || n.return;
    }, { priority: "high" });
  }
  /**
   * Integrates the feature with the clipboard via {@link module:engine/model/model~Model#insertContent} and
   * {@link module:engine/model/model~Model#getSelectedContent}.
   */
  _setupClipboardIntegration() {
    const e = this.editor.model, t = this.editor.plugins.get("ClipboardPipeline");
    this.listenTo(e, "insertContent", s3(e), { priority: "high" }), this.listenTo(t, "outputTransformation", (n, s) => {
      e.change((o) => {
        const r = Array.from(s.content.getChildren()), a = r[r.length - 1];
        if (r.length > 1 && a.is("element") && a.isEmpty && r.slice(0, -1).every(fe) && o.remove(a), s.method == "copy" || s.method == "cut") {
          const l = Array.from(s.content.getChildren());
          cs(l) && ur(l, o);
        }
      });
    });
  }
  /**
   * Informs editor accessibility features about keystrokes brought by the plugin.
   */
  _setupAccessibilityIntegration() {
    const e = this.editor, t = e.t;
    e.accessibility.addKeystrokeInfoGroup({
      id: "list",
      label: t("Keystrokes that can be used in a list"),
      keystrokes: [
        {
          label: t("Increase list item indent"),
          keystroke: "Tab"
        },
        {
          label: t("Decrease list item indent"),
          keystroke: "Shift+Tab"
        }
      ]
    });
  }
}
function i3(i, e, t, n) {
  const s = i.document.differ.getChanges(), o = /* @__PURE__ */ new Map(), r = n.editor.config.get("list.multiBlock");
  let a = !1;
  for (const c of s) {
    if (c.type == "insert" && c.name != "$text") {
      const u = c.position.nodeAfter;
      if (!i.schema.checkAttribute(u, "listItemId"))
        for (const d of Array.from(u.getAttributeKeys()))
          t.includes(d) && (e.removeAttribute(d, u), a = !0);
      tt(c.position, o), c.attributes.has("listItemId") || tt(c.position.getShiftedBy(c.length), o);
      for (const { item: d, previousPosition: h } of i.createRangeIn(u))
        fe(d) && tt(h, o);
    } else c.type == "remove" ? tt(c.position, o) : c.type == "attribute" && t.includes(c.attributeKey) && (tt(c.range.start, o), c.attributeNewValue === null && tt(c.range.start.getShiftedBy(1), o));
    if (!r && c.type == "attribute" && ao.includes(c.attributeKey)) {
      const u = c.range.start.nodeAfter;
      c.attributeNewValue === null && u && u.is("element", "listItem") ? (e.rename(u, "paragraph"), a = !0) : c.attributeOldValue === null && u && u.is("element") && u.name != "listItem" && (e.rename(u, "listItem"), a = !0);
    }
  }
  const l = /* @__PURE__ */ new Set();
  for (const c of o.values())
    a = n.fire("postFixer", {
      listNodes: new BR(c),
      listHead: c,
      writer: e,
      seenIds: l
    }) || a;
  return a;
}
function s3(i) {
  return (e, [t, n]) => {
    const s = t.is("documentFragment") ? Array.from(t.getChildren()) : [t];
    if (!s.length)
      return;
    const r = (n ? i.createSelection(n) : i.document.selection).getFirstPosition();
    let a;
    if (fe(r.parent))
      a = r.parent;
    else if (fe(r.nodeBefore))
      a = r.nodeBefore;
    else
      return;
    i.change((l) => {
      const c = a.getAttribute("listType"), u = a.getAttribute("listIndent"), d = s[0].getAttribute("listIndent") || 0, h = Math.max(u - d, 0);
      for (const f of s) {
        const m = fe(f);
        a.is("element", "listItem") && f.is("element", "paragraph") && l.rename(f, "listItem"), l.setAttributes({
          listIndent: (m ? f.getAttribute("listIndent") : 0) + h,
          listItemId: m ? f.getAttribute("listItemId") : ri.next(),
          listType: c
        }, f);
      }
    });
  };
}
function Gd(i, e) {
  const t = i.document.selection;
  if (!t.isCollapsed)
    return !us(i);
  if (e === "forward")
    return !0;
  const s = t.getFirstPosition().parent, o = s.previousSibling;
  return i.schema.isObject(o) ? !1 : o.isEmpty ? !0 : cs([s, o]);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function jd(i, e, t, n) {
  i.ui.componentFactory.add(e, () => {
    const s = Kd(P, i, e, t, n);
    return s.set({
      tooltip: !0,
      isToggleable: !0
    }), s;
  }), i.ui.componentFactory.add(`menuBar:${e}`, () => Kd(de, i, e, t, n));
}
function Kd(i, e, t, n, s) {
  const o = e.commands.get(t), r = new i(e.locale);
  return r.set({
    label: n,
    icon: s
  }), r.bind("isOn", "isEnabled").to(o, "value", "isEnabled"), r.on("execute", () => {
    e.execute(t), e.editing.view.focus();
  }), r;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class o3 extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ListUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor.t;
    this.editor.ui.componentFactory.has("numberedList") || jd(this.editor, "numberedList", e("Numbered List"), A.numberedList), this.editor.ui.componentFactory.has("bulletedList") || jd(this.editor, "bulletedList", e("Bulleted List"), A.bulletedList);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class r3 extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [n3, o3];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "List";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const a3 = [
  { listStyle: "disc", typeAttribute: "disc", listType: "bulleted" },
  { listStyle: "circle", typeAttribute: "circle", listType: "bulleted" },
  { listStyle: "square", typeAttribute: "square", listType: "bulleted" },
  { listStyle: "decimal", typeAttribute: "1", listType: "numbered" },
  { listStyle: "decimal-leading-zero", typeAttribute: null, listType: "numbered" },
  { listStyle: "lower-roman", typeAttribute: "i", listType: "numbered" },
  { listStyle: "upper-roman", typeAttribute: "I", listType: "numbered" },
  { listStyle: "lower-alpha", typeAttribute: "a", listType: "numbered" },
  { listStyle: "upper-alpha", typeAttribute: "A", listType: "numbered" },
  { listStyle: "lower-latin", typeAttribute: "a", listType: "numbered" },
  { listStyle: "upper-latin", typeAttribute: "A", listType: "numbered" }
];
for (const { listStyle: i, typeAttribute: e, listType: t } of a3)
  ;
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
gs("Ctrl+Enter");
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
gs("Ctrl+Enter");
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class l3 extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "IndentEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor;
    e.commands.add("indent", new Kc(e)), e.commands.add("outdent", new Kc(e));
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class c3 extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "IndentUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.locale, n = e.t, s = t.uiLanguageDirection == "ltr" ? A.indent : A.outdent, o = t.uiLanguageDirection == "ltr" ? A.outdent : A.indent;
    this._defineButton("indent", n("Increase indent"), s), this._defineButton("outdent", n("Decrease indent"), o);
  }
  /**
   * Defines UI buttons for both toolbar and menu bar.
   */
  _defineButton(e, t, n) {
    const s = this.editor;
    s.ui.componentFactory.add(e, () => {
      const o = this._createButton(P, e, t, n);
      return o.set({
        tooltip: !0
      }), o;
    }), s.ui.componentFactory.add("menuBar:" + e, () => this._createButton(de, e, t, n));
  }
  /**
   * Creates a button to use either in toolbar or in menu bar.
   */
  _createButton(e, t, n, s) {
    const o = this.editor, r = o.commands.get(t), a = new e(o.locale);
    return a.set({
      label: n,
      icon: s
    }), a.bind("isEnabled").to(r, "isEnabled"), this.listenTo(a, "execute", () => {
      o.execute(t), o.editing.view.focus();
    }), a;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class u3 extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Indent";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [l3, c3];
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Xs extends V {
  /**
   * Creates an instance of the command.
   */
  constructor(e, t) {
    super(e), this._indentBehavior = t;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const t = this.editor.model, n = me(t.document.selection.getSelectedBlocks());
    if (!n || !this._isIndentationChangeAllowed(n)) {
      this.isEnabled = !1;
      return;
    }
    this.isEnabled = this._indentBehavior.checkEnabled(n.getAttribute("blockIndent"));
  }
  /**
   * @inheritDoc
   */
  execute() {
    const e = this.editor.model, t = this._getBlocksToChange();
    e.change((n) => {
      for (const s of t) {
        const o = s.getAttribute("blockIndent"), r = this._indentBehavior.getNextIndent(o);
        r ? n.setAttribute("blockIndent", r, s) : n.removeAttribute("blockIndent", s);
      }
    });
  }
  /**
   * Returns blocks from selection that should have blockIndent selection set.
   */
  _getBlocksToChange() {
    const t = this.editor.model.document.selection;
    return Array.from(t.getSelectedBlocks()).filter((s) => this._isIndentationChangeAllowed(s));
  }
  /**
   * Returns false if indentation cannot be applied, i.e.:
   * - for blocks disallowed by schema declaration
   * - for blocks in Document Lists (disallowed forward indentation only). See https://github.com/ckeditor/ckeditor5/issues/14155.
   * Otherwise returns true.
   */
  _isIndentationChangeAllowed(e) {
    const t = this.editor;
    return t.model.schema.checkAttribute(e, "blockIndent") ? !t.plugins.has("ListUtils") || !this._indentBehavior.isForward ? !0 : !t.plugins.get("ListUtils").isListItemBlock(e) : !1;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Zd {
  /**
   * Creates an instance of the indentation behavior.
   *
   * @param config.direction The direction of indentation.
   * @param config.offset The offset of the next indentation step.
   * @param config.unit Indentation unit.
   */
  constructor(e) {
    this.isForward = e.direction === "forward", this.offset = e.offset, this.unit = e.unit;
  }
  /**
   * @inheritDoc
   */
  checkEnabled(e) {
    const t = parseFloat(e || "0");
    return this.isForward || t > 0;
  }
  /**
   * @inheritDoc
   */
  getNextIndent(e) {
    const t = parseFloat(e || "0");
    if (!(!e || e.endsWith(this.unit)))
      return this.isForward ? this.offset + this.unit : void 0;
    const s = this.isForward ? this.offset : -this.offset, o = t + s;
    return o > 0 ? o + this.unit : void 0;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Jd {
  /**
   * Creates an instance of the indentation behavior.
   *
   * @param config.direction The direction of indentation.
   * @param config.classes A list of classes used for indentation.
   */
  constructor(e) {
    this.isForward = e.direction === "forward", this.classes = e.classes;
  }
  /**
   * @inheritDoc
   */
  checkEnabled(e) {
    const t = this.classes.indexOf(e);
    return this.isForward ? t < this.classes.length - 1 : t >= 0;
  }
  /**
   * @inheritDoc
   */
  getNextIndent(e) {
    const t = this.classes.indexOf(e), n = this.isForward ? 1 : -1;
    return this.classes[t + n];
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const d3 = ["paragraph", "heading1", "heading2", "heading3", "heading4", "heading5", "heading6"];
class h3 extends b {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), e.config.define("indentBlock", {
      offset: 40,
      unit: "px"
    });
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "IndentBlock";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.config.get("indentBlock");
    t.classes && t.classes.length ? (this._setupConversionUsingClasses(t.classes), e.commands.add("indentBlock", new Xs(e, new Jd({
      direction: "forward",
      classes: t.classes
    }))), e.commands.add("outdentBlock", new Xs(e, new Jd({
      direction: "backward",
      classes: t.classes
    })))) : (e.data.addStyleProcessorRules(G5), this._setupConversionUsingOffset(), e.commands.add("indentBlock", new Xs(e, new Zd({
      direction: "forward",
      offset: t.offset,
      unit: t.unit
    }))), e.commands.add("outdentBlock", new Xs(e, new Zd({
      direction: "backward",
      offset: t.offset,
      unit: t.unit
    }))));
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    const e = this.editor, t = e.model.schema, n = e.commands.get("indent"), s = e.commands.get("outdent"), o = e.config.get("heading.options");
    (o && o.map((l) => l.model) || d3).forEach((l) => {
      t.isRegistered(l) && t.extend(l, { allowAttributes: "blockIndent" });
    }), t.setAttributeProperties("blockIndent", { isFormatting: !0 }), n.registerChildCommand(e.commands.get("indentBlock")), s.registerChildCommand(e.commands.get("outdentBlock"));
  }
  /**
   * Setups conversion for using offset indents.
   */
  _setupConversionUsingOffset() {
    const e = this.editor.conversion, n = this.editor.locale.contentLanguageDirection === "rtl" ? "margin-right" : "margin-left";
    e.for("upcast").attributeToAttribute({
      view: {
        styles: {
          [n]: /[\s\S]+/
        }
      },
      model: {
        key: "blockIndent",
        value: (s) => {
          if (!s.is("element", "li"))
            return s.getStyle(n);
        }
      }
    }), e.for("downcast").attributeToAttribute({
      model: "blockIndent",
      view: (s) => ({
        key: "style",
        value: {
          [n]: s
        }
      })
    });
  }
  /**
   * Setups conversion for using classes.
   */
  _setupConversionUsingClasses(e) {
    const t = {
      model: {
        key: "blockIndent",
        values: []
      },
      view: {}
    };
    for (const n of e)
      t.model.values.push(n), t.view[n] = {
        key: "class",
        value: [n]
      };
    this.editor.conversion.attributeToAttribute(t);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class f3 extends V {
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor.model, t = e.schema, n = e.document.selection;
    this.isEnabled = m3(n, t, e);
  }
  /**
   * Executes the command.
   *
   * @fires execute
   */
  execute() {
    const e = this.editor.model;
    e.change((t) => {
      const n = t.createElement("horizontalLine");
      e.insertObject(n, null, null, { setSelection: "after" });
    });
  }
}
function m3(i, e, t) {
  const n = g3(i, t);
  return e.checkChild(n, "horizontalLine");
}
function g3(i, e) {
  const n = Bl(i, e).start.parent;
  return n.isEmpty && !n.is("element", "$root") ? n.parent : n;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class p3 extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "HorizontalLineEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model.schema, n = e.t, s = e.conversion;
    t.register("horizontalLine", {
      inheritAllFrom: "$blockObject"
    }), s.for("dataDowncast").elementToElement({
      model: "horizontalLine",
      view: (o, { writer: r }) => r.createEmptyElement("hr")
    }), s.for("editingDowncast").elementToStructure({
      model: "horizontalLine",
      view: (o, { writer: r }) => {
        const a = n("Horizontal line"), l = r.createContainerElement("div", null, r.createEmptyElement("hr"));
        return r.addClass("ck-horizontal-line", l), r.setCustomProperty("hr", !0, l), b3(l, r, a);
      }
    }), s.for("upcast").elementToElement({ view: "hr", model: "horizontalLine" }), e.commands.add("horizontalLine", new f3(e));
  }
}
function b3(i, e, t) {
  return e.setCustomProperty("horizontalLine", !0, i), lr(i, e, { label: t });
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class w3 extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "HorizontalLineUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor;
    e.ui.componentFactory.add("horizontalLine", () => {
      const t = this._createButton(P);
      return t.set({
        tooltip: !0
      }), t;
    }), e.ui.componentFactory.add("menuBar:horizontalLine", () => this._createButton(de));
  }
  /**
   * Creates a button for horizontal line command to use either in toolbar or in menu bar.
   */
  _createButton(e) {
    const t = this.editor, n = t.locale, s = t.commands.get("horizontalLine"), o = new e(t.locale), r = n.t;
    return o.set({
      label: r("Horizontal line"),
      icon: A.horizontalLine
    }), o.bind("isEnabled").to(s, "isEnabled"), this.listenTo(o, "execute", () => {
      t.execute("horizontalLine"), t.editing.view.focus();
    }), o;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class _3 extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [p3, w3, gi];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "HorizontalLine";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class v3 extends V {
  /**
   * @inheritDoc
   */
  refresh() {
    this.value = this._getValue(), this.isEnabled = this._checkEnabled();
  }
  /**
   * Executes the command. When the command {@link #value is on}, all top-most block quotes within
   * the selection will be removed. If it is off, all selected blocks will be wrapped with
   * a block quote.
   *
   * @fires execute
   * @param options Command options.
   * @param options.forceValue If set, it will force the command behavior. If `true`, the command will apply a block quote,
   * otherwise the command will remove the block quote. If not set, the command will act basing on its current value.
   */
  execute(e = {}) {
    const t = this.editor.model, n = t.schema, s = t.document.selection, o = Array.from(s.getSelectedBlocks()), r = e.forceValue === void 0 ? !this.value : e.forceValue;
    t.change((a) => {
      if (!r)
        this._removeQuote(a, o.filter(Qs));
      else {
        const l = o.filter((c) => Qs(c) || Qd(n, c));
        this._applyQuote(a, l);
      }
    });
  }
  /**
   * Checks the command's {@link #value}.
   */
  _getValue() {
    const e = this.editor.model.document.selection, t = me(e.getSelectedBlocks());
    return !!(t && Qs(t));
  }
  /**
   * Checks whether the command can be enabled in the current context.
   *
   * @returns Whether the command should be enabled.
   */
  _checkEnabled() {
    if (this.value)
      return !0;
    const e = this.editor.model.document.selection, t = this.editor.model.schema, n = me(e.getSelectedBlocks());
    return n ? Qd(t, n) : !1;
  }
  /**
   * Removes the quote from given blocks.
   *
   * If blocks which are supposed to be "unquoted" are in the middle of a quote,
   * start it or end it, then the quote will be split (if needed) and the blocks
   * will be moved out of it, so other quoted blocks remained quoted.
   */
  _removeQuote(e, t) {
    Xd(e, t).reverse().forEach((n) => {
      if (n.start.isAtStart && n.end.isAtEnd) {
        e.unwrap(n.start.parent);
        return;
      }
      if (n.start.isAtStart) {
        const o = e.createPositionBefore(n.start.parent);
        e.move(n, o);
        return;
      }
      n.end.isAtEnd || e.split(n.end);
      const s = e.createPositionAfter(n.end.parent);
      e.move(n, s);
    });
  }
  /**
   * Applies the quote to given blocks.
   */
  _applyQuote(e, t) {
    const n = [];
    Xd(e, t).reverse().forEach((s) => {
      let o = Qs(s.start);
      o || (o = e.createElement("blockQuote"), e.wrap(s, o)), n.push(o);
    }), n.reverse().reduce((s, o) => s.nextSibling == o ? (e.merge(e.createPositionAfter(s)), s) : o);
  }
}
function Qs(i) {
  return i.parent.name == "blockQuote" ? i.parent : null;
}
function Xd(i, e) {
  let t, n = 0;
  const s = [];
  for (; n < e.length; ) {
    const o = e[n], r = e[n + 1];
    t || (t = i.createPositionBefore(o)), (!r || o.nextSibling != r) && (s.push(i.createRange(t, i.createPositionAfter(o))), t = null), n++;
  }
  return s;
}
function Qd(i, e) {
  const t = i.checkChild(e.parent, "blockQuote"), n = i.checkChild(["$root", "blockQuote"], e);
  return t && n;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class y3 extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "BlockQuoteEditing";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ar, bt];
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model.schema;
    e.commands.add("blockQuote", new v3(e)), t.register("blockQuote", {
      inheritAllFrom: "$container"
    }), e.conversion.elementToElement({ model: "blockQuote", view: "blockquote" }), e.model.document.registerPostFixer((r) => {
      const a = e.model.document.differ.getChanges();
      for (const l of a)
        if (l.type == "insert") {
          const c = l.position.nodeAfter;
          if (!c)
            continue;
          if (c.is("element", "blockQuote") && c.isEmpty)
            return r.remove(c), !0;
          if (c.is("element", "blockQuote") && !t.checkChild(l.position, c))
            return r.unwrap(c), !0;
          if (c.is("element")) {
            const u = r.createRangeIn(c);
            for (const d of u.getItems())
              if (d.is("element", "blockQuote") && !t.checkChild(r.createPositionBefore(d), d))
                return r.unwrap(d), !0;
          }
        } else if (l.type == "remove") {
          const c = l.position.parent;
          if (c.is("element", "blockQuote") && c.isEmpty)
            return r.remove(c), !0;
        }
      return !1;
    });
    const n = this.editor.editing.view.document, s = e.model.document.selection, o = e.commands.get("blockQuote");
    this.listenTo(n, "enter", (r, a) => {
      if (!s.isCollapsed || !o.value)
        return;
      s.getLastPosition().parent.isEmpty && (e.execute("blockQuote"), e.editing.view.scrollToTheSelection(), a.preventDefault(), r.stop());
    }, { context: "blockquote" }), this.listenTo(n, "delete", (r, a) => {
      if (a.direction != "backward" || !s.isCollapsed || !o.value)
        return;
      const l = s.getLastPosition().parent;
      l.isEmpty && !l.previousSibling && (e.execute("blockQuote"), e.editing.view.scrollToTheSelection(), a.preventDefault(), r.stop());
    }, { context: "blockquote" });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class C3 extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "BlockQuoteUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.commands.get("blockQuote");
    e.ui.componentFactory.add("blockQuote", () => {
      const n = this._createButton(P);
      return n.set({
        tooltip: !0
      }), n.bind("isOn").to(t, "value"), n;
    }), e.ui.componentFactory.add("menuBar:blockQuote", () => this._createButton(de));
  }
  /**
   * Creates a button for block quote command to use either in toolbar or in menu bar.
   */
  _createButton(e) {
    const t = this.editor, n = t.locale, s = t.commands.get("blockQuote"), o = new e(t.locale), r = n.t;
    return o.set({
      label: r("Block quote"),
      icon: A.quote,
      isToggleable: !0
    }), o.bind("isEnabled").to(s, "isEnabled"), this.listenTo(o, "execute", () => {
      t.execute("blockQuote"), t.editing.view.focus();
    }), o;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class k3 extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [y3, C3];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "BlockQuote";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class T3 {
  constructor() {
    this._definitions = /* @__PURE__ */ new Set();
  }
  /**
   * Gives information about the number of decorators stored in the {@link module:link/utils/automaticdecorators~AutomaticDecorators}
   * instance.
   */
  get length() {
    return this._definitions.size;
  }
  /**
   * Adds automatic decorator objects or an array with them to be used during downcasting.
   *
   * @param item A configuration object of automatic rules for decorating links. It might also be an array of such objects.
   */
  add(e) {
    Array.isArray(e) ? e.forEach((t) => this._definitions.add(t)) : this._definitions.add(e);
  }
  /**
   * Provides the conversion helper used in the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add} method.
   *
   * @returns A dispatcher function used as conversion helper in {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add}.
   */
  getDispatcher() {
    return (e) => {
      e.on("attribute:linkHref", (t, n, s) => {
        if (!s.consumable.test(n.item, "attribute:linkHref") || !(n.item.is("selection") || s.schema.isInline(n.item)))
          return;
        const o = s.writer, r = o.document.selection;
        for (const a of this._definitions) {
          const l = o.createAttributeElement("a", a.attributes, {
            priority: 5
          });
          a.classes && o.addClass(a.classes, l);
          for (const c in a.styles)
            o.setStyle(c, a.styles[c], l);
          o.setCustomProperty("link", !0, l), a.callback(n.attributeNewValue) ? n.item.is("selection") ? o.wrap(r.getFirstRange(), l) : o.wrap(s.mapper.toViewRange(n.range), l) : o.unwrap(s.mapper.toViewRange(n.range), l);
        }
      }, { priority: "high" });
    };
  }
  /**
   * Provides the conversion helper used in the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add} method
   * when linking images.
   *
   * @returns A dispatcher function used as conversion helper in {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add}.
   */
  getDispatcherForLinkedImage() {
    return (e) => {
      e.on("attribute:linkHref:imageBlock", (t, n, { writer: s, mapper: o }) => {
        const r = o.toViewElement(n.item), a = Array.from(r.getChildren()).find((l) => l.is("element", "a"));
        for (const l of this._definitions) {
          const c = pt(l.attributes);
          if (l.callback(n.attributeNewValue)) {
            for (const [u, d] of c)
              u === "class" ? s.addClass(d, a) : s.setAttribute(u, d, a);
            l.classes && s.addClass(l.classes, a);
            for (const u in l.styles)
              s.setStyle(u, l.styles[u], a);
          } else {
            for (const [u, d] of c)
              u === "class" ? s.removeClass(d, a) : s.removeAttribute(u, a);
            l.classes && s.removeClass(l.classes, a);
            for (const u in l.styles)
              s.removeStyle(u, a);
          }
        }
      });
    };
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const E3 = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g, A3 = "^(?:(?:<protocols>):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))", x3 = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i, I3 = /^((\w+:(\/{2,})?)|(\W))/i, S3 = [
  "https?",
  "ftps?",
  "mailto"
], Mi = "Ctrl+K";
function P3(i) {
  return i.is("attributeElement") && !!i.getCustomProperty("link");
}
function Yd(i, { writer: e }) {
  const t = e.createAttributeElement("a", { href: i }, { priority: 5 });
  return e.setCustomProperty("link", !0, t), t;
}
function Ap(i, e = S3) {
  const t = String(i), n = e.join("|"), s = new RegExp(`${A3.replace("<protocols>", n)}`, "i");
  return R3(t, s) ? t : "#";
}
function R3(i, e) {
  return !!i.replace(E3, "").match(e);
}
function V3(i, e) {
  const t = {
    "Open in a new tab": i("Open in a new tab"),
    Downloadable: i("Downloadable")
  };
  return e.forEach((n) => ("label" in n && t[n.label] && (n.label = t[n.label]), n)), e;
}
function M3(i) {
  const e = [];
  if (i)
    for (const [t, n] of Object.entries(i)) {
      const s = Object.assign({}, n, { id: `link${c_(t)}` });
      e.push(s);
    }
  return e;
}
function Aa(i, e) {
  return i ? e.checkAttribute(i.name, "linkHref") : !1;
}
function B3(i) {
  return x3.test(i);
}
function $l(i, e) {
  const t = B3(i) ? "mailto:" : e, n = !!t && !xp(i);
  return i && n ? t + i : i;
}
function xp(i) {
  return I3.test(i);
}
function eh(i) {
  window.open(i, "_blank", "noopener");
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class L3 extends V {
  constructor() {
    super(...arguments), this.manualDecorators = new ke(), this.automaticDecorators = new T3();
  }
  /**
   * Synchronizes the state of {@link #manualDecorators} with the currently present elements in the model.
   */
  restoreManualDecoratorStates() {
    for (const e of this.manualDecorators)
      e.value = this._getDecoratorStateFromModel(e.id);
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor.model, t = e.document.selection, n = t.getSelectedElement() || me(t.getSelectedBlocks());
    Aa(n, e.schema) ? (this.value = n.getAttribute("linkHref"), this.isEnabled = e.schema.checkAttribute(n, "linkHref")) : (this.value = t.getAttribute("linkHref"), this.isEnabled = e.schema.checkAttributeInSelection(t, "linkHref"));
    for (const s of this.manualDecorators)
      s.value = this._getDecoratorStateFromModel(s.id);
  }
  /**
   * Executes the command.
   *
   * When the selection is non-collapsed, the `linkHref` attribute will be applied to nodes inside the selection, but only to
   * those nodes where the `linkHref` attribute is allowed (disallowed nodes will be omitted).
   *
   * When the selection is collapsed and is not inside the text with the `linkHref` attribute, a
   * new {@link module:engine/model/text~Text text node} with the `linkHref` attribute will be inserted in place of the caret, but
   * only if such element is allowed in this place. The `_data` of the inserted text will equal the `href` parameter.
   * The selection will be updated to wrap the just inserted text node.
   *
   * When the selection is collapsed and inside the text with the `linkHref` attribute, the attribute value will be updated.
   *
   * # Decorators and model attribute management
   *
   * There is an optional argument to this command that applies or removes model
   * {@glink framework/architecture/editing-engine#text-attributes text attributes} brought by
   * {@link module:link/utils/manualdecorator~ManualDecorator manual link decorators}.
   *
   * Text attribute names in the model correspond to the entries in the {@link module:link/linkconfig~LinkConfig#decorators
   * configuration}.
   * For every decorator configured, a model text attribute exists with the "link" prefix. For example, a `'linkMyDecorator'` attribute
   * corresponds to `'myDecorator'` in the configuration.
   *
   * To learn more about link decorators, check out the {@link module:link/linkconfig~LinkConfig#decorators `config.link.decorators`}
   * documentation.
   *
   * Here is how to manage decorator attributes with the link command:
   *
   * ```ts
   * const linkCommand = editor.commands.get( 'link' );
   *
   * // Adding a new decorator attribute.
   * linkCommand.execute( 'http://example.com', {
   * 	linkIsExternal: true
   * } );
   *
   * // Removing a decorator attribute from the selection.
   * linkCommand.execute( 'http://example.com', {
   * 	linkIsExternal: false
   * } );
   *
   * // Adding multiple decorator attributes at the same time.
   * linkCommand.execute( 'http://example.com', {
   * 	linkIsExternal: true,
   * 	linkIsDownloadable: true,
   * } );
   *
   * // Removing and adding decorator attributes at the same time.
   * linkCommand.execute( 'http://example.com', {
   * 	linkIsExternal: false,
   * 	linkFoo: true,
   * 	linkIsDownloadable: false,
   * } );
   * ```
   *
   * **Note**: If the decorator attribute name is not specified, its state remains untouched.
   *
   * **Note**: {@link module:link/unlinkcommand~UnlinkCommand#execute `UnlinkCommand#execute()`} removes all
   * decorator attributes.
   *
   * @fires execute
   * @param href Link destination.
   * @param manualDecoratorIds The information about manual decorator attributes to be applied or removed upon execution.
   */
  execute(e, t = {}) {
    const n = this.editor.model, s = n.document.selection, o = [], r = [];
    for (const a in t)
      t[a] ? o.push(a) : r.push(a);
    n.change((a) => {
      if (s.isCollapsed) {
        const l = s.getFirstPosition();
        if (s.hasAttribute("linkHref")) {
          const c = th(s);
          let u = er(l, "linkHref", s.getAttribute("linkHref"), n);
          s.getAttribute("linkHref") === c && (u = this._updateLinkContent(n, a, u, e)), a.setAttribute("linkHref", e, u), o.forEach((d) => {
            a.setAttribute(d, !0, u);
          }), r.forEach((d) => {
            a.removeAttribute(d, u);
          }), a.setSelection(a.createPositionAfter(u.end.nodeBefore));
        } else if (e !== "") {
          const c = pt(s.getAttributes());
          c.set("linkHref", e), o.forEach((d) => {
            c.set(d, !0);
          });
          const { end: u } = n.insertContent(a.createText(e, c), l);
          a.setSelection(u);
        }
        ["linkHref", ...o, ...r].forEach((c) => {
          a.removeSelectionAttribute(c);
        });
      } else {
        const l = n.schema.getValidRanges(s.getRanges(), "linkHref"), c = [];
        for (const d of s.getSelectedBlocks())
          n.schema.checkAttribute(d, "linkHref") && c.push(a.createRangeOn(d));
        const u = c.slice();
        for (const d of l)
          this._isRangeToUpdate(d, c) && u.push(d);
        for (const d of u) {
          let h = d;
          if (u.length === 1) {
            const f = th(s);
            s.getAttribute("linkHref") === f && (h = this._updateLinkContent(n, a, d, e), a.setSelection(a.createSelection(h)));
          }
          a.setAttribute("linkHref", e, h), o.forEach((f) => {
            a.setAttribute(f, !0, h);
          }), r.forEach((f) => {
            a.removeAttribute(f, h);
          });
        }
      }
    });
  }
  /**
   * Provides information whether a decorator with a given name is present in the currently processed selection.
   *
   * @param decoratorName The name of the manual decorator used in the model
   * @returns The information whether a given decorator is currently present in the selection.
   */
  _getDecoratorStateFromModel(e) {
    const t = this.editor.model, n = t.document.selection, s = n.getSelectedElement();
    return Aa(s, t.schema) ? s.getAttribute(e) : n.getAttribute(e);
  }
  /**
   * Checks whether specified `range` is inside an element that accepts the `linkHref` attribute.
   *
   * @param range A range to check.
   * @param allowedRanges An array of ranges created on elements where the attribute is accepted.
   */
  _isRangeToUpdate(e, t) {
    for (const n of t)
      if (n.containsRange(e))
        return !1;
    return !0;
  }
  /**
   * Updates selected link with a new value as its content and as its href attribute.
   *
   * @param model Model is need to insert content.
   * @param writer Writer is need to create text element in model.
   * @param range A range where should be inserted content.
   * @param href A link value which should be in the href attribute and in the content.
   */
  _updateLinkContent(e, t, n, s) {
    const o = t.createText(s, { linkHref: s });
    return e.insertContent(o, n);
  }
}
function th(i) {
  if (i.isCollapsed) {
    const e = i.getFirstPosition();
    return e.textNode && e.textNode.data;
  } else {
    const e = Array.from(i.getFirstRange().getItems());
    if (e.length > 1)
      return null;
    const t = e[0];
    return t.is("$text") || t.is("$textProxy") ? t.data : null;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class O3 extends V {
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor.model, t = e.document.selection, n = t.getSelectedElement();
    Aa(n, e.schema) ? this.isEnabled = e.schema.checkAttribute(n, "linkHref") : this.isEnabled = e.schema.checkAttributeInSelection(t, "linkHref");
  }
  /**
   * Executes the command.
   *
   * When the selection is collapsed, it removes the `linkHref` attribute from each node with the same `linkHref` attribute value.
   * When the selection is non-collapsed, it removes the `linkHref` attribute from each node in selected ranges.
   *
   * # Decorators
   *
   * If {@link module:link/linkconfig~LinkConfig#decorators `config.link.decorators`} is specified,
   * all configured decorators are removed together with the `linkHref` attribute.
   *
   * @fires execute
   */
  execute() {
    const e = this.editor, t = this.editor.model, n = t.document.selection, s = e.commands.get("link");
    t.change((o) => {
      const r = n.isCollapsed ? [er(n.getFirstPosition(), "linkHref", n.getAttribute("linkHref"), t)] : t.schema.getValidRanges(n.getRanges(), "linkHref");
      for (const a of r)
        if (o.removeAttribute("linkHref", a), s)
          for (const l of s.manualDecorators)
            o.removeAttribute(l.id, a);
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class F3 extends U() {
  /**
   * Creates a new instance of {@link module:link/utils/manualdecorator~ManualDecorator}.
   *
   * @param config.id The name of the attribute used in the model that represents a given manual decorator.
   * For example: `'linkIsExternal'`.
   * @param config.label The label used in the user interface to toggle the manual decorator.
   * @param config.attributes A set of attributes added to output data when the decorator is active for a specific link.
   * Attributes should keep the format of attributes defined in {@link module:engine/view/elementdefinition~ElementDefinition}.
   * @param [config.defaultValue] Controls whether the decorator is "on" by default.
   */
  constructor({ id: e, label: t, attributes: n, classes: s, styles: o, defaultValue: r }) {
    super(), this.id = e, this.set("value", void 0), this.defaultValue = r, this.label = t, this.attributes = n, this.classes = s, this.styles = o;
  }
  /**
   * Returns {@link module:engine/view/matcher~MatcherPattern} with decorator attributes.
   *
   * @internal
   */
  _createPattern() {
    return {
      attributes: this.attributes,
      classes: this.classes,
      styles: this.styles
    };
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const N3 = "ck-link_selected", nh = "automatic", D3 = "manual", z3 = /^(https?:)?\/\//;
class dr extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "LinkEditing";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Eo, hg, Ze];
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), e.config.define("link", {
      allowCreatingEmptyLinks: !1,
      addTargetToExternalLinks: !1
    });
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = this.editor.config.get("link.allowedProtocols");
    e.model.schema.extend("$text", { allowAttributes: "linkHref" }), e.conversion.for("dataDowncast").attributeToElement({ model: "linkHref", view: Yd }), e.conversion.for("editingDowncast").attributeToElement({ model: "linkHref", view: (o, r) => Yd(Ap(o, t), r) }), e.conversion.for("upcast").elementToAttribute({
      view: {
        name: "a",
        attributes: {
          href: !0
        }
      },
      model: {
        key: "linkHref",
        value: (o) => o.getAttribute("href")
      }
    }), e.commands.add("link", new L3(e)), e.commands.add("unlink", new O3(e));
    const n = V3(e.t, M3(e.config.get("link.decorators")));
    this._enableAutomaticDecorators(n.filter((o) => o.mode === nh)), this._enableManualDecorators(n.filter((o) => o.mode === D3)), e.plugins.get(Eo).registerAttribute("linkHref"), bg(e, "linkHref", "a", N3), this._enableLinkOpen(), this._enableSelectionAttributesFixer(), this._enableClipboardIntegration();
  }
  /**
   * Processes an array of configured {@link module:link/linkconfig~LinkDecoratorAutomaticDefinition automatic decorators}
   * and registers a {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher downcast dispatcher}
   * for each one of them. Downcast dispatchers are obtained using the
   * {@link module:link/utils/automaticdecorators~AutomaticDecorators#getDispatcher} method.
   *
   * **Note**: This method also activates the automatic external link decorator if enabled with
   * {@link module:link/linkconfig~LinkConfig#addTargetToExternalLinks `config.link.addTargetToExternalLinks`}.
   */
  _enableAutomaticDecorators(e) {
    const t = this.editor, s = t.commands.get("link").automaticDecorators;
    t.config.get("link.addTargetToExternalLinks") && s.add({
      id: "linkIsExternal",
      mode: nh,
      callback: (o) => !!o && z3.test(o),
      attributes: {
        target: "_blank",
        rel: "noopener noreferrer"
      }
    }), s.add(e), s.length && t.conversion.for("downcast").add(s.getDispatcher());
  }
  /**
   * Processes an array of configured {@link module:link/linkconfig~LinkDecoratorManualDefinition manual decorators},
   * transforms them into {@link module:link/utils/manualdecorator~ManualDecorator} instances and stores them in the
   * {@link module:link/linkcommand~LinkCommand#manualDecorators} collection (a model for manual decorators state).
   *
   * Also registers an {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement attribute-to-element}
   * converter for each manual decorator and extends the {@link module:engine/model/schema~Schema model's schema}
   * with adequate model attributes.
   */
  _enableManualDecorators(e) {
    if (!e.length)
      return;
    const t = this.editor, s = t.commands.get("link").manualDecorators;
    e.forEach((o) => {
      t.model.schema.extend("$text", { allowAttributes: o.id });
      const r = new F3(o);
      s.add(r), t.conversion.for("downcast").attributeToElement({
        model: r.id,
        view: (a, { writer: l, schema: c }, { item: u }) => {
          if ((u.is("selection") || c.isInline(u)) && a) {
            const d = l.createAttributeElement("a", r.attributes, { priority: 5 });
            r.classes && l.addClass(r.classes, d);
            for (const h in r.styles)
              l.setStyle(h, r.styles[h], d);
            return l.setCustomProperty("link", !0, d), d;
          }
        }
      }), t.conversion.for("upcast").elementToAttribute({
        view: {
          name: "a",
          ...r._createPattern()
        },
        model: {
          key: r.id
        }
      });
    });
  }
  /**
   * Attaches handlers for {@link module:engine/view/document~Document#event:enter} and
   * {@link module:engine/view/document~Document#event:click} to enable link following.
   */
  _enableLinkOpen() {
    const e = this.editor, n = e.editing.view.document;
    this.listenTo(n, "click", (s, o) => {
      if (!(M.isMac ? o.domEvent.metaKey : o.domEvent.ctrlKey))
        return;
      let a = o.domTarget;
      if (a.tagName.toLowerCase() != "a" && (a = a.closest("a")), !a)
        return;
      const l = a.getAttribute("href");
      l && (s.stop(), o.preventDefault(), eh(l));
    }, { context: "$capture" }), this.listenTo(n, "keydown", (s, o) => {
      const a = e.commands.get("link").value;
      a && o.keyCode === N.enter && o.altKey && (s.stop(), eh(a));
    });
  }
  /**
   * Watches the DocumentSelection attribute changes and removes link decorator attributes when the linkHref attribute is removed.
   *
   * This is to ensure that there is no left-over link decorator attributes on the document selection that is no longer in a link.
   */
  _enableSelectionAttributesFixer() {
    const t = this.editor.model, n = t.document.selection;
    this.listenTo(n, "change:attribute", (s, { attributeKeys: o }) => {
      !o.includes("linkHref") || n.hasAttribute("linkHref") || t.change((r) => {
        H3(r, U3(t.schema));
      });
    });
  }
  /**
   * Enables URL fixing on pasting.
   */
  _enableClipboardIntegration() {
    const e = this.editor, t = e.model, n = this.editor.config.get("link.defaultProtocol");
    n && this.listenTo(e.plugins.get("ClipboardPipeline"), "contentInsertion", (s, o) => {
      t.change((r) => {
        const a = r.createRangeIn(o.content);
        for (const l of a.getItems())
          if (l.hasAttribute("linkHref")) {
            const c = $l(l.getAttribute("linkHref"), n);
            r.setAttribute("linkHref", c, l);
          }
      });
    });
  }
}
function H3(i, e) {
  i.removeSelectionAttribute("linkHref");
  for (const t of e)
    i.removeSelectionAttribute(t);
}
function U3(i) {
  return i.getDefinition("$text").allowAttributes.filter((t) => t.startsWith("link"));
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class $3 extends T {
  /**
   * Creates an instance of the {@link module:link/ui/linkformview~LinkFormView} class.
   *
   * Also see {@link #render}.
   *
   * @param locale The localization services instance.
   * @param linkCommand Reference to {@link module:link/linkcommand~LinkCommand}.
   * @param validators  Form validators used by {@link #isValid}.
   */
  constructor(e, t, n) {
    super(e), this.focusTracker = new X(), this.keystrokes = new ie(), this._focusables = new ve();
    const s = e.t;
    this._validators = n, this.urlInputView = this._createUrlInput(), this.saveButtonView = this._createButton(s("Save"), A.check, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(s("Cancel"), A.cancel, "ck-button-cancel", "cancel"), this._manualDecoratorSwitches = this._createManualDecoratorSwitches(t), this.children = this._createFormChildren(t.manualDecorators), this._focusCycler = new ge({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    });
    const o = ["ck", "ck-link-form", "ck-responsive-form"];
    t.manualDecorators.length && o.push("ck-link-form_layout-vertical", "ck-vertical-form"), this.setTemplate({
      tag: "form",
      attributes: {
        class: o,
        // https://github.com/ckeditor/ckeditor5-link/issues/90
        tabindex: "-1"
      },
      children: this.children
    });
  }
  /**
   * Obtains the state of the {@link module:ui/button/switchbuttonview~SwitchButtonView switch buttons} representing
   * {@link module:link/linkcommand~LinkCommand#manualDecorators manual link decorators}
   * in the {@link module:link/ui/linkformview~LinkFormView}.
   *
   * @returns Key-value pairs, where the key is the name of the decorator and the value is its state.
   */
  getDecoratorSwitchesState() {
    return Array.from(this._manualDecoratorSwitches).reduce((e, t) => (e[t.name] = t.isOn, e), {});
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), Cn({
      view: this
    }), [
      this.urlInputView,
      ...this._manualDecoratorSwitches,
      this.saveButtonView,
      this.cancelButtonView
    ].forEach((t) => {
      this._focusables.add(t), this.focusTracker.add(t.element);
    }), this.keystrokes.listenTo(this.element);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  /**
   * Focuses the fist {@link #_focusables} in the form.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
   * Validates the form and returns `false` when some fields are invalid.
   */
  isValid() {
    this.resetFormStatus();
    for (const e of this._validators) {
      const t = e(this);
      if (t)
        return this.urlInputView.errorText = t, !1;
    }
    return !0;
  }
  /**
   * Cleans up the supplementary error and information text of the {@link #urlInputView}
   * bringing them back to the state when the form has been displayed for the first time.
   *
   * See {@link #isValid}.
   */
  resetFormStatus() {
    this.urlInputView.errorText = null;
  }
  /**
   * Creates a labeled input view.
   *
   * @returns Labeled field view instance.
   */
  _createUrlInput() {
    const e = this.locale.t, t = new ue(this.locale, He);
    return t.label = e("Link URL"), t;
  }
  /**
   * Creates a button view.
   *
   * @param label The button label.
   * @param icon The button icon.
   * @param className The additional button CSS class name.
   * @param eventName An event name that the `ButtonView#execute` event will be delegated to.
   * @returns The button view instance.
   */
  _createButton(e, t, n, s) {
    const o = new P(this.locale);
    return o.set({
      label: e,
      icon: t,
      tooltip: !0
    }), o.extendTemplate({
      attributes: {
        class: n
      }
    }), s && o.delegate("execute").to(this, s), o;
  }
  /**
   * Populates {@link module:ui/viewcollection~ViewCollection} of {@link module:ui/button/switchbuttonview~SwitchButtonView}
   * made based on {@link module:link/linkcommand~LinkCommand#manualDecorators}.
   *
   * @param linkCommand A reference to the link command.
   * @returns ViewCollection of switch buttons.
   */
  _createManualDecoratorSwitches(e) {
    const t = this.createCollection();
    for (const n of e.manualDecorators) {
      const s = new nr(this.locale);
      s.set({
        name: n.id,
        label: n.label,
        withText: !0
      }), s.bind("isOn").toMany([n, e], "value", (o, r) => r === void 0 && o === void 0 ? !!n.defaultValue : !!o), s.on("execute", () => {
        n.set("value", !s.isOn);
      }), t.add(s);
    }
    return t;
  }
  /**
   * Populates the {@link #children} collection of the form.
   *
   * If {@link module:link/linkcommand~LinkCommand#manualDecorators manual decorators} are configured in the editor, it creates an
   * additional `View` wrapping all {@link #_manualDecoratorSwitches} switch buttons corresponding
   * to these decorators.
   *
   * @param manualDecorators A reference to
   * the collection of manual decorators stored in the link command.
   * @returns The children of link form view.
   */
  _createFormChildren(e) {
    const t = this.createCollection();
    if (t.add(this.urlInputView), e.length) {
      const n = new T();
      n.setTemplate({
        tag: "ul",
        children: this._manualDecoratorSwitches.map((s) => ({
          tag: "li",
          children: [s],
          attributes: {
            class: [
              "ck",
              "ck-list__item"
            ]
          }
        })),
        attributes: {
          class: [
            "ck",
            "ck-reset",
            "ck-list"
          ]
        }
      }), t.add(n);
    }
    return t.add(this.saveButtonView), t.add(this.cancelButtonView), t;
  }
  /**
   * The native DOM `value` of the {@link #urlInputView} element.
   *
   * **Note**: Do not confuse it with the {@link module:ui/inputtext/inputtextview~InputTextView#value}
   * which works one way only and may not represent the actual state of the component in the DOM.
   */
  get url() {
    const { element: e } = this.urlInputView.fieldView;
    return e ? e.value.trim() : null;
  }
}
const W3 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>';
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class q3 extends T {
  /**
   * @inheritDoc
   */
  constructor(e, t = {}) {
    super(e), this.focusTracker = new X(), this.keystrokes = new ie(), this._focusables = new ve();
    const n = e.t;
    this.previewButtonView = this._createPreviewButton(), this.unlinkButtonView = this._createButton(n("Unlink"), W3, "unlink"), this.editButtonView = this._createButton(n("Edit link"), A.pencil, "edit"), this.set("href", void 0), this._linkConfig = t, this._focusCycler = new ge({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate fields forwards using the Tab key.
        focusNext: "tab"
      }
    }), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-link-actions",
          "ck-responsive-form"
        ],
        // https://github.com/ckeditor/ckeditor5-link/issues/90
        tabindex: "-1"
      },
      children: [
        this.previewButtonView,
        this.editButtonView,
        this.unlinkButtonView
      ]
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), [
      this.previewButtonView,
      this.editButtonView,
      this.unlinkButtonView
    ].forEach((t) => {
      this._focusables.add(t), this.focusTracker.add(t.element);
    }), this.keystrokes.listenTo(this.element);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  /**
   * Focuses the fist {@link #_focusables} in the actions.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
   * Creates a button view.
   *
   * @param label The button label.
   * @param icon The button icon.
   * @param eventName An event name that the `ButtonView#execute` event will be delegated to.
   * @returns The button view instance.
   */
  _createButton(e, t, n) {
    const s = new P(this.locale);
    return s.set({
      label: e,
      icon: t,
      tooltip: !0
    }), s.delegate("execute").to(this, n), s;
  }
  /**
   * Creates a link href preview button.
   *
   * @returns The button view instance.
   */
  _createPreviewButton() {
    const e = new P(this.locale), t = this.bindTemplate, n = this.t;
    return e.set({
      withText: !0,
      tooltip: n("Open link in new tab")
    }), e.extendTemplate({
      attributes: {
        class: [
          "ck",
          "ck-link-actions__preview"
        ],
        href: t.to("href", (s) => s && Ap(s, this._linkConfig.allowedProtocols)),
        target: "_blank",
        rel: "noopener noreferrer"
      }
    }), e.bind("label").to(this, "href", (s) => s || n("This link has no URL")), e.bind("isEnabled").to(this, "href", (s) => !!s), e.template.tag = "a", e.template.eventListeners = {}, e;
  }
}
const Ip = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>';
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const dt = "link-ui";
class Sp extends b {
  constructor() {
    super(...arguments), this.actionsView = null, this.formView = null;
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Rt];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "LinkUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = this.editor.t;
    e.editing.view.addObserver(_5), this._balloon = e.plugins.get(Rt), this._createToolbarLinkButton(), this._enableBalloonActivators(), e.conversion.for("editingDowncast").markerToHighlight({
      model: dt,
      view: {
        classes: ["ck-fake-link-selection"]
      }
    }), e.conversion.for("editingDowncast").markerToElement({
      model: dt,
      view: {
        name: "span",
        classes: ["ck-fake-link-selection", "ck-fake-link-selection_collapsed"]
      }
    }), e.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: t("Create link"),
          keystroke: Mi
        },
        {
          label: t("Move out of a link"),
          keystroke: [
            ["arrowleft", "arrowleft"],
            ["arrowright", "arrowright"]
          ]
        }
      ]
    });
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.formView && this.formView.destroy(), this.actionsView && this.actionsView.destroy();
  }
  /**
   * Creates views.
   */
  _createViews() {
    this.actionsView = this._createActionsView(), this.formView = this._createFormView(), this._enableUserBalloonInteractions();
  }
  /**
   * Creates the {@link module:link/ui/linkactionsview~LinkActionsView} instance.
   */
  _createActionsView() {
    const e = this.editor, t = new q3(e.locale, e.config.get("link")), n = e.commands.get("link"), s = e.commands.get("unlink");
    return t.bind("href").to(n, "value"), t.editButtonView.bind("isEnabled").to(n), t.unlinkButtonView.bind("isEnabled").to(s), this.listenTo(t, "edit", () => {
      this._addFormView();
    }), this.listenTo(t, "unlink", () => {
      e.execute("unlink"), this._hideUI();
    }), t.keystrokes.set("Esc", (o, r) => {
      this._hideUI(), r();
    }), t.keystrokes.set(Mi, (o, r) => {
      this._addFormView(), r();
    }), t;
  }
  /**
   * Creates the {@link module:link/ui/linkformview~LinkFormView} instance.
   */
  _createFormView() {
    const e = this.editor, t = e.commands.get("link"), n = e.config.get("link.defaultProtocol"), s = new (tr($3))(e.locale, t, G3(e));
    return s.urlInputView.fieldView.bind("value").to(t, "value"), s.urlInputView.bind("isEnabled").to(t, "isEnabled"), s.saveButtonView.bind("isEnabled").to(t, "isEnabled"), this.listenTo(s, "submit", () => {
      if (s.isValid()) {
        const { value: o } = s.urlInputView.fieldView.element, r = $l(o, n);
        e.execute("link", r, s.getDecoratorSwitchesState()), this._closeFormView();
      }
    }), this.listenTo(s.urlInputView, "change:errorText", () => {
      e.ui.update();
    }), this.listenTo(s, "cancel", () => {
      this._closeFormView();
    }), s.keystrokes.set("Esc", (o, r) => {
      this._closeFormView(), r();
    }), s;
  }
  /**
   * Creates a toolbar Link button. Clicking this button will show
   * a {@link #_balloon} attached to the selection.
   */
  _createToolbarLinkButton() {
    const e = this.editor, t = e.commands.get("link");
    e.ui.componentFactory.add("link", () => {
      const n = this._createButton(P);
      return n.set({
        tooltip: !0,
        isToggleable: !0
      }), n.bind("isOn").to(t, "value", (s) => !!s), n;
    }), e.ui.componentFactory.add("menuBar:link", () => this._createButton(de));
  }
  /**
   * Creates a button for link command to use either in toolbar or in menu bar.
   */
  _createButton(e) {
    const t = this.editor, n = t.locale, s = t.commands.get("link"), o = new e(t.locale), r = n.t;
    return o.set({
      label: r("Link"),
      icon: Ip,
      keystroke: Mi
    }), o.bind("isEnabled").to(s, "isEnabled"), this.listenTo(o, "execute", () => this._showUI(!0)), o;
  }
  /**
   * Attaches actions that control whether the balloon panel containing the
   * {@link #formView} should be displayed.
   */
  _enableBalloonActivators() {
    const e = this.editor, t = e.editing.view.document;
    this.listenTo(t, "click", () => {
      this._getSelectedLinkElement() && this._showUI();
    }), e.keystrokes.set(Mi, (n, s) => {
      s(), e.commands.get("link").isEnabled && this._showUI(!0);
    });
  }
  /**
   * Attaches actions that control whether the balloon panel containing the
   * {@link #formView} is visible or not.
   */
  _enableUserBalloonInteractions() {
    this.editor.keystrokes.set("Tab", (e, t) => {
      this._areActionsVisible && !this.actionsView.focusTracker.isFocused && (this.actionsView.focus(), t());
    }, {
      // Use the high priority because the link UI navigation is more important
      // than other feature's actions, e.g. list indentation.
      // https://github.com/ckeditor/ckeditor5-link/issues/146
      priority: "high"
    }), this.editor.keystrokes.set("Esc", (e, t) => {
      this._isUIVisible && (this._hideUI(), t());
    }), yn({
      emitter: this.formView,
      activator: () => this._isUIInPanel,
      contextElements: () => [this._balloon.view.element],
      callback: () => this._hideUI()
    });
  }
  /**
   * Adds the {@link #actionsView} to the {@link #_balloon}.
   *
   * @internal
   */
  _addActionsView() {
    this.actionsView || this._createViews(), !this._areActionsInPanel && this._balloon.add({
      view: this.actionsView,
      position: this._getBalloonPositionData()
    });
  }
  /**
   * Adds the {@link #formView} to the {@link #_balloon}.
   */
  _addFormView() {
    if (this.formView || this._createViews(), this._isFormInPanel)
      return;
    const t = this.editor.commands.get("link");
    this.formView.disableCssTransitions(), this.formView.resetFormStatus(), this._balloon.add({
      view: this.formView,
      position: this._getBalloonPositionData()
    }), this.formView.urlInputView.fieldView.value = t.value || "", this._balloon.visibleView === this.formView && this.formView.urlInputView.fieldView.select(), this.formView.enableCssTransitions();
  }
  /**
   * Closes the form view. Decides whether the balloon should be hidden completely or if the action view should be shown. This is
   * decided upon the link command value (which has a value if the document selection is in the link).
   *
   * Additionally, if any {@link module:link/linkconfig~LinkConfig#decorators} are defined in the editor configuration, the state of
   * switch buttons responsible for manual decorator handling is restored.
   */
  _closeFormView() {
    const e = this.editor.commands.get("link");
    e.restoreManualDecoratorStates(), e.value !== void 0 ? this._removeFormView() : this._hideUI();
  }
  /**
   * Removes the {@link #formView} from the {@link #_balloon}.
   */
  _removeFormView() {
    this._isFormInPanel && (this.formView.saveButtonView.focus(), this.formView.urlInputView.fieldView.reset(), this._balloon.remove(this.formView), this.editor.editing.view.focus(), this._hideFakeVisualSelection());
  }
  /**
   * Shows the correct UI type. It is either {@link #formView} or {@link #actionsView}.
   *
   * @internal
   */
  _showUI(e = !1) {
    this.formView || this._createViews(), this._getSelectedLinkElement() ? (this._areActionsVisible ? this._addFormView() : this._addActionsView(), e && this._balloon.showStack("main")) : (this._showFakeVisualSelection(), this._addActionsView(), e && this._balloon.showStack("main"), this._addFormView()), this._startUpdatingUI();
  }
  /**
   * Removes the {@link #formView} from the {@link #_balloon}.
   *
   * See {@link #_addFormView}, {@link #_addActionsView}.
   */
  _hideUI() {
    if (!this._isUIInPanel)
      return;
    const e = this.editor;
    this.stopListening(e.ui, "update"), this.stopListening(this._balloon, "change:visibleView"), e.editing.view.focus(), this._removeFormView(), this._balloon.remove(this.actionsView), this._hideFakeVisualSelection();
  }
  /**
   * Makes the UI react to the {@link module:ui/editorui/editorui~EditorUI#event:update} event to
   * reposition itself when the editor UI should be refreshed.
   *
   * See: {@link #_hideUI} to learn when the UI stops reacting to the `update` event.
   */
  _startUpdatingUI() {
    const e = this.editor, t = e.editing.view.document;
    let n = this._getSelectedLinkElement(), s = r();
    const o = () => {
      const a = this._getSelectedLinkElement(), l = r();
      n && !a || !n && l !== s ? this._hideUI() : this._isUIVisible && this._balloon.updatePosition(this._getBalloonPositionData()), n = a, s = l;
    };
    function r() {
      return t.selection.focus.getAncestors().reverse().find((a) => a.is("element"));
    }
    this.listenTo(e.ui, "update", o), this.listenTo(this._balloon, "change:visibleView", o);
  }
  /**
   * Returns `true` when {@link #formView} is in the {@link #_balloon}.
   */
  get _isFormInPanel() {
    return !!this.formView && this._balloon.hasView(this.formView);
  }
  /**
   * Returns `true` when {@link #actionsView} is in the {@link #_balloon}.
   */
  get _areActionsInPanel() {
    return !!this.actionsView && this._balloon.hasView(this.actionsView);
  }
  /**
   * Returns `true` when {@link #actionsView} is in the {@link #_balloon} and it is
   * currently visible.
   */
  get _areActionsVisible() {
    return !!this.actionsView && this._balloon.visibleView === this.actionsView;
  }
  /**
   * Returns `true` when {@link #actionsView} or {@link #formView} is in the {@link #_balloon}.
   */
  get _isUIInPanel() {
    return this._isFormInPanel || this._areActionsInPanel;
  }
  /**
   * Returns `true` when {@link #actionsView} or {@link #formView} is in the {@link #_balloon} and it is
   * currently visible.
   */
  get _isUIVisible() {
    const e = this._balloon.visibleView;
    return !!this.formView && e == this.formView || this._areActionsVisible;
  }
  /**
   * Returns positioning options for the {@link #_balloon}. They control the way the balloon is attached
   * to the target element or selection.
   *
   * If the selection is collapsed and inside a link element, the panel will be attached to the
   * entire link element. Otherwise, it will be attached to the selection.
   */
  _getBalloonPositionData() {
    const e = this.editor.editing.view, t = this.editor.model, n = e.document;
    let s;
    if (t.markers.has(dt)) {
      const o = Array.from(this.editor.editing.mapper.markerNameToElements(dt)), r = e.createRange(e.createPositionBefore(o[0]), e.createPositionAfter(o[o.length - 1]));
      s = e.domConverter.viewRangeToDom(r);
    } else
      s = () => {
        const o = this._getSelectedLinkElement();
        return o ? (
          // When selection is inside link element, then attach panel to this element.
          e.domConverter.mapViewToDom(o)
        ) : (
          // Otherwise attach panel to the selection.
          e.domConverter.viewRangeToDom(n.selection.getFirstRange())
        );
      };
    return { target: s };
  }
  /**
   * Returns the link {@link module:engine/view/attributeelement~AttributeElement} under
   * the {@link module:engine/view/document~Document editing view's} selection or `null`
   * if there is none.
   *
   * **Note**: For a non–collapsed selection, the link element is returned when **fully**
   * selected and the **only** element within the selection boundaries, or when
   * a linked widget is selected.
   */
  _getSelectedLinkElement() {
    const e = this.editor.editing.view, t = e.document.selection, n = t.getSelectedElement();
    if (t.isCollapsed || n && ae(n))
      return Ur(t.getFirstPosition());
    {
      const s = t.getFirstRange().getTrimmed(), o = Ur(s.start), r = Ur(s.end);
      return !o || o != r ? null : e.createRangeIn(o).getTrimmed().isEqual(s) ? o : null;
    }
  }
  /**
   * Displays a fake visual selection when the contextual balloon is displayed.
   *
   * This adds a 'link-ui' marker into the document that is rendered as a highlight on selected text fragment.
   */
  _showFakeVisualSelection() {
    const e = this.editor.model;
    e.change((t) => {
      const n = e.document.selection.getFirstRange();
      if (e.markers.has(dt))
        t.updateMarker(dt, { range: n });
      else if (n.start.isAtEnd) {
        const s = n.start.getLastMatchingPosition(({ item: o }) => !e.schema.isContent(o), { boundaries: n });
        t.addMarker(dt, {
          usingOperation: !1,
          affectsData: !1,
          range: t.createRange(s, n.end)
        });
      } else
        t.addMarker(dt, {
          usingOperation: !1,
          affectsData: !1,
          range: n
        });
    });
  }
  /**
   * Hides the fake visual selection created in {@link #_showFakeVisualSelection}.
   */
  _hideFakeVisualSelection() {
    const e = this.editor.model;
    e.markers.has(dt) && e.change((t) => {
      t.removeMarker(dt);
    });
  }
}
function Ur(i) {
  return i.getAncestors().find((e) => P3(e)) || null;
}
function G3(i) {
  const e = i.t, t = i.config.get("link.allowCreatingEmptyLinks");
  return [
    (n) => {
      if (!t && !n.url.length)
        return e("Link URL must not be empty.");
    }
  ];
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const j3 = 4, Pp = new RegExp(
  // Group 1: Line start or after a space.
  "(^|\\s)(((?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(((?!www\\.)|(www\\.))(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+(?:[a-z\\u00a1-\\uffff]{2,63})))(?::\\d{2,5})?(?:[/?#]\\S*)?)|((www.|(\\S+@))((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+(?:[a-z\\u00a1-\\uffff]{2,63})))$",
  "i"
), K3 = 2;
class Z3 extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [bt, dr];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "AutoLink";
  }
  /**
   * @inheritDoc
   */
  init() {
    const t = this.editor.model.document.selection;
    t.on("change:range", () => {
      this.isEnabled = !t.anchor.parent.is("element", "codeBlock");
    }), this._enableTypingHandling();
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    this._enableEnterHandling(), this._enableShiftEnterHandling(), this._enablePasteLinking();
  }
  /**
   * For given position, returns a range that includes the whole link that contains the position.
   *
   * If position is not inside a link, returns `null`.
   */
  _expandLinkRange(e, t) {
    return t.textNode && t.textNode.hasAttribute("linkHref") ? er(t, "linkHref", t.textNode.getAttribute("linkHref"), e) : null;
  }
  /**
   * Extends the document selection to includes all links that intersects with given `selectedRange`.
   */
  _selectEntireLinks(e, t) {
    const s = this.editor.model, o = s.document.selection, r = o.getFirstPosition(), a = o.getLastPosition();
    let l = t.getJoined(this._expandLinkRange(s, r) || t);
    l && (l = l.getJoined(this._expandLinkRange(s, a) || t)), l && (l.start.isBefore(r) || l.end.isAfter(a)) && e.setSelection(l);
  }
  /**
   * Enables autolinking on pasting a URL when some content is selected.
   */
  _enablePasteLinking() {
    const e = this.editor, t = e.model, n = t.document.selection, s = e.plugins.get("ClipboardPipeline"), o = e.commands.get("link");
    s.on("inputTransformation", (r, a) => {
      if (!this.isEnabled || !o.isEnabled || n.isCollapsed || a.method !== "paste" || n.rangeCount > 1)
        return;
      const l = n.getFirstRange(), c = a.dataTransfer.getData("text/plain");
      if (!c)
        return;
      const u = c.match(Pp);
      u && u[2] === c && (t.change((d) => {
        this._selectEntireLinks(d, l), o.execute(c);
      }), r.stop());
    }, { priority: "high" });
  }
  /**
   * Enables autolinking on typing.
   */
  _enableTypingHandling() {
    const e = this.editor, t = new pg(e.model, (n) => {
      if (!J3(n))
        return;
      const s = ih(n.substr(0, n.length - 1));
      if (s)
        return { url: s };
    });
    t.on("matched:data", (n, s) => {
      const { batch: o, range: r, url: a } = s;
      if (!o.isTyping)
        return;
      const l = r.end.getShiftedBy(-1), c = l.getShiftedBy(-a.length), u = e.model.createRange(c, l);
      this._applyAutoLink(a, u);
    }), t.bind("isEnabled").to(this);
  }
  /**
   * Enables autolinking on the <kbd>Enter</kbd> key.
   */
  _enableEnterHandling() {
    const e = this.editor, t = e.model, n = e.commands.get("enter");
    n && n.on("execute", () => {
      const s = t.document.selection.getFirstPosition();
      if (!s.parent.previousSibling)
        return;
      const o = t.createRangeIn(s.parent.previousSibling);
      this._checkAndApplyAutoLinkOnRange(o);
    });
  }
  /**
   * Enables autolinking on the <kbd>Shift</kbd>+<kbd>Enter</kbd> keyboard shortcut.
   */
  _enableShiftEnterHandling() {
    const e = this.editor, t = e.model, n = e.commands.get("shiftEnter");
    n && n.on("execute", () => {
      const s = t.document.selection.getFirstPosition(), o = t.createRange(t.createPositionAt(s.parent, 0), s.getShiftedBy(-1));
      this._checkAndApplyAutoLinkOnRange(o);
    });
  }
  /**
   * Checks if the passed range contains a linkable text.
   */
  _checkAndApplyAutoLinkOnRange(e) {
    const t = this.editor.model, { text: n, range: s } = gg(e, t), o = ih(n);
    if (o) {
      const r = t.createRange(s.end.getShiftedBy(-o.length), s.end);
      this._applyAutoLink(o, r);
    }
  }
  /**
   * Applies a link on a given range if the link should be applied.
   *
   * @param url The URL to link.
   * @param range The text range to apply the link attribute to.
   */
  _applyAutoLink(e, t) {
    const n = this.editor.model, s = this.editor.config.get("link.defaultProtocol"), o = $l(e, s);
    !this.isEnabled || !X3(t, n) || !xp(o) || Q3(t) || this._persistAutoLink(o, t);
  }
  /**
   * Enqueues autolink changes in the model.
   *
   * @param url The URL to link.
   * @param range The text range to apply the link attribute to.
   */
  _persistAutoLink(e, t) {
    const n = this.editor.model, s = this.editor.plugins.get("Delete");
    n.enqueueChange((o) => {
      o.setAttribute("linkHref", e, t), n.enqueueChange(() => {
        s.requestUndoOnBackspace();
      });
    });
  }
}
function J3(i) {
  return i.length > j3 && i[i.length - 1] === " " && i[i.length - 2] !== " ";
}
function ih(i) {
  const e = Pp.exec(i);
  return e ? e[K3] : null;
}
function X3(i, e) {
  return e.schema.checkAttributeInSelection(e.createSelection(i), "linkHref");
}
function Q3(i) {
  const e = i.start.nodeAfter;
  return !!e && e.hasAttribute("linkHref");
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Y3 extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [dr, Sp, Z3];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Link";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class e7 extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return ["ImageEditing", "ImageUtils", dr];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "LinkImageEditing";
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    const e = this.editor, t = e.model.schema;
    e.plugins.has("ImageBlockEditing") && t.extend("imageBlock", { allowAttributes: ["linkHref"] }), e.conversion.for("upcast").add(t7(e)), e.conversion.for("downcast").add(n7(e)), this._enableAutomaticDecorators(), this._enableManualDecorators();
  }
  /**
   * Processes {@link module:link/linkconfig~LinkDecoratorAutomaticDefinition automatic decorators} definitions and
   * attaches proper converters that will work when linking an image.`
   */
  _enableAutomaticDecorators() {
    const e = this.editor, n = e.commands.get("link").automaticDecorators;
    n.length && e.conversion.for("downcast").add(n.getDispatcherForLinkedImage());
  }
  /**
   * Processes transformed {@link module:link/utils/manualdecorator~ManualDecorator} instances and attaches proper converters
   * that will work when linking an image.
   */
  _enableManualDecorators() {
    const e = this.editor, t = e.commands.get("link");
    for (const n of t.manualDecorators)
      e.plugins.has("ImageBlockEditing") && e.model.schema.extend("imageBlock", { allowAttributes: n.id }), e.plugins.has("ImageInlineEditing") && e.model.schema.extend("imageInline", { allowAttributes: n.id }), e.conversion.for("downcast").add(i7(n)), e.conversion.for("upcast").add(s7(e, n));
  }
}
function t7(i) {
  const e = i.plugins.has("ImageInlineEditing"), t = i.plugins.get("ImageUtils");
  return (n) => {
    n.on("element:a", (s, o, r) => {
      const a = o.viewItem, l = t.findViewImgElement(a);
      if (!l)
        return;
      const c = l.findAncestor((f) => t.isBlockImageView(f));
      if (e && !c)
        return;
      const u = { attributes: ["href"] };
      if (!r.consumable.consume(a, u))
        return;
      const d = a.getAttribute("href");
      if (!d)
        return;
      let h = o.modelCursor.parent;
      if (!h.is("element", "imageBlock")) {
        const f = r.convertItem(l, o.modelCursor);
        o.modelRange = f.modelRange, o.modelCursor = f.modelCursor, h = o.modelCursor.nodeBefore;
      }
      h && h.is("element", "imageBlock") && r.writer.setAttribute("linkHref", d, h);
    }, { priority: "high" });
  };
}
function n7(i) {
  const e = i.plugins.get("ImageUtils");
  return (t) => {
    t.on("attribute:linkHref:imageBlock", (n, s, o) => {
      if (!o.consumable.consume(s.item, n.name))
        return;
      const r = o.mapper.toViewElement(s.item), a = o.writer, l = Array.from(r.getChildren()).find((d) => d.is("element", "a")), c = e.findViewImgElement(r), u = c.parent.is("element", "picture") ? c.parent : c;
      if (l)
        s.attributeNewValue ? a.setAttribute("href", s.attributeNewValue, l) : (a.move(a.createRangeOn(u), a.createPositionAt(r, 0)), a.remove(l));
      else {
        const d = a.createContainerElement("a", { href: s.attributeNewValue });
        a.insert(a.createPositionAt(r, 0), d), a.move(a.createRangeOn(u), a.createPositionAt(d, 0));
      }
    }, { priority: "high" });
  };
}
function i7(i) {
  return (e) => {
    e.on(`attribute:${i.id}:imageBlock`, (t, n, s) => {
      const o = s.mapper.toViewElement(n.item), r = Array.from(o.getChildren()).find((a) => a.is("element", "a"));
      if (r) {
        for (const [a, l] of pt(i.attributes))
          s.writer.setAttribute(a, l, r);
        i.classes && s.writer.addClass(i.classes, r);
        for (const a in i.styles)
          s.writer.setStyle(a, i.styles[a], r);
      }
    });
  };
}
function s7(i, e) {
  const t = i.plugins.has("ImageInlineEditing"), n = i.plugins.get("ImageUtils");
  return (s) => {
    s.on("element:a", (o, r, a) => {
      const l = r.viewItem, c = n.findViewImgElement(l);
      if (!c)
        return;
      const u = c.findAncestor((m) => n.isBlockImageView(m));
      if (t && !u)
        return;
      const h = new ot(e._createPattern()).match(l);
      if (!h || !a.consumable.consume(l, h.match))
        return;
      const f = r.modelCursor.nodeBefore || r.modelCursor.parent;
      a.writer.setAttribute(e.id, !0, f);
    }, { priority: "high" });
  };
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class o7 extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [dr, Sp, "ImageBlockEditing"];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "LinkImageUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.editing.view.document;
    this.listenTo(t, "click", (n, s) => {
      this._isSelectedLinkedImage(e.model.document.selection) && (s.preventDefault(), n.stop());
    }, { priority: "high" }), this._createToolbarLinkImageButton();
  }
  /**
   * Creates a `LinkImageUI` button view.
   *
   * Clicking this button shows a {@link module:link/linkui~LinkUI#_balloon} attached to the selection.
   * When an image is already linked, the view shows {@link module:link/linkui~LinkUI#actionsView} or
   * {@link module:link/linkui~LinkUI#formView} if it is not.
   */
  _createToolbarLinkImageButton() {
    const e = this.editor, t = e.t;
    e.ui.componentFactory.add("linkImage", (n) => {
      const s = new P(n), o = e.plugins.get("LinkUI"), r = e.commands.get("link");
      return s.set({
        isEnabled: !0,
        label: t("Link image"),
        icon: Ip,
        keystroke: Mi,
        tooltip: !0,
        isToggleable: !0
      }), s.bind("isEnabled").to(r, "isEnabled"), s.bind("isOn").to(r, "value", (a) => !!a), this.listenTo(s, "execute", () => {
        this._isSelectedLinkedImage(e.model.document.selection) ? o._addActionsView() : o._showUI(!0);
      }), s;
    });
  }
  /**
   * Returns true if a linked image (either block or inline) is the only selected element
   * in the model document.
   */
  _isSelectedLinkedImage(e) {
    const t = e.getSelectedElement();
    return this.editor.plugins.get("ImageUtils").isImage(t) && t.hasAttribute("linkHref");
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class r7 extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [e7, o7];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "LinkImage";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function sh(i, e) {
  const t = (n, s, o) => {
    if (!o.consumable.consume(s.item, n.name))
      return;
    const r = s.attributeNewValue, a = o.writer, l = o.mapper.toViewElement(s.item), c = [...l.getChildren()].find((d) => d.getCustomProperty("media-content"));
    a.remove(c);
    const u = i.getMediaViewElement(a, r, e);
    a.insert(a.createPositionAt(l, 0), u);
  };
  return (n) => {
    n.on("attribute:url:media", t);
  };
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function a7(i, e, t) {
  return e.setCustomProperty("media", !0, i), lr(i, e, { label: t });
}
function oh(i, e, t, n) {
  return i.createContainerElement("figure", { class: "media" }, [
    e.getMediaViewElement(i, t, n),
    i.createSlot()
  ]);
}
function rh(i) {
  const e = i.getSelectedElement();
  return e && e.is("element", "media") ? e : null;
}
function Rp(i, e, t, n) {
  i.change((s) => {
    const o = s.createElement("media", { url: e });
    i.insertObject(o, t, null, {
      setSelection: "on",
      findOptimalPosition: n ? "auto" : void 0
    });
  });
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class l7 extends V {
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor.model, t = e.document.selection, n = rh(t);
    this.value = n ? n.getAttribute("url") : void 0, this.isEnabled = u7(t) || c7(t, e);
  }
  /**
   * Executes the command, which either:
   *
   * * updates the URL of the selected media,
   * * inserts the new media into the editor and puts the selection around it.
   *
   * @fires execute
   * @param url The URL of the media.
   */
  execute(e) {
    const t = this.editor.model, n = t.document.selection, s = rh(n);
    s ? t.change((o) => {
      o.setAttribute("url", e, s);
    }) : Rp(t, e, n, !0);
  }
}
function c7(i, e) {
  let n = Bl(i, e).start.parent;
  return n.isEmpty && !e.schema.isLimit(n) && (n = n.parent), e.schema.checkChild(n, "media");
}
function u7(i) {
  const e = i.getSelectedElement();
  return !!e && e.name === "media";
}
const d7 = '<svg viewBox="0 0 64 42" xmlns="http://www.w3.org/2000/svg"><path d="M47.426 17V3.713L63.102 0v19.389h-.001l.001.272c0 1.595-2.032 3.43-4.538 4.098-2.506.668-4.538-.083-4.538-1.678 0-1.594 2.032-3.43 4.538-4.098.914-.244 2.032-.565 2.888-.603V4.516L49.076 7.447v9.556A1.014 1.014 0 0 0 49 17h-1.574zM29.5 17h-8.343a7.073 7.073 0 1 0-4.657 4.06v3.781H3.3a2.803 2.803 0 0 1-2.8-2.804V8.63a2.803 2.803 0 0 1 2.8-2.805h4.082L8.58 2.768A1.994 1.994 0 0 1 10.435 1.5h8.985c.773 0 1.477.448 1.805 1.149l1.488 3.177H26.7c1.546 0 2.8 1.256 2.8 2.805V17zm-11.637 0H17.5a1 1 0 0 0-1 1v.05A4.244 4.244 0 1 1 17.863 17zm29.684 2c.97 0 .953-.048.953.889v20.743c0 .953.016.905-.953.905H19.453c-.97 0-.953.048-.953-.905V19.89c0-.937-.016-.889.97-.889h28.077zm-4.701 19.338V22.183H24.154v16.155h18.692zM20.6 21.375v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616V37.53H20.6zm24.233-16.155v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615V37.53h-1.615zM29.485 25.283a.4.4 0 0 1 .593-.35l9.05 4.977a.4.4 0 0 1 0 .701l-9.05 4.978a.4.4 0 0 1-.593-.35v-9.956z"/></svg>';
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const h7 = "0 0 64 42";
class f7 {
  /**
   * Creates an instance of the {@link module:media-embed/mediaregistry~MediaRegistry} class.
   *
   * @param locale The localization services instance.
   * @param config The configuration of the media embed feature.
   */
  constructor(e, t) {
    const n = t.providers, s = t.extraProviders || [], o = new Set(t.removeProviders), r = n.concat(s).filter((a) => {
      const l = a.name;
      return l ? !o.has(l) : (D("media-embed-no-provider-name", { provider: a }), !1);
    });
    this.locale = e, this.providerDefinitions = r;
  }
  /**
   * Checks whether the passed URL is representing a certain media type allowed in the editor.
   *
   * @param url The URL to be checked
   */
  hasMedia(e) {
    return !!this._getMedia(e);
  }
  /**
   * For the given media URL string and options, it returns the {@link module:engine/view/element~Element view element}
   * representing that media.
   *
   * **Note:** If no URL is specified, an empty view element is returned.
   *
   * @param writer The view writer used to produce a view element.
   * @param url The URL to be translated into a view element.
   */
  getMediaViewElement(e, t, n) {
    return this._getMedia(t).getViewElement(e, n);
  }
  /**
   * Returns a `Media` instance for the given URL.
   *
   * @param url The URL of the media.
   * @returns The `Media` instance or `null` when there is none.
   */
  _getMedia(e) {
    if (!e)
      return new ah(this.locale);
    e = e.trim();
    for (const t of this.providerDefinitions) {
      const n = t.html, s = Z(t.url);
      for (const o of s) {
        const r = this._getUrlMatches(e, o);
        if (r)
          return new ah(this.locale, e, r, n);
      }
    }
    return null;
  }
  /**
   * Tries to match `url` to `pattern`.
   *
   * @param url The URL of the media.
   * @param pattern The pattern that should accept the media URL.
   */
  _getUrlMatches(e, t) {
    let n = e.match(t);
    if (n)
      return n;
    let s = e.replace(/^https?:\/\//, "");
    return n = s.match(t), n || (s = s.replace(/^www\./, ""), n = s.match(t), n) ? n : null;
  }
}
class ah {
  constructor(e, t, n, s) {
    this.url = this._getValidUrl(t), this._locale = e, this._match = n, this._previewRenderer = s;
  }
  /**
   * Returns the view element representation of the media.
   *
   * @param writer The view writer used to produce a view element.
   */
  getViewElement(e, t) {
    const n = {};
    let s;
    if (t.renderForEditingView || t.renderMediaPreview && this.url && this._previewRenderer) {
      this.url && (n["data-oembed-url"] = this.url), t.renderForEditingView && (n.class = "ck-media__wrapper");
      const o = this._getPreviewHtml(t);
      s = e.createRawElement("div", n, (r, a) => {
        a.setContentOf(r, o);
      });
    } else
      this.url && (n.url = this.url), s = e.createEmptyElement(t.elementName, n);
    return e.setCustomProperty("media-content", !0, s), s;
  }
  /**
   * Returns the HTML string of the media content preview.
   */
  _getPreviewHtml(e) {
    return this._previewRenderer ? this._previewRenderer(this._match) : this.url && e.renderForEditingView ? this._getPlaceholderHtml() : "";
  }
  /**
   * Returns the placeholder HTML when the media has no content preview.
   */
  _getPlaceholderHtml() {
    const e = new ut(), t = this._locale.t;
    return e.content = d7, e.viewBox = h7, new Me({
      tag: "div",
      attributes: {
        class: "ck ck-reset_all ck-media__placeholder"
      },
      children: [
        {
          tag: "div",
          attributes: {
            class: "ck-media__placeholder__icon"
          },
          children: [e]
        },
        {
          tag: "a",
          attributes: {
            class: "ck-media__placeholder__url",
            target: "_blank",
            rel: "noopener noreferrer",
            href: this.url,
            "data-cke-tooltip-text": t("Open media in new tab")
          },
          children: [
            {
              tag: "span",
              attributes: {
                class: "ck-media__placeholder__url__text"
              },
              children: [this.url]
            }
          ]
        }
      ]
    }).render().outerHTML;
  }
  /**
   * Returns the full URL to the specified media.
   *
   * @param url The URL of the media.
   */
  _getValidUrl(e) {
    return e ? e.match(/^https?/) ? e : "https://" + e : null;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Ro extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "MediaEmbedEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), e.config.define("mediaEmbed", {
      elementName: "oembed",
      providers: [
        {
          name: "dailymotion",
          url: [
            /^dailymotion\.com\/video\/(\w+)/,
            /^dai.ly\/(\w+)/
          ],
          html: (t) => `<div style="position: relative; padding-bottom: 100%; height: 0; "><iframe src="https://www.dailymotion.com/embed/video/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" width="480" height="270" allowfullscreen allow="autoplay"></iframe></div>`
        },
        {
          name: "spotify",
          url: [
            /^open\.spotify\.com\/(artist\/\w+)/,
            /^open\.spotify\.com\/(album\/\w+)/,
            /^open\.spotify\.com\/(track\/\w+)/
          ],
          html: (t) => `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 126%;"><iframe src="https://open.spotify.com/embed/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe></div>`
        },
        {
          name: "youtube",
          url: [
            /^(?:m\.)?youtube\.com\/watch\?v=([\w-]+)(?:&t=(\d+))?/,
            /^(?:m\.)?youtube\.com\/v\/([\w-]+)(?:\?t=(\d+))?/,
            /^youtube\.com\/embed\/([\w-]+)(?:\?start=(\d+))?/,
            /^youtu\.be\/([\w-]+)(?:\?t=(\d+))?/
          ],
          html: (t) => {
            const n = t[1], s = t[2];
            return `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://www.youtube.com/embed/${n}${s ? `?start=${s}` : ""}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div>`;
          }
        },
        {
          name: "vimeo",
          url: [
            /^vimeo\.com\/(\d+)/,
            /^vimeo\.com\/[^/]+\/[^/]+\/video\/(\d+)/,
            /^vimeo\.com\/album\/[^/]+\/video\/(\d+)/,
            /^vimeo\.com\/channels\/[^/]+\/(\d+)/,
            /^vimeo\.com\/groups\/[^/]+\/videos\/(\d+)/,
            /^vimeo\.com\/ondemand\/[^/]+\/(\d+)/,
            /^player\.vimeo\.com\/video\/(\d+)/
          ],
          html: (t) => `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://player.vimeo.com/video/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>`
        },
        {
          name: "instagram",
          url: /^instagram\.com\/p\/(\w+)/
        },
        {
          name: "twitter",
          url: /^twitter\.com/
        },
        {
          name: "googleMaps",
          url: [
            /^google\.com\/maps/,
            /^goo\.gl\/maps/,
            /^maps\.google\.com/,
            /^maps\.app\.goo\.gl/
          ]
        },
        {
          name: "flickr",
          url: /^flickr\.com/
        },
        {
          name: "facebook",
          url: /^facebook\.com/
        }
      ]
    }), this.registry = new f7(e.locale, e.config.get("mediaEmbed"));
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model.schema, n = e.t, s = e.conversion, o = e.config.get("mediaEmbed.previewsInData"), r = e.config.get("mediaEmbed.elementName"), a = this.registry;
    e.commands.add("mediaEmbed", new l7(e)), t.register("media", {
      inheritAllFrom: "$blockObject",
      allowAttributes: ["url"]
    }), s.for("dataDowncast").elementToStructure({
      model: "media",
      view: (l, { writer: c }) => {
        const u = l.getAttribute("url");
        return oh(c, a, u, {
          elementName: r,
          renderMediaPreview: !!u && o
        });
      }
    }), s.for("dataDowncast").add(sh(a, {
      elementName: r,
      renderMediaPreview: o
    })), s.for("editingDowncast").elementToStructure({
      model: "media",
      view: (l, { writer: c }) => {
        const u = l.getAttribute("url"), d = oh(c, a, u, {
          elementName: r,
          renderForEditingView: !0
        });
        return a7(d, c, n("media widget"));
      }
    }), s.for("editingDowncast").add(sh(a, {
      elementName: r,
      renderForEditingView: !0
    })), s.for("upcast").elementToElement({
      view: (l) => ["oembed", r].includes(l.name) && l.getAttribute("url") ? { name: !0 } : null,
      model: (l, { writer: c }) => {
        const u = l.getAttribute("url");
        return a.hasMedia(u) ? c.createElement("media", { url: u }) : null;
      }
    }).elementToElement({
      view: {
        name: "div",
        attributes: {
          "data-oembed-url": !0
        }
      },
      model: (l, { writer: c }) => {
        const u = l.getAttribute("data-oembed-url");
        return a.hasMedia(u) ? c.createElement("media", { url: u }) : null;
      }
    }).add((l) => {
      const c = (u, d, h) => {
        if (!h.consumable.consume(d.viewItem, { name: !0, classes: "media" }))
          return;
        const { modelRange: f, modelCursor: m } = h.convertChildren(d.viewItem, d.modelCursor);
        d.modelRange = f, d.modelCursor = m, me(f.getItems()) || h.consumable.revert(d.viewItem, { name: !0, classes: "media" });
      };
      l.on("element:figure", c);
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const m7 = /^(?:http(s)?:\/\/)?[\w-]+\.[\w-.~:/?#[\]@!$&'()*+,;=%]+$/;
class g7 extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Ol, bt, Fl];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "AutoMediaEmbed";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this._timeoutId = null, this._positionToInsert = null;
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model.document, n = e.plugins.get("ClipboardPipeline");
    this.listenTo(n, "inputTransformation", () => {
      const o = t.selection.getFirstRange(), r = ce.fromPosition(o.start);
      r.stickiness = "toPrevious";
      const a = ce.fromPosition(o.end);
      a.stickiness = "toNext", t.once("change:data", () => {
        this._embedMediaBetweenPositions(r, a), r.detach(), a.detach();
      }, { priority: "high" });
    }), e.commands.get("undo").on("execute", () => {
      this._timeoutId && (E.window.clearTimeout(this._timeoutId), this._positionToInsert.detach(), this._timeoutId = null, this._positionToInsert = null);
    }, { priority: "high" });
  }
  /**
   * Analyzes the part of the document between provided positions in search for a URL representing media.
   * When the URL is found, it is automatically converted into media.
   *
   * @param leftPosition Left position of the selection.
   * @param rightPosition Right position of the selection.
   */
  _embedMediaBetweenPositions(e, t) {
    const n = this.editor, s = n.plugins.get(Ro).registry, o = new Pe(e, t), r = o.getWalker({ ignoreElementEnd: !0 });
    let a = "";
    for (const c of r)
      c.item.is("$textProxy") && (a += c.item.data);
    if (a = a.trim(), !a.match(m7)) {
      o.detach();
      return;
    }
    if (!s.hasMedia(a)) {
      o.detach();
      return;
    }
    if (!n.commands.get("mediaEmbed").isEnabled) {
      o.detach();
      return;
    }
    this._positionToInsert = ce.fromPosition(e), this._timeoutId = E.window.setTimeout(() => {
      n.model.change((c) => {
        this._timeoutId = null, c.remove(o), o.detach();
        let u = null;
        this._positionToInsert.root.rootName !== "$graveyard" && (u = this._positionToInsert), Rp(n.model, a, u, !1), this._positionToInsert.detach(), this._positionToInsert = null;
      }), n.plugins.get(bt).requestUndoOnBackspace();
    }, 100);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class p7 extends T {
  /**
   * @param validators Form validators used by {@link #isValid}.
   * @param locale The localization services instance.
   */
  constructor(e, t) {
    super(t);
    const n = t.t;
    this.focusTracker = new X(), this.keystrokes = new ie(), this.set("mediaURLInputValue", ""), this.urlInputView = this._createUrlInput(), this.saveButtonView = this._createButton(n("Save"), A.check, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(n("Cancel"), A.cancel, "ck-button-cancel", "cancel"), this._focusables = new ve(), this._focusCycler = new ge({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the <kbd>Shift</kbd> + <kbd>Tab</kbd> keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the <kbd>Tab</kbd> key.
        focusNext: "tab"
      }
    }), this._validators = e, this.setTemplate({
      tag: "form",
      attributes: {
        class: [
          "ck",
          "ck-media-form",
          "ck-responsive-form"
        ],
        tabindex: "-1"
      },
      children: [
        this.urlInputView,
        this.saveButtonView,
        this.cancelButtonView
      ]
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), Cn({
      view: this
    }), [
      this.urlInputView,
      this.saveButtonView,
      this.cancelButtonView
    ].forEach((n) => {
      this._focusables.add(n), this.focusTracker.add(n.element);
    }), this.keystrokes.listenTo(this.element);
    const t = (n) => n.stopPropagation();
    this.keystrokes.set("arrowright", t), this.keystrokes.set("arrowleft", t), this.keystrokes.set("arrowup", t), this.keystrokes.set("arrowdown", t);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  /**
   * Focuses the fist {@link #_focusables} in the form.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
   * The native DOM `value` of the {@link #urlInputView} element.
   *
   * **Note**: Do not confuse it with the {@link module:ui/inputtext/inputtextview~InputTextView#value}
   * which works one way only and may not represent the actual state of the component in the DOM.
   */
  get url() {
    return this.urlInputView.fieldView.element.value.trim();
  }
  set url(e) {
    this.urlInputView.fieldView.element.value = e.trim();
  }
  /**
   * Validates the form and returns `false` when some fields are invalid.
   */
  isValid() {
    this.resetFormStatus();
    for (const e of this._validators) {
      const t = e(this);
      if (t)
        return this.urlInputView.errorText = t, !1;
    }
    return !0;
  }
  /**
   * Cleans up the supplementary error and information text of the {@link #urlInputView}
   * bringing them back to the state when the form has been displayed for the first time.
   *
   * See {@link #isValid}.
   */
  resetFormStatus() {
    this.urlInputView.errorText = null, this.urlInputView.infoText = this._urlInputViewInfoDefault;
  }
  /**
   * Creates a labeled input view.
   *
   * @returns Labeled input view instance.
   */
  _createUrlInput() {
    const e = this.locale.t, t = new ue(this.locale, He), n = t.fieldView;
    return this._urlInputViewInfoDefault = e("Paste the media URL in the input."), this._urlInputViewInfoTip = e("Tip: Paste the URL into the content to embed faster."), t.label = e("Media URL"), t.infoText = this._urlInputViewInfoDefault, n.on("input", () => {
      t.infoText = n.element.value ? this._urlInputViewInfoTip : this._urlInputViewInfoDefault, this.mediaURLInputValue = n.element.value.trim();
    }), t;
  }
  /**
   * Creates a button view.
   *
   * @param label The button label.
   * @param icon The button icon.
   * @param className The additional button CSS class name.
   * @param eventName An event name that the `ButtonView#execute` event will be delegated to.
   * @returns The button view instance.
   */
  _createButton(e, t, n, s) {
    const o = new P(this.locale);
    return o.set({
      label: e,
      icon: t,
      tooltip: !0
    }), o.extendTemplate({
      attributes: {
        class: n
      }
    }), s && o.delegate("execute").to(this, s), o;
  }
}
const b7 = '<svg viewBox="0 0 22 20" xmlns="http://www.w3.org/2000/svg"><path d="M1.587 1.5c-.612 0-.601-.029-.601.551v14.84c0 .59-.01.559.591.559h18.846c.602 0 .591.03.591-.56V2.052c0-.58.01-.55-.591-.55H1.587Zm.701.971h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-14.24 1h13.008v12H4.467l.029-12Zm-2.208 1h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h1.003l-.029 1h-.974v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h.974v1h-.974v-1Zm16.448 0h1.003v1h-1.003v-1Z"/><path d="M8.374 6.648a.399.399 0 0 1 .395-.4.402.402 0 0 1 .2.049l5.148 2.824a.4.4 0 0 1 0 .7l-5.148 2.824a.403.403 0 0 1-.595-.35V6.648Z"/></svg>';
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class w7 extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Ro];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "MediaEmbedUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.commands.get("mediaEmbed");
    e.ui.componentFactory.add("mediaEmbed", (n) => {
      const s = we(n);
      return this._setUpDropdown(s, t), s;
    });
  }
  _setUpDropdown(e, t) {
    const n = this.editor, s = n.t, o = e.buttonView, r = n.plugins.get(Ro).registry;
    e.once("change:isOpen", () => {
      const a = new (tr(p7))(_7(n.t, r), n.locale);
      e.panelView.children.add(a), o.on("open", () => {
        a.disableCssTransitions(), a.url = t.value || "", a.urlInputView.fieldView.select(), a.enableCssTransitions();
      }, { priority: "low" }), e.on("submit", () => {
        a.isValid() && (n.execute("mediaEmbed", a.url), n.editing.view.focus());
      }), e.on("change:isOpen", () => a.resetFormStatus()), e.on("cancel", () => {
        n.editing.view.focus();
      }), a.delegate("submit", "cancel").to(e), a.urlInputView.fieldView.bind("value").to(t, "value"), a.urlInputView.on("change:errorText", () => {
        n.ui.update();
      }), a.urlInputView.bind("isEnabled").to(t, "isEnabled");
    }), e.bind("isEnabled").to(t), o.set({
      label: s("Insert media"),
      icon: b7,
      tooltip: !0
    });
  }
}
function _7(i, e) {
  return [
    (t) => {
      if (!t.url.length)
        return i("The URL must not be empty.");
    },
    (t) => {
      if (!e.hasMedia(t.url))
        return i("This media URL is not supported.");
    }
  ];
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class v7 extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Ro, w7, g7, gi];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "MediaEmbed";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function y7(i) {
  const e = parseFloat(i);
  return i.endsWith("pt") ? Wn(e * 96 / 72) : i.endsWith("pc") ? Wn(e * 12 * 96 / 72) : i.endsWith("in") ? Wn(e * 96) : i.endsWith("cm") ? Wn(e * 96 / 2.54) : i.endsWith("mm") ? Wn(e / 10 * 96 / 2.54) : i;
}
function lh(i) {
  return i !== void 0 && i.endsWith("px");
}
function Wn(i) {
  return i.toFixed(2).replace(/\.?0+$/, "") + "px";
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function C7(i, e, t) {
  if (!i.childCount)
    return;
  const n = new Bt(i.document), s = T7(i, n);
  if (!s.length)
    return;
  const o = {}, r = [];
  for (const a of s)
    if (a.indent !== void 0) {
      E7(a) || (r.length = 0);
      const l = `${a.id}:${a.indent}`, c = Math.min(a.indent - 1, r.length);
      if (c < r.length && r[c].id !== a.id && (r.length = c), c < r.length - 1)
        r.length = c + 1;
      else {
        const d = A7(a, e);
        if (c > r.length - 1 || r[c].listElement.name != d.type) {
          c == 0 && d.type == "ol" && a.id !== void 0 && o[l] && (d.startIndex = o[l]);
          const h = P7(d, n, t);
          if (lh(a.marginLeft) && (c == 0 || lh(r[c - 1].marginLeft))) {
            let f = a.marginLeft;
            c > 0 && (f = Wn(parseFloat(f) - parseFloat(r[c - 1].marginLeft))), n.setStyle("padding-left", f, h);
          }
          if (r.length == 0) {
            const f = a.element.parent, m = f.getChildIndex(a.element) + 1;
            n.insertChild(m, h, f);
          } else {
            const f = r[c - 1].listItemElements;
            n.appendChild(h, f[f.length - 1]);
          }
          r[c] = {
            ...a,
            listElement: h,
            listItemElements: []
          }, c == 0 && a.id !== void 0 && (o[l] = d.startIndex || 1);
        }
      }
      const u = a.element.name == "li" ? a.element : n.createElement("li");
      n.appendChild(u, r[c].listElement), r[c].listItemElements.push(u), c == 0 && a.id !== void 0 && o[l]++, a.element != u && n.appendChild(a.element, u), V7(a.element, n), n.removeStyle("text-indent", a.element), n.removeStyle("margin-left", a.element);
    } else {
      const l = r.find((c) => c.marginLeft == a.marginLeft);
      if (l) {
        const c = l.listItemElements;
        n.appendChild(a.element, c[c.length - 1]), n.removeStyle("margin-left", a.element);
      } else
        r.length = 0;
    }
}
function k7(i, e) {
  for (const t of e.createRangeIn(i)) {
    const n = t.item;
    if (n.is("element", "li")) {
      const s = n.getChild(0);
      s && s.is("element", "p") && e.unwrapElement(s);
    }
  }
}
function T7(i, e) {
  const t = e.createRangeIn(i), n = [], s = /* @__PURE__ */ new Set();
  for (const o of t.getItems()) {
    if (!o.is("element") || !o.name.match(/^(p|h\d+|li|div)$/))
      continue;
    let r = M7(o);
    if (r !== void 0 && parseFloat(r) == 0 && !Array.from(o.getClassNames()).find((a) => a.startsWith("MsoList")) && (r = void 0), o.hasStyle("mso-list") || r !== void 0 && s.has(r)) {
      const a = R7(o);
      n.push({
        element: o,
        id: a.id,
        order: a.order,
        indent: a.indent,
        marginLeft: r
      }), r !== void 0 && s.add(r);
    } else
      s.clear();
  }
  return n;
}
function E7(i) {
  const e = i.element.previousSibling;
  return ch(e || i.element.parent);
}
function ch(i) {
  return i.is("element", "ol") || i.is("element", "ul");
}
function A7(i, e) {
  const t = new RegExp(`@list l${i.id}:level${i.indent}\\s*({[^}]*)`, "gi"), n = /mso-level-number-format:([^;]{0,100});/gi, s = /mso-level-start-at:\s{0,100}([0-9]{0,10})\s{0,100};/gi, o = new RegExp(`@list\\s+l${i.id}:level\\d\\s*{[^{]*mso-level-text:"%\\d\\\\.`, "gi"), r = new RegExp(`@list l${i.id}:level\\d\\s*{[^{]*mso-level-number-format:`, "gi"), a = o.exec(e), l = r.exec(e), c = a && !l, u = t.exec(e);
  let d = "decimal", h = "ol", f = null;
  if (u && u[1]) {
    const m = n.exec(u[1]);
    if (m && m[1] && (d = m[1].trim(), h = d !== "bullet" && d !== "image" ? "ol" : "ul"), d === "bullet") {
      const p = x7(i.element);
      p && (d = p);
    } else {
      const p = s.exec(u[1]);
      p && p[1] && (f = parseInt(p[1]));
    }
    c && (h = "ol");
  }
  return {
    type: h,
    startIndex: f,
    style: S7(d),
    isLegalStyleList: c
  };
}
function x7(i) {
  if (i.name == "li" && i.parent.name == "ul" && i.parent.hasAttribute("type"))
    return i.parent.getAttribute("type");
  const e = I7(i);
  if (!e)
    return null;
  const t = e._data;
  return t === "o" ? "circle" : t === "·" ? "disc" : t === "§" ? "square" : null;
}
function I7(i) {
  if (i.getChild(0).is("$text"))
    return null;
  for (const e of i.getChildren()) {
    if (!e.is("element", "span"))
      continue;
    const t = e.getChild(0);
    if (t)
      return t.is("$text") ? t : t.getChild(0);
  }
  /* istanbul ignore next -- @preserve */
  return null;
}
function S7(i) {
  if (i.startsWith("arabic-leading-zero"))
    return "decimal-leading-zero";
  switch (i) {
    case "alpha-upper":
      return "upper-alpha";
    case "alpha-lower":
      return "lower-alpha";
    case "roman-upper":
      return "upper-roman";
    case "roman-lower":
      return "lower-roman";
    case "circle":
    case "disc":
    case "square":
      return i;
    default:
      return null;
  }
}
function P7(i, e, t) {
  const n = e.createElement(i.type);
  return i.style && e.setStyle("list-style-type", i.style, n), i.startIndex && i.startIndex > 1 && e.setAttribute("start", i.startIndex, n), i.isLegalStyleList && t && e.addClass("legal-list", n), n;
}
function R7(i) {
  const e = i.getStyle("mso-list");
  if (e === void 0)
    return {};
  const t = e.match(/(^|\s{1,100})l(\d+)/i), n = e.match(/\s{0,100}lfo(\d+)/i), s = e.match(/\s{0,100}level(\d+)/i);
  return t && n && s ? {
    id: t[2],
    order: n[1],
    indent: parseInt(s[1])
  } : {
    indent: 1
    // Handle empty mso-list style as a marked for default list item.
  };
}
function V7(i, e) {
  const t = new ot({
    name: "span",
    styles: {
      "mso-list": "Ignore"
    }
  }), n = e.createRangeIn(i);
  for (const s of n)
    s.type === "elementStart" && t.match(s.item) && e.remove(s.item);
}
function M7(i) {
  const e = i.getStyle("margin-left");
  return e === void 0 || e.endsWith("px") ? e : y7(e);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function B7(i, e) {
  if (!i.childCount)
    return;
  const t = new Bt(i.document), n = O7(i, t);
  F7(n, i, t), D7(n, i, t), N7(i, t);
  const s = z7(i, t);
  s.length && U7(s, H7(e), t);
}
function L7(i) {
  return btoa(i.match(/\w{2}/g).map((e) => String.fromCharCode(parseInt(e, 16))).join(""));
}
function O7(i, e) {
  const t = e.createRangeIn(i), n = new ot({
    name: /v:(.+)/
  }), s = [];
  for (const o of t) {
    if (o.type != "elementStart")
      continue;
    const r = o.item, a = r.previousSibling, l = a && a.is("element") ? a.name : null, c = ["Chart"], u = n.match(r), d = r.getAttribute("o:gfxdata"), h = l === "v:shapetype", f = d && c.some((m) => r.getAttribute("id").includes(m));
    u && d && !h && !f && s.push(o.item.getAttribute("id"));
  }
  return s;
}
function F7(i, e, t) {
  const n = t.createRangeIn(e), s = new ot({
    name: "img"
  }), o = [];
  for (const r of n)
    if (r.item.is("element") && s.match(r.item)) {
      const a = r.item, l = a.getAttribute("v:shapes") ? a.getAttribute("v:shapes").split(" ") : [];
      l.length && l.every((c) => i.indexOf(c) > -1) ? o.push(a) : a.getAttribute("src") || o.push(a);
    }
  for (const r of o)
    t.remove(r);
}
function N7(i, e) {
  const t = e.createRangeIn(i), n = new ot({
    name: /v:(.+)/
  }), s = [];
  for (const o of t)
    o.type == "elementStart" && n.match(o.item) && s.push(o.item);
  for (const o of s)
    e.remove(o);
}
function D7(i, e, t) {
  const n = t.createRangeIn(e), s = [];
  for (const a of n)
    if (a.type == "elementStart" && a.item.is("element", "v:shape")) {
      const l = a.item.getAttribute("id");
      if (i.includes(l))
        continue;
      o(a.item.parent.getChildren(), l) || s.push(a.item);
    }
  for (const a of s) {
    const l = {
      src: r(a)
    };
    a.hasAttribute("alt") && (l.alt = a.getAttribute("alt"));
    const c = t.createElement("img", l);
    t.insertChild(a.index + 1, c, a.parent);
  }
  function o(a, l) {
    for (const c of a) {
      /* istanbul ignore else -- @preserve */
      if (c.is("element") && (c.name == "img" && c.getAttribute("v:shapes") == l || o(c.getChildren(), l)))
        return !0;
    }
    return !1;
  }
  function r(a) {
    for (const l of a.getChildren()) {
      /* istanbul ignore else -- @preserve */
      if (l.is("element") && l.getAttribute("src"))
        return l.getAttribute("src");
    }
  }
}
function z7(i, e) {
  const t = e.createRangeIn(i), n = new ot({
    name: "img"
  }), s = [];
  for (const o of t)
    o.item.is("element") && n.match(o.item) && o.item.getAttribute("src").startsWith("file://") && s.push(o.item);
  return s;
}
function H7(i) {
  if (!i)
    return [];
  const e = /{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/, t = new RegExp("(?:(" + e.source + "))([\\da-fA-F\\s]+)\\}", "g"), n = i.match(t), s = [];
  if (n)
    for (const o of n) {
      let r = !1;
      o.includes("\\pngblip") ? r = "image/png" : o.includes("\\jpegblip") && (r = "image/jpeg"), r && s.push({
        hex: o.replace(e, "").replace(/[^\da-fA-F]/g, ""),
        type: r
      });
    }
  return s;
}
function U7(i, e, t) {
  if (i.length === e.length)
    for (let n = 0; n < i.length; n++) {
      const s = `data:${e[n].type};base64,${L7(e[n].hex)}`;
      t.setAttribute("src", s, i[n]);
    }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function $7(i) {
  const e = [], t = new Bt(i.document);
  for (const { item: n } of t.createRangeIn(i))
    if (n.is("element")) {
      for (const s of n.getClassNames())
        /\bmso/gi.exec(s) && t.removeClass(s, n);
      for (const s of n.getStyleNames())
        /\bmso/gi.exec(s) && t.removeStyle(s, n);
      (n.is("element", "w:sdt") || n.is("element", "w:sdtpr") && n.isEmpty || n.is("element", "o:p") && n.isEmpty) && e.push(n);
    }
  for (const n of e) {
    const s = n.parent, o = s.getChildIndex(n);
    t.insertChild(o, n.getChildren(), s), t.remove(n);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const W7 = /<meta\s*name="?generator"?\s*content="?microsoft\s*word\s*\d+"?\/?>/i, q7 = /xmlns:o="urn:schemas-microsoft-com/i;
class G7 {
  /**
   * Creates a new `MSWordNormalizer` instance.
   *
   * @param document View document.
   */
  constructor(e, t = !1) {
    this.document = e, this.hasMultiLevelListPlugin = t;
  }
  /**
   * @inheritDoc
   */
  isActive(e) {
    return W7.test(e) || q7.test(e);
  }
  /**
   * @inheritDoc
   */
  execute(e) {
    const { body: t, stylesString: n } = e._parsedData;
    C7(t, n, this.hasMultiLevelListPlugin), B7(t, e.dataTransfer.getData("text/rtf")), $7(t), e.content = t;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function j7(i, e) {
  for (const t of i.getChildren())
    if (t.is("element", "b") && t.getStyle("font-weight") === "normal") {
      const n = i.getChildIndex(t);
      e.remove(t), e.insertChild(n, t.getChildren(), i);
    }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function K7(i, e) {
  const t = new Zo(e.document.stylesProcessor), n = new Xo(t, { renderingMode: "data" }), s = n.blockElements, o = n.inlineObjectElements, r = [];
  for (const a of e.createRangeIn(i)) {
    const l = a.item;
    if (l.is("element", "br")) {
      const c = uh(l, "forward", e, { blockElements: s, inlineObjectElements: o }), u = uh(l, "backward", e, { blockElements: s, inlineObjectElements: o }), d = dh(c, s);
      (dh(u, s) || d) && r.push(l);
    }
  }
  for (const a of r)
    a.hasClass("Apple-interchange-newline") ? e.remove(a) : e.replace(a, e.createElement("p"));
}
function uh(i, e, t, { blockElements: n, inlineObjectElements: s }) {
  let o = t.createPositionAt(i, e == "forward" ? "after" : "before");
  return o = o.getLastMatchingPosition(({ item: r }) => r.is("element") && !n.includes(r.name) && !s.includes(r.name), { direction: e }), e == "forward" ? o.nodeAfter : o.nodeBefore;
}
function dh(i, e) {
  return !!i && i.is("element") && e.includes(i.name);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Z7 = /id=("|')docs-internal-guid-[-0-9a-f]+("|')/i;
class J7 {
  /**
   * Creates a new `GoogleDocsNormalizer` instance.
   *
   * @param document View document.
   */
  constructor(e) {
    this.document = e;
  }
  /**
   * @inheritDoc
   */
  isActive(e) {
    return Z7.test(e);
  }
  /**
   * @inheritDoc
   */
  execute(e) {
    const t = new Bt(this.document), { body: n } = e._parsedData;
    j7(n, t), k7(n, t), K7(n, t), e.content = n;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function X7(i, e) {
  for (const t of i.getChildren())
    t.is("element", "table") && t.hasAttribute("xmlns") && e.removeAttribute("xmlns", t);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Q7(i, e) {
  for (const t of i.getChildren())
    if (t.is("element", "google-sheets-html-origin")) {
      const n = i.getChildIndex(t);
      e.remove(t), e.insertChild(n, t.getChildren(), i);
    }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Y7(i, e) {
  for (const t of i.getChildren())
    t.is("element", "table") && t.getStyle("width") === "0px" && e.removeStyle("width", t);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function e4(i, e) {
  for (const t of Array.from(i.getChildren()))
    t.is("element", "style") && e.remove(t);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const t4 = /<google-sheets-html-origin/i;
class n4 {
  /**
   * Creates a new `GoogleSheetsNormalizer` instance.
   *
   * @param document View document.
   */
  constructor(e) {
    this.document = e;
  }
  /**
   * @inheritDoc
   */
  isActive(e) {
    return t4.test(e);
  }
  /**
   * @inheritDoc
   */
  execute(e) {
    const t = new Bt(this.document), { body: n } = e._parsedData;
    Q7(n, t), X7(n, t), Y7(n, t), e4(n, t), e.content = n;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function i4(i) {
  return hh(hh(i)).replace(/(<span\s+style=['"]mso-spacerun:yes['"]>[^\S\r\n]*?)[\r\n]+([^\S\r\n]*<\/span>)/g, "$1$2").replace(/<span\s+style=['"]mso-spacerun:yes['"]><\/span>/g, "").replace(/(<span\s+style=['"]letter-spacing:[^'"]+?['"]>)[\r\n]+(<\/span>)/g, "$1 $2").replace(/ <\//g, " </").replace(/ <o:p><\/o:p>/g, " <o:p></o:p>").replace(/<o:p>(&nbsp;|\u00A0)<\/o:p>/g, "").replace(/>([^\S\r\n]*[\r\n]\s*)</g, "><");
}
function s4(i) {
  i.querySelectorAll("span[style*=spacerun]").forEach((e) => {
    const t = e, n = t.innerText.length || 0;
    t.innerText = Array(n + 1).join("  ").substr(0, n);
  });
}
function hh(i) {
  return i.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (e, t) => t.length === 1 ? " " : Array(t.length + 1).join("  ").substr(0, t.length));
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function o4(i, e) {
  const t = new DOMParser();
  i = i.replace(/<!--\[if gte vml 1]>/g, ""), i = i.replace(/<o:SmartTagType(?:\s+[^\s>=]+(?:="[^"]*")?)*\s*\/?>/gi, "");
  const n = i4(l4(i)), s = t.parseFromString(n, "text/html");
  s4(s);
  const o = s.body.innerHTML, r = r4(s, e), a = a4(s);
  return {
    body: r,
    bodyString: o,
    styles: a.styles,
    stylesString: a.stylesString
  };
}
function r4(i, e) {
  const t = new Zo(e), n = new Xo(t, { renderingMode: "data" }), s = i.createDocumentFragment(), o = i.body.childNodes;
  for (; o.length > 0; )
    s.appendChild(o[0]);
  return n.domToView(s, { skipComments: !0 });
}
function a4(i) {
  const e = [], t = [], n = Array.from(i.getElementsByTagName("style"));
  for (const s of n)
    s.sheet && s.sheet.cssRules && s.sheet.cssRules.length && (e.push(s.sheet), t.push(s.innerHTML));
  return {
    styles: e,
    stylesString: t.join(" ")
  };
}
function l4(i) {
  const e = "</body>", t = "</html>", n = i.indexOf(e);
  if (n < 0)
    return i;
  const s = i.indexOf(t, n + e.length);
  return i.substring(0, n + e.length) + (s >= 0 ? i.substring(s) : "");
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class c4 extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "PasteFromOffice";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Ze];
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.plugins.get("ClipboardPipeline"), n = e.editing.view.document, s = [], o = this.editor.plugins.has("MultiLevelList");
    s.push(new G7(n, o)), s.push(new J7(n)), s.push(new n4(n)), t.on("inputTransformation", (r, a) => {
      if (a._isTransformedWithPasteFromOffice || e.model.document.selection.getFirstPosition().parent.is("element", "codeBlock"))
        return;
      const c = a.dataTransfer.getData("text/html"), u = s.find((d) => d.isActive(c));
      u && (a._parsedData || (a._parsedData = o4(c, n.stylesProcessor)), u.execute(a), a._isTransformedWithPasteFromOffice = !0);
    }, { priority: "high" });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Wl(i, e) {
  const { modelAttribute: t, styleName: n, viewElement: s, defaultValue: o, reduceBoxSides: r = !1, shouldUpcast: a = () => !0 } = e;
  i.for("upcast").attributeToAttribute({
    view: {
      name: s,
      styles: {
        [n]: /[\s\S]+/
      }
    },
    model: {
      key: t,
      value: (l) => {
        if (!a(l))
          return;
        const c = l.getNormalizedStyle(n), u = r ? co(c) : c;
        if (o !== u)
          return u;
      }
    }
  });
}
function xa(i, e, t, n) {
  i.for("upcast").add((s) => s.on("element:" + e, (o, r, a) => {
    if (!r.modelRange)
      return;
    const l = [
      "border-top-width",
      "border-top-color",
      "border-top-style",
      "border-bottom-width",
      "border-bottom-color",
      "border-bottom-style",
      "border-right-width",
      "border-right-color",
      "border-right-style",
      "border-left-width",
      "border-left-color",
      "border-left-style"
    ].filter((f) => r.viewItem.hasStyle(f));
    if (!l.length)
      return;
    const c = {
      styles: l
    };
    if (!a.consumable.test(r.viewItem, c))
      return;
    const u = [...r.modelRange.getItems({ shallow: !0 })].pop();
    a.consumable.consume(r.viewItem, c);
    const d = {
      style: r.viewItem.getNormalizedStyle("border-style"),
      color: r.viewItem.getNormalizedStyle("border-color"),
      width: r.viewItem.getNormalizedStyle("border-width")
    }, h = {
      style: co(d.style),
      color: co(d.color),
      width: co(d.width)
    };
    h.style !== n.style && a.writer.setAttribute(t.style, h.style, u), h.color !== n.color && a.writer.setAttribute(t.color, h.color, u), h.width !== n.width && a.writer.setAttribute(t.width, h.width, u);
  }));
}
function $i(i, e) {
  const { modelElement: t, modelAttribute: n, styleName: s } = e;
  i.for("downcast").attributeToAttribute({
    model: {
      name: t,
      key: n
    },
    view: (o) => ({
      key: "style",
      value: {
        [s]: o
      }
    })
  });
}
function lo(i, e) {
  const { modelAttribute: t, styleName: n } = e;
  i.for("downcast").add((s) => s.on(`attribute:${t}:table`, (o, r, a) => {
    const { item: l, attributeNewValue: c } = r, { mapper: u, writer: d } = a;
    if (!a.consumable.consume(r.item, o.name))
      return;
    const h = [...u.toViewElement(l).getChildren()].find((f) => f.is("element", "table"));
    c ? d.setStyle(n, c, h) : d.removeStyle(n, h);
  }));
}
function co(i) {
  if (!i)
    return;
  const e = ["top", "right", "bottom", "left"];
  if (!e.every((o) => i[o]))
    return i;
  const n = i.top;
  return e.every((o) => i[o] === n) ? n : i;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function se(i, e, t, n, s = 1) {
  e != null && s !== void 0 && s !== null && e > s ? n.setAttribute(i, e, t) : n.removeAttribute(i, t);
}
function An(i, e, t = {}) {
  const n = i.createElement("tableCell", t);
  return i.insertElement("paragraph", n), i.insert(n, e), n;
}
function Ia(i, e) {
  const t = e.parent.parent, n = parseInt(t.getAttribute("headingColumns") || "0"), { column: s } = i.getCellLocation(e);
  return !!n && s < n;
}
function uo(i, e, t) {
  const { modelAttribute: n } = t;
  i.extend("tableCell", {
    allowAttributes: [n]
  }), Wl(e, { viewElement: /^(td|th)$/, ...t }), $i(e, { modelElement: "tableCell", ...t });
}
function ln(i) {
  const e = i.getSelectedElement();
  return e && e.is("element", "table") ? e : i.getFirstPosition().findAncestor("table");
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function u4() {
  return (i) => {
    i.on("element:figure", (e, t, n) => {
      if (!n.consumable.test(t.viewItem, { name: !0, classes: "table" }))
        return;
      const s = f4(t.viewItem);
      if (!s || !n.consumable.test(s, { name: !0 }))
        return;
      n.consumable.consume(t.viewItem, { name: !0, classes: "table" });
      const o = n.convertItem(s, t.modelCursor), r = me(o.modelRange.getItems());
      if (!r) {
        n.consumable.revert(t.viewItem, { name: !0, classes: "table" });
        return;
      }
      n.convertChildren(t.viewItem, n.writer.createPositionAt(r, "end")), n.updateConversionResult(r, t);
    });
  };
}
function d4() {
  return (i) => {
    i.on("element:table", (e, t, n) => {
      const s = t.viewItem;
      if (!n.consumable.test(s, { name: !0 }))
        return;
      const { rows: o, headingRows: r, headingColumns: a } = m4(s), l = {};
      a && (l.headingColumns = a), r && (l.headingRows = r);
      const c = n.writer.createElement("table", l);
      if (n.safeInsert(c, t.modelCursor)) {
        if (n.consumable.consume(s, { name: !0 }), o.forEach((u) => n.convertItem(u, n.writer.createPositionAt(c, "end"))), n.convertChildren(s, n.writer.createPositionAt(c, "end")), c.isEmpty) {
          const u = n.writer.createElement("tableRow");
          n.writer.insert(u, n.writer.createPositionAt(c, "end")), An(n.writer, n.writer.createPositionAt(u, "end"));
        }
        n.updateConversionResult(c, t);
      }
    });
  };
}
function h4() {
  return (i) => {
    i.on("element:tr", (e, t) => {
      t.viewItem.isEmpty && t.modelCursor.index == 0 && e.stop();
    }, { priority: "high" });
  };
}
function fh(i) {
  return (e) => {
    e.on(`element:${i}`, (t, n, { writer: s }) => {
      if (!n.modelRange)
        return;
      const o = n.modelRange.start.nodeAfter, r = s.createPositionAt(o, 0);
      if (n.viewItem.isEmpty) {
        s.insertElement("paragraph", r);
        return;
      }
      const a = Array.from(o.getChildren());
      if (a.every((l) => l.is("element", "$marker"))) {
        const l = s.createElement("paragraph");
        s.insert(l, s.createPositionAt(o, 0));
        for (const c of a)
          s.move(s.createRangeOn(c), s.createPositionAt(l, "end"));
      }
    }, { priority: "low" });
  };
}
function f4(i) {
  for (const e of i.getChildren())
    if (e.is("element", "table"))
      return e;
}
function m4(i) {
  let e = 0, t;
  const n = [], s = [];
  let o;
  for (const r of Array.from(i.getChildren())) {
    if (r.name !== "tbody" && r.name !== "thead" && r.name !== "tfoot")
      continue;
    r.name === "thead" && !o && (o = r);
    const a = Array.from(r.getChildren()).filter((l) => l.is("element", "tr"));
    for (const l of a)
      if (o && r === o || r.name === "tbody" && Array.from(l.getChildren()).length && Array.from(l.getChildren()).every((c) => c.is("element", "th")))
        e++, n.push(l);
      else {
        s.push(l);
        const c = g4(l);
        (!t || c < t) && (t = c);
      }
  }
  return {
    headingRows: e,
    headingColumns: t || 0,
    rows: [...n, ...s]
  };
}
function g4(i) {
  let e = 0, t = 0;
  const n = Array.from(i.getChildren()).filter((s) => s.name === "th" || s.name === "td");
  for (; t < n.length && n[t].name === "th"; ) {
    const s = n[t], o = parseInt(s.getAttribute("colspan") || "1");
    e = e + o, t++;
  }
  return e;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class W {
  /**
   * Creates an instance of the table walker.
   *
   * The table walker iterates internally by traversing the table from row index = 0 and column index = 0.
   * It walks row by row and column by column in order to output values defined in the constructor.
   * By default it will output only the locations that are occupied by a cell. To include also spanned rows and columns,
   * pass the `includeAllSlots` option to the constructor.
   *
   * The most important values of the iterator are column and row indexes of a cell.
   *
   * See {@link module:table/tablewalker~TableSlot} what values are returned by the table walker.
   *
   * To iterate over a given row:
   *
   * ```ts
   * const tableWalker = new TableWalker( table, { startRow: 1, endRow: 2 } );
   *
   * for ( const tableSlot of tableWalker ) {
   *   console.log( 'A cell at row', tableSlot.row, 'and column', tableSlot.column );
   * }
   * ```
   *
   * For instance the code above for the following table:
   *
   *  +----+----+----+----+----+----+
   *  | 00      | 02 | 03 | 04 | 05 |
   *  |         +----+----+----+----+
   *  |         | 12      | 14 | 15 |
   *  |         +----+----+----+    +
   *  |         | 22           |    |
   *  |----+----+----+----+----+    +
   *  | 30 | 31 | 32 | 33 | 34 |    |
   *  +----+----+----+----+----+----+
   *
   * will log in the console:
   *
   *  'A cell at row 1 and column 2'
   *  'A cell at row 1 and column 4'
   *  'A cell at row 1 and column 5'
   *  'A cell at row 2 and column 2'
   *
   * To also iterate over spanned cells:
   *
   * ```ts
   * const tableWalker = new TableWalker( table, { row: 1, includeAllSlots: true } );
   *
   * for ( const tableSlot of tableWalker ) {
   *   console.log( 'Slot at', tableSlot.row, 'x', tableSlot.column, ':', tableSlot.isAnchor ? 'is anchored' : 'is spanned' );
   * }
   * ```
   *
   * will log in the console for the table from the previous example:
   *
   *  'Cell at 1 x 0 : is spanned'
   *  'Cell at 1 x 1 : is spanned'
   *  'Cell at 1 x 2 : is anchored'
   *  'Cell at 1 x 3 : is spanned'
   *  'Cell at 1 x 4 : is anchored'
   *  'Cell at 1 x 5 : is anchored'
   *
   * **Note**: Option `row` is a shortcut that sets both `startRow` and `endRow` to the same row.
   * (Use either `row` or `startRow` and `endRow` but never together). Similarly the `column` option sets both `startColumn`
   * and `endColumn` to the same column (Use either `column` or `startColumn` and `endColumn` but never together).
   *
   * @param table A table over which the walker iterates.
   * @param options An object with configuration.
   * @param options.row A row index for which this iterator will output cells. Can't be used together with `startRow` and `endRow`.
   * @param options.startRow A row index from which this iterator should start. Can't be used together with `row`. Default value is 0.
   * @param options.endRow A row index at which this iterator should end. Can't be used together with `row`.
   * @param options.column A column index for which this iterator will output cells.
   * Can't be used together with `startColumn` and `endColumn`.
   * @param options.startColumn A column index from which this iterator should start.
   * Can't be used together with `column`. Default value is 0.
   * @param options.endColumn A column index at which this iterator should end. Can't be used together with `column`.
   * @param options.includeAllSlots Also return values for spanned cells. Default value is "false".
   */
  constructor(e, t = {}) {
    this._jumpedToStartRow = !1, this._table = e, this._startRow = t.row !== void 0 ? t.row : t.startRow || 0, this._endRow = t.row !== void 0 ? t.row : t.endRow, this._startColumn = t.column !== void 0 ? t.column : t.startColumn || 0, this._endColumn = t.column !== void 0 ? t.column : t.endColumn, this._includeAllSlots = !!t.includeAllSlots, this._skipRows = /* @__PURE__ */ new Set(), this._row = 0, this._rowIndex = 0, this._column = 0, this._cellIndex = 0, this._spannedCells = /* @__PURE__ */ new Map(), this._nextCellAtColumn = -1;
  }
  /**
   * Iterable interface.
   */
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Gets the next table walker's value.
   *
   * @returns The next table walker's value.
   */
  next() {
    this._canJumpToStartRow() && this._jumpToNonSpannedRowClosestToStartRow();
    const e = this._table.getChild(this._rowIndex);
    if (!e || this._isOverEndRow())
      return { done: !0, value: void 0 };
    if (!e.is("element", "tableRow"))
      return this._rowIndex++, this.next();
    if (this._isOverEndColumn())
      return this._advanceToNextRow();
    let t = null;
    const n = this._getSpanned();
    if (n)
      this._includeAllSlots && !this._shouldSkipSlot() && (t = this._formatOutValue(n.cell, n.row, n.column));
    else {
      const s = e.getChild(this._cellIndex);
      if (!s)
        return this._advanceToNextRow();
      const o = parseInt(s.getAttribute("colspan") || "1"), r = parseInt(s.getAttribute("rowspan") || "1");
      (o > 1 || r > 1) && this._recordSpans(s, r, o), this._shouldSkipSlot() || (t = this._formatOutValue(s)), this._nextCellAtColumn = this._column + o;
    }
    return this._column++, this._column == this._nextCellAtColumn && this._cellIndex++, t || this.next();
  }
  /**
   * Marks a row to skip in the next iteration. It will also skip cells from the current row if there are any cells from the current row
   * to output.
   *
   * @param row The row index to skip.
   */
  skipRow(e) {
    this._skipRows.add(e);
  }
  /**
   * Advances internal cursor to the next row.
   */
  _advanceToNextRow() {
    return this._row++, this._rowIndex++, this._column = 0, this._cellIndex = 0, this._nextCellAtColumn = -1, this.next();
  }
  /**
   * Checks if the current row is over {@link #_endRow}.
   */
  _isOverEndRow() {
    return this._endRow !== void 0 && this._row > this._endRow;
  }
  /**
   * Checks if the current cell is over {@link #_endColumn}
   */
  _isOverEndColumn() {
    return this._endColumn !== void 0 && this._column > this._endColumn;
  }
  /**
   * A common method for formatting the iterator's output value.
   *
   * @param cell The table cell to output.
   * @param anchorRow The row index of a cell anchor slot.
   * @param anchorColumn The column index of a cell anchor slot.
   */
  _formatOutValue(e, t = this._row, n = this._column) {
    return {
      done: !1,
      value: new p4(this, e, t, n)
    };
  }
  /**
   * Checks if the current slot should be skipped.
   */
  _shouldSkipSlot() {
    const e = this._skipRows.has(this._row), t = this._row < this._startRow, n = this._column < this._startColumn, s = this._endColumn !== void 0 && this._column > this._endColumn;
    return e || t || n || s;
  }
  /**
   * Returns the cell element that is spanned over the current cell location.
   */
  _getSpanned() {
    const e = this._spannedCells.get(this._row);
    return e && e.get(this._column) || null;
  }
  /**
   * Updates spanned cells map relative to the current cell location and its span dimensions.
   *
   * @param cell A cell that is spanned.
   * @param rowspan Cell height.
   * @param colspan Cell width.
   */
  _recordSpans(e, t, n) {
    const s = {
      cell: e,
      row: this._row,
      column: this._column
    };
    for (let o = this._row; o < this._row + t; o++)
      for (let r = this._column; r < this._column + n; r++)
        (o != this._row || r != this._column) && this._markSpannedCell(o, r, s);
  }
  /**
   * Marks the cell location as spanned by another cell.
   *
   * @param row The row index of the cell location.
   * @param column The column index of the cell location.
   * @param data A spanned cell details (cell element, anchor row and column).
   */
  _markSpannedCell(e, t, n) {
    this._spannedCells.has(e) || this._spannedCells.set(e, /* @__PURE__ */ new Map()), this._spannedCells.get(e).set(t, n);
  }
  /**
   * Checks if part of the table can be skipped.
   */
  _canJumpToStartRow() {
    return !!this._startRow && this._startRow > 0 && !this._jumpedToStartRow;
  }
  /**
   * Sets the current row to `this._startRow` or the first row before it that has the number of cells
   * equal to the number of columns in the table.
   *
   * Example:
   * 	+----+----+----+
   *  | 00 | 01 | 02 |
   *  |----+----+----+
   *  | 10      | 12 |
   *  |         +----+
   *  |         | 22 |
   *  |         +----+
   *  |         | 32 | <--- Start row
   *  +----+----+----+
   *  | 40 | 41 | 42 |
   *  +----+----+----+
   *
   * If the 4th row is a `this._startRow`, this method will:
   * 1.) Count the number of columns this table has based on the first row (3 columns in this case).
   * 2.) Check if the 4th row contains 3 cells. It doesn't, so go to the row before it.
   * 3.) Check if the 3rd row contains 3 cells. It doesn't, so go to the row before it.
   * 4.) Check if the 2nd row contains 3 cells. It does, so set the current row to that row.
   *
   * Setting the current row this way is necessary to let the `next()`  method loop over the cells
   * spanning multiple rows or columns and update the `this._spannedCells` property.
   */
  _jumpToNonSpannedRowClosestToStartRow() {
    const e = this._getRowLength(0);
    for (let t = this._startRow; !this._jumpedToStartRow; t--)
      e === this._getRowLength(t) && (this._row = t, this._rowIndex = t, this._jumpedToStartRow = !0);
  }
  /**
   * Returns a number of columns in a row taking `colspan` into consideration.
   */
  _getRowLength(e) {
    return [...this._table.getChild(e).getChildren()].reduce((n, s) => n + parseInt(s.getAttribute("colspan") || "1"), 0);
  }
}
class p4 {
  /**
   * Creates an instance of the table walker value.
   *
   * @param tableWalker The table walker instance.
   * @param cell The current table cell.
   * @param anchorRow The row index of a cell anchor slot.
   * @param anchorColumn The column index of a cell anchor slot.
   */
  constructor(e, t, n, s) {
    this.cell = t, this.row = e._row, this.column = e._column, this.cellAnchorRow = n, this.cellAnchorColumn = s, this._cellIndex = e._cellIndex, this._rowIndex = e._rowIndex, this._table = e._table;
  }
  // @if CK_DEBUG // public get isSpanned(): unknown { return throwMissingGetterError( 'isSpanned' ); }
  // @if CK_DEBUG // public get colspan(): unknown { return throwMissingGetterError( 'colspan' ); }
  // @if CK_DEBUG // public get rowspan(): unknown { return throwMissingGetterError( 'rowspan' ); }
  // @if CK_DEBUG // public get cellIndex(): unknown { return throwMissingGetterError( 'cellIndex' ); }
  /**
   * Whether the cell is anchored in the current slot.
   */
  get isAnchor() {
    return this.row === this.cellAnchorRow && this.column === this.cellAnchorColumn;
  }
  /**
   * The width of a cell defined by a `colspan` attribute. If the model attribute is not present, it is set to `1`.
   */
  get cellWidth() {
    return parseInt(this.cell.getAttribute("colspan") || "1");
  }
  /**
   * The height of a cell defined by a `rowspan` attribute. If the model attribute is not present, it is set to `1`.
   */
  get cellHeight() {
    return parseInt(this.cell.getAttribute("rowspan") || "1");
  }
  /**
   * The index of the current row element in the table.
   */
  get rowIndex() {
    return this._rowIndex;
  }
  /**
   * Returns the {@link module:engine/model/position~Position} before the table slot.
   */
  getPositionBefore() {
    return this._table.root.document.model.createPositionAt(this._table.getChild(this.row), this._cellIndex);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function mh(i, e) {
  return (t, { writer: n }) => {
    const s = t.getAttribute("headingRows") || 0, o = n.createContainerElement("table", null, []), r = n.createContainerElement("figure", { class: "table" }, o);
    s > 0 && n.insert(n.createPositionAt(o, "end"), n.createContainerElement("thead", null, n.createSlot((a) => a.is("element", "tableRow") && a.index < s))), s < i.getRows(t) && n.insert(n.createPositionAt(o, "end"), n.createContainerElement("tbody", null, n.createSlot((a) => a.is("element", "tableRow") && a.index >= s)));
    for (const { positionOffset: a, filter: l } of e.additionalSlots)
      n.insert(n.createPositionAt(o, a), n.createSlot(l));
    return n.insert(n.createPositionAt(o, "after"), n.createSlot((a) => a.is("element", "tableRow") ? !1 : !e.additionalSlots.some(({ filter: l }) => l(a)))), e.asWidget ? w4(r, n) : r;
  };
}
function b4() {
  return (i, { writer: e }) => i.isEmpty ? e.createEmptyElement("tr") : e.createContainerElement("tr");
}
function gh(i = {}) {
  return (e, { writer: t }) => {
    const n = e.parent, s = n.parent, o = s.getChildIndex(n), r = new W(s, { row: o }), a = s.getAttribute("headingRows") || 0, l = s.getAttribute("headingColumns") || 0;
    let c = null;
    for (const u of r)
      if (u.cell == e) {
        const h = u.row < a || u.column < l ? "th" : "td";
        c = i.asWidget ? Ml(t.createEditableElement(h), t) : t.createContainerElement(h);
        break;
      }
    return c;
  };
}
function ph(i = {}) {
  return (e, { writer: t }) => {
    if (!e.parent.is("element", "tableCell") || !Vp(e))
      return null;
    if (i.asWidget)
      return t.createContainerElement("span", { class: "ck-table-bogus-paragraph" });
    {
      const n = t.createContainerElement("p");
      return t.setCustomProperty("dataPipeline:transparentRendering", !0, n), n;
    }
  };
}
function Vp(i) {
  return i.parent.childCount == 1 && !_4(i);
}
function w4(i, e) {
  return e.setCustomProperty("table", !0, i), lr(i, e, { hasSelectionHandle: !0 });
}
function _4(i) {
  return !i.getAttributeKeys().next().done;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class v4 extends V {
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor.model, t = e.document.selection, n = e.schema;
    this.isEnabled = y4(t, n);
  }
  /**
   * Executes the command.
   *
   * Inserts a table with the given number of rows and columns into the editor.
   *
   * @param options.rows The number of rows to create in the inserted table. Default value is 2.
   * @param options.columns The number of columns to create in the inserted table. Default value is 2.
   * @param options.headingRows The number of heading rows. If not provided it will default to
   * {@link module:table/tableconfig~TableConfig#defaultHeadings `config.table.defaultHeadings.rows`} table config.
   * @param options.headingColumns The number of heading columns. If not provided it will default to
   * {@link module:table/tableconfig~TableConfig#defaultHeadings `config.table.defaultHeadings.columns`} table config.
   * @fires execute
   */
  execute(e = {}) {
    const t = this.editor, n = t.model, s = t.plugins.get("TableUtils"), o = t.config.get("table.defaultHeadings.rows"), r = t.config.get("table.defaultHeadings.columns");
    e.headingRows === void 0 && o && (e.headingRows = o), e.headingColumns === void 0 && r && (e.headingColumns = r), n.change((a) => {
      const l = s.createTable(a, e);
      n.insertObject(l, null, null, { findOptimalPosition: "auto" }), a.setSelection(a.createPositionAt(l.getNodeByPath([0, 0, 0]), 0));
    });
  }
}
function y4(i, e) {
  const t = i.getFirstPosition().parent, n = t === t.root ? t : t.parent;
  return e.checkChild(n, "table");
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class bh extends V {
  /**
   * Creates a new `InsertRowCommand` instance.
   *
   * @param editor The editor on which this command will be used.
   * @param options.order The order of insertion relative to the row in which the caret is located.
   * Possible values: `"above"` and `"below"`. Default value is "below"
   */
  constructor(e, t = {}) {
    super(e), this.order = t.order || "below";
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor.model.document.selection, n = !!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(e).length;
    this.isEnabled = n;
  }
  /**
   * Executes the command.
   *
   * Depending on the command's {@link #order} value, it inserts a row `'below'` or `'above'` the row in which selection is set.
   *
   * @fires execute
   */
  execute() {
    const e = this.editor, t = e.model.document.selection, n = e.plugins.get("TableUtils"), s = this.order === "above", o = n.getSelectionAffectedTableCells(t), r = n.getRowIndexes(o), a = s ? r.first : r.last, l = o[0].findAncestor("table");
    n.insertRows(l, { at: s ? a : a + 1, copyStructureFromAbove: !s });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class wh extends V {
  /**
   * Creates a new `InsertColumnCommand` instance.
   *
   * @param editor An editor on which this command will be used.
   * @param options.order The order of insertion relative to the column in which the caret is located.
   * Possible values: `"left"` and `"right"`. Default value is "right".
   */
  constructor(e, t = {}) {
    super(e), this.order = t.order || "right";
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor.model.document.selection, n = !!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(e).length;
    this.isEnabled = n;
  }
  /**
   * Executes the command.
   *
   * Depending on the command's {@link #order} value, it inserts a column to the `'left'` or `'right'` of the column
   * in which the selection is set.
   *
   * @fires execute
   */
  execute() {
    const e = this.editor, t = e.model.document.selection, n = e.plugins.get("TableUtils"), s = this.order === "left", o = n.getSelectionAffectedTableCells(t), r = n.getColumnIndexes(o), a = s ? r.first : r.last, l = o[0].findAncestor("table");
    n.insertColumns(l, { columns: 1, at: s ? a : a + 1 });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class _h extends V {
  /**
   * Creates a new `SplitCellCommand` instance.
   *
   * @param editor The editor on which this command will be used.
   * @param options.direction Indicates whether the command should split cells `'horizontally'` or `'vertically'`.
   */
  constructor(e, t = {}) {
    super(e), this.direction = t.direction || "horizontally";
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const t = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
    this.isEnabled = t.length === 1;
  }
  /**
   * @inheritDoc
   */
  execute() {
    const e = this.editor.plugins.get("TableUtils"), t = e.getSelectionAffectedTableCells(this.editor.model.document.selection)[0];
    this.direction === "horizontally" ? e.splitCellHorizontally(t, 2) : e.splitCellVertically(t, 2);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Mp(i, e, t) {
  const { startRow: n, startColumn: s, endRow: o, endColumn: r } = e, a = t.createElement("table"), l = o - n + 1;
  for (let u = 0; u < l; u++)
    t.insertElement("tableRow", a, "end");
  const c = [...new W(i, { startRow: n, endRow: o, startColumn: s, endColumn: r, includeAllSlots: !0 })];
  for (const { row: u, column: d, cell: h, isAnchor: f, cellAnchorRow: m, cellAnchorColumn: p } of c) {
    const w = u - n, v = a.getChild(w);
    if (!f)
      (m < n || p < s) && An(t, t.createPositionAt(v, "end"));
    else {
      const C = t.cloneElement(h);
      t.append(C, v), Np(C, u, d, o, r, t);
    }
  }
  return C4(a, i, n, s, t), a;
}
function Bp(i, e, t = 0) {
  const n = [], s = new W(i, { startRow: t, endRow: e - 1 });
  for (const o of s) {
    const { row: r, cellHeight: a } = o, l = r + a - 1;
    r < e && e <= l && n.push(o);
  }
  return n;
}
function Lp(i, e, t) {
  const n = i.parent, s = n.parent, o = n.index, r = parseInt(i.getAttribute("rowspan")), a = e - o, l = {}, c = r - a;
  c > 1 && (l.rowspan = c);
  const u = parseInt(i.getAttribute("colspan") || "1");
  u > 1 && (l.colspan = u);
  const d = o, h = d + a, f = [...new W(s, { startRow: d, endRow: h, includeAllSlots: !0 })];
  let m = null, p;
  for (const w of f) {
    const { row: v, column: C, cell: L } = w;
    L === i && p === void 0 && (p = C), p !== void 0 && p === C && v === h && (m = An(t, w.getPositionBefore(), l));
  }
  return se("rowspan", a, i, t), m;
}
function Op(i, e) {
  const t = [], n = new W(i);
  for (const s of n) {
    const { column: o, cellWidth: r } = s, a = o + r - 1;
    o < e && e <= a && t.push(s);
  }
  return t;
}
function Fp(i, e, t, n) {
  const s = parseInt(i.getAttribute("colspan")), o = t - e, r = {}, a = s - o;
  a > 1 && (r.colspan = a);
  const l = parseInt(i.getAttribute("rowspan") || "1");
  l > 1 && (r.rowspan = l);
  const c = An(n, n.createPositionAfter(i), r);
  return se("colspan", o, i, n), c;
}
function Np(i, e, t, n, s, o) {
  const r = parseInt(i.getAttribute("colspan") || "1"), a = parseInt(i.getAttribute("rowspan") || "1");
  if (t + r - 1 > s) {
    const u = s - t + 1;
    se("colspan", u, i, o, 1);
  }
  if (e + a - 1 > n) {
    const u = n - e + 1;
    se("rowspan", u, i, o, 1);
  }
}
function C4(i, e, t, n, s) {
  const o = parseInt(e.getAttribute("headingRows") || "0");
  if (o > 0) {
    const a = o - t;
    se("headingRows", a, i, s, 0);
  }
  const r = parseInt(e.getAttribute("headingColumns") || "0");
  if (r > 0) {
    const a = r - n;
    se("headingColumns", a, i, s, 0);
  }
}
function Sa(i, e) {
  const t = e.getColumns(i), n = new Array(t).fill(0);
  for (const { column: o } of new W(i))
    n[o]++;
  const s = n.reduce((o, r, a) => r ? o : [...o, a], []);
  if (s.length > 0) {
    const o = s[s.length - 1];
    return e.removeColumns(i, { at: o }), !0;
  }
  return !1;
}
function Pa(i, e) {
  const t = [], n = e.getRows(i);
  for (let s = 0; s < n; s++)
    i.getChild(s).isEmpty && t.push(s);
  if (t.length > 0) {
    const s = t[t.length - 1];
    return e.removeRows(i, { at: s }), !0;
  }
  return !1;
}
function ql(i, e) {
  Sa(i, e) || Pa(i, e);
}
function Dp(i, e) {
  const t = Array.from(new W(i, {
    startColumn: e.firstColumn,
    endColumn: e.lastColumn,
    row: e.lastRow
  }));
  if (t.every(({ cellHeight: o }) => o === 1))
    return e.lastRow;
  const s = t[0].cellHeight - 1;
  return e.lastRow + s;
}
function zp(i, e) {
  const t = Array.from(new W(i, {
    startRow: e.firstRow,
    endRow: e.lastRow,
    column: e.lastColumn
  }));
  if (t.every(({ cellWidth: o }) => o === 1))
    return e.lastColumn;
  const s = t[0].cellWidth - 1;
  return e.lastColumn + s;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Ys extends V {
  /**
   * Creates a new `MergeCellCommand` instance.
   *
   * @param editor The editor on which this command will be used.
   * @param options.direction Indicates which cell to merge with the currently selected one.
   * Possible values are: `'left'`, `'right'`, `'up'` and `'down'`.
   */
  constructor(e, t) {
    super(e), this.direction = t.direction, this.isHorizontal = this.direction == "right" || this.direction == "left";
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this._getMergeableCell();
    this.value = e, this.isEnabled = !!e;
  }
  /**
   * Executes the command.
   *
   * Depending on the command's {@link #direction} value, it will merge the cell that is to the `'left'`, `'right'`, `'up'` or `'down'`.
   *
   * @fires execute
   */
  execute() {
    const e = this.editor.model, t = e.document, s = this.editor.plugins.get("TableUtils").getTableCellsContainingSelection(t.selection)[0], o = this.value, r = this.direction;
    e.change((a) => {
      const l = r == "right" || r == "down", c = l ? s : o, u = l ? o : s, d = u.parent;
      E4(u, c, a);
      const h = this.isHorizontal ? "colspan" : "rowspan", f = parseInt(s.getAttribute(h) || "1"), m = parseInt(o.getAttribute(h) || "1");
      a.setAttribute(h, f + m, c), a.setSelection(a.createRangeIn(c));
      const p = this.editor.plugins.get("TableUtils"), w = d.findAncestor("table");
      ql(w, p);
    });
  }
  /**
   * Returns a cell that can be merged with the current cell depending on the command's direction.
   */
  _getMergeableCell() {
    const t = this.editor.model.document, n = this.editor.plugins.get("TableUtils"), s = n.getTableCellsContainingSelection(t.selection)[0];
    if (!s)
      return;
    const o = this.isHorizontal ? k4(s, this.direction, n) : T4(s, this.direction, n);
    if (!o)
      return;
    const r = this.isHorizontal ? "rowspan" : "colspan", a = parseInt(s.getAttribute(r) || "1");
    if (parseInt(o.getAttribute(r) || "1") === a)
      return o;
  }
}
function k4(i, e, t) {
  const s = i.parent.parent, o = e == "right" ? i.nextSibling : i.previousSibling, r = (s.getAttribute("headingColumns") || 0) > 0;
  if (!o)
    return;
  const a = e == "right" ? i : o, l = e == "right" ? o : i, { column: c } = t.getCellLocation(a), { column: u } = t.getCellLocation(l), d = parseInt(a.getAttribute("colspan") || "1"), h = Ia(t, a), f = Ia(t, l);
  return r && h != f ? void 0 : c + d === u ? o : void 0;
}
function T4(i, e, t) {
  const n = i.parent, s = n.parent, o = s.getChildIndex(n);
  if (e == "down" && o === t.getRows(s) - 1 || e == "up" && o === 0)
    return null;
  const r = parseInt(i.getAttribute("rowspan") || "1"), a = s.getAttribute("headingRows") || 0, l = e == "down" && o + r === a, c = e == "up" && o === a;
  if (a && (l || c))
    return null;
  const u = parseInt(i.getAttribute("rowspan") || "1"), d = e == "down" ? o + u : o, h = [...new W(s, { endRow: d })], m = h.find((w) => w.cell === i).column, p = h.find(({ row: w, cellHeight: v, column: C }) => C !== m ? !1 : e == "down" ? w === d : d === w + v);
  return p && p.cell ? p.cell : null;
}
function E4(i, e, t) {
  vh(i) || (vh(e) && t.remove(t.createRangeIn(e)), t.move(t.createRangeIn(i), t.createPositionAt(e, "end"))), t.remove(i);
}
function vh(i) {
  const e = i.getChild(0);
  return i.childCount == 1 && e.is("element", "paragraph") && e.isEmpty;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class A4 extends V {
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor.plugins.get("TableUtils"), t = e.getSelectionAffectedTableCells(this.editor.model.document.selection), n = t[0];
    if (n) {
      const s = n.findAncestor("table"), r = e.getRows(s) - 1, a = e.getRowIndexes(t), l = a.first === 0 && a.last === r;
      this.isEnabled = !l;
    } else
      this.isEnabled = !1;
  }
  /**
   * @inheritDoc
   */
  execute() {
    const e = this.editor.model, t = this.editor.plugins.get("TableUtils"), n = t.getSelectionAffectedTableCells(e.document.selection), s = t.getRowIndexes(n), o = n[0], r = o.findAncestor("table"), a = t.getCellLocation(o).column;
    e.change((l) => {
      const c = s.last - s.first + 1;
      t.removeRows(r, {
        at: s.first,
        rows: c
      });
      const u = x4(r, s.first, a, t.getRows(r));
      l.setSelection(l.createPositionAt(u, 0));
    });
  }
}
function x4(i, e, t, n) {
  const s = i.getChild(Math.min(e, n - 1));
  let o = s.getChild(0), r = 0;
  for (const a of s.getChildren()) {
    if (r > t)
      return o;
    o = a, r += parseInt(a.getAttribute("colspan") || "1");
  }
  return o;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class I4 extends V {
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor.plugins.get("TableUtils"), t = e.getSelectionAffectedTableCells(this.editor.model.document.selection), n = t[0];
    if (n) {
      const s = n.findAncestor("table"), o = e.getColumns(s), { first: r, last: a } = e.getColumnIndexes(t);
      this.isEnabled = a - r < o - 1;
    } else
      this.isEnabled = !1;
  }
  /**
   * @inheritDoc
   */
  execute() {
    const e = this.editor.plugins.get("TableUtils"), [t, n] = P4(this.editor.model.document.selection, e), s = t.parent.parent, o = [...new W(s)], r = {
      first: o.find((l) => l.cell === t).column,
      last: o.find((l) => l.cell === n).column
    }, a = S4(o, t, n, r);
    this.editor.model.change((l) => {
      const c = r.last - r.first + 1;
      e.removeColumns(s, {
        at: r.first,
        columns: c
      }), l.setSelection(l.createPositionAt(a, 0));
    });
  }
}
function S4(i, e, t, n) {
  return parseInt(t.getAttribute("colspan") || "1") > 1 ? t : e.previousSibling || t.nextSibling ? t.nextSibling || e.previousSibling : n.first ? i.reverse().find(({ column: o }) => o < n.first).cell : i.reverse().find(({ column: o }) => o > n.last).cell;
}
function P4(i, e) {
  const t = e.getSelectionAffectedTableCells(i), n = t[0], s = t.pop(), o = [n, s];
  return n.isBefore(s) ? o : o.reverse();
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class R4 extends V {
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor.plugins.get("TableUtils"), t = this.editor.model, n = e.getSelectionAffectedTableCells(t.document.selection), s = n.length > 0;
    this.isEnabled = s, this.value = s && n.every((o) => this._isInHeading(o, o.parent.parent));
  }
  /**
   * Executes the command.
   *
   * When the selection is in a non-header row, the command will set the `headingRows` table attribute to cover that row.
   *
   * When the selection is already in a header row, it will set `headingRows` so the heading section will end before that row.
   *
   * @fires execute
   * @param options.forceValue If set, the command will set (`true`) or unset (`false`) the header rows according to
   * the `forceValue` parameter instead of the current model state.
   */
  execute(e = {}) {
    if (e.forceValue === this.value)
      return;
    const t = this.editor.plugins.get("TableUtils"), n = this.editor.model, s = t.getSelectionAffectedTableCells(n.document.selection), o = s[0].findAncestor("table"), { first: r, last: a } = t.getRowIndexes(s), l = this.value ? r : a + 1, c = o.getAttribute("headingRows") || 0;
    n.change((u) => {
      if (l) {
        const d = l > c ? c : 0, h = Bp(o, l, d);
        for (const { cell: f } of h)
          Lp(f, l, u);
      }
      se("headingRows", l, o, u, 0);
    });
  }
  /**
   * Checks if a table cell is in the heading section.
   */
  _isInHeading(e, t) {
    const n = parseInt(t.getAttribute("headingRows") || "0");
    return !!n && e.parent.index < n;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class V4 extends V {
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor.model, t = this.editor.plugins.get("TableUtils"), n = t.getSelectionAffectedTableCells(e.document.selection), s = n.length > 0;
    this.isEnabled = s, this.value = s && n.every((o) => Ia(t, o));
  }
  /**
   * Executes the command.
   *
   * When the selection is in a non-header column, the command will set the `headingColumns` table attribute to cover that column.
   *
   * When the selection is already in a header column, it will set `headingColumns` so the heading section will end before that column.
   *
   * @fires execute
   * @param options.forceValue If set, the command will set (`true`) or unset (`false`) the header columns according to
   * the `forceValue` parameter instead of the current model state.
   */
  execute(e = {}) {
    if (e.forceValue === this.value)
      return;
    const t = this.editor.plugins.get("TableUtils"), n = this.editor.model, s = t.getSelectionAffectedTableCells(n.document.selection), o = s[0].findAncestor("table"), { first: r, last: a } = t.getColumnIndexes(s), l = this.value ? r : a + 1;
    n.change((c) => {
      if (l) {
        const u = Op(o, l);
        for (const { cell: d, column: h } of u)
          Fp(d, h, l, c);
      }
      se("headingColumns", l, o, c, 0);
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const M4 = 5, Ra = 40, B4 = 2;
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function L4(i) {
  const e = /* @__PURE__ */ new Set();
  for (const t of i.document.differ.getChanges()) {
    let n = null;
    switch (t.type) {
      case "insert":
        n = ["table", "tableRow", "tableCell"].includes(t.name) ? t.position : null;
        break;
      case "remove":
        n = ["tableRow", "tableCell"].includes(t.name) ? t.position : null;
        break;
      case "attribute":
        t.range.start.nodeAfter && (n = ["table", "tableRow", "tableCell"].includes(t.range.start.nodeAfter.name) ? t.range.start : null);
        break;
    }
    if (!n)
      continue;
    const s = n.nodeAfter && n.nodeAfter.is("element", "table") ? n.nodeAfter : n.findAncestor("table");
    for (const o of i.createRangeOn(s).getItems())
      o.is("element", "table") && ys(o) && e.add(o);
  }
  return e;
}
function O4(i, e) {
  return Ra * 100 / Hp(i, e);
}
function Hp(i, e) {
  const t = yh(i, "tbody", e) || yh(i, "thead", e), n = e.editing.view.domConverter.mapViewToDom(t);
  return Va(n);
}
function yh(i, e, t) {
  return [...[...t.editing.mapper.toViewElement(i).getChildren()].find((o) => o.is("element", "table")).getChildren()].find((o) => o.is("element", e));
}
function Va(i) {
  const e = E.window.getComputedStyle(i);
  return e.boxSizing === "border-box" ? parseFloat(e.width) - parseFloat(e.paddingLeft) - parseFloat(e.paddingRight) - parseFloat(e.borderLeftWidth) - parseFloat(e.borderRightWidth) : parseFloat(e.width);
}
function F4(i, e) {
  const t = e.getCellLocation(i).column, n = i.getAttribute("colspan") || 1;
  return {
    leftEdge: t,
    rightEdge: t + n - 1
  };
}
function Se(i) {
  const e = Math.pow(10, B4), t = typeof i == "number" ? i : parseFloat(i);
  return Math.round(t * e) / e;
}
function N4(i, e, t) {
  return i <= e ? Se(e) : i >= t ? Se(t) : Se(i);
}
function D4(i, e) {
  return Array(i).fill(e);
}
function ds(i) {
  return i.map((e) => typeof e == "number" ? e : parseFloat(e)).filter((e) => !Number.isNaN(e)).reduce((e, t) => e + t, 0);
}
function Gl(i) {
  const e = i.map((s) => s === "auto" ? s : parseFloat(s.replace("%", "")));
  let t = z4(e);
  const n = ds(t);
  return n !== 100 && (t = t.map((s) => Se(s * 100 / n)).map((s, o, r) => {
    if (!(o === r.length - 1))
      return s;
    const l = ds(r);
    return Se(s + 100 - l);
  })), t.map((s) => s + "%");
}
function z4(i) {
  const e = i.filter((s) => s === "auto").length;
  if (e === 0)
    return i.map((s) => Se(s));
  const t = ds(i), n = Math.max((100 - t) / e, M4);
  return i.map((s) => s === "auto" ? n : s).map((s) => Se(s));
}
function H4(i) {
  const e = E.window.getComputedStyle(i);
  return e.boxSizing === "border-box" ? parseInt(e.width) : parseFloat(e.width) + parseFloat(e.paddingLeft) + parseFloat(e.paddingRight) + parseFloat(e.borderWidth);
}
function Up(i, e, t, n) {
  for (let s = 0; s < Math.max(t.length, i.length); s++) {
    const o = i[s], r = t[s];
    r ? o ? n.setAttribute("columnWidth", r, o) : n.appendElement("tableColumn", { columnWidth: r }, e) : n.remove(o);
  }
}
function ys(i) {
  if (i.is("element", "tableColumnGroup"))
    return i;
  const e = i.getChildren();
  return Array.from(e).find((t) => t.is("element", "tableColumnGroup"));
}
function Cs(i) {
  const e = ys(i);
  return e ? Array.from(e.getChildren()) : [];
}
function U4(i) {
  return Cs(i).map((e) => e.getAttribute("columnWidth"));
}
function $4(i, e) {
  return Cs(i).reduce((n, s) => {
    const o = s.getAttribute("columnWidth"), r = s.getAttribute("colSpan");
    if (!r)
      return n.push(o), n;
    for (let a = 0; a < r; a++)
      n.push(o);
    return e.removeAttribute("colSpan", s), n;
  }, []);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class be extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableUtils";
  }
  /**
   * @inheritDoc
   */
  init() {
    this.decorate("insertColumns"), this.decorate("insertRows");
  }
  /**
   * Returns the table cell location as an object with table row and table column indexes.
   *
   * For instance, in the table below:
   *
   *      0   1   2   3
   *    +---+---+---+---+
   *  0 | a     | b | c |
   *    +       +   +---+
   *  1 |       |   | d |
   *    +---+---+   +---+
   *  2 | e     |   | f |
   *    +---+---+---+---+
   *
   * the method will return:
   *
   * ```ts
   * const cellA = table.getNodeByPath( [ 0, 0 ] );
   * editor.plugins.get( 'TableUtils' ).getCellLocation( cellA );
   * // will return { row: 0, column: 0 }
   *
   * const cellD = table.getNodeByPath( [ 1, 0 ] );
   * editor.plugins.get( 'TableUtils' ).getCellLocation( cellD );
   * // will return { row: 1, column: 3 }
   * ```
   *
   * @returns Returns a `{row, column}` object.
   */
  getCellLocation(e) {
    const t = e.parent, n = t.parent, s = n.getChildIndex(t), o = new W(n, { row: s });
    for (const { cell: r, row: a, column: l } of o)
      if (r === e)
        return { row: a, column: l };
    /* istanbul ignore next -- @preserve */
  }
  /**
   * Creates an empty table with a proper structure. The table needs to be inserted into the model,
   * for example, by using the {@link module:engine/model/model~Model#insertContent} function.
   *
   * ```ts
   * model.change( ( writer ) => {
   *   // Create a table of 2 rows and 7 columns:
   *   const table = tableUtils.createTable( writer, { rows: 2, columns: 7 } );
   *
   *   // Insert a table to the model at the best position taking the current selection:
   *   model.insertContent( table );
   * }
   * ```
   *
   * @param writer The model writer.
   * @param options.rows The number of rows to create. Default value is 2.
   * @param options.columns The number of columns to create. Default value is 2.
   * @param options.headingRows The number of heading rows. Default value is 0.
   * @param options.headingColumns The number of heading columns. Default value is 0.
   * @returns The created table element.
   */
  createTable(e, t) {
    const n = e.createElement("table"), s = t.rows || 2, o = t.columns || 2;
    return $r(e, n, 0, s, o), t.headingRows && se("headingRows", Math.min(t.headingRows, s), n, e, 0), t.headingColumns && se("headingColumns", Math.min(t.headingColumns, o), n, e, 0), n;
  }
  /**
   * Inserts rows into a table.
   *
   * ```ts
   * editor.plugins.get( 'TableUtils' ).insertRows( table, { at: 1, rows: 2 } );
   * ```
   *
   * Assuming the table on the left, the above code will transform it to the table on the right:
   *
   *  row index
   *    0 +---+---+---+       `at` = 1,      +---+---+---+ 0
   *      | a | b | c |       `rows` = 2,    | a | b | c |
   *    1 +   +---+---+   <-- insert here    +   +---+---+ 1
   *      |   | d | e |                      |   |   |   |
   *    2 +   +---+---+       will give:     +   +---+---+ 2
   *      |   | f | g |                      |   |   |   |
   *    3 +---+---+---+                      +   +---+---+ 3
   *                                         |   | d | e |
   *                                         +   +---+---+ 4
   *                                         +   + f | g |
   *                                         +---+---+---+ 5
   *
   * @param table The table model element where the rows will be inserted.
   * @param options.at The row index at which the rows will be inserted.  Default value is 0.
   * @param options.rows The number of rows to insert.  Default value is 1.
   * @param options.copyStructureFromAbove The flag for copying row structure. Note that
   * the row structure will not be copied if this option is not provided.
   */
  insertRows(e, t = {}) {
    const n = this.editor.model, s = t.at || 0, o = t.rows || 1, r = t.copyStructureFromAbove !== void 0, a = t.copyStructureFromAbove ? s - 1 : s, l = this.getRows(e), c = this.getColumns(e);
    if (s > l)
      throw new g("tableutils-insertrows-insert-out-of-range", this, { options: t });
    n.change((u) => {
      const d = e.getAttribute("headingRows") || 0;
      if (d > s && se("headingRows", d + o, e, u, 0), !r && (s === 0 || s === l)) {
        $r(u, e, s, o, c);
        return;
      }
      const h = r ? Math.max(s, a) : s, f = new W(e, { endRow: h }), m = new Array(c).fill(1);
      for (const { row: p, column: w, cellHeight: v, cellWidth: C, cell: L } of f) {
        const F = p + v - 1, q = p < s && s <= F, x = p <= a && a <= F;
        q ? (u.setAttribute("rowspan", v + o, L), m[w] = -C) : r && x && (m[w] = C);
      }
      for (let p = 0; p < o; p++) {
        const w = u.createElement("tableRow");
        u.insert(w, e, s);
        for (let v = 0; v < m.length; v++) {
          const C = m[v], L = u.createPositionAt(w, "end");
          C > 0 && An(u, L, C > 1 ? { colspan: C } : void 0), v += Math.abs(C) - 1;
        }
      }
    });
  }
  /**
   * Inserts columns into a table.
   *
   * ```ts
   * editor.plugins.get( 'TableUtils' ).insertColumns( table, { at: 1, columns: 2 } );
   * ```
   *
   * Assuming the table on the left, the above code will transform it to the table on the right:
   *
   *  0   1   2   3                   0   1   2   3   4   5
   *  +---+---+---+                   +---+---+---+---+---+
   *  | a     | b |                   | a             | b |
   *  +       +---+                   +               +---+
   *  |       | c |                   |               | c |
   *  +---+---+---+     will give:    +---+---+---+---+---+
   *  | d | e | f |                   | d |   |   | e | f |
   *  +---+   +---+                   +---+---+---+   +---+
   *  | g |   | h |                   | g |   |   |   | h |
   *  +---+---+---+                   +---+---+---+---+---+
   *  | i         |                   | i                 |
   *  +---+---+---+                   +---+---+---+---+---+
   *      ^---- insert here, `at` = 1, `columns` = 2
   *
   * @param table The table model element where the columns will be inserted.
   * @param options.at The column index at which the columns will be inserted. Default value is 0.
   * @param options.columns The number of columns to insert. Default value is 1.
   */
  insertColumns(e, t = {}) {
    const n = this.editor.model, s = t.at || 0, o = t.columns || 1;
    n.change((r) => {
      const a = e.getAttribute("headingColumns");
      s < a && r.setAttribute("headingColumns", a + o, e);
      const l = this.getColumns(e);
      if (s === 0 || l === s) {
        for (const u of e.getChildren())
          u.is("element", "tableRow") && qn(o, r, r.createPositionAt(u, s ? "end" : 0));
        return;
      }
      const c = new W(e, { column: s, includeAllSlots: !0 });
      for (const u of c) {
        const { row: d, cell: h, cellAnchorColumn: f, cellAnchorRow: m, cellWidth: p, cellHeight: w } = u;
        if (f < s) {
          r.setAttribute("colspan", p + o, h);
          const v = m + w - 1;
          for (let C = d; C <= v; C++)
            c.skipRow(C);
        } else
          qn(o, r, u.getPositionBefore());
      }
    });
  }
  /**
   * Removes rows from the given `table`.
   *
   * This method re-calculates the table geometry including `rowspan` attribute of table cells overlapping removed rows
   * and table headings values.
   *
   * ```ts
   * editor.plugins.get( 'TableUtils' ).removeRows( table, { at: 1, rows: 2 } );
   * ```
   *
   * Executing the above code in the context of the table on the left will transform its structure as presented on the right:
   *
   *  row index
   *      ┌───┬───┬───┐        `at` = 1        ┌───┬───┬───┐
   *    0 │ a │ b │ c │        `rows` = 2      │ a │ b │ c │ 0
   *      │   ├───┼───┤                        │   ├───┼───┤
   *    1 │   │ d │ e │  <-- remove from here  │   │ d │ g │ 1
   *      │   │   ├───┤        will give:      ├───┼───┼───┤
   *    2 │   │   │ f │                        │ h │ i │ j │ 2
   *      │   │   ├───┤                        └───┴───┴───┘
   *    3 │   │   │ g │
   *      ├───┼───┼───┤
   *    4 │ h │ i │ j │
   *      └───┴───┴───┘
   *
   * @param options.at The row index at which the removing rows will start.
   * @param options.rows The number of rows to remove. Default value is 1.
   */
  removeRows(e, t) {
    const n = this.editor.model, s = t.rows || 1, o = this.getRows(e), r = t.at, a = r + s - 1;
    if (a > o - 1)
      throw new g("tableutils-removerows-row-index-out-of-range", this, { table: e, options: t });
    n.change((l) => {
      const c = { first: r, last: a }, { cellsToMove: u, cellsToTrim: d } = G4(e, c);
      if (u.size) {
        const h = a + 1;
        j4(e, h, u, l);
      }
      for (let h = a; h >= r; h--)
        l.remove(e.getChild(h));
      for (const { rowspan: h, cell: f } of d)
        se("rowspan", h, f, l);
      q4(e, c, l), Sa(e, this) || Pa(e, this);
    });
  }
  /**
   * Removes columns from the given `table`.
   *
   * This method re-calculates the table geometry including the `colspan` attribute of table cells overlapping removed columns
   * and table headings values.
   *
   * ```ts
   * editor.plugins.get( 'TableUtils' ).removeColumns( table, { at: 1, columns: 2 } );
   * ```
   *
   * Executing the above code in the context of the table on the left will transform its structure as presented on the right:
   *
   *    0   1   2   3   4                       0   1   2
   *  ┌───────────────┬───┐                   ┌───────┬───┐
   *  │ a             │ b │                   │ a     │ b │
   *  │               ├───┤                   │       ├───┤
   *  │               │ c │                   │       │ c │
   *  ├───┬───┬───┬───┼───┤     will give:    ├───┬───┼───┤
   *  │ d │ e │ f │ g │ h │                   │ d │ g │ h │
   *  ├───┼───┼───┤   ├───┤                   ├───┤   ├───┤
   *  │ i │ j │ k │   │ l │                   │ i │   │ l │
   *  ├───┴───┴───┴───┴───┤                   ├───┴───┴───┤
   *  │ m                 │                   │ m         │
   *  └───────────────────┘                   └───────────┘
   *        ^---- remove from here, `at` = 1, `columns` = 2
   *
   * @param options.at The row index at which the removing columns will start.
   * @param options.columns The number of columns to remove.
   */
  removeColumns(e, t) {
    const n = this.editor.model, s = t.at, o = t.columns || 1, r = t.at + o - 1;
    n.change((a) => {
      W4(e, { first: s, last: r }, a);
      const l = Cs(e);
      for (let c = r; c >= s; c--) {
        for (const { cell: u, column: d, cellWidth: h } of [...new W(e)])
          d <= c && h > 1 && d + h > c ? se("colspan", h - 1, u, a) : d === c && a.remove(u);
        if (l[c]) {
          const u = c === 0 ? l[1] : l[c - 1], d = parseFloat(l[c].getAttribute("columnWidth")), h = parseFloat(u.getAttribute("columnWidth"));
          a.remove(l[c]), a.setAttribute("columnWidth", d + h + "%", u);
        }
      }
      Pa(e, this) || Sa(e, this);
    });
  }
  /**
   * Divides a table cell vertically into several ones.
   *
   * The cell will be visually split into more cells by updating colspans of other cells in a column
   * and inserting cells (columns) after that cell.
   *
   * In the table below, if cell "a" is split into 3 cells:
   *
   *  +---+---+---+
   *  | a | b | c |
   *  +---+---+---+
   *  | d | e | f |
   *  +---+---+---+
   *
   * it will result in the table below:
   *
   *  +---+---+---+---+---+
   *  | a |   |   | b | c |
   *  +---+---+---+---+---+
   *  | d         | e | f |
   *  +---+---+---+---+---+
   *
   * So cell "d" will get its `colspan` updated to `3` and 2 cells will be added (2 columns will be created).
   *
   * Splitting a cell that already has a `colspan` attribute set will distribute the cell `colspan` evenly and the remainder
   * will be left to the original cell:
   *
   *  +---+---+---+
   *  | a         |
   *  +---+---+---+
   *  | b | c | d |
   *  +---+---+---+
   *
   * Splitting cell "a" with `colspan=3` into 2 cells will create 1 cell with a `colspan=a` and cell "a" that will have `colspan=2`:
   *
   *  +---+---+---+
   *  | a     |   |
   *  +---+---+---+
   *  | b | c | d |
   *  +---+---+---+
   */
  splitCellVertically(e, t = 2) {
    const n = this.editor.model, o = e.parent.parent, r = parseInt(e.getAttribute("rowspan") || "1"), a = parseInt(e.getAttribute("colspan") || "1");
    n.change((l) => {
      if (a > 1) {
        const { newCellsSpan: c, updatedSpan: u } = Ch(a, t);
        se("colspan", u, e, l);
        const d = {};
        c > 1 && (d.colspan = c), r > 1 && (d.rowspan = r);
        const h = a > t ? t - 1 : a - 1;
        qn(h, l, l.createPositionAfter(e), d);
      }
      if (a < t) {
        const c = t - a, u = [...new W(o)], { column: d } = u.find(({ cell: p }) => p === e), h = u.filter(({ cell: p, cellWidth: w, column: v }) => {
          const C = p !== e && v === d, L = v < d && v + w > d;
          return C || L;
        });
        for (const { cell: p, cellWidth: w } of h)
          l.setAttribute("colspan", w + c, p);
        const f = {};
        r > 1 && (f.rowspan = r), qn(c, l, l.createPositionAfter(e), f);
        const m = o.getAttribute("headingColumns") || 0;
        m > d && se("headingColumns", m + c, o, l);
      }
    });
  }
  /**
   * Divides a table cell horizontally into several ones.
   *
   * The cell will be visually split into more cells by updating rowspans of other cells in the row and inserting rows with a single cell
   * below.
   *
   * If in the table below cell "b" is split into 3 cells:
   *
   *  +---+---+---+
   *  | a | b | c |
   *  +---+---+---+
   *  | d | e | f |
   *  +---+---+---+
   *
   * It will result in the table below:
   *
   *  +---+---+---+
   *  | a | b | c |
   *  +   +---+   +
   *  |   |   |   |
   *  +   +---+   +
   *  |   |   |   |
   *  +---+---+---+
   *  | d | e | f |
   *  +---+---+---+
   *
   * So cells "a" and "b" will get their `rowspan` updated to `3` and 2 rows with a single cell will be added.
   *
   * Splitting a cell that already has a `rowspan` attribute set will distribute the cell `rowspan` evenly and the remainder
   * will be left to the original cell:
   *
   *  +---+---+---+
   *  | a | b | c |
   *  +   +---+---+
   *  |   | d | e |
   *  +   +---+---+
   *  |   | f | g |
   *  +   +---+---+
   *  |   | h | i |
   *  +---+---+---+
   *
   * Splitting cell "a" with `rowspan=4` into 3 cells will create 2 cells with a `rowspan=1` and cell "a" will have `rowspan=2`:
   *
   *  +---+---+---+
   *  | a | b | c |
   *  +   +---+---+
   *  |   | d | e |
   *  +---+---+---+
   *  |   | f | g |
   *  +---+---+---+
   *  |   | h | i |
   *  +---+---+---+
   */
  splitCellHorizontally(e, t = 2) {
    const n = this.editor.model, s = e.parent, o = s.parent, r = o.getChildIndex(s), a = parseInt(e.getAttribute("rowspan") || "1"), l = parseInt(e.getAttribute("colspan") || "1");
    n.change((c) => {
      if (a > 1) {
        const u = [...new W(o, {
          startRow: r,
          endRow: r + a - 1,
          includeAllSlots: !0
        })], { newCellsSpan: d, updatedSpan: h } = Ch(a, t);
        se("rowspan", h, e, c);
        const { column: f } = u.find(({ cell: p }) => p === e), m = {};
        d > 1 && (m.rowspan = d), l > 1 && (m.colspan = l);
        for (const p of u) {
          const { column: w, row: v } = p, C = v >= r + h, L = w === f, F = (v + r + h) % d === 0;
          C && L && F && qn(1, c, p.getPositionBefore(), m);
        }
      }
      if (a < t) {
        const u = t - a, d = [...new W(o, { startRow: 0, endRow: r })];
        for (const { cell: m, cellHeight: p, row: w } of d)
          if (m !== e && w + p > r) {
            const v = p + u;
            c.setAttribute("rowspan", v, m);
          }
        const h = {};
        l > 1 && (h.colspan = l), $r(c, o, r + 1, u, 1, h);
        const f = o.getAttribute("headingRows") || 0;
        f > r && se("headingRows", f + u, o, c);
      }
    });
  }
  /**
   * Returns the number of columns for a given table.
   *
   * ```ts
   * editor.plugins.get( 'TableUtils' ).getColumns( table );
   * ```
   *
   * @param table The table to analyze.
   */
  getColumns(e) {
    return [...e.getChild(0).getChildren()].filter((n) => n.is("element", "tableCell")).reduce((n, s) => {
      const o = parseInt(s.getAttribute("colspan") || "1");
      return n + o;
    }, 0);
  }
  /**
   * Returns the number of rows for a given table. Any other element present in the table model is omitted.
   *
   * ```ts
   * editor.plugins.get( 'TableUtils' ).getRows( table );
   * ```
   *
   * @param table The table to analyze.
   */
  getRows(e) {
    return Array.from(e.getChildren()).reduce((t, n) => n.is("element", "tableRow") ? t + 1 : t, 0);
  }
  /**
   * Creates an instance of the table walker.
   *
   * The table walker iterates internally by traversing the table from row index = 0 and column index = 0.
   * It walks row by row and column by column in order to output values defined in the options.
   * By default it will output only the locations that are occupied by a cell. To include also spanned rows and columns,
   * pass the `includeAllSlots` option.
   *
   * @internal
   * @param table A table over which the walker iterates.
   * @param options An object with configuration.
   */
  createTableWalker(e, t = {}) {
    return new W(e, t);
  }
  /**
   * Returns all model table cells that are fully selected (from the outside)
   * within the provided model selection's ranges.
   *
   * To obtain the cells selected from the inside, use
   * {@link #getTableCellsContainingSelection}.
   */
  getSelectedTableCells(e) {
    const t = [];
    for (const n of this.sortRanges(e.getRanges())) {
      const s = n.getContainedElement();
      s && s.is("element", "tableCell") && t.push(s);
    }
    return t;
  }
  /**
   * Returns all model table cells that the provided model selection's ranges
   * {@link module:engine/model/range~Range#start} inside.
   *
   * To obtain the cells selected from the outside, use
   * {@link #getSelectedTableCells}.
   */
  getTableCellsContainingSelection(e) {
    const t = [];
    for (const n of e.getRanges()) {
      const s = n.start.findAncestor("tableCell");
      s && t.push(s);
    }
    return t;
  }
  /**
   * Returns all model table cells that are either completely selected
   * by selection ranges or host selection range
   * {@link module:engine/model/range~Range#start start positions} inside them.
   *
   * Combines {@link #getTableCellsContainingSelection} and
   * {@link #getSelectedTableCells}.
   */
  getSelectionAffectedTableCells(e) {
    const t = this.getSelectedTableCells(e);
    return t.length ? t : this.getTableCellsContainingSelection(e);
  }
  /**
   * Returns an object with the `first` and `last` row index contained in the given `tableCells`.
   *
   * ```ts
   * const selectedTableCells = getSelectedTableCells( editor.model.document.selection );
   *
   * const { first, last } = getRowIndexes( selectedTableCells );
   *
   * console.log( `Selected rows: ${ first } to ${ last }` );
   * ```
   *
   * @returns Returns an object with the `first` and `last` table row indexes.
   */
  getRowIndexes(e) {
    const t = e.map((n) => n.parent.index);
    return this._getFirstLastIndexesObject(t);
  }
  /**
   * Returns an object with the `first` and `last` column index contained in the given `tableCells`.
   *
   * ```ts
   * const selectedTableCells = getSelectedTableCells( editor.model.document.selection );
   *
   * const { first, last } = getColumnIndexes( selectedTableCells );
   *
   * console.log( `Selected columns: ${ first } to ${ last }` );
   * ```
   *
   * @returns Returns an object with the `first` and `last` table column indexes.
   */
  getColumnIndexes(e) {
    const t = e[0].findAncestor("table"), s = [...new W(t)].filter((o) => e.includes(o.cell)).map((o) => o.column);
    return this._getFirstLastIndexesObject(s);
  }
  /**
   * Checks if the selection contains cells that do not exceed rectangular selection.
   *
   * In a table below:
   *
   *  ┌───┬───┬───┬───┐
   *  │ a │ b │ c │ d │
   *  ├───┴───┼───┤   │
   *  │ e     │ f │   │
   *  │       ├───┼───┤
   *  │       │ g │ h │
   *  └───────┴───┴───┘
   *
   * Valid selections are these which create a solid rectangle (without gaps), such as:
   *   - a, b (two horizontal cells)
   *   - c, f (two vertical cells)
   *   - a, b, e (cell "e" spans over four cells)
   *   - c, d, f (cell d spans over a cell in the row below)
   *
   * While an invalid selection would be:
   *   - a, c (the unselected cell "b" creates a gap)
   *   - f, g, h (cell "d" spans over a cell from the row of "f" cell - thus creates a gap)
   */
  isSelectionRectangular(e) {
    if (e.length < 2 || !this._areCellInTheSameTableSection(e))
      return !1;
    const t = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set();
    let s = 0;
    for (const r of e) {
      const { row: a, column: l } = this.getCellLocation(r), c = parseInt(r.getAttribute("rowspan")) || 1, u = parseInt(r.getAttribute("colspan")) || 1;
      t.add(a), n.add(l), c > 1 && t.add(a + c - 1), u > 1 && n.add(l + u - 1), s += c * u;
    }
    return Z4(t, n) == s;
  }
  /**
   * Returns array of sorted ranges.
   */
  sortRanges(e) {
    return Array.from(e).sort(K4);
  }
  /**
   * Helper method to get an object with `first` and `last` indexes from an unsorted array of indexes.
   */
  _getFirstLastIndexesObject(e) {
    const t = e.sort((o, r) => o - r), n = t[0], s = t[t.length - 1];
    return { first: n, last: s };
  }
  /**
   * Checks if the selection does not mix a header (column or row) with other cells.
   *
   * For instance, in the table below valid selections consist of cells with the same letter only.
   * So, a-a (same heading row and column) or d-d (body cells) are valid while c-d or a-b are not.
   *
   * header columns
   *    ↓   ↓
   *  ┌───┬───┬───┬───┐
   *  │ a │ a │ b │ b │  ← header row
   *  ├───┼───┼───┼───┤
   *  │ c │ c │ d │ d │
   *  ├───┼───┼───┼───┤
   *  │ c │ c │ d │ d │
   *  └───┴───┴───┴───┘
   */
  _areCellInTheSameTableSection(e) {
    const t = e[0].findAncestor("table"), n = this.getRowIndexes(e), s = parseInt(t.getAttribute("headingRows")) || 0;
    if (!this._areIndexesInSameSection(n, s))
      return !1;
    const o = this.getColumnIndexes(e), r = parseInt(t.getAttribute("headingColumns")) || 0;
    return this._areIndexesInSameSection(o, r);
  }
  /**
   * Unified check if table rows/columns indexes are in the same heading/body section.
   */
  _areIndexesInSameSection({ first: e, last: t }, n) {
    const s = e < n, o = t < n;
    return s === o;
  }
}
function $r(i, e, t, n, s, o = {}) {
  for (let r = 0; r < n; r++) {
    const a = i.createElement("tableRow");
    i.insert(a, e, t), qn(s, i, i.createPositionAt(a, "end"), o);
  }
}
function qn(i, e, t, n = {}) {
  for (let s = 0; s < i; s++)
    An(e, t, n);
}
function Ch(i, e) {
  if (i < e)
    return { newCellsSpan: 1, updatedSpan: 1 };
  const t = Math.floor(i / e), n = i - t * e + t;
  return { newCellsSpan: t, updatedSpan: n };
}
function W4(i, e, t) {
  const n = i.getAttribute("headingColumns") || 0;
  if (n && e.first < n) {
    const s = Math.min(n - 1, e.last) - e.first + 1;
    t.setAttribute("headingColumns", n - s, i);
  }
}
function q4(i, { first: e, last: t }, n) {
  const s = i.getAttribute("headingRows") || 0;
  if (e < s) {
    const o = t < s ? s - (t - e + 1) : e;
    se("headingRows", o, i, n, 0);
  }
}
function G4(i, { first: e, last: t }) {
  const n = /* @__PURE__ */ new Map(), s = [];
  for (const { row: o, column: r, cellHeight: a, cell: l } of new W(i, { endRow: t })) {
    const c = o + a - 1;
    if (o >= e && o <= t && c > t) {
      const h = t - o + 1, f = a - h;
      n.set(r, {
        cell: l,
        rowspan: f
      });
    }
    if (o < e && c >= e) {
      let h;
      c >= t ? h = t - e + 1 : h = c - e + 1, s.push({
        cell: l,
        rowspan: a - h
      });
    }
  }
  return { cellsToMove: n, cellsToTrim: s };
}
function j4(i, e, t, n) {
  const o = [...new W(i, {
    includeAllSlots: !0,
    row: e
  })], r = i.getChild(e);
  let a;
  for (const { column: l, cell: c, isAnchor: u } of o)
    if (t.has(l)) {
      const { cell: d, rowspan: h } = t.get(l), f = a ? n.createPositionAfter(a) : n.createPositionAt(r, 0);
      n.move(n.createRangeOn(d), f), se("rowspan", h, d, n), a = d;
    } else u && (a = c);
}
function K4(i, e) {
  const t = i.start, n = e.start;
  return t.isBefore(n) ? -1 : 1;
}
function Z4(i, e) {
  const t = Array.from(i.values()), n = Array.from(e.values()), s = Math.max(...t), o = Math.min(...t), r = Math.max(...n), a = Math.min(...n);
  return (s - o + 1) * (r - a + 1);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class J4 extends V {
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor.plugins.get(be), t = e.getSelectedTableCells(this.editor.model.document.selection);
    this.isEnabled = e.isSelectionRectangular(t);
  }
  /**
   * Executes the command.
   *
   * @fires execute
   */
  execute() {
    const e = this.editor.model, t = this.editor.plugins.get(be);
    e.change((n) => {
      const s = t.getSelectedTableCells(e.document.selection), o = s.shift(), { mergeWidth: r, mergeHeight: a } = Q4(o, s, t);
      se("colspan", r, o, n), se("rowspan", a, o, n);
      for (const c of s)
        X4(c, o, n);
      const l = o.findAncestor("table");
      ql(l, t), n.setSelection(o, "in");
    });
  }
}
function X4(i, e, t) {
  kh(i) || (kh(e) && t.remove(t.createRangeIn(e)), t.move(t.createRangeIn(i), t.createPositionAt(e, "end"))), t.remove(i);
}
function kh(i) {
  const e = i.getChild(0);
  return i.childCount == 1 && e.is("element", "paragraph") && e.isEmpty;
}
function Q4(i, e, t) {
  let n = 0, s = 0;
  for (const c of e) {
    const { row: u, column: d } = t.getCellLocation(c);
    n = Th(c, d, n, "colspan"), s = Th(c, u, s, "rowspan");
  }
  const { row: o, column: r } = t.getCellLocation(i), a = n - r, l = s - o;
  return { mergeWidth: a, mergeHeight: l };
}
function Th(i, e, t, n) {
  const s = parseInt(i.getAttribute(n) || "1");
  return Math.max(t, e + s);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Y4 extends V {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.affectsData = !1;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const t = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
    this.isEnabled = t.length > 0;
  }
  /**
   * @inheritDoc
   */
  execute() {
    const e = this.editor.model, t = this.editor.plugins.get("TableUtils"), n = t.getSelectionAffectedTableCells(e.document.selection), s = t.getRowIndexes(n), o = n[0].findAncestor("table"), r = [];
    for (let a = s.first; a <= s.last; a++)
      for (const l of o.getChild(a).getChildren())
        r.push(e.createRangeOn(l));
    e.change((a) => {
      a.setSelection(r);
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class eV extends V {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.affectsData = !1;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const t = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
    this.isEnabled = t.length > 0;
  }
  /**
   * @inheritDoc
   */
  execute() {
    const e = this.editor.plugins.get("TableUtils"), t = this.editor.model, n = e.getSelectionAffectedTableCells(t.document.selection), s = n[0], o = n.pop(), r = s.findAncestor("table"), a = e.getCellLocation(s), l = e.getCellLocation(o), c = Math.min(a.column, l.column), u = Math.max(a.column, l.column), d = [];
    for (const h of new W(r, { startColumn: c, endColumn: u }))
      d.push(t.createRangeOn(h.cell));
    t.change((h) => {
      h.setSelection(d);
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function tV(i) {
  i.document.registerPostFixer((e) => nV(e, i));
}
function nV(i, e) {
  const t = e.document.differ.getChanges();
  let n = !1;
  const s = /* @__PURE__ */ new Set();
  for (const o of t) {
    let r = null;
    o.type == "insert" && o.name == "table" && (r = o.position.nodeAfter), (o.type == "insert" || o.type == "remove") && (o.name == "tableRow" || o.name == "tableCell") && (r = o.position.findAncestor("table")), aV(o) && (r = o.range.start.findAncestor("table")), r && !s.has(r) && (n = iV(r, i) || n, n = sV(r, i) || n, s.add(r));
  }
  return n;
}
function iV(i, e) {
  let t = !1;
  const n = oV(i);
  if (n.length) {
    t = !0;
    for (const s of n)
      se("rowspan", s.rowspan, s.cell, e, 1);
  }
  return t;
}
function sV(i, e) {
  let t = !1;
  const n = rV(i), s = [];
  for (const [l, c] of n.entries())
    !c && i.getChild(l).is("element", "tableRow") && s.push(l);
  if (s.length) {
    t = !0;
    for (const l of s.reverse())
      e.remove(i.getChild(l)), n.splice(l, 1);
  }
  const o = n.filter((l, c) => i.getChild(c).is("element", "tableRow")), r = o[0];
  if (!o.every((l) => l === r)) {
    const l = o.reduce((c, u) => u > c ? u : c, 0);
    for (const [c, u] of o.entries()) {
      const d = l - u;
      if (d) {
        for (let h = 0; h < d; h++)
          An(e, e.createPositionAt(i.getChild(c), "end"));
        t = !0;
      }
    }
  }
  return t;
}
function oV(i) {
  const e = parseInt(i.getAttribute("headingRows") || "0"), t = Array.from(i.getChildren()).reduce((s, o) => o.is("element", "tableRow") ? s + 1 : s, 0), n = [];
  for (const { row: s, cell: o, cellHeight: r } of new W(i)) {
    if (r < 2)
      continue;
    const l = s < e ? e : t;
    if (s + r > l) {
      const c = l - s;
      n.push({ cell: o, rowspan: c });
    }
  }
  return n;
}
function rV(i) {
  const e = new Array(i.childCount).fill(0);
  for (const { rowIndex: t } of new W(i, { includeAllSlots: !0 }))
    e[t]++;
  return e;
}
function aV(i) {
  if (i.type !== "attribute")
    return !1;
  const e = i.attributeKey;
  return e === "headingRows" || e === "colspan" || e === "rowspan";
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function lV(i) {
  i.document.registerPostFixer((e) => cV(e, i));
}
function cV(i, e) {
  const t = e.document.differ.getChanges();
  let n = !1;
  for (const s of t)
    s.type == "insert" && s.name == "table" && (n = uV(s.position.nodeAfter, i) || n), s.type == "insert" && s.name == "tableRow" && (n = $p(s.position.nodeAfter, i) || n), s.type == "insert" && s.name == "tableCell" && (n = Ma(s.position.nodeAfter, i) || n), (s.type == "remove" || s.type == "insert") && dV(s) && (n = Ma(s.position.parent, i) || n);
  return n;
}
function uV(i, e) {
  let t = !1;
  for (const n of i.getChildren())
    n.is("element", "tableRow") && (t = $p(n, e) || t);
  return t;
}
function $p(i, e) {
  let t = !1;
  for (const n of i.getChildren())
    t = Ma(n, e) || t;
  return t;
}
function Ma(i, e) {
  if (i.childCount == 0)
    return e.insertElement("paragraph", i), !0;
  const t = Array.from(i.getChildren()).filter((n) => n.is("$text"));
  for (const n of t)
    e.wrap(e.createRangeOn(n), "paragraph");
  return !!t.length;
}
function dV(i) {
  return i.position.parent.is("element", "tableCell") ? i.type == "insert" && i.name == "$text" || i.type == "remove" : !1;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function hV(i, e) {
  const t = i.document.differ;
  for (const n of t.getChanges()) {
    let s, o = !1;
    if (n.type == "attribute") {
      const c = n.range.start.nodeAfter;
      if (!c || !c.is("element", "table") || n.attributeKey != "headingRows" && n.attributeKey != "headingColumns")
        continue;
      s = c, o = n.attributeKey == "headingRows";
    } else (n.name == "tableRow" || n.name == "tableCell") && (s = n.position.findAncestor("table"), o = n.name == "tableRow");
    if (!s)
      continue;
    const r = s.getAttribute("headingRows") || 0, a = s.getAttribute("headingColumns") || 0, l = new W(s);
    for (const c of l) {
      const d = c.row < r || c.column < a ? "th" : "td", h = e.mapper.toViewElement(c.cell);
      h && h.is("element") && h.name != d && e.reconvertItem(o ? c.cell.parent : c.cell);
    }
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function fV(i, e) {
  const t = i.document.differ, n = /* @__PURE__ */ new Set();
  for (const s of t.getChanges()) {
    const o = s.type == "attribute" ? s.range.start.parent : s.position.parent;
    o.is("element", "tableCell") && n.add(o);
  }
  for (const s of n.values()) {
    const o = Array.from(s.getChildren()).filter((r) => mV(r, e.mapper));
    for (const r of o)
      e.reconvertItem(r);
  }
}
function mV(i, e) {
  if (!i.is("element", "paragraph"))
    return !1;
  const t = e.toViewElement(i);
  return t ? Vp(i) !== t.is("element", "span") : !1;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ks extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableEditing";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [be];
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this._additionalSlots = [];
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model, n = t.schema, s = e.conversion, o = e.plugins.get(be);
    n.register("table", {
      inheritAllFrom: "$blockObject",
      allowAttributes: ["headingRows", "headingColumns"]
    }), n.register("tableRow", {
      allowIn: "table",
      isLimit: !0
    }), n.register("tableCell", {
      allowContentOf: "$container",
      allowIn: "tableRow",
      allowAttributes: ["colspan", "rowspan"],
      isLimit: !0,
      isSelectable: !0
    }), s.for("upcast").add(u4()), s.for("upcast").add(d4()), s.for("editingDowncast").elementToStructure({
      model: {
        name: "table",
        attributes: ["headingRows"]
      },
      view: mh(o, {
        asWidget: !0,
        additionalSlots: this._additionalSlots
      })
    }), s.for("dataDowncast").elementToStructure({
      model: {
        name: "table",
        attributes: ["headingRows"]
      },
      view: mh(o, {
        additionalSlots: this._additionalSlots
      })
    }), s.for("upcast").elementToElement({ model: "tableRow", view: "tr" }), s.for("upcast").add(h4()), s.for("downcast").elementToElement({
      model: "tableRow",
      view: b4()
    }), s.for("upcast").elementToElement({ model: "tableCell", view: "td" }), s.for("upcast").elementToElement({ model: "tableCell", view: "th" }), s.for("upcast").add(fh("td")), s.for("upcast").add(fh("th")), s.for("editingDowncast").elementToElement({
      model: "tableCell",
      view: gh({ asWidget: !0 })
    }), s.for("dataDowncast").elementToElement({
      model: "tableCell",
      view: gh()
    }), s.for("editingDowncast").elementToElement({
      model: "paragraph",
      view: ph({ asWidget: !0 }),
      converterPriority: "high"
    }), s.for("dataDowncast").elementToElement({
      model: "paragraph",
      view: ph(),
      converterPriority: "high"
    }), s.for("downcast").attributeToAttribute({ model: "colspan", view: "colspan" }), s.for("upcast").attributeToAttribute({
      model: { key: "colspan", value: Eh("colspan") },
      view: "colspan"
    }), s.for("downcast").attributeToAttribute({ model: "rowspan", view: "rowspan" }), s.for("upcast").attributeToAttribute({
      model: { key: "rowspan", value: Eh("rowspan") },
      view: "rowspan"
    }), e.config.define("table.defaultHeadings.rows", 0), e.config.define("table.defaultHeadings.columns", 0), e.commands.add("insertTable", new v4(e)), e.commands.add("insertTableRowAbove", new bh(e, { order: "above" })), e.commands.add("insertTableRowBelow", new bh(e, { order: "below" })), e.commands.add("insertTableColumnLeft", new wh(e, { order: "left" })), e.commands.add("insertTableColumnRight", new wh(e, { order: "right" })), e.commands.add("removeTableRow", new A4(e)), e.commands.add("removeTableColumn", new I4(e)), e.commands.add("splitTableCellVertically", new _h(e, { direction: "vertically" })), e.commands.add("splitTableCellHorizontally", new _h(e, { direction: "horizontally" })), e.commands.add("mergeTableCells", new J4(e)), e.commands.add("mergeTableCellRight", new Ys(e, { direction: "right" })), e.commands.add("mergeTableCellLeft", new Ys(e, { direction: "left" })), e.commands.add("mergeTableCellDown", new Ys(e, { direction: "down" })), e.commands.add("mergeTableCellUp", new Ys(e, { direction: "up" })), e.commands.add("setTableColumnHeader", new V4(e)), e.commands.add("setTableRowHeader", new R4(e)), e.commands.add("selectTableRow", new Y4(e)), e.commands.add("selectTableColumn", new eV(e)), tV(t), lV(t), this.listenTo(t.document, "change:data", () => {
      hV(t, e.editing), fV(t, e.editing);
    });
  }
  /**
   * Registers downcast handler for the additional table slot.
   */
  registerAdditionalSlot(e) {
    this._additionalSlots.push(e);
  }
}
function Eh(i) {
  return (e) => {
    const t = parseInt(e.getAttribute(i));
    return Number.isNaN(t) || t <= 0 ? null : t;
  };
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Ah extends T {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e);
    const t = this.bindTemplate;
    this.items = this._createGridCollection(), this.keystrokes = new ie(), this.focusTracker = new X(), this.set("rows", 0), this.set("columns", 0), this.bind("label").to(this, "columns", this, "rows", (n, s) => `${s} × ${n}`), this.setTemplate({
      tag: "div",
      attributes: {
        class: ["ck"]
      },
      children: [
        {
          tag: "div",
          attributes: {
            class: ["ck-insert-table-dropdown__grid"]
          },
          on: {
            "mouseover@.ck-insert-table-dropdown-grid-box": t.to("boxover")
          },
          children: this.items
        },
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-insert-table-dropdown__label"
            ],
            "aria-hidden": !0
          },
          children: [
            {
              text: t.to("label")
            }
          ]
        }
      ],
      on: {
        mousedown: t.to((n) => {
          n.preventDefault();
        }),
        click: t.to(() => {
          this.fire("execute");
        })
      }
    }), this.on("boxover", (n, s) => {
      const { row: o, column: r } = s.target.dataset;
      this.items.get((parseInt(o, 10) - 1) * 10 + (parseInt(r, 10) - 1)).focus();
    }), this.focusTracker.on("change:focusedElement", (n, s, o) => {
      if (!o)
        return;
      const { row: r, column: a } = o.dataset;
      this.set({
        rows: parseInt(r),
        columns: parseInt(a)
      });
    }), this.on("change:columns", () => this._highlightGridBoxes()), this.on("change:rows", () => this._highlightGridBoxes());
  }
  render() {
    super.render(), Al({
      keystrokeHandler: this.keystrokes,
      focusTracker: this.focusTracker,
      gridItems: this.items,
      numberOfColumns: 10,
      uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
    });
    for (const e of this.items)
      this.focusTracker.add(e.element);
    this.keystrokes.listenTo(this.element);
  }
  /**
   * Resets the rows and columns selection.
   */
  reset() {
    this.set({
      rows: 1,
      columns: 1
    });
  }
  /**
   * @inheritDoc
   */
  focus() {
    this.items.get(0).focus();
  }
  /**
   * @inheritDoc
   */
  focusLast() {
    this.items.get(0).focus();
  }
  /**
   * Highlights grid boxes depending on rows and columns selected.
   */
  _highlightGridBoxes() {
    const e = this.rows, t = this.columns;
    this.items.map((n, s) => {
      const o = Math.floor(s / 10), r = s % 10, a = o < e && r < t;
      n.set("isOn", a);
    });
  }
  /**
   * Creates a new Button for the grid.
   *
   * @param locale The locale instance.
   * @param row Row number.
   * @param column Column number.
   * @param label The grid button label.
   */
  _createGridButton(e, t, n, s) {
    const o = new P(e);
    return o.set({
      label: s,
      class: "ck-insert-table-dropdown-grid-box"
    }), o.extendTemplate({
      attributes: {
        "data-row": t,
        "data-column": n
      }
    }), o;
  }
  /**
   * @returns A view collection containing boxes to be placed in a table grid.
   */
  _createGridCollection() {
    const e = [];
    for (let t = 0; t < 100; t++) {
      const n = Math.floor(t / 10), s = t % 10, o = `${n + 1} × ${s + 1}`;
      e.push(this._createGridButton(this.locale, n + 1, s + 1, o));
    }
    return this.createCollection(e);
  }
}
const gV = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>', pV = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>', bV = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z"/></svg>';
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class wV extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = this.editor.t, s = e.locale.contentLanguageDirection === "ltr";
    e.ui.componentFactory.add("insertTable", (o) => {
      const r = e.commands.get("insertTable"), a = we(o);
      a.bind("isEnabled").to(r), a.buttonView.set({
        icon: A.table,
        label: t("Insert table"),
        tooltip: !0
      });
      let l;
      return a.on("change:isOpen", () => {
        l || (l = new Ah(o), a.panelView.children.add(l), l.delegate("execute").to(a), a.on("execute", () => {
          e.execute("insertTable", { rows: l.rows, columns: l.columns }), e.editing.view.focus();
        }));
      }), a;
    }), e.ui.componentFactory.add("menuBar:insertTable", (o) => {
      const r = e.commands.get("insertTable"), a = new Ge(o), l = new Ah(o);
      return l.delegate("execute").to(a), a.on("change:isOpen", (c, u, d) => {
        d || l.reset();
      }), l.on("execute", () => {
        e.execute("insertTable", { rows: l.rows, columns: l.columns }), e.editing.view.focus();
      }), a.buttonView.set({
        label: t("Table"),
        icon: A.table
      }), a.panelView.children.add(l), a.bind("isEnabled").to(r), a;
    }), e.ui.componentFactory.add("tableColumn", (o) => {
      const r = [
        {
          type: "switchbutton",
          model: {
            commandName: "setTableColumnHeader",
            label: t("Header column"),
            bindIsOn: !0
          }
        },
        { type: "separator" },
        {
          type: "button",
          model: {
            commandName: s ? "insertTableColumnLeft" : "insertTableColumnRight",
            label: t("Insert column left")
          }
        },
        {
          type: "button",
          model: {
            commandName: s ? "insertTableColumnRight" : "insertTableColumnLeft",
            label: t("Insert column right")
          }
        },
        {
          type: "button",
          model: {
            commandName: "removeTableColumn",
            label: t("Delete column")
          }
        },
        {
          type: "button",
          model: {
            commandName: "selectTableColumn",
            label: t("Select column")
          }
        }
      ];
      return this._prepareDropdown(t("Column"), gV, r, o);
    }), e.ui.componentFactory.add("tableRow", (o) => {
      const r = [
        {
          type: "switchbutton",
          model: {
            commandName: "setTableRowHeader",
            label: t("Header row"),
            bindIsOn: !0
          }
        },
        { type: "separator" },
        {
          type: "button",
          model: {
            commandName: "insertTableRowAbove",
            label: t("Insert row above")
          }
        },
        {
          type: "button",
          model: {
            commandName: "insertTableRowBelow",
            label: t("Insert row below")
          }
        },
        {
          type: "button",
          model: {
            commandName: "removeTableRow",
            label: t("Delete row")
          }
        },
        {
          type: "button",
          model: {
            commandName: "selectTableRow",
            label: t("Select row")
          }
        }
      ];
      return this._prepareDropdown(t("Row"), pV, r, o);
    }), e.ui.componentFactory.add("mergeTableCells", (o) => {
      const r = [
        {
          type: "button",
          model: {
            commandName: "mergeTableCellUp",
            label: t("Merge cell up")
          }
        },
        {
          type: "button",
          model: {
            commandName: s ? "mergeTableCellRight" : "mergeTableCellLeft",
            label: t("Merge cell right")
          }
        },
        {
          type: "button",
          model: {
            commandName: "mergeTableCellDown",
            label: t("Merge cell down")
          }
        },
        {
          type: "button",
          model: {
            commandName: s ? "mergeTableCellLeft" : "mergeTableCellRight",
            label: t("Merge cell left")
          }
        },
        { type: "separator" },
        {
          type: "button",
          model: {
            commandName: "splitTableCellVertically",
            label: t("Split cell vertically")
          }
        },
        {
          type: "button",
          model: {
            commandName: "splitTableCellHorizontally",
            label: t("Split cell horizontally")
          }
        }
      ];
      return this._prepareMergeSplitButtonDropdown(t("Merge cells"), bV, r, o);
    });
  }
  /**
   * Creates a dropdown view from a set of options.
   *
   * @param label The dropdown button label.
   * @param icon An icon for the dropdown button.
   * @param options The list of options for the dropdown.
   */
  _prepareDropdown(e, t, n, s) {
    const o = this.editor, r = we(s), a = this._fillDropdownWithListOptions(r, n);
    return r.buttonView.set({
      label: e,
      icon: t,
      tooltip: !0
    }), r.bind("isEnabled").toMany(a, "isEnabled", (...l) => l.some((c) => c)), this.listenTo(r, "execute", (l) => {
      o.execute(l.source.commandName), l.source instanceof nr || o.editing.view.focus();
    }), r;
  }
  /**
   * Creates a dropdown view with a {@link module:ui/dropdown/button/splitbuttonview~SplitButtonView} for
   * merge (and split)–related commands.
   *
   * @param label The dropdown button label.
   * @param icon An icon for the dropdown button.
   * @param options The list of options for the dropdown.
   */
  _prepareMergeSplitButtonDropdown(e, t, n, s) {
    const o = this.editor, r = we(s, sr), a = "mergeTableCells", l = o.commands.get(a), c = this._fillDropdownWithListOptions(r, n);
    return r.buttonView.set({
      label: e,
      icon: t,
      tooltip: !0,
      isEnabled: !0
    }), r.bind("isEnabled").toMany([l, ...c], "isEnabled", (...u) => u.some((d) => d)), this.listenTo(r.buttonView, "execute", () => {
      o.execute(a), o.editing.view.focus();
    }), this.listenTo(r, "execute", (u) => {
      o.execute(u.source.commandName), o.editing.view.focus();
    }), r;
  }
  /**
   * Injects a {@link module:ui/list/listview~ListView} into the passed dropdown with buttons
   * which execute editor commands as configured in passed options.
   *
   * @param options The list of options for the dropdown.
   * @returns Commands the list options are interacting with.
   */
  _fillDropdownWithListOptions(e, t) {
    const n = this.editor, s = [], o = new ke();
    for (const r of t)
      _V(r, n, s, o);
    return Kt(e, o), s;
  }
}
function _V(i, e, t, n) {
  if (i.type === "button" || i.type === "switchbutton") {
    const s = i.model = new $t(i.model), { commandName: o, bindIsOn: r } = i.model, a = e.commands.get(o);
    t.push(a), s.set({ commandName: o }), s.bind("isEnabled").to(a), r && s.bind("isOn").to(a, "value"), s.set({
      withText: !0
    });
  }
  n.add(i);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class cn extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableSelection";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [be, be];
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model, n = e.editing.view;
    this.listenTo(t, "deleteContent", (s, o) => this._handleDeleteContent(s, o), { priority: "high" }), this.listenTo(n.document, "insertText", (s, o) => this._handleInsertTextEvent(s, o), { priority: "high" }), this._defineSelectionConverter(), this._enablePluginDisabling();
  }
  /**
   * Returns the currently selected table cells or `null` if it is not a table cells selection.
   */
  getSelectedTableCells() {
    const e = this.editor.plugins.get(be), t = this.editor.model.document.selection, n = e.getSelectedTableCells(t);
    return n.length == 0 ? null : n;
  }
  /**
   * Returns the selected table fragment as a document fragment.
   */
  getSelectionAsFragment() {
    const e = this.editor.plugins.get(be), t = this.getSelectedTableCells();
    return t ? this.editor.model.change((n) => {
      const s = n.createDocumentFragment(), { first: o, last: r } = e.getColumnIndexes(t), { first: a, last: l } = e.getRowIndexes(t), c = t[0].findAncestor("table");
      let u = l, d = r;
      if (e.isSelectionRectangular(t)) {
        const m = {
          firstColumn: o,
          lastColumn: r,
          firstRow: a,
          lastRow: l
        };
        u = Dp(c, m), d = zp(c, m);
      }
      const f = Mp(c, {
        startRow: a,
        startColumn: o,
        endRow: u,
        endColumn: d
      }, n);
      return n.insert(f, s, 0), s;
    }) : null;
  }
  /**
   * Sets the model selection based on given anchor and target cells (can be the same cell).
   * Takes care of setting the backward flag.
   *
   * ```ts
   * const modelRoot = editor.model.document.getRoot();
   * const firstCell = modelRoot.getNodeByPath( [ 0, 0, 0 ] );
   * const lastCell = modelRoot.getNodeByPath( [ 0, 0, 1 ] );
   *
   * const tableSelection = editor.plugins.get( 'TableSelection' );
   * tableSelection.setCellSelection( firstCell, lastCell );
   * ```
   */
  setCellSelection(e, t) {
    const n = this._getCellsToSelect(e, t);
    this.editor.model.change((s) => {
      s.setSelection(n.cells.map((o) => s.createRangeOn(o)), { backward: n.backward });
    });
  }
  /**
   * Returns the focus cell from the current selection.
   */
  getFocusCell() {
    const n = [...this.editor.model.document.selection.getRanges()].pop().getContainedElement();
    return n && n.is("element", "tableCell") ? n : null;
  }
  /**
   * Returns the anchor cell from the current selection.
   */
  getAnchorCell() {
    const e = this.editor.model.document.selection, n = me(e.getRanges()).getContainedElement();
    return n && n.is("element", "tableCell") ? n : null;
  }
  /**
   * Defines a selection converter which marks the selected cells with a specific class.
   *
   * The real DOM selection is put in the last cell. Since the order of ranges is dependent on whether the
   * selection is backward or not, the last cell will usually be close to the "focus" end of the selection
   * (a selection has anchor and focus).
   *
   * The real DOM selection is then hidden with CSS.
   */
  _defineSelectionConverter() {
    const e = this.editor, t = /* @__PURE__ */ new Set();
    e.conversion.for("editingDowncast").add((s) => s.on("selection", (o, r, a) => {
      const l = a.writer;
      n(l);
      const c = this.getSelectedTableCells();
      if (!c)
        return;
      for (const d of c) {
        const h = a.mapper.toViewElement(d);
        l.addClass("ck-editor__editable_selected", h), t.add(h);
      }
      const u = a.mapper.toViewElement(c[c.length - 1]);
      l.setSelection(u, 0);
    }, { priority: "lowest" }));
    function n(s) {
      for (const o of t)
        s.removeClass("ck-editor__editable_selected", o);
      t.clear();
    }
  }
  /**
   * Creates a listener that reacts to changes in {@link #isEnabled} and, if the plugin was disabled,
   * it collapses the multi-cell selection to a regular selection placed inside a table cell.
   *
   * This listener helps features that disable the table selection plugin bring the selection
   * to a clear state they can work with (for instance, because they don't support multiple cell selection).
   */
  _enablePluginDisabling() {
    const e = this.editor;
    this.on("change:isEnabled", () => {
      if (!this.isEnabled) {
        const t = this.getSelectedTableCells();
        if (!t)
          return;
        e.model.change((n) => {
          const s = n.createPositionAt(t[0], 0), o = e.model.schema.getNearestSelectionRange(s);
          n.setSelection(o);
        });
      }
    });
  }
  /**
   * Overrides the default `model.deleteContent()` behavior over a selected table fragment.
   *
   * @param args Delete content method arguments.
   */
  _handleDeleteContent(e, t) {
    const n = this.editor.plugins.get(be), s = t[0], o = t[1], r = this.editor.model, a = !o || o.direction == "backward", l = n.getSelectedTableCells(s);
    l.length && (e.stop(), r.change((c) => {
      const u = l[a ? l.length - 1 : 0];
      r.change((h) => {
        for (const f of l)
          r.deleteContent(h.createSelection(f, "in"));
      });
      const d = r.schema.getNearestSelectionRange(c.createPositionAt(u, 0));
      s.is("documentSelection") ? c.setSelection(d) : s.setTo(d);
    }));
  }
  /**
   * This handler makes it possible to remove the content of all selected cells by starting to type.
   * If you take a look at {@link #_defineSelectionConverter} you will find out that despite the multi-cell selection being set
   * in the model, the view selection is collapsed in the last cell (because most browsers are unable to render multi-cell selections;
   * yes, it's a hack).
   *
   * When multiple cells are selected in the model and the user starts to type, the
   * {@link module:engine/view/document~Document#event:insertText} event carries information provided by the
   * beforeinput DOM  event, that in turn only knows about this collapsed DOM selection in the last cell.
   *
   * As a result, the selected cells have no chance to be cleaned up. To fix this, this listener intercepts
   * the event and injects the custom view selection in the data that translates correctly to the actual state
   * of the multi-cell selection in the model.
   *
   * @param data Insert text event data.
   */
  _handleInsertTextEvent(e, t) {
    const n = this.editor, s = this.getSelectedTableCells();
    if (!s)
      return;
    const o = n.editing.view, r = n.editing.mapper, a = s.map((l) => o.createRangeOn(r.toViewElement(l)));
    t.selection = o.createSelection(a);
  }
  /**
   * Returns an array of table cells that should be selected based on the
   * given anchor cell and target (focus) cell.
   *
   * The cells are returned in a reverse direction if the selection is backward.
   */
  _getCellsToSelect(e, t) {
    const n = this.editor.plugins.get("TableUtils"), s = n.getCellLocation(e), o = n.getCellLocation(t), r = Math.min(s.row, o.row), a = Math.max(s.row, o.row), l = Math.min(s.column, o.column), c = Math.max(s.column, o.column), u = new Array(a - r + 1).fill(null).map(() => []), d = {
      startRow: r,
      endRow: a,
      startColumn: l,
      endColumn: c
    };
    for (const { row: m, cell: p } of new W(e.findAncestor("table"), d))
      u[m - r].push(p);
    const h = o.row < s.row, f = o.column < s.column;
    return h && u.reverse(), f && u.forEach((m) => m.reverse()), {
      cells: u.flat(),
      backward: h || f
    };
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class vV extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableClipboard";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Ui, Ze, cn, be];
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.editing.view.document;
    this.listenTo(t, "copy", (n, s) => this._onCopyCut(n, s)), this.listenTo(t, "cut", (n, s) => this._onCopyCut(n, s)), this.listenTo(e.model, "insertContent", (n, [s, o]) => this._onInsertContent(n, s, o), { priority: "high" }), this.decorate("_replaceTableSlotCell");
  }
  /**
   * Copies table content to a clipboard on "copy" & "cut" events.
   *
   * @param evt An object containing information about the handled event.
   * @param data Clipboard event data.
   */
  _onCopyCut(e, t) {
    const n = this.editor.editing.view, s = this.editor.plugins.get(cn), o = this.editor.plugins.get(Ui);
    s.getSelectedTableCells() && (e.name == "cut" && !this.editor.model.canEditAt(this.editor.model.document.selection) || (t.preventDefault(), e.stop(), this.editor.model.enqueueChange({ isUndoable: e.name === "cut" }, () => {
      const r = o._copySelectedFragmentWithMarkers(e.name, this.editor.model.document.selection, () => s.getSelectionAsFragment());
      n.document.fire("clipboardOutput", {
        dataTransfer: t.dataTransfer,
        content: this.editor.data.toView(r),
        method: e.name
      });
    })));
  }
  /**
   * Overrides default {@link module:engine/model/model~Model#insertContent `model.insertContent()`} method to handle pasting table inside
   * selected table fragment.
   *
   * Depending on selected table fragment:
   * - If a selected table fragment is smaller than paste table it will crop pasted table to match dimensions.
   * - If dimensions are equal it will replace selected table fragment with a pasted table contents.
   *
   * @param content The content to insert.
   * @param selectable The selection into which the content should be inserted.
   * If not provided the current model document selection will be used.
   */
  _onInsertContent(e, t, n) {
    if (n && !n.is("documentSelection"))
      return;
    const s = this.editor.model, o = this.editor.plugins.get(be), r = this.editor.plugins.get(Ui), a = this.getTableIfOnlyTableInContent(t, s);
    if (!a)
      return;
    const l = o.getSelectionAffectedTableCells(s.document.selection);
    if (!l.length) {
      ql(a, o);
      return;
    }
    e.stop(), t.is("documentFragment") ? r._pasteMarkersIntoTransformedElement(t.markers, (c) => this._replaceSelectedCells(a, l, c)) : this.editor.model.change((c) => {
      this._replaceSelectedCells(a, l, c);
    });
  }
  /**
   * Inserts provided `selectedTableCells` into `pastedTable`.
   */
  _replaceSelectedCells(e, t, n) {
    const s = this.editor.plugins.get(be), o = {
      width: s.getColumns(e),
      height: s.getRows(e)
    }, r = yV(t, o, n, s), a = r.lastRow - r.firstRow + 1, l = r.lastColumn - r.firstColumn + 1, c = {
      startRow: 0,
      startColumn: 0,
      endRow: Math.min(a, o.height) - 1,
      endColumn: Math.min(l, o.width) - 1
    };
    e = Mp(e, c, n);
    const u = t[0].findAncestor("table"), d = this._replaceSelectedCellsWithPasted(e, o, u, r, n);
    if (this.editor.plugins.get("TableSelection").isEnabled) {
      const h = s.sortRanges(d.map((f) => n.createRangeOn(f)));
      n.setSelection(h);
    } else
      n.setSelection(d[0], 0);
    return u;
  }
  /**
   * Replaces the part of selectedTable with pastedTable.
   */
  _replaceSelectedCellsWithPasted(e, t, n, s, o) {
    const { width: r, height: a } = t, l = kV(e, r, a), c = [...new W(n, {
      startRow: s.firstRow,
      endRow: s.lastRow,
      startColumn: s.firstColumn,
      endColumn: s.lastColumn,
      includeAllSlots: !0
    })], u = [];
    let d;
    for (const w of c) {
      const { row: v, column: C } = w;
      C === s.firstColumn && (d = w.getPositionBefore());
      const L = v - s.firstRow, F = C - s.firstColumn, q = l[L % a][F % r], x = q ? o.cloneElement(q) : null, R = this._replaceTableSlotCell(w, x, d, o);
      R && (Np(R, v, C, s.lastRow, s.lastColumn, o), u.push(R), d = o.createPositionAfter(R));
    }
    const h = parseInt(n.getAttribute("headingRows") || "0"), f = parseInt(n.getAttribute("headingColumns") || "0"), m = s.firstRow < h && h <= s.lastRow, p = s.firstColumn < f && f <= s.lastColumn;
    if (m) {
      const w = { first: s.firstColumn, last: s.lastColumn }, v = Ba(n, h, w, o, s.firstRow);
      u.push(...v);
    }
    if (p) {
      const w = { first: s.firstRow, last: s.lastRow }, v = La(n, f, w, o);
      u.push(...v);
    }
    return u;
  }
  /**
   * Replaces a single table slot.
   *
   * @returns Inserted table cell or null if slot should remain empty.
   * @private
   */
  _replaceTableSlotCell(e, t, n, s) {
    const { cell: o, isAnchor: r } = e;
    return r && s.remove(o), t ? (s.insert(t, n), t) : null;
  }
  /**
   * Extracts the table for pasting into a table.
   *
   * @param content The content to insert.
   * @param model The editor model.
   */
  getTableIfOnlyTableInContent(e, t) {
    if (!e.is("documentFragment") && !e.is("element"))
      return null;
    if (e.is("element", "table"))
      return e;
    if (e.childCount == 1 && e.getChild(0).is("element", "table"))
      return e.getChild(0);
    const n = t.createRangeIn(e);
    for (const s of n.getItems())
      if (s.is("element", "table")) {
        const o = t.createRange(n.start, t.createPositionBefore(s));
        if (t.hasContent(o, { ignoreWhitespaces: !0 }))
          return null;
        const r = t.createRange(t.createPositionAfter(s), n.end);
        return t.hasContent(r, { ignoreWhitespaces: !0 }) ? null : s;
      }
    return null;
  }
}
function yV(i, e, t, n) {
  const s = i[0].findAncestor("table"), o = n.getColumnIndexes(i), r = n.getRowIndexes(i), a = {
    firstColumn: o.first,
    lastColumn: o.last,
    firstRow: r.first,
    lastRow: r.last
  }, l = i.length === 1;
  return l && (a.lastRow += e.height - 1, a.lastColumn += e.width - 1, CV(s, a.lastRow + 1, a.lastColumn + 1, n)), l || !n.isSelectionRectangular(i) ? TV(s, a, t) : (a.lastRow = Dp(s, a), a.lastColumn = zp(s, a)), a;
}
function CV(i, e, t, n) {
  const s = n.getColumns(i), o = n.getRows(i);
  t > s && n.insertColumns(i, {
    at: s,
    columns: t - s
  }), e > o && n.insertRows(i, {
    at: o,
    rows: e - o
  });
}
function kV(i, e, t) {
  const n = new Array(t).fill(null).map(() => new Array(e).fill(null));
  for (const { column: s, row: o, cell: r } of new W(i))
    n[o][s] = r;
  return n;
}
function TV(i, e, t) {
  const { firstRow: n, lastRow: s, firstColumn: o, lastColumn: r } = e, a = { first: n, last: s }, l = { first: o, last: r };
  La(i, o, a, t), La(i, r + 1, a, t), Ba(i, n, l, t), Ba(i, s + 1, l, t, n);
}
function Ba(i, e, t, n, s = 0) {
  return e < 1 ? void 0 : Bp(i, e, s).filter(({ column: a, cellWidth: l }) => Wp(a, l, t)).map(({ cell: a }) => Lp(a, e, n));
}
function La(i, e, t, n) {
  return e < 1 ? void 0 : Op(i, e).filter(({ row: r, cellHeight: a }) => Wp(r, a, t)).map(({ cell: r, column: a }) => Fp(r, a, e, n));
}
function Wp(i, e, t) {
  const n = i + e - 1, { first: s, last: o } = t, r = i >= s && i <= o, a = i < s && n >= s;
  return r || a;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class EV extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableKeyboard";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [cn, be];
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, n = e.editing.view.document, s = e.t;
    this.listenTo(n, "arrowKey", (...o) => this._onArrowKey(...o), { context: "table" }), this.listenTo(n, "tab", (...o) => this._handleTabOnSelectedTable(...o), { context: "figure" }), this.listenTo(n, "tab", (...o) => this._handleTab(...o), { context: ["th", "td"] }), e.accessibility.addKeystrokeInfoGroup({
      id: "table",
      label: s("Keystrokes that can be used in a table cell"),
      keystrokes: [
        {
          label: s("Move the selection to the next cell"),
          keystroke: "Tab"
        },
        {
          label: s("Move the selection to the previous cell"),
          keystroke: "Shift+Tab"
        },
        {
          label: s("Insert a new table row (when in the last cell of a table)"),
          keystroke: "Tab"
        },
        {
          label: s("Navigate through the table"),
          keystroke: [["arrowup"], ["arrowright"], ["arrowdown"], ["arrowleft"]]
        }
      ]
    });
  }
  /**
   * Handles {@link module:engine/view/document~Document#event:tab tab} events for the <kbd>Tab</kbd> key executed
   * when the table widget is selected.
   */
  _handleTabOnSelectedTable(e, t) {
    const n = this.editor, o = n.model.document.selection.getSelectedElement();
    !o || !o.is("element", "table") || (t.preventDefault(), t.stopPropagation(), e.stop(), n.model.change((r) => {
      r.setSelection(r.createRangeIn(o.getChild(0).getChild(0)));
    }));
  }
  /**
   * Handles {@link module:engine/view/document~Document#event:tab tab} events for the <kbd>Tab</kbd> key executed
   * inside table cells.
   */
  _handleTab(e, t) {
    const n = this.editor, s = this.editor.plugins.get(be), o = this.editor.plugins.get("TableSelection"), r = n.model.document.selection, a = !t.shiftKey;
    let l = s.getTableCellsContainingSelection(r)[0];
    if (l || (l = o.getFocusCell()), !l)
      return;
    t.preventDefault(), t.stopPropagation(), e.stop();
    const c = l.parent, u = c.parent, d = u.getChildIndex(c), h = c.getChildIndex(l), f = h === 0;
    if (!a && f && d === 0) {
      n.model.change((v) => {
        v.setSelection(v.createRangeOn(u));
      });
      return;
    }
    const m = h === c.childCount - 1, p = d === s.getRows(u) - 1;
    if (a && p && m && (n.execute("insertTableRowBelow"), d === s.getRows(u) - 1)) {
      n.model.change((v) => {
        v.setSelection(v.createRangeOn(u));
      });
      return;
    }
    let w;
    if (a && m)
      w = u.getChild(d + 1).getChild(0);
    else if (!a && f) {
      const v = u.getChild(d - 1);
      w = v.getChild(v.childCount - 1);
    } else
      w = c.getChild(h + (a ? 1 : -1));
    n.model.change((v) => {
      v.setSelection(v.createRangeIn(w));
    });
  }
  /**
   * Handles {@link module:engine/view/document~Document#event:keydown keydown} events.
   */
  _onArrowKey(e, t) {
    const n = this.editor, s = t.keyCode, o = ll(s, n.locale.contentLanguageDirection);
    this._handleArrowKeys(o, t.shiftKey) && (t.preventDefault(), t.stopPropagation(), e.stop());
  }
  /**
   * Handles arrow keys to move the selection around the table.
   *
   * @param direction The direction of the arrow key.
   * @param expandSelection If the current selection should be expanded.
   * @returns Returns `true` if key was handled.
   */
  _handleArrowKeys(e, t) {
    const n = this.editor.plugins.get(be), s = this.editor.plugins.get("TableSelection"), o = this.editor.model, r = o.document.selection, a = ["right", "down"].includes(e), l = n.getSelectedTableCells(r);
    if (l.length) {
      let u;
      return t ? u = s.getFocusCell() : u = a ? l[l.length - 1] : l[0], this._navigateFromCellInDirection(u, e, t), !0;
    }
    const c = r.focus.findAncestor("tableCell");
    /* istanbul ignore if: paranoid check -- @preserve */
    if (!c)
      return !1;
    if (!r.isCollapsed)
      if (t) {
        if (r.isBackward == a && !r.containsEntireContent(c))
          return !1;
      } else {
        const u = r.getSelectedElement();
        if (!u || !o.schema.isObject(u))
          return !1;
      }
    return this._isSelectionAtCellEdge(r, c, a) ? (this._navigateFromCellInDirection(c, e, t), !0) : !1;
  }
  /**
   * Returns `true` if the selection is at the boundary of a table cell according to the navigation direction.
   *
   * @param selection The current selection.
   * @param tableCell The current table cell element.
   * @param isForward The expected navigation direction.
   */
  _isSelectionAtCellEdge(e, t, n) {
    const s = this.editor.model, o = this.editor.model.schema, r = n ? e.getLastPosition() : e.getFirstPosition();
    if (!o.getLimitElement(r).is("element", "tableCell"))
      return s.createPositionAt(t, n ? "end" : 0).isTouching(r);
    const a = s.createSelection(r);
    return s.modifySelection(a, { direction: n ? "forward" : "backward" }), r.isEqual(a.focus);
  }
  /**
   * Moves the selection from the given table cell in the specified direction.
   *
   * @param focusCell The table cell that is current multi-cell selection focus.
   * @param direction Direction in which selection should move.
   * @param expandSelection If the current selection should be expanded. Default value is false.
   */
  _navigateFromCellInDirection(e, t, n = !1) {
    const s = this.editor.model, o = e.findAncestor("table"), r = [...new W(o, { includeAllSlots: !0 })], { row: a, column: l } = r[r.length - 1], c = r.find(({ cell: C }) => C == e);
    let { row: u, column: d } = c;
    switch (t) {
      case "left":
        d--;
        break;
      case "up":
        u--;
        break;
      case "right":
        d += c.cellWidth;
        break;
      case "down":
        u += c.cellHeight;
        break;
    }
    const h = u < 0 || u > a, f = d < 0 && u <= 0, m = d > l && u >= a;
    if (h || f || m) {
      s.change((C) => {
        C.setSelection(C.createRangeOn(o));
      });
      return;
    }
    d < 0 ? (d = n ? 0 : l, u--) : d > l && (d = n ? l : 0, u++);
    const p = r.find((C) => C.row == u && C.column == d).cell, w = ["right", "down"].includes(t), v = this.editor.plugins.get("TableSelection");
    if (n && v.isEnabled) {
      const C = v.getAnchorCell() || e;
      v.setCellSelection(C, p);
    } else {
      const C = s.createPositionAt(p, w ? 0 : "end");
      s.change((L) => {
        L.setSelection(C);
      });
    }
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class qp extends Gt {
  constructor() {
    super(...arguments), this.domEventType = [
      "mousemove",
      "mouseleave"
    ];
  }
  /**
   * @inheritDoc
   */
  onDomEvent(e) {
    this.fire(e.type, e);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class AV extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableMouse";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [cn, be];
  }
  /**
   * @inheritDoc
   */
  init() {
    this.editor.editing.view.addObserver(qp), this._enableShiftClickSelection(), this._enableMouseDragSelection();
  }
  /**
   * Enables making cells selection by <kbd>Shift</kbd>+click. Creates a selection from the cell which previously held
   * the selection to the cell which was clicked. It can be the same cell, in which case it selects a single cell.
   */
  _enableShiftClickSelection() {
    const e = this.editor, t = e.plugins.get(be);
    let n = !1;
    const s = e.plugins.get(cn);
    this.listenTo(e.editing.view.document, "mousedown", (o, r) => {
      const a = e.model.document.selection;
      if (!this.isEnabled || !s.isEnabled || !r.domEvent.shiftKey)
        return;
      const l = s.getAnchorCell() || t.getTableCellsContainingSelection(a)[0];
      if (!l)
        return;
      const c = this._getModelTableCellFromDomEvent(r);
      c && xh(l, c) && (n = !0, s.setCellSelection(l, c), r.preventDefault());
    }), this.listenTo(e.editing.view.document, "mouseup", () => {
      n = !1;
    }), this.listenTo(e.editing.view.document, "selectionChange", (o) => {
      n && o.stop();
    }, { priority: "highest" });
  }
  /**
   * Enables making cells selection by dragging.
   *
   * The selection is made only on mousemove. Mouse tracking is started on mousedown.
   * However, the cells selection is enabled only after the mouse cursor left the anchor cell.
   * Thanks to that normal text selection within one cell works just fine. However, you can still select
   * just one cell by leaving the anchor cell and moving back to it.
   */
  _enableMouseDragSelection() {
    const e = this.editor;
    let t, n, s = !1, o = !1;
    const r = e.plugins.get(cn);
    this.listenTo(e.editing.view.document, "mousedown", (a, l) => {
      !this.isEnabled || !r.isEnabled || l.domEvent.shiftKey || l.domEvent.ctrlKey || l.domEvent.altKey || (t = this._getModelTableCellFromDomEvent(l));
    }), this.listenTo(e.editing.view.document, "mousemove", (a, l) => {
      if (!l.domEvent.buttons || !t)
        return;
      const c = this._getModelTableCellFromDomEvent(l);
      c && xh(t, c) && (n = c, !s && n != t && (s = !0)), s && (o = !0, r.setCellSelection(t, n), l.preventDefault());
    }), this.listenTo(e.editing.view.document, "mouseup", () => {
      s = !1, o = !1, t = null, n = null;
    }), this.listenTo(e.editing.view.document, "selectionChange", (a) => {
      o && a.stop();
    }, { priority: "highest" });
  }
  /**
   * Returns the model table cell element based on the target element of the passed DOM event.
   *
   * @returns Returns the table cell or `undefined`.
   */
  _getModelTableCellFromDomEvent(e) {
    const t = e.target, n = this.editor.editing.view.createPositionAt(t, 0);
    return this.editor.editing.mapper.toModelPosition(n).parent.findAncestor("tableCell", { includeSelf: !0 });
  }
}
function xh(i, e) {
  return i.parent.parent == e.parent.parent;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class xV extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ks, wV, cn, AV, EV, vV, gi];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Table";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Gp(i) {
  const e = jp(i);
  return e || hr(i);
}
function jp(i) {
  const e = i.getSelectedElement();
  return e && Kp(e) ? e : null;
}
function hr(i) {
  const e = i.getFirstPosition();
  if (!e)
    return null;
  let t = e.parent;
  for (; t; ) {
    if (t.is("element") && Kp(t))
      return t;
    t = t.parent;
  }
  return null;
}
function Kp(i) {
  return !!i.getCustomProperty("table") && ae(i);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class IV extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [So];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableToolbar";
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    const e = this.editor, t = e.t, n = e.plugins.get(So), s = e.config.get("table.contentToolbar"), o = e.config.get("table.tableToolbar");
    s && n.register("tableContent", {
      ariaLabel: t("Table toolbar"),
      items: s,
      getRelatedElement: hr
    }), o && n.register("table", {
      ariaLabel: t("Table toolbar"),
      items: o,
      getRelatedElement: jp
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class SV extends T {
  /**
   * Creates an instance of the color input view.
   *
   * @param locale The locale instance.
   * @param options The input options.
   * @param options.colorDefinitions The colors to be displayed in the palette inside the input's dropdown.
   * @param options.columns The number of columns in which the colors will be displayed.
   * @param options.defaultColorValue If specified, the color input view will replace the "Remove color" button with
   * the "Restore default" button. Instead of clearing the input field, the default color value will be set.
   */
  constructor(e, t) {
    super(e), this.set("value", ""), this.set("isReadOnly", !1), this.set("isFocused", !1), this.set("isEmpty", !0), this.options = t, this.focusTracker = new X(), this._focusables = new ve(), this.dropdownView = this._createDropdownView(), this.inputView = this._createInputTextView(), this.keystrokes = new ie(), this._stillTyping = !1, this.focusCycler = new ge({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate items backwards using the <kbd>Shift</kbd> + <kbd>Tab</kbd> keystroke.
        focusPrevious: "shift + tab",
        // Navigate items forwards using the <kbd>Tab</kbd> key.
        focusNext: "tab"
      }
    }), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-input-color"
        ]
      },
      children: [
        this.dropdownView,
        this.inputView
      ]
    }), this.on("change:value", (n, s, o) => this._setInputValue(o));
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), [this.inputView, this.dropdownView.buttonView].forEach((e) => {
      this.focusTracker.add(e.element), this._focusables.add(e);
    }), this.keystrokes.listenTo(this.element);
  }
  /**
   * Focuses the view.
   */
  focus(e) {
    e === -1 ? this.focusCycler.focusLast() : this.focusCycler.focusFirst();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  /**
   * Creates and configures the {@link #dropdownView}.
   */
  _createDropdownView() {
    const e = this.locale, t = e.t, n = this.bindTemplate, s = this._createColorSelector(e), o = we(e), r = new T();
    return r.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-input-color__button__preview"
        ],
        style: {
          backgroundColor: n.to("value")
        }
      },
      children: [{
        tag: "span",
        attributes: {
          class: [
            "ck",
            "ck-input-color__button__preview__no-color-indicator",
            n.if("value", "ck-hidden", (a) => a != "")
          ]
        }
      }]
    }), o.buttonView.extendTemplate({
      attributes: {
        class: "ck-input-color__button"
      }
    }), o.buttonView.children.add(r), o.buttonView.label = t("Color picker"), o.buttonView.tooltip = !0, o.panelPosition = e.uiLanguageDirection === "rtl" ? "se" : "sw", o.panelView.children.add(s), o.bind("isEnabled").to(this, "isReadOnly", (a) => !a), o.on("change:isOpen", (a, l, c) => {
      c && (s.updateSelectedColors(), s.showColorGridsFragment());
    }), o;
  }
  /**
   * Creates and configures an instance of {@link module:ui/inputtext/inputtextview~InputTextView}.
   *
   * @returns A configured instance to be set as {@link #inputView}.
   */
  _createInputTextView() {
    const e = this.locale, t = new Lg(e);
    return t.extendTemplate({
      on: {
        blur: t.bindTemplate.to("blur")
      }
    }), t.value = this.value, t.bind("isReadOnly", "hasError").to(this), this.bind("isFocused", "isEmpty").to(t), t.on("input", () => {
      const n = t.element.value, s = this.options.colorDefinitions.find((o) => n === o.label);
      this._stillTyping = !0, this.value = s && s.color || n;
    }), t.on("blur", () => {
      this._stillTyping = !1, this._setInputValue(t.element.value);
    }), t.delegate("input").to(this), t;
  }
  /**
   * Creates and configures the panel with "color grid" and "color picker" inside the {@link #dropdownView}.
   */
  _createColorSelector(e) {
    const t = e.t, n = this.options.defaultColorValue || "", s = t(n ? "Restore default" : "Remove color"), o = new Vl(e, {
      colors: this.options.colorDefinitions,
      columns: this.options.columns,
      removeButtonLabel: s,
      colorPickerLabel: t("Color picker"),
      colorPickerViewConfig: this.options.colorPickerConfig === !1 ? !1 : {
        ...this.options.colorPickerConfig,
        hideInput: !0
      }
    });
    o.appendUI(), o.on("execute", (a, l) => {
      if (l.source === "colorPickerSaveButton") {
        this.dropdownView.isOpen = !1;
        return;
      }
      this.value = l.value || n, this.fire("input"), l.source !== "colorPicker" && (this.dropdownView.isOpen = !1);
    });
    let r = this.value;
    return o.on("colorPicker:cancel", () => {
      this.value = r, this.fire("input"), this.dropdownView.isOpen = !1;
    }), o.colorGridsFragmentView.colorPickerButtonView.on("execute", () => {
      r = this.value;
    }), o.bind("selectedColor").to(this, "value"), o;
  }
  /**
   * Sets {@link #inputView}'s value property to the color value or color label,
   * if there is one and the user is not typing.
   *
   * Handles cases like:
   *
   * * Someone picks the color in the grid.
   * * The color is set from the plugin level.
   *
   * @param inputValue Color value to be set.
   */
  _setInputValue(e) {
    if (!this._stillTyping) {
      const t = Ih(e), n = this.options.colorDefinitions.find((s) => t === Ih(s.color));
      n ? this.inputView.value = n.label : this.inputView.value = e || "";
    }
  }
}
function Ih(i) {
  return i.replace(/([(,])\s+/g, "$1").replace(/^\s+|\s+(?=[),\s]|$)/g, "").replace(/,|\s/g, " ");
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const jl = (i) => i === "";
function Kl(i) {
  return {
    none: i("None"),
    solid: i("Solid"),
    dotted: i("Dotted"),
    dashed: i("Dashed"),
    double: i("Double"),
    groove: i("Groove"),
    ridge: i("Ridge"),
    inset: i("Inset"),
    outset: i("Outset")
  };
}
function Zp(i) {
  return i('The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".');
}
function Jp(i) {
  return i('The value is invalid. Try "10px" or "2em" or simply "2".');
}
function Vo(i) {
  return i = i.trim().toLowerCase(), jl(i) || og(i);
}
function Wi(i) {
  return i = i.trim(), jl(i) || Yp(i) || Yo(i) || rg(i);
}
function Xp(i) {
  return i = i.trim(), jl(i) || Yp(i) || Yo(i);
}
function Qp(i, e) {
  const t = new ke(), n = Kl(i.t);
  for (const s in n) {
    const o = {
      type: "button",
      model: new $t({
        _borderStyleValue: s,
        label: n[s],
        role: "menuitemradio",
        withText: !0
      })
    };
    s === "none" ? o.model.bind("isOn").to(i, "borderStyle", (r) => e === "none" ? !r : r === s) : o.model.bind("isOn").to(i, "borderStyle", (r) => r === s), t.add(o);
  }
  return t;
}
function Oa(i) {
  const { view: e, icons: t, toolbar: n, labels: s, propertyName: o, nameToValue: r, defaultValue: a } = i;
  for (const l in s) {
    const c = new P(e.locale);
    c.set({
      label: s[l],
      icon: t[l],
      tooltip: s[l]
    });
    const u = r ? r(l) : l;
    c.bind("isOn").to(e, o, (d) => {
      let h = d;
      return d === "" && a && (h = a), u === h;
    }), c.on("execute", () => {
      e[o] = u;
    }), n.items.add(c);
  }
}
const Mo = [
  {
    color: "hsl(0, 0%, 0%)",
    label: "Black"
  },
  {
    color: "hsl(0, 0%, 30%)",
    label: "Dim grey"
  },
  {
    color: "hsl(0, 0%, 60%)",
    label: "Grey"
  },
  {
    color: "hsl(0, 0%, 90%)",
    label: "Light grey"
  },
  {
    color: "hsl(0, 0%, 100%)",
    label: "White",
    hasBorder: !0
  },
  {
    color: "hsl(0, 75%, 60%)",
    label: "Red"
  },
  {
    color: "hsl(30, 75%, 60%)",
    label: "Orange"
  },
  {
    color: "hsl(60, 75%, 60%)",
    label: "Yellow"
  },
  {
    color: "hsl(90, 75%, 60%)",
    label: "Light green"
  },
  {
    color: "hsl(120, 75%, 60%)",
    label: "Green"
  },
  {
    color: "hsl(150, 75%, 60%)",
    label: "Aquamarine"
  },
  {
    color: "hsl(180, 75%, 60%)",
    label: "Turquoise"
  },
  {
    color: "hsl(210, 75%, 60%)",
    label: "Light blue"
  },
  {
    color: "hsl(240, 75%, 60%)",
    label: "Blue"
  },
  {
    color: "hsl(270, 75%, 60%)",
    label: "Purple"
  }
];
function Bo(i) {
  return (e, t, n) => {
    const s = new SV(e.locale, {
      colorDefinitions: PV(i.colorConfig),
      columns: i.columns,
      defaultColorValue: i.defaultColorValue,
      colorPickerConfig: i.colorPickerConfig
    });
    return s.inputView.set({
      id: t,
      ariaDescribedById: n
    }), s.bind("isReadOnly").to(e, "isEnabled", (o) => !o), s.bind("hasError").to(e, "errorText", (o) => !!o), s.on("input", () => {
      e.errorText = null;
    }), e.bind("isEmpty", "isFocused").to(s), s;
  };
}
function Yp(i) {
  const e = parseFloat(i);
  return !Number.isNaN(e) && i === String(e);
}
function PV(i) {
  return i.map((e) => ({
    color: e.model,
    label: e.label,
    options: {
      hasBorder: e.hasBorder
    }
  }));
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Oe extends T {
  /**
   * Creates an instance of the form row class.
   *
   * @param locale The locale instance.
   * @param options.labelView When passed, the row gets the `group` and `aria-labelledby`
   * DOM attributes and gets described by the label.
   */
  constructor(e, t = {}) {
    super(e);
    const n = this.bindTemplate;
    this.set("class", t.class || null), this.children = this.createCollection(), t.children && t.children.forEach((s) => this.children.add(s)), this.set("_role", null), this.set("_ariaLabelledBy", null), t.labelView && this.set({
      _role: "group",
      _ariaLabelledBy: t.labelView.id
    }), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-form__row",
          n.to("class")
        ],
        role: n.to("_role"),
        "aria-labelledby": n.to("_ariaLabelledBy")
      },
      children: this.children
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Sh = {
  left: A.alignLeft,
  center: A.alignCenter,
  right: A.alignRight,
  justify: A.alignJustify,
  top: A.alignTop,
  middle: A.alignMiddle,
  bottom: A.alignBottom
};
class RV extends T {
  /**
   * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
   * @param options Additional configuration of the view.
   * @param options.borderColors A configuration of the border color palette used by the
   * {@link module:table/tablecellproperties/ui/tablecellpropertiesview~TableCellPropertiesView#borderColorInput}.
   * @param options.backgroundColors A configuration of the background color palette used by the
   * {@link module:table/tablecellproperties/ui/tablecellpropertiesview~TableCellPropertiesView#backgroundInput}.
   * @param options.defaultTableCellProperties The default table cell properties.
   */
  constructor(e, t) {
    super(e), this.set({
      borderStyle: "",
      borderWidth: "",
      borderColor: "",
      padding: "",
      backgroundColor: "",
      width: "",
      height: "",
      horizontalAlignment: "",
      verticalAlignment: ""
    }), this.options = t;
    const { borderStyleDropdown: n, borderWidthInput: s, borderColorInput: o, borderRowLabel: r } = this._createBorderFields(), { backgroundRowLabel: a, backgroundInput: l } = this._createBackgroundFields(), { widthInput: c, operatorLabel: u, heightInput: d, dimensionsLabel: h } = this._createDimensionFields(), { horizontalAlignmentToolbar: f, verticalAlignmentToolbar: m, alignmentLabel: p } = this._createAlignmentFields();
    this.focusTracker = new X(), this.keystrokes = new ie(), this.children = this.createCollection(), this.borderStyleDropdown = n, this.borderWidthInput = s, this.borderColorInput = o, this.backgroundInput = l, this.paddingInput = this._createPaddingField(), this.widthInput = c, this.heightInput = d, this.horizontalAlignmentToolbar = f, this.verticalAlignmentToolbar = m;
    const { saveButtonView: w, cancelButtonView: v } = this._createActionButtons();
    this.saveButtonView = w, this.cancelButtonView = v, this._focusables = new ve(), this._focusCycler = new ge({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    }), this.children.add(new rr(e, {
      label: this.t("Cell properties")
    })), this.children.add(new Oe(e, {
      labelView: r,
      children: [
        r,
        n,
        o,
        s
      ],
      class: "ck-table-form__border-row"
    })), this.children.add(new Oe(e, {
      labelView: a,
      children: [
        a,
        l
      ],
      class: "ck-table-form__background-row"
    })), this.children.add(new Oe(e, {
      children: [
        // Dimensions row.
        new Oe(e, {
          labelView: h,
          children: [
            h,
            c,
            u,
            d
          ],
          class: "ck-table-form__dimensions-row"
        }),
        // Padding row.
        new Oe(e, {
          children: [
            this.paddingInput
          ],
          class: "ck-table-cell-properties-form__padding-row"
        })
      ]
    })), this.children.add(new Oe(e, {
      labelView: p,
      children: [
        p,
        f,
        m
      ],
      class: "ck-table-cell-properties-form__alignment-row"
    })), this.children.add(new Oe(e, {
      children: [
        this.saveButtonView,
        this.cancelButtonView
      ],
      class: "ck-table-form__action-row"
    })), this.setTemplate({
      tag: "form",
      attributes: {
        class: [
          "ck",
          "ck-form",
          "ck-table-form",
          "ck-table-cell-properties-form"
        ],
        // https://github.com/ckeditor/ckeditor5-link/issues/90
        tabindex: "-1"
      },
      children: this.children
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), Cn({
      view: this
    }), [this.borderColorInput, this.backgroundInput].forEach((e) => {
      e.fieldView.focusCycler.on("forwardCycle", (t) => {
        this._focusCycler.focusNext(), t.stop();
      }), e.fieldView.focusCycler.on("backwardCycle", (t) => {
        this._focusCycler.focusPrevious(), t.stop();
      });
    }), [
      this.borderStyleDropdown,
      this.borderColorInput,
      this.borderWidthInput,
      this.backgroundInput,
      this.widthInput,
      this.heightInput,
      this.paddingInput,
      this.horizontalAlignmentToolbar,
      this.verticalAlignmentToolbar,
      this.saveButtonView,
      this.cancelButtonView
    ].forEach((e) => {
      this._focusables.add(e), this.focusTracker.add(e.element);
    }), this.keystrokes.listenTo(this.element);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  /**
   * Focuses the fist focusable field in the form.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
   * Creates the following form fields:
   *
   * * {@link #borderStyleDropdown},
   * * {@link #borderWidthInput},
   * * {@link #borderColorInput}.
   */
  _createBorderFields() {
    const e = this.options.defaultTableCellProperties, t = {
      style: e.borderStyle,
      width: e.borderWidth,
      color: e.borderColor
    }, n = Bo({
      colorConfig: this.options.borderColors,
      columns: 5,
      defaultColorValue: t.color,
      colorPickerConfig: this.options.colorPickerConfig
    }), s = this.locale, o = this.t, r = o("Style"), a = new ze(s);
    a.text = o("Border");
    const l = Kl(o), c = new ue(s, Dg);
    c.set({
      label: r,
      class: "ck-table-form__border-style"
    }), c.fieldView.buttonView.set({
      ariaLabel: r,
      ariaLabelledBy: void 0,
      isOn: !1,
      withText: !0,
      tooltip: r
    }), c.fieldView.buttonView.bind("label").to(this, "borderStyle", (h) => l[h || "none"]), c.fieldView.on("execute", (h) => {
      this.borderStyle = h.source._borderStyleValue;
    }), c.bind("isEmpty").to(this, "borderStyle", (h) => !h), Kt(c.fieldView, Qp(this, t.style), {
      role: "menu",
      ariaLabel: r
    });
    const u = new ue(s, He);
    u.set({
      label: o("Width"),
      class: "ck-table-form__border-width"
    }), u.fieldView.bind("value").to(this, "borderWidth"), u.bind("isEnabled").to(this, "borderStyle", eo), u.fieldView.on("input", () => {
      this.borderWidth = u.fieldView.element.value;
    });
    const d = new ue(s, n);
    return d.set({
      label: o("Color"),
      class: "ck-table-form__border-color"
    }), d.fieldView.bind("value").to(this, "borderColor"), d.bind("isEnabled").to(this, "borderStyle", eo), d.fieldView.on("input", () => {
      this.borderColor = d.fieldView.value;
    }), this.on("change:borderStyle", (h, f, m, p) => {
      eo(m) || (this.borderColor = "", this.borderWidth = ""), eo(p) || (this.borderColor = t.color, this.borderWidth = t.width);
    }), {
      borderRowLabel: a,
      borderStyleDropdown: c,
      borderColorInput: d,
      borderWidthInput: u
    };
  }
  /**
   * Creates the following form fields:
   *
   * * {@link #backgroundInput}.
   */
  _createBackgroundFields() {
    const e = this.locale, t = this.t, n = new ze(e);
    n.text = t("Background");
    const s = Bo({
      colorConfig: this.options.backgroundColors,
      columns: 5,
      defaultColorValue: this.options.defaultTableCellProperties.backgroundColor,
      colorPickerConfig: this.options.colorPickerConfig
    }), o = new ue(e, s);
    return o.set({
      label: t("Color"),
      class: "ck-table-cell-properties-form__background"
    }), o.fieldView.bind("value").to(this, "backgroundColor"), o.fieldView.on("input", () => {
      this.backgroundColor = o.fieldView.value;
    }), {
      backgroundRowLabel: n,
      backgroundInput: o
    };
  }
  /**
   * Creates the following form fields:
   *
   * * {@link #widthInput}.
   * * {@link #heightInput}.
   */
  _createDimensionFields() {
    const e = this.locale, t = this.t, n = new ze(e);
    n.text = t("Dimensions");
    const s = new ue(e, He);
    s.set({
      label: t("Width"),
      class: "ck-table-form__dimensions-row__width"
    }), s.fieldView.bind("value").to(this, "width"), s.fieldView.on("input", () => {
      this.width = s.fieldView.element.value;
    });
    const o = new T(e);
    o.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck-table-form__dimension-operator"
        ]
      },
      children: [
        { text: "×" }
      ]
    });
    const r = new ue(e, He);
    return r.set({
      label: t("Height"),
      class: "ck-table-form__dimensions-row__height"
    }), r.fieldView.bind("value").to(this, "height"), r.fieldView.on("input", () => {
      this.height = r.fieldView.element.value;
    }), {
      dimensionsLabel: n,
      widthInput: s,
      operatorLabel: o,
      heightInput: r
    };
  }
  /**
   * Creates the following form fields:
   *
   * * {@link #paddingInput}.
   */
  _createPaddingField() {
    const e = this.locale, t = this.t, n = new ue(e, He);
    return n.set({
      label: t("Padding"),
      class: "ck-table-cell-properties-form__padding"
    }), n.fieldView.bind("value").to(this, "padding"), n.fieldView.on("input", () => {
      this.padding = n.fieldView.element.value;
    }), n;
  }
  /**
   * Creates the following form fields:
   *
   * * {@link #horizontalAlignmentToolbar},
   * * {@link #verticalAlignmentToolbar}.
   */
  _createAlignmentFields() {
    const e = this.locale, t = this.t, n = new ze(e);
    n.text = t("Table cell text alignment");
    const s = new ni(e), o = e.contentLanguageDirection === "rtl";
    s.set({
      isCompact: !0,
      ariaLabel: t("Horizontal text alignment toolbar")
    }), Oa({
      view: this,
      icons: Sh,
      toolbar: s,
      labels: this._horizontalAlignmentLabels,
      propertyName: "horizontalAlignment",
      nameToValue: (a) => {
        if (o) {
          if (a === "left")
            return "right";
          if (a === "right")
            return "left";
        }
        return a;
      },
      defaultValue: this.options.defaultTableCellProperties.horizontalAlignment
    });
    const r = new ni(e);
    return r.set({
      isCompact: !0,
      ariaLabel: t("Vertical text alignment toolbar")
    }), Oa({
      view: this,
      icons: Sh,
      toolbar: r,
      labels: this._verticalAlignmentLabels,
      propertyName: "verticalAlignment",
      defaultValue: this.options.defaultTableCellProperties.verticalAlignment
    }), {
      horizontalAlignmentToolbar: s,
      verticalAlignmentToolbar: r,
      alignmentLabel: n
    };
  }
  /**
   * Creates the following form controls:
   *
   * * {@link #saveButtonView},
   * * {@link #cancelButtonView}.
   */
  _createActionButtons() {
    const e = this.locale, t = this.t, n = new P(e), s = new P(e), o = [
      this.borderWidthInput,
      this.borderColorInput,
      this.backgroundInput,
      this.paddingInput
    ];
    return n.set({
      label: t("Save"),
      icon: A.check,
      class: "ck-button-save",
      type: "submit",
      withText: !0
    }), n.bind("isEnabled").toMany(o, "errorText", (...r) => r.every((a) => !a)), s.set({
      label: t("Cancel"),
      icon: A.cancel,
      class: "ck-button-cancel",
      withText: !0
    }), s.delegate("execute").to(this, "cancel"), {
      saveButtonView: n,
      cancelButtonView: s
    };
  }
  /**
   * Provides localized labels for {@link #horizontalAlignmentToolbar} buttons.
   */
  get _horizontalAlignmentLabels() {
    const e = this.locale, t = this.t, n = t("Align cell text to the left"), s = t("Align cell text to the center"), o = t("Align cell text to the right"), r = t("Justify cell text");
    return e.uiLanguageDirection === "rtl" ? { right: o, center: s, left: n, justify: r } : { left: n, center: s, right: o, justify: r };
  }
  /**
   * Provides localized labels for {@link #verticalAlignmentToolbar} buttons.
   */
  get _verticalAlignmentLabels() {
    const e = this.t;
    return {
      top: e("Align cell text to the top"),
      middle: e("Align cell text to the middle"),
      bottom: e("Align cell text to the bottom")
    };
  }
}
function eo(i) {
  return i !== "none";
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const nn = Ce.defaultPositions, Fa = [
  nn.northArrowSouth,
  nn.northArrowSouthWest,
  nn.northArrowSouthEast,
  nn.southArrowNorth,
  nn.southArrowNorthWest,
  nn.southArrowNorthEast,
  nn.viewportStickyNorth
];
function eb(i, e) {
  const t = i.plugins.get("ContextualBalloon"), n = i.editing.view.document.selection;
  let s;
  e === "cell" ? hr(n) && (s = nb(i)) : Gp(n) && (s = tb(i)), s && t.updatePosition(s);
}
function tb(i) {
  const e = i.model.document.selection, t = ln(e), n = i.editing.mapper.toViewElement(t);
  return {
    target: i.editing.view.domConverter.mapViewToDom(n),
    positions: Fa
  };
}
function nb(i) {
  const e = i.editing.mapper, t = i.editing.view.domConverter, n = i.model.document.selection;
  if (n.rangeCount > 1)
    return {
      target: () => VV(n.getRanges(), i),
      positions: Fa
    };
  const s = ib(n.getFirstPosition()), o = e.toViewElement(s);
  return {
    target: t.mapViewToDom(o),
    positions: Fa
  };
}
function ib(i) {
  return i.nodeAfter && i.nodeAfter.is("element", "tableCell") ? i.nodeAfter : i.findAncestor("tableCell");
}
function VV(i, e) {
  const t = e.editing.mapper, n = e.editing.view.domConverter, s = Array.from(i).map((o) => {
    const r = ib(o.start), a = t.toViewElement(r);
    return new B(n.mapViewToDom(a));
  });
  return B.getBoundingRect(s);
}
const MV = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.105 18-.17 1H2.5A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1h15A1.5 1.5 0 0 1 19 2.5v9.975l-.85-.124-.15-.302V8h-5v4h.021l-.172.351-1.916.28-.151.027c-.287.063-.54.182-.755.341L8 13v5h3.105zM2 12h5V8H2v4zm10-4H8v4h4V8zM2 2v5h5V2H2zm0 16h5v-5H2v5zM13 7h5V2h-5v5zM8 2v5h4V2H8z" opacity=".6"/><path d="m15.5 11.5 1.323 2.68 2.957.43-2.14 2.085.505 2.946L15.5 18.25l-2.645 1.39.505-2.945-2.14-2.086 2.957-.43L15.5 11.5zM13 6a1 1 0 0 1 1 1v3.172a2.047 2.047 0 0 0-.293.443l-.858 1.736-1.916.28-.151.027A1.976 1.976 0 0 0 9.315 14H7a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h6zm-1 2H8v4h4V8z"/></svg>';
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function xn(i) {
  if (!i || !J(i))
    return i;
  const { top: e, right: t, bottom: n, left: s } = i;
  if (e == t && t == n && n == s)
    return e;
}
function In(i, e) {
  const t = parseFloat(i);
  return Number.isNaN(t) || String(t) !== String(i) ? i : `${t}${e}`;
}
function Ts(i, e = {}) {
  const t = {
    borderStyle: "none",
    borderWidth: "",
    borderColor: "",
    backgroundColor: "",
    width: "",
    height: "",
    ...i
  };
  return e.includeAlignmentProperty && !t.alignment && (t.alignment = "center"), e.includePaddingProperty && !t.padding && (t.padding = ""), e.includeVerticalAlignmentProperty && !t.verticalAlignment && (t.verticalAlignment = "middle"), e.includeHorizontalAlignmentProperty && !t.horizontalAlignment && (t.horizontalAlignment = e.isRightToLeftContent ? "right" : "left"), t;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const BV = 500, Ph = {
  borderStyle: "tableCellBorderStyle",
  borderColor: "tableCellBorderColor",
  borderWidth: "tableCellBorderWidth",
  height: "tableCellHeight",
  width: "tableCellWidth",
  padding: "tableCellPadding",
  backgroundColor: "tableCellBackgroundColor",
  horizontalAlignment: "tableCellHorizontalAlignment",
  verticalAlignment: "tableCellVerticalAlignment"
};
class LV extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Rt];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableCellPropertiesUI";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), e.config.define("table.tableCellProperties", {
      borderColors: Mo,
      backgroundColors: Mo
    });
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.t;
    this._defaultTableCellProperties = Ts(e.config.get("table.tableCellProperties.defaultProperties"), {
      includeVerticalAlignmentProperty: !0,
      includeHorizontalAlignmentProperty: !0,
      includePaddingProperty: !0,
      isRightToLeftContent: e.locale.contentLanguageDirection === "rtl"
    }), this._balloon = e.plugins.get(Rt), this.view = null, this._isReady = !1, e.ui.componentFactory.add("tableCellProperties", (n) => {
      const s = new P(n);
      s.set({
        label: t("Cell properties"),
        icon: MV,
        tooltip: !0
      }), this.listenTo(s, "execute", () => this._showView());
      const o = Object.values(Ph).map((r) => e.commands.get(r));
      return s.bind("isEnabled").toMany(o, "isEnabled", (...r) => r.some((a) => a)), s;
    });
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.view && this.view.destroy();
  }
  /**
   * Creates the {@link module:table/tablecellproperties/ui/tablecellpropertiesview~TableCellPropertiesView} instance.
   *
   * @returns The cell properties form view instance.
   */
  _createPropertiesView() {
    const e = this.editor, t = e.config.get("table.tableCellProperties"), n = os(t.borderColors), s = ss(e.locale, n), o = os(t.backgroundColors), r = ss(e.locale, o), a = t.colorPicker !== !1, l = new RV(e.locale, {
      borderColors: s,
      backgroundColors: r,
      defaultTableCellProperties: this._defaultTableCellProperties,
      colorPickerConfig: a ? t.colorPicker || {} : !1
    }), c = e.t;
    l.render(), this.listenTo(l, "submit", () => {
      this._hideView();
    }), this.listenTo(l, "cancel", () => {
      this._undoStepBatch.operations.length && e.execute("undo", this._undoStepBatch), this._hideView();
    }), l.keystrokes.set("Esc", (h, f) => {
      this._hideView(), f();
    }), yn({
      emitter: l,
      activator: () => this._isViewInBalloon,
      contextElements: [this._balloon.view.element],
      callback: () => this._hideView()
    });
    const u = Zp(c), d = Jp(c);
    return l.on("change:borderStyle", this._getPropertyChangeCallback("tableCellBorderStyle")), l.on("change:borderColor", this._getValidatedPropertyChangeCallback({
      viewField: l.borderColorInput,
      commandName: "tableCellBorderColor",
      errorText: u,
      validator: Vo
    })), l.on("change:borderWidth", this._getValidatedPropertyChangeCallback({
      viewField: l.borderWidthInput,
      commandName: "tableCellBorderWidth",
      errorText: d,
      validator: Xp
    })), l.on("change:padding", this._getValidatedPropertyChangeCallback({
      viewField: l.paddingInput,
      commandName: "tableCellPadding",
      errorText: d,
      validator: Wi
    })), l.on("change:width", this._getValidatedPropertyChangeCallback({
      viewField: l.widthInput,
      commandName: "tableCellWidth",
      errorText: d,
      validator: Wi
    })), l.on("change:height", this._getValidatedPropertyChangeCallback({
      viewField: l.heightInput,
      commandName: "tableCellHeight",
      errorText: d,
      validator: Wi
    })), l.on("change:backgroundColor", this._getValidatedPropertyChangeCallback({
      viewField: l.backgroundInput,
      commandName: "tableCellBackgroundColor",
      errorText: u,
      validator: Vo
    })), l.on("change:horizontalAlignment", this._getPropertyChangeCallback("tableCellHorizontalAlignment")), l.on("change:verticalAlignment", this._getPropertyChangeCallback("tableCellVerticalAlignment")), l;
  }
  /**
   * In this method the "editor data -> UI" binding is happening.
   *
   * When executed, this method obtains selected cell property values from various table commands
   * and passes them to the {@link #view}.
   *
   * This way, the UI stays up–to–date with the editor data.
   */
  _fillViewFormFromCommandValues() {
    const e = this.editor.commands, t = e.get("tableCellBorderStyle");
    Object.entries(Ph).map(([n, s]) => {
      const o = this._defaultTableCellProperties[n] || "";
      return [
        n,
        e.get(s).value || o
      ];
    }).forEach(([n, s]) => {
      (n === "borderColor" || n === "borderWidth") && t.value === "none" || this.view.set(n, s);
    }), this._isReady = !0;
  }
  /**
   * Shows the {@link #view} in the {@link #_balloon}.
   *
   * **Note**: Each time a view is shown, a new {@link #_undoStepBatch} is created. It contains
   * all changes made to the document when the view is visible, allowing a single undo step
   * for all of them.
   */
  _showView() {
    const e = this.editor;
    this.view || (this.view = this._createPropertiesView()), this.listenTo(e.ui, "update", () => {
      this._updateView();
    }), this._fillViewFormFromCommandValues(), this._balloon.add({
      view: this.view,
      position: nb(e)
    }), this._undoStepBatch = e.model.createBatch(), this.view.focus();
  }
  /**
   * Removes the {@link #view} from the {@link #_balloon}.
   */
  _hideView() {
    const e = this.editor;
    this.stopListening(e.ui, "update"), this._isReady = !1, this.view.saveButtonView.focus(), this._balloon.remove(this.view), this.editor.editing.view.focus();
  }
  /**
   * Repositions the {@link #_balloon} or hides the {@link #view} if a table cell is no longer selected.
   */
  _updateView() {
    const e = this.editor, t = e.editing.view.document;
    hr(t.selection) ? this._isViewVisible && eb(e, "cell") : this._hideView();
  }
  /**
   * Returns `true` when the {@link #view} is visible in the {@link #_balloon}.
   */
  get _isViewVisible() {
    return !!this.view && this._balloon.visibleView === this.view;
  }
  /**
   * Returns `true` when the {@link #view} is in the {@link #_balloon}.
   */
  get _isViewInBalloon() {
    return !!this.view && this._balloon.hasView(this.view);
  }
  /**
   * Creates a callback that when executed upon the {@link #view view's} property change
   * executes a related editor command with the new property value.
   *
   * @param defaultValue The default value of the command.
   */
  _getPropertyChangeCallback(e) {
    return (t, n, s) => {
      this._isReady && this.editor.execute(e, {
        value: s,
        batch: this._undoStepBatch
      });
    };
  }
  /**
   * Creates a callback that when executed upon the {@link #view view's} property change:
   * * Executes a related editor command with the new property value if the value is valid,
   * * Or sets the error text next to the invalid field, if the value did not pass the validation.
   */
  _getValidatedPropertyChangeCallback(e) {
    const { commandName: t, viewField: n, validator: s, errorText: o } = e, r = Pt(() => {
      n.errorText = o;
    }, BV);
    return (a, l, c) => {
      r.cancel(), this._isReady && (s(c) ? (this.editor.execute(t, {
        value: c,
        batch: this._undoStepBatch
      }), n.errorText = null) : r());
    };
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Lt extends V {
  /**
   * Creates a new `TableCellPropertyCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param attributeName Table cell attribute name.
   * @param defaultValue The default value of the attribute.
   */
  constructor(e, t, n) {
    super(e), this.attributeName = t, this._defaultValue = n;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor, n = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(e.model.document.selection);
    this.isEnabled = !!n.length, this.value = this._getSingleValue(n);
  }
  /**
   * Executes the command.
   *
   * @fires execute
   * @param options.value If set, the command will set the attribute on selected table cells.
   * If it is not set, the command will remove the attribute from the selected table cells.
   * @param options.batch Pass the model batch instance to the command to aggregate changes,
   * for example to allow a single undo step for multiple executions.
   */
  execute(e = {}) {
    const { value: t, batch: n } = e, s = this.editor.model, r = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(s.document.selection), a = this._getValueToSet(t);
    s.enqueueChange(n, (l) => {
      a ? r.forEach((c) => l.setAttribute(this.attributeName, a, c)) : r.forEach((c) => l.removeAttribute(this.attributeName, c));
    });
  }
  /**
   * Returns the attribute value for a table cell.
   */
  _getAttribute(e) {
    if (!e)
      return;
    const t = e.getAttribute(this.attributeName);
    if (t !== this._defaultValue)
      return t;
  }
  /**
   * Returns the proper model value. It can be used to add a default unit to numeric values.
   */
  _getValueToSet(e) {
    if (e !== this._defaultValue)
      return e;
  }
  /**
   * Returns a single value for all selected table cells. If the value is the same for all cells,
   * it will be returned (`undefined` otherwise).
   */
  _getSingleValue(e) {
    const t = this._getAttribute(e[0]);
    return e.every((s) => this._getAttribute(s) === t) ? t : void 0;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class OV extends Lt {
  /**
   * Creates a new `TableCellWidthCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value of the attribute.
   */
  constructor(e, t) {
    super(e, "tableCellWidth", t);
  }
  /**
   * @inheritDoc
   */
  _getValueToSet(e) {
    if (e = In(e, "px"), e !== this._defaultValue)
      return e;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class sb extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableCellWidthEditing";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ks];
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = Ts(e.config.get("table.tableCellProperties.defaultProperties"));
    uo(e.model.schema, e.conversion, {
      modelAttribute: "tableCellWidth",
      styleName: "width",
      defaultValue: t.width
    }), e.commands.add("tableCellWidth", new OV(e, t.width));
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class FV extends Lt {
  /**
   * Creates a new `TableCellPaddingCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value of the attribute.
   */
  constructor(e, t) {
    super(e, "tableCellPadding", t);
  }
  /**
   * @inheritDoc
   */
  _getAttribute(e) {
    if (!e)
      return;
    const t = xn(e.getAttribute(this.attributeName));
    if (t !== this._defaultValue)
      return t;
  }
  /**
   * @inheritDoc
   */
  _getValueToSet(e) {
    const t = In(e, "px");
    if (t !== this._defaultValue)
      return t;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class NV extends Lt {
  /**
   * Creates a new `TableCellHeightCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value of the attribute.
   */
  constructor(e, t) {
    super(e, "tableCellHeight", t);
  }
  /**
   * @inheritDoc
   */
  _getValueToSet(e) {
    const t = In(e, "px");
    if (t !== this._defaultValue)
      return t;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class DV extends Lt {
  /**
   * Creates a new `TableCellBackgroundColorCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value of the attribute.
   */
  constructor(e, t) {
    super(e, "tableCellBackgroundColor", t);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class zV extends Lt {
  /**
   * Creates a new `TableCellVerticalAlignmentCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value for the "alignment" attribute.
   */
  constructor(e, t) {
    super(e, "tableCellVerticalAlignment", t);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class HV extends Lt {
  /**
   * Creates a new `TableCellHorizontalAlignmentCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value for the "alignment" attribute.
   */
  constructor(e, t) {
    super(e, "tableCellHorizontalAlignment", t);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class UV extends Lt {
  /**
   * Creates a new `TableCellBorderStyleCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value of the attribute.
   */
  constructor(e, t) {
    super(e, "tableCellBorderStyle", t);
  }
  /**
   * @inheritDoc
   */
  _getAttribute(e) {
    if (!e)
      return;
    const t = xn(e.getAttribute(this.attributeName));
    if (t !== this._defaultValue)
      return t;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class $V extends Lt {
  /**
   * Creates a new `TableCellBorderColorCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value of the attribute.
   */
  constructor(e, t) {
    super(e, "tableCellBorderColor", t);
  }
  /**
   * @inheritDoc
   */
  _getAttribute(e) {
    if (!e)
      return;
    const t = xn(e.getAttribute(this.attributeName));
    if (t !== this._defaultValue)
      return t;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class WV extends Lt {
  /**
   * Creates a new `TableCellBorderWidthCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value of the attribute.
   */
  constructor(e, t) {
    super(e, "tableCellBorderWidth", t);
  }
  /**
   * @inheritDoc
   */
  _getAttribute(e) {
    if (!e)
      return;
    const t = xn(e.getAttribute(this.attributeName));
    if (t !== this._defaultValue)
      return t;
  }
  /**
   * @inheritDoc
   */
  _getValueToSet(e) {
    const t = In(e, "px");
    if (t !== this._defaultValue)
      return t;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Rh = /^(top|middle|bottom)$/, Vh = /^(left|center|right|justify)$/;
class qV extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableCellPropertiesEditing";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ks, sb];
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model.schema, n = e.conversion;
    e.config.define("table.tableCellProperties.defaultProperties", {});
    const s = Ts(e.config.get("table.tableCellProperties.defaultProperties"), {
      includeVerticalAlignmentProperty: !0,
      includeHorizontalAlignmentProperty: !0,
      includePaddingProperty: !0,
      isRightToLeftContent: e.locale.contentLanguageDirection === "rtl"
    });
    e.data.addStyleProcessorRules(lg), GV(t, n, {
      color: s.borderColor,
      style: s.borderStyle,
      width: s.borderWidth
    }), e.commands.add("tableCellBorderStyle", new UV(e, s.borderStyle)), e.commands.add("tableCellBorderColor", new $V(e, s.borderColor)), e.commands.add("tableCellBorderWidth", new WV(e, s.borderWidth)), uo(t, n, {
      modelAttribute: "tableCellHeight",
      styleName: "height",
      defaultValue: s.height
    }), e.commands.add("tableCellHeight", new NV(e, s.height)), e.data.addStyleProcessorRules(j5), uo(t, n, {
      modelAttribute: "tableCellPadding",
      styleName: "padding",
      reduceBoxSides: !0,
      defaultValue: s.padding
    }), e.commands.add("tableCellPadding", new FV(e, s.padding)), e.data.addStyleProcessorRules(kl), uo(t, n, {
      modelAttribute: "tableCellBackgroundColor",
      styleName: "background-color",
      defaultValue: s.backgroundColor
    }), e.commands.add("tableCellBackgroundColor", new DV(e, s.backgroundColor)), jV(t, n, s.horizontalAlignment), e.commands.add("tableCellHorizontalAlignment", new HV(e, s.horizontalAlignment)), KV(t, n, s.verticalAlignment), e.commands.add("tableCellVerticalAlignment", new zV(e, s.verticalAlignment));
  }
}
function GV(i, e, t) {
  const n = {
    width: "tableCellBorderWidth",
    color: "tableCellBorderColor",
    style: "tableCellBorderStyle"
  };
  i.extend("tableCell", {
    allowAttributes: Object.values(n)
  }), xa(e, "td", n, t), xa(e, "th", n, t), $i(e, { modelElement: "tableCell", modelAttribute: n.style, styleName: "border-style" }), $i(e, { modelElement: "tableCell", modelAttribute: n.color, styleName: "border-color" }), $i(e, { modelElement: "tableCell", modelAttribute: n.width, styleName: "border-width" });
}
function jV(i, e, t) {
  i.extend("tableCell", {
    allowAttributes: ["tableCellHorizontalAlignment"]
  }), e.for("downcast").attributeToAttribute({
    model: {
      name: "tableCell",
      key: "tableCellHorizontalAlignment"
    },
    view: (n) => ({
      key: "style",
      value: {
        "text-align": n
      }
    })
  }), e.for("upcast").attributeToAttribute({
    view: {
      name: /^(td|th)$/,
      styles: {
        "text-align": Vh
      }
    },
    model: {
      key: "tableCellHorizontalAlignment",
      value: (n) => {
        const s = n.getStyle("text-align");
        return s === t ? null : s;
      }
    }
  }).attributeToAttribute({
    view: {
      name: /^(td|th)$/,
      attributes: {
        align: Vh
      }
    },
    model: {
      key: "tableCellHorizontalAlignment",
      value: (n) => {
        const s = n.getAttribute("align");
        return s === t ? null : s;
      }
    }
  });
}
function KV(i, e, t) {
  i.extend("tableCell", {
    allowAttributes: ["tableCellVerticalAlignment"]
  }), e.for("downcast").attributeToAttribute({
    model: {
      name: "tableCell",
      key: "tableCellVerticalAlignment"
    },
    view: (n) => ({
      key: "style",
      value: {
        "vertical-align": n
      }
    })
  }), e.for("upcast").attributeToAttribute({
    view: {
      name: /^(td|th)$/,
      styles: {
        "vertical-align": Rh
      }
    },
    model: {
      key: "tableCellVerticalAlignment",
      value: (n) => {
        const s = n.getStyle("vertical-align");
        return s === t ? null : s;
      }
    }
  }).attributeToAttribute({
    view: {
      name: /^(td|th)$/,
      attributes: {
        valign: Rh
      }
    },
    model: {
      key: "tableCellVerticalAlignment",
      value: (n) => {
        const s = n.getAttribute("valign");
        return s === t ? null : s;
      }
    }
  });
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ZV extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableCellProperties";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [qV, LV];
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Sn extends V {
  /**
   * Creates a new `TablePropertyCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param attributeName Table cell attribute name.
   * @param defaultValue The default value of the attribute.
   */
  constructor(e, t, n) {
    super(e), this.attributeName = t, this._defaultValue = n;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const t = this.editor.model.document.selection, n = ln(t);
    this.isEnabled = !!n, this.value = this._getValue(n);
  }
  /**
   * Executes the command.
   *
   * @fires execute
   * @param options.value If set, the command will set the attribute on the selected table.
   * If not set, the command will remove the attribute from the selected table.
   * @param options.batch Pass the model batch instance to the command to aggregate changes,
   * for example, to allow a single undo step for multiple executions.
   */
  execute(e = {}) {
    const t = this.editor.model, n = t.document.selection, { value: s, batch: o } = e, r = ln(n), a = this._getValueToSet(s);
    t.enqueueChange(o, (l) => {
      a ? l.setAttribute(this.attributeName, a, r) : l.removeAttribute(this.attributeName, r);
    });
  }
  /**
   * Returns the attribute value for a table.
   */
  _getValue(e) {
    if (!e)
      return;
    const t = e.getAttribute(this.attributeName);
    if (t !== this._defaultValue)
      return t;
  }
  /**
   * Returns the proper model value. It can be used to add a default unit to numeric values.
   */
  _getValueToSet(e) {
    if (e !== this._defaultValue)
      return e;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class JV extends Sn {
  /**
   * Creates a new `TableBackgroundColorCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value of the attribute.
   */
  constructor(e, t) {
    super(e, "tableBackgroundColor", t);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class XV extends Sn {
  /**
   * Creates a new `TableBorderColorCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value of the attribute.
   */
  constructor(e, t) {
    super(e, "tableBorderColor", t);
  }
  /**
   * @inheritDoc
   */
  _getValue(e) {
    if (!e)
      return;
    const t = xn(e.getAttribute(this.attributeName));
    if (t !== this._defaultValue)
      return t;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class QV extends Sn {
  /**
   * Creates a new `TableBorderStyleCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value of the attribute.
   */
  constructor(e, t) {
    super(e, "tableBorderStyle", t);
  }
  /**
   * @inheritDoc
   */
  _getValue(e) {
    if (!e)
      return;
    const t = xn(e.getAttribute(this.attributeName));
    if (t !== this._defaultValue)
      return t;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class YV extends Sn {
  /**
   * Creates a new `TableBorderWidthCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value of the attribute.
   */
  constructor(e, t) {
    super(e, "tableBorderWidth", t);
  }
  /**
   * @inheritDoc
   */
  _getValue(e) {
    if (!e)
      return;
    const t = xn(e.getAttribute(this.attributeName));
    if (t !== this._defaultValue)
      return t;
  }
  /**
   * @inheritDoc
   */
  _getValueToSet(e) {
    const t = In(e, "px");
    if (t !== this._defaultValue)
      return t;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class e6 extends Sn {
  /**
   * Creates a new `TableWidthCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value of the attribute.
   */
  constructor(e, t) {
    super(e, "tableWidth", t);
  }
  /**
   * @inheritDoc
   */
  _getValueToSet(e) {
    if (e = In(e, "px"), e !== this._defaultValue)
      return e;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class t6 extends Sn {
  /**
   * Creates a new `TableHeightCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value of the attribute.
   */
  constructor(e, t) {
    super(e, "tableHeight", t);
  }
  /**
   * @inheritDoc
   */
  _getValueToSet(e) {
    if (e = In(e, "px"), e !== this._defaultValue)
      return e;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class n6 extends Sn {
  /**
   * Creates a new `TableAlignmentCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value for the "alignment" attribute.
   */
  constructor(e, t) {
    super(e, "tableAlignment", t);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const i6 = /^(left|center|right)$/, s6 = /^(left|none|right)$/;
class o6 extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TablePropertiesEditing";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ks];
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model.schema, n = e.conversion;
    e.config.define("table.tableProperties.defaultProperties", {});
    const s = Ts(e.config.get("table.tableProperties.defaultProperties"), {
      includeAlignmentProperty: !0
    });
    e.data.addStyleProcessorRules(lg), r6(t, n, {
      color: s.borderColor,
      style: s.borderStyle,
      width: s.borderWidth
    }), e.commands.add("tableBorderColor", new XV(e, s.borderColor)), e.commands.add("tableBorderStyle", new QV(e, s.borderStyle)), e.commands.add("tableBorderWidth", new YV(e, s.borderWidth)), a6(t, n, s.alignment), e.commands.add("tableAlignment", new n6(e, s.alignment)), Mh(t, n, {
      modelAttribute: "tableWidth",
      styleName: "width",
      defaultValue: s.width
    }), e.commands.add("tableWidth", new e6(e, s.width)), Mh(t, n, {
      modelAttribute: "tableHeight",
      styleName: "height",
      defaultValue: s.height
    }), e.commands.add("tableHeight", new t6(e, s.height)), e.data.addStyleProcessorRules(kl), l6(t, n, {
      modelAttribute: "tableBackgroundColor",
      styleName: "background-color",
      defaultValue: s.backgroundColor
    }), e.commands.add("tableBackgroundColor", new JV(e, s.backgroundColor));
  }
}
function r6(i, e, t) {
  const n = {
    width: "tableBorderWidth",
    color: "tableBorderColor",
    style: "tableBorderStyle"
  };
  i.extend("table", {
    allowAttributes: Object.values(n)
  }), xa(e, "table", n, t), lo(e, { modelAttribute: n.color, styleName: "border-color" }), lo(e, { modelAttribute: n.style, styleName: "border-style" }), lo(e, { modelAttribute: n.width, styleName: "border-width" });
}
function a6(i, e, t) {
  i.extend("table", {
    allowAttributes: ["tableAlignment"]
  }), e.for("downcast").attributeToAttribute({
    model: {
      name: "table",
      key: "tableAlignment"
    },
    view: (n) => ({
      key: "style",
      value: {
        // Model: `alignment:center` => CSS: `float:none`.
        float: n === "center" ? "none" : n
      }
    }),
    converterPriority: "high"
  }), e.for("upcast").attributeToAttribute({
    view: {
      name: /^(table|figure)$/,
      styles: {
        float: s6
      }
    },
    model: {
      key: "tableAlignment",
      value: (n) => {
        let s = n.getStyle("float");
        return s === "none" && (s = "center"), s === t ? null : s;
      }
    }
  }).attributeToAttribute({
    view: {
      attributes: {
        align: i6
      }
    },
    model: {
      name: "table",
      key: "tableAlignment",
      value: (n) => {
        const s = n.getAttribute("align");
        return s === t ? null : s;
      }
    }
  });
}
function l6(i, e, t) {
  const { modelAttribute: n } = t;
  i.extend("table", {
    allowAttributes: [n]
  }), Wl(e, { viewElement: "table", ...t }), lo(e, t);
}
function Mh(i, e, t) {
  const { modelAttribute: n } = t;
  i.extend("table", {
    allowAttributes: [n]
  }), Wl(e, {
    viewElement: /^(table|figure)$/,
    shouldUpcast: (s) => !(s.name == "table" && s.parent.name == "figure"),
    ...t
  }), $i(e, { modelElement: "table", ...t });
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const c6 = {
  left: A.objectLeft,
  center: A.objectCenter,
  right: A.objectRight
};
class u6 extends T {
  /**
   * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
   * @param options Additional configuration of the view.
   */
  constructor(e, t) {
    super(e), this.set({
      borderStyle: "",
      borderWidth: "",
      borderColor: "",
      backgroundColor: "",
      width: "",
      height: "",
      alignment: ""
    }), this.options = t;
    const { borderStyleDropdown: n, borderWidthInput: s, borderColorInput: o, borderRowLabel: r } = this._createBorderFields(), { backgroundRowLabel: a, backgroundInput: l } = this._createBackgroundFields(), { widthInput: c, operatorLabel: u, heightInput: d, dimensionsLabel: h } = this._createDimensionFields(), { alignmentToolbar: f, alignmentLabel: m } = this._createAlignmentFields();
    this.focusTracker = new X(), this.keystrokes = new ie(), this.children = this.createCollection(), this.borderStyleDropdown = n, this.borderWidthInput = s, this.borderColorInput = o, this.backgroundInput = l, this.widthInput = c, this.heightInput = d, this.alignmentToolbar = f;
    const { saveButtonView: p, cancelButtonView: w } = this._createActionButtons();
    this.saveButtonView = p, this.cancelButtonView = w, this._focusables = new ve(), this._focusCycler = new ge({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    }), this.children.add(new rr(e, {
      label: this.t("Table properties")
    })), this.children.add(new Oe(e, {
      labelView: r,
      children: [
        r,
        n,
        o,
        s
      ],
      class: "ck-table-form__border-row"
    })), this.children.add(new Oe(e, {
      labelView: a,
      children: [
        a,
        l
      ],
      class: "ck-table-form__background-row"
    })), this.children.add(new Oe(e, {
      children: [
        // Dimensions row.
        new Oe(e, {
          labelView: h,
          children: [
            h,
            c,
            u,
            d
          ],
          class: "ck-table-form__dimensions-row"
        }),
        // Alignment row.
        new Oe(e, {
          labelView: m,
          children: [
            m,
            f
          ],
          class: "ck-table-properties-form__alignment-row"
        })
      ]
    })), this.children.add(new Oe(e, {
      children: [
        this.saveButtonView,
        this.cancelButtonView
      ],
      class: "ck-table-form__action-row"
    })), this.setTemplate({
      tag: "form",
      attributes: {
        class: [
          "ck",
          "ck-form",
          "ck-table-form",
          "ck-table-properties-form"
        ],
        // https://github.com/ckeditor/ckeditor5-link/issues/90
        tabindex: "-1"
      },
      children: this.children
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), Cn({
      view: this
    }), [this.borderColorInput, this.backgroundInput].forEach((e) => {
      e.fieldView.focusCycler.on("forwardCycle", (t) => {
        this._focusCycler.focusNext(), t.stop();
      }), e.fieldView.focusCycler.on("backwardCycle", (t) => {
        this._focusCycler.focusPrevious(), t.stop();
      });
    }), [
      this.borderStyleDropdown,
      this.borderColorInput,
      this.borderWidthInput,
      this.backgroundInput,
      this.widthInput,
      this.heightInput,
      this.alignmentToolbar,
      this.saveButtonView,
      this.cancelButtonView
    ].forEach((e) => {
      this._focusables.add(e), this.focusTracker.add(e.element);
    }), this.keystrokes.listenTo(this.element);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  /**
   * Focuses the fist focusable field in the form.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
   * Creates the following form fields:
   *
   * * {@link #borderStyleDropdown},
   * * {@link #borderWidthInput},
   * * {@link #borderColorInput}.
   */
  _createBorderFields() {
    const e = this.options.defaultTableProperties, t = {
      style: e.borderStyle,
      width: e.borderWidth,
      color: e.borderColor
    }, n = Bo({
      colorConfig: this.options.borderColors,
      columns: 5,
      defaultColorValue: t.color,
      colorPickerConfig: this.options.colorPickerConfig
    }), s = this.locale, o = this.t, r = o("Style"), a = new ze(s);
    a.text = o("Border");
    const l = Kl(o), c = new ue(s, Dg);
    c.set({
      label: r,
      class: "ck-table-form__border-style"
    }), c.fieldView.buttonView.set({
      ariaLabel: r,
      ariaLabelledBy: void 0,
      isOn: !1,
      withText: !0,
      tooltip: r
    }), c.fieldView.buttonView.bind("label").to(this, "borderStyle", (h) => l[h || "none"]), c.fieldView.on("execute", (h) => {
      this.borderStyle = h.source._borderStyleValue;
    }), c.bind("isEmpty").to(this, "borderStyle", (h) => !h), Kt(c.fieldView, Qp(this, t.style), {
      role: "menu",
      ariaLabel: r
    });
    const u = new ue(s, He);
    u.set({
      label: o("Width"),
      class: "ck-table-form__border-width"
    }), u.fieldView.bind("value").to(this, "borderWidth"), u.bind("isEnabled").to(this, "borderStyle", to), u.fieldView.on("input", () => {
      this.borderWidth = u.fieldView.element.value;
    });
    const d = new ue(s, n);
    return d.set({
      label: o("Color"),
      class: "ck-table-form__border-color"
    }), d.fieldView.bind("value").to(this, "borderColor"), d.bind("isEnabled").to(this, "borderStyle", to), d.fieldView.on("input", () => {
      this.borderColor = d.fieldView.value;
    }), this.on("change:borderStyle", (h, f, m, p) => {
      to(m) || (this.borderColor = "", this.borderWidth = ""), to(p) || (this.borderColor = t.color, this.borderWidth = t.width);
    }), {
      borderRowLabel: a,
      borderStyleDropdown: c,
      borderColorInput: d,
      borderWidthInput: u
    };
  }
  /**
   * Creates the following form fields:
   *
   * * {@link #backgroundInput}.
   */
  _createBackgroundFields() {
    const e = this.locale, t = this.t, n = new ze(e);
    n.text = t("Background");
    const s = Bo({
      colorConfig: this.options.backgroundColors,
      columns: 5,
      defaultColorValue: this.options.defaultTableProperties.backgroundColor,
      colorPickerConfig: this.options.colorPickerConfig
    }), o = new ue(e, s);
    return o.set({
      label: t("Color"),
      class: "ck-table-properties-form__background"
    }), o.fieldView.bind("value").to(this, "backgroundColor"), o.fieldView.on("input", () => {
      this.backgroundColor = o.fieldView.value;
    }), {
      backgroundRowLabel: n,
      backgroundInput: o
    };
  }
  /**
   * Creates the following form fields:
   *
   * * {@link #widthInput},
   * * {@link #heightInput}.
   */
  _createDimensionFields() {
    const e = this.locale, t = this.t, n = new ze(e);
    n.text = t("Dimensions");
    const s = new ue(e, He);
    s.set({
      label: t("Width"),
      class: "ck-table-form__dimensions-row__width"
    }), s.fieldView.bind("value").to(this, "width"), s.fieldView.on("input", () => {
      this.width = s.fieldView.element.value;
    });
    const o = new T(e);
    o.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck-table-form__dimension-operator"
        ]
      },
      children: [
        { text: "×" }
      ]
    });
    const r = new ue(e, He);
    return r.set({
      label: t("Height"),
      class: "ck-table-form__dimensions-row__height"
    }), r.fieldView.bind("value").to(this, "height"), r.fieldView.on("input", () => {
      this.height = r.fieldView.element.value;
    }), {
      dimensionsLabel: n,
      widthInput: s,
      operatorLabel: o,
      heightInput: r
    };
  }
  /**
   * Creates the following form fields:
   *
   * * {@link #alignmentToolbar}.
   */
  _createAlignmentFields() {
    const e = this.locale, t = this.t, n = new ze(e);
    n.text = t("Alignment");
    const s = new ni(e);
    return s.set({
      isCompact: !0,
      ariaLabel: t("Table alignment toolbar")
    }), Oa({
      view: this,
      icons: c6,
      toolbar: s,
      labels: this._alignmentLabels,
      propertyName: "alignment",
      defaultValue: this.options.defaultTableProperties.alignment
    }), {
      alignmentLabel: n,
      alignmentToolbar: s
    };
  }
  /**
   * Creates the following form controls:
   *
   * * {@link #saveButtonView},
   * * {@link #cancelButtonView}.
   */
  _createActionButtons() {
    const e = this.locale, t = this.t, n = new P(e), s = new P(e), o = [
      this.borderWidthInput,
      this.borderColorInput,
      this.backgroundInput,
      this.widthInput,
      this.heightInput
    ];
    return n.set({
      label: t("Save"),
      icon: A.check,
      class: "ck-button-save",
      type: "submit",
      withText: !0
    }), n.bind("isEnabled").toMany(o, "errorText", (...r) => r.every((a) => !a)), s.set({
      label: t("Cancel"),
      icon: A.cancel,
      class: "ck-button-cancel",
      withText: !0
    }), s.delegate("execute").to(this, "cancel"), {
      saveButtonView: n,
      cancelButtonView: s
    };
  }
  /**
   * Provides localized labels for {@link #alignmentToolbar} buttons.
   */
  get _alignmentLabels() {
    const e = this.locale, t = this.t, n = t("Align table to the left"), s = t("Center table"), o = t("Align table to the right");
    return e.uiLanguageDirection === "rtl" ? { right: o, center: s, left: n } : { left: n, center: s, right: o };
  }
}
function to(i) {
  return i !== "none";
}
const d6 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8 2v5h4V2h1v5h5v1h-5v4h.021l-.172.351-1.916.28-.151.027c-.287.063-.54.182-.755.341L8 13v5H7v-5H2v-1h5V8H2V7h5V2h1zm4 6H8v4h4V8z" opacity=".6"/><path d="m15.5 11.5 1.323 2.68 2.957.43-2.14 2.085.505 2.946L15.5 18.25l-2.645 1.39.505-2.945-2.14-2.086 2.957-.43L15.5 11.5zM17 1a2 2 0 0 1 2 2v9.475l-.85-.124-.857-1.736a2.048 2.048 0 0 0-.292-.44L17 3H3v14h7.808l.402.392L10.935 19H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14z"/></svg>';
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const h6 = 500, Bh = {
  borderStyle: "tableBorderStyle",
  borderColor: "tableBorderColor",
  borderWidth: "tableBorderWidth",
  backgroundColor: "tableBackgroundColor",
  width: "tableWidth",
  height: "tableHeight",
  alignment: "tableAlignment"
};
class f6 extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Rt];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TablePropertiesUI";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.view = null, e.config.define("table.tableProperties", {
      borderColors: Mo,
      backgroundColors: Mo
    });
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.t;
    this._defaultTableProperties = Ts(e.config.get("table.tableProperties.defaultProperties"), {
      includeAlignmentProperty: !0
    }), this._balloon = e.plugins.get(Rt), e.ui.componentFactory.add("tableProperties", (n) => {
      const s = new P(n);
      s.set({
        label: t("Table properties"),
        icon: d6,
        tooltip: !0
      }), this.listenTo(s, "execute", () => this._showView());
      const o = Object.values(Bh).map((r) => e.commands.get(r));
      return s.bind("isEnabled").toMany(o, "isEnabled", (...r) => r.some((a) => a)), s;
    });
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.view && this.view.destroy();
  }
  /**
   * Creates the {@link module:table/tableproperties/ui/tablepropertiesview~TablePropertiesView} instance.
   *
   * @returns The table properties form view instance.
   */
  _createPropertiesView() {
    const e = this.editor, t = e.config.get("table.tableProperties"), n = os(t.borderColors), s = ss(e.locale, n), o = os(t.backgroundColors), r = ss(e.locale, o), a = t.colorPicker !== !1, l = new u6(e.locale, {
      borderColors: s,
      backgroundColors: r,
      defaultTableProperties: this._defaultTableProperties,
      colorPickerConfig: a ? t.colorPicker || {} : !1
    }), c = e.t;
    l.render(), this.listenTo(l, "submit", () => {
      this._hideView();
    }), this.listenTo(l, "cancel", () => {
      this._undoStepBatch.operations.length && e.execute("undo", this._undoStepBatch), this._hideView();
    }), l.keystrokes.set("Esc", (h, f) => {
      this._hideView(), f();
    }), yn({
      emitter: l,
      activator: () => this._isViewInBalloon,
      contextElements: [this._balloon.view.element],
      callback: () => this._hideView()
    });
    const u = Zp(c), d = Jp(c);
    return l.on("change:borderStyle", this._getPropertyChangeCallback("tableBorderStyle")), l.on("change:borderColor", this._getValidatedPropertyChangeCallback({
      viewField: l.borderColorInput,
      commandName: "tableBorderColor",
      errorText: u,
      validator: Vo
    })), l.on("change:borderWidth", this._getValidatedPropertyChangeCallback({
      viewField: l.borderWidthInput,
      commandName: "tableBorderWidth",
      errorText: d,
      validator: Xp
    })), l.on("change:backgroundColor", this._getValidatedPropertyChangeCallback({
      viewField: l.backgroundInput,
      commandName: "tableBackgroundColor",
      errorText: u,
      validator: Vo
    })), l.on("change:width", this._getValidatedPropertyChangeCallback({
      viewField: l.widthInput,
      commandName: "tableWidth",
      errorText: d,
      validator: Wi
    })), l.on("change:height", this._getValidatedPropertyChangeCallback({
      viewField: l.heightInput,
      commandName: "tableHeight",
      errorText: d,
      validator: Wi
    })), l.on("change:alignment", this._getPropertyChangeCallback("tableAlignment")), l;
  }
  /**
   * In this method the "editor data -> UI" binding is happening.
   *
   * When executed, this method obtains selected table property values from various table commands
   * and passes them to the {@link #view}.
   *
   * This way, the UI stays up–to–date with the editor data.
   */
  _fillViewFormFromCommandValues() {
    const e = this.editor.commands, t = e.get("tableBorderStyle");
    Object.entries(Bh).map(([n, s]) => {
      const o = n, r = this._defaultTableProperties[o] || "";
      return [o, e.get(s).value || r];
    }).forEach(([n, s]) => {
      (n === "borderColor" || n === "borderWidth") && t.value === "none" || this.view.set(n, s);
    }), this._isReady = !0;
  }
  /**
   * Shows the {@link #view} in the {@link #_balloon}.
   *
   * **Note**: Each time a view is shown, the new {@link #_undoStepBatch} is created that contains
   * all changes made to the document when the view is visible, allowing a single undo step
   * for all of them.
   */
  _showView() {
    const e = this.editor;
    this.view || (this.view = this._createPropertiesView()), this.listenTo(e.ui, "update", () => {
      this._updateView();
    }), this._fillViewFormFromCommandValues(), this._balloon.add({
      view: this.view,
      position: tb(e)
    }), this._undoStepBatch = e.model.createBatch(), this.view.focus();
  }
  /**
   * Removes the {@link #view} from the {@link #_balloon}.
   */
  _hideView() {
    const e = this.editor;
    this.stopListening(e.ui, "update"), this._isReady = !1, this.view.saveButtonView.focus(), this._balloon.remove(this.view), this.editor.editing.view.focus();
  }
  /**
   * Repositions the {@link #_balloon} or hides the {@link #view} if a table is no longer selected.
   */
  _updateView() {
    const e = this.editor, t = e.editing.view.document;
    Gp(t.selection) ? this._isViewVisible && eb(e, "table") : this._hideView();
  }
  /**
   * Returns `true` when the {@link #view} is the visible in the {@link #_balloon}.
   */
  get _isViewVisible() {
    return !!this.view && this._balloon.visibleView === this.view;
  }
  /**
   * Returns `true` when the {@link #view} is in the {@link #_balloon}.
   */
  get _isViewInBalloon() {
    return !!this.view && this._balloon.hasView(this.view);
  }
  /**
   * Creates a callback that when executed upon {@link #view view's} property change
   * executes a related editor command with the new property value.
   *
   * If new value will be set to the default value, the command will not be executed.
   *
   * @param commandName The command that will be executed.
   */
  _getPropertyChangeCallback(e) {
    return (t, n, s) => {
      this._isReady && this.editor.execute(e, {
        value: s,
        batch: this._undoStepBatch
      });
    };
  }
  /**
   * Creates a callback that when executed upon {@link #view view's} property change:
   * * executes a related editor command with the new property value if the value is valid,
   * * or sets the error text next to the invalid field, if the value did not pass the validation.
   */
  _getValidatedPropertyChangeCallback(e) {
    const { commandName: t, viewField: n, validator: s, errorText: o } = e, r = Pt(() => {
      n.errorText = o;
    }, h6);
    return (a, l, c) => {
      r.cancel(), this._isReady && (s(c) ? (this.editor.execute(t, {
        value: c,
        batch: this._undoStepBatch
      }), n.errorText = null) : r());
    };
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class m6 extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableProperties";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [o6, f6];
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function g6(i) {
  i.document.registerPostFixer((e) => p6(e, i));
}
function p6(i, e) {
  const t = e.document.differ.getChanges();
  let n = !1;
  for (const s of t) {
    if (s.type != "insert")
      continue;
    const o = s.position.parent;
    if (o.is("element", "table") || s.name == "table") {
      const r = s.name == "table" ? s.position.nodeAfter : o, a = Array.from(r.getChildren()).filter((c) => c.is("element", "caption")), l = a.shift();
      if (!l)
        continue;
      for (const c of a)
        i.move(i.createRangeIn(c), l, "end"), i.remove(c);
      l.nextSibling && (i.move(i.createRangeOn(l), r, "end"), n = !0), n = !!a.length || n;
    }
  }
  return n;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Lh(i) {
  return !!i && i.is("element", "table");
}
function Na(i) {
  for (const e of i.getChildren())
    if (e.is("element", "caption"))
      return e;
  return null;
}
function b6(i) {
  const e = ln(i);
  return e ? Na(e) : null;
}
function w6(i) {
  const e = i.parent;
  return i.name == "figcaption" && e && e.is("element", "figure") && e.hasClass("table") ? { name: !0 } : i.name == "caption" && e && e.is("element", "table") ? { name: !0 } : null;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class _6 extends V {
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor, t = ln(e.model.document.selection);
    this.isEnabled = !!t, this.isEnabled ? this.value = !!Na(t) : this.value = !1;
  }
  /**
   * Executes the command.
   *
   * ```ts
   * editor.execute( 'toggleTableCaption' );
   * ```
   *
   * @param options Options for the executed command.
   * @param options.focusCaptionOnShow When true and the caption shows up, the selection will be moved into it straight away.
   * @fires execute
   */
  execute({ focusCaptionOnShow: e = !1 } = {}) {
    this.editor.model.change((t) => {
      this.value ? this._hideTableCaption(t) : this._showTableCaption(t, e);
    });
  }
  /**
   * Shows the table caption. Also:
   *
   * * it attempts to restore the caption content from the `TableCaptionEditing` caption registry,
   * * it moves the selection to the caption right away, it the `focusCaptionOnShow` option was set.
   *
   * @param focusCaptionOnShow Default focus behavior when showing the caption.
   */
  _showTableCaption(e, t) {
    const n = this.editor.model, s = ln(n.document.selection), a = this.editor.plugins.get("TableCaptionEditing")._getSavedCaption(s) || e.createElement("caption");
    n.insertContent(a, s, "end"), t && e.setSelection(a, "in");
  }
  /**
   * Hides the caption of a selected table (or an table caption the selection is anchored to).
   *
   * The content of the caption is stored in the `TableCaptionEditing` caption registry to make this
   * a reversible action.
   */
  _hideTableCaption(e) {
    const t = this.editor.model, n = ln(t.document.selection), s = this.editor.plugins.get("TableCaptionEditing"), o = Na(n);
    s._saveCaption(n, o), t.deleteContent(e.createSelection(o, "on"));
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class v6 extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableCaptionEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this._savedCaptionsMap = /* @__PURE__ */ new WeakMap();
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model.schema, n = e.editing.view, s = e.t;
    t.isRegistered("caption") ? t.extend("caption", {
      allowIn: "table"
    }) : t.register("caption", {
      allowIn: "table",
      allowContentOf: "$block",
      isLimit: !0
    }), e.commands.add("toggleTableCaption", new _6(this.editor)), e.conversion.for("upcast").elementToElement({
      view: w6,
      model: "caption"
    }), e.conversion.for("dataDowncast").elementToElement({
      model: "caption",
      view: (o, { writer: r }) => Lh(o.parent) ? r.createContainerElement("figcaption") : null
    }), e.conversion.for("editingDowncast").elementToElement({
      model: "caption",
      view: (o, { writer: r }) => {
        if (!Lh(o.parent))
          return null;
        const a = r.createEditableElement("figcaption");
        return r.setCustomProperty("tableCaption", !0, a), a.placeholder = s("Enter table caption"), hl({
          view: n,
          element: a,
          keepOnFocus: !0
        }), Ml(a, r);
      }
    }), g6(e.model);
  }
  /**
   * Returns the saved {@link module:engine/model/element~Element#toJSON JSONified} caption
   * of a table model element.
   *
   * See {@link #_saveCaption}.
   *
   * @internal
   * @param tableModelElement The model element the caption should be returned for.
   * @returns The model caption element or `null` if there is none.
   */
  _getSavedCaption(e) {
    const t = this._savedCaptionsMap.get(e);
    return t ? $.fromJSON(t) : null;
  }
  /**
   * Saves a {@link module:engine/model/element~Element#toJSON JSONified} caption for
   * a table element to allow restoring it in the future.
   *
   * A caption is saved every time it gets hidden. The
   * user should be able to restore it on demand.
   *
   * **Note**: The caption cannot be stored in the table model element attribute because,
   * for instance, when the model state propagates to collaborators, the attribute would get
   * lost (mainly because it does not convert to anything when the caption is hidden) and
   * the states of collaborators' models would de-synchronize causing numerous issues.
   *
   * See {@link #_getSavedCaption}.
   *
   * @internal
   * @param tableModelElement The model element the caption is saved for.
   * @param caption The caption model element to be saved.
   */
  _saveCaption(e, t) {
    this._savedCaptionsMap.set(e, t.toJSON());
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class y6 extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableCaptionUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.editing.view, n = e.t;
    e.ui.componentFactory.add("toggleTableCaption", (s) => {
      const o = e.commands.get("toggleTableCaption"), r = new P(s);
      return r.set({
        icon: A.caption,
        tooltip: !0,
        isToggleable: !0
      }), r.bind("isOn", "isEnabled").to(o, "value", "isEnabled"), r.bind("label").to(o, "value", (a) => n(a ? "Toggle caption off" : "Toggle caption on")), this.listenTo(r, "execute", () => {
        if (e.execute("toggleTableCaption", { focusCaptionOnShow: !0 }), o.value) {
          const a = b6(e.model.document.selection), l = e.editing.mapper.toViewElement(a);
          if (!l)
            return;
          t.scrollToTheSelection(), t.change((c) => {
            c.addClass("table__caption_highlighted", l);
          });
        }
        e.editing.view.focus();
      }), r;
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class C6 extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableCaption";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [v6, y6];
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class k6 extends V {
  /**
   * @inheritDoc
   */
  refresh() {
    this.isEnabled = !0;
  }
  /**
   * Updated the `tableWidth` attribute of the table and the `columnWidth` attribute of the columns of that table.
   */
  execute(e = {}) {
    const { model: t, plugins: n } = this.editor;
    let { table: s = t.document.selection.getSelectedElement(), columnWidths: o, tableWidth: r } = e;
    o && (o = Array.isArray(o) ? o : o.split(",")), t.change((a) => {
      r ? a.setAttribute("tableWidth", r, s) : a.removeAttribute("tableWidth", s);
      const l = n.get("TableColumnResizeEditing").getColumnGroupElement(s);
      if (!o && !l)
        return;
      if (!o)
        return a.remove(l);
      const c = Gl(o);
      if (l)
        Array.from(l.getChildren()).forEach((u, d) => a.setAttribute("columnWidth", c[d], u));
      else {
        const u = a.createElement("tableColumnGroup");
        c.forEach((d) => a.appendElement("tableColumn", { columnWidth: d }, u)), a.append(u, s);
      }
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function T6(i) {
  return (e) => e.on("element:colgroup", (t, n, s) => {
    const o = n.modelCursor.findAncestor("table"), r = ys(o);
    if (!r)
      return;
    const a = Cs(r), l = i.getColumns(o);
    let c = $4(r, s.writer);
    c = Array.from({ length: l }, (u, d) => c[d] || "auto"), (c.length != a.length || c.includes("auto")) && Up(a, r, Gl(c), s.writer);
  }, { priority: "low" });
}
function E6() {
  return (i) => i.on("insert:table", (e, t, n) => {
    const s = n.writer, o = t.item, r = n.mapper.toViewElement(o), a = r.is("element", "table") ? r : Array.from(r.getChildren()).find((c) => c.is("element", "table"));
    ys(o) ? s.addClass("ck-table-resized", a) : s.removeClass("ck-table-resized", a);
  }, { priority: "low" });
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class A6 extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ks, be];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableColumnResizeEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this._isResizingActive = !1, this.set("_isResizingAllowed", !0), this._resizingData = null, this._domEmitter = new (Le())(), this._tableUtilsPlugin = e.plugins.get("TableUtils"), this.on("change:_isResizingAllowed", (t, n, s) => {
      const o = s ? "removeClass" : "addClass";
      e.editing.view.change((r) => {
        for (const a of e.editing.view.document.roots)
          r[o]("ck-column-resize_disabled", e.editing.view.document.getRoot(a.rootName));
      });
    });
  }
  /**
   * @inheritDoc
   */
  init() {
    this._extendSchema(), this._registerPostFixer(), this._registerConverters(), this._registerResizingListeners(), this._registerResizerInserter();
    const e = this.editor, t = e.plugins.get("TableColumnResize");
    e.plugins.get("TableEditing").registerAdditionalSlot({
      filter: (o) => o.is("element", "tableColumnGroup"),
      positionOffset: 0
    });
    const s = new k6(e);
    e.commands.add("resizeTableWidth", s), e.commands.add("resizeColumnWidths", s), this.bind("_isResizingAllowed").to(e, "isReadOnly", t, "isEnabled", s, "isEnabled", (o, r, a) => !o && r && a);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    this._domEmitter.stopListening(), super.destroy();
  }
  /**
   * Returns a 'tableColumnGroup' element from the 'table'.
   *
   * @param element A 'table' or 'tableColumnGroup' element.
   * @returns A 'tableColumnGroup' element.
   */
  getColumnGroupElement(e) {
    return ys(e);
  }
  /**
   * Returns an array of 'tableColumn' elements.
   *
   * @param element A 'table' or 'tableColumnGroup' element.
   * @returns An array of 'tableColumn' elements.
   */
  getTableColumnElements(e) {
    return Cs(e);
  }
  /**
   * Returns an array of table column widths.
   *
   * @param element A 'table' or 'tableColumnGroup' element.
   * @returns An array of table column widths.
   */
  getTableColumnsWidths(e) {
    return U4(e);
  }
  /**
   * Registers new attributes for a table model element.
   */
  _extendSchema() {
    this.editor.model.schema.extend("table", {
      allowAttributes: ["tableWidth"]
    }), this.editor.model.schema.register("tableColumnGroup", {
      allowIn: "table",
      isLimit: !0
    }), this.editor.model.schema.register("tableColumn", {
      allowIn: "tableColumnGroup",
      allowAttributes: ["columnWidth", "colSpan"],
      isLimit: !0
    });
  }
  /**
   * Registers table column resize post-fixer.
   *
   * It checks if the change from the differ concerns a table-related element or attribute. For detected changes it:
   *  * Adjusts the `columnWidths` attribute to guarantee that the sum of the widths from all columns is 100%.
   *  * Checks if the `columnWidths` attribute gets updated accordingly after columns have been added or removed.
   */
  _registerPostFixer() {
    const t = this.editor.model;
    t.document.registerPostFixer((o) => {
      let r = !1;
      for (const a of L4(t)) {
        const l = this.getColumnGroupElement(a), c = this.getTableColumnElements(l), u = this.getTableColumnsWidths(l);
        let d = Gl(u);
        d = n(d, a, this), !wo(u, d) && (Up(c, l, d, o), r = !0);
      }
      return r;
    });
    function n(o, r, a) {
      const l = a._tableUtilsPlugin.getColumns(r);
      if (l - o.length === 0)
        return o;
      const u = o.map((h) => Number(h.replace("%", ""))), d = s(a.editor.model.document.differ, r);
      for (const h of d) {
        const f = l - u.length;
        if (f === 0)
          continue;
        const m = f > 0, p = a._tableUtilsPlugin.getCellLocation(h).column;
        if (m) {
          const w = O4(r, a.editor), v = D4(f, w);
          u.splice(p, 0, ...v);
        } else {
          const w = u.splice(p, Math.abs(f));
          u[p] += ds(w);
        }
      }
      return u.map((h) => h + "%");
    }
    function s(o, r) {
      const a = /* @__PURE__ */ new Set();
      for (const l of o.getChanges())
        if (l.type == "insert" && l.position.nodeAfter && l.position.nodeAfter.name == "tableCell" && l.position.nodeAfter.getAncestors().includes(r))
          a.add(l.position.nodeAfter);
        else if (l.type == "remove") {
          const c = l.position.nodeBefore || l.position.nodeAfter;
          c.name == "tableCell" && c.getAncestors().includes(r) && a.add(c);
        }
      return a;
    }
  }
  /**
   * Registers table column resize converters.
   */
  _registerConverters() {
    const t = this.editor.conversion;
    t.for("upcast").attributeToAttribute({
      view: {
        name: "figure",
        key: "style",
        value: {
          width: /[\s\S]+/
        }
      },
      model: {
        name: "table",
        key: "tableWidth",
        value: (n) => n.getStyle("width")
      }
    }), t.for("downcast").attributeToAttribute({
      model: {
        name: "table",
        key: "tableWidth"
      },
      view: (n) => ({
        name: "figure",
        key: "style",
        value: {
          width: n
        }
      })
    }), t.elementToElement({ model: "tableColumnGroup", view: "colgroup" }), t.elementToElement({ model: "tableColumn", view: "col" }), t.for("downcast").add(E6()), t.for("upcast").add(T6(this._tableUtilsPlugin)), t.for("upcast").attributeToAttribute({
      view: {
        name: "col",
        styles: {
          width: /.*/
        }
      },
      model: {
        key: "columnWidth",
        value: (n) => {
          const s = n.getStyle("width");
          return !s || !s.endsWith("%") && !s.endsWith("pt") ? "auto" : s;
        }
      }
    }), t.for("upcast").attributeToAttribute({
      view: {
        name: "col",
        key: "span"
      },
      model: "colSpan"
    }), t.for("downcast").attributeToAttribute({
      model: {
        name: "tableColumn",
        key: "columnWidth"
      },
      view: (n) => ({ key: "style", value: { width: n } })
    });
  }
  /**
   * Registers listeners to handle resizing process.
   */
  _registerResizingListeners() {
    const e = this.editor.editing.view;
    e.addObserver(qp), e.document.on("mousedown", this._onMouseDownHandler.bind(this), { priority: "high" }), this._domEmitter.listenTo(E.window.document, "mousemove", Xn(this._onMouseMoveHandler.bind(this), 50)), this._domEmitter.listenTo(E.window.document, "mouseup", this._onMouseUpHandler.bind(this));
  }
  /**
   * Handles the `mousedown` event on column resizer element:
   *  * calculates the initial column pixel widths,
   *  * inserts the `<colgroup>` element if it is not present in the `<table>`,
   *  * puts the necessary data in the temporary storage,
   *  * applies the attributes to the `<table>` view element.
   *
   * @param eventInfo An object containing information about the fired event.
   * @param domEventData The data related to the DOM event.
   */
  _onMouseDownHandler(e, t) {
    const n = t.target;
    if (!n.hasClass("ck-table-column-resizer") || !this._isResizingAllowed)
      return;
    const s = this.editor, o = s.editing.mapper.toModelElement(n.findAncestor("figure"));
    if (!s.model.canEditAt(o))
      return;
    t.preventDefault(), e.stop();
    const r = c(o, this._tableUtilsPlugin, s), a = n.findAncestor("table"), l = s.editing.view;
    Array.from(a.getChildren()).find((h) => h.is("element", "colgroup")) || l.change((h) => {
      u(h, r, a);
    }), this._isResizingActive = !0, this._resizingData = this._getResizingData(t, r), l.change((h) => d(h, a, this._resizingData));
    function c(h, f, m) {
      const p = Array(f.getColumns(h)), w = new W(h);
      for (const v of w) {
        const C = m.editing.mapper.toViewElement(v.cell), L = m.editing.view.domConverter.mapViewToDom(C), F = H4(L);
        (!p[v.column] || F < p[v.column]) && (p[v.column] = Se(F));
      }
      return p;
    }
    function u(h, f, m) {
      const p = h.createContainerElement("colgroup");
      for (let w = 0; w < f.length; w++) {
        const v = h.createEmptyElement("col"), C = `${Se(f[w] / ds(f) * 100)}%`;
        h.setStyle("width", C, v), h.insert(h.createPositionAt(p, "end"), v);
      }
      h.insert(h.createPositionAt(m, 0), p);
    }
    function d(h, f, m) {
      const p = m.widths.viewFigureWidth / m.widths.viewFigureParentWidth;
      h.addClass("ck-table-resized", f), h.addClass("ck-table-column-resizer__active", m.elements.viewResizer), h.setStyle("width", `${Se(p * 100)}%`, f.findAncestor("figure"));
    }
  }
  /**
   * Handles the `mousemove` event.
   *  * If resizing process is not in progress, it does nothing.
   *  * If resizing is active but not allowed, it stops the resizing process instantly calling the `mousedown` event handler.
   *  * Otherwise it dynamically updates the widths of the resized columns.
   *
   * @param eventInfo An object containing information about the fired event.
   * @param mouseEventData The native DOM event.
   */
  _onMouseMoveHandler(e, t) {
    if (!this._isResizingActive)
      return;
    if (!this._isResizingAllowed) {
      this._onMouseUpHandler();
      return;
    }
    const { columnPosition: n, flags: { isRightEdge: s, isTableCentered: o, isLtrContent: r }, elements: { viewFigure: a, viewLeftColumn: l, viewRightColumn: c }, widths: { viewFigureParentWidth: u, tableWidth: d, leftColumnWidth: h, rightColumnWidth: f } } = this._resizingData, m = -h + Ra, p = s ? u - d : f - Ra, w = (r ? 1 : -1) * (s && o ? 2 : 1), v = N4((t.clientX - n) * w, Math.min(m, 0), Math.max(p, 0));
    v !== 0 && this.editor.editing.view.change((C) => {
      const L = Se((h + v) * 100 / d);
      if (C.setStyle("width", `${L}%`, l), s) {
        const F = Se((d + v) * 100 / u);
        C.setStyle("width", `${F}%`, a);
      } else {
        const F = Se((f - v) * 100 / d);
        C.setStyle("width", `${F}%`, c);
      }
    });
  }
  /**
   * Handles the `mouseup` event.
   *  * If resizing process is not in progress, it does nothing.
   *  * If resizing is active but not allowed, it cancels the resizing process restoring the original widths.
   *  * Otherwise it propagates the changes from view to the model by executing the adequate commands.
   */
  _onMouseUpHandler() {
    if (!this._isResizingActive)
      return;
    const { viewResizer: e, modelTable: t, viewFigure: n, viewColgroup: s } = this._resizingData.elements, o = this.editor, r = o.editing.view, a = this.getColumnGroupElement(t), l = Array.from(s.getChildren()).filter((p) => p.is("view:element")), c = a ? this.getTableColumnsWidths(a) : null, u = l.map((p) => p.getStyle("width")), d = !wo(c, u), h = t.getAttribute("tableWidth"), f = n.getStyle("width"), m = h !== f;
    (d || m) && (this._isResizingAllowed ? o.execute("resizeTableWidth", {
      table: t,
      tableWidth: `${Se(f)}%`,
      columnWidths: u
    }) : r.change((p) => {
      if (c)
        for (const w of l)
          p.setStyle("width", c.shift(), w);
      else
        p.remove(s);
      m && (h ? p.setStyle("width", h, n) : p.removeStyle("width", n)), !c && !h && p.removeClass("ck-table-resized", [...n.getChildren()].find((w) => w.name === "table"));
    })), r.change((p) => {
      p.removeClass("ck-table-column-resizer__active", e);
    }), this._isResizingActive = !1, this._resizingData = null;
  }
  /**
   * Retrieves and returns required data needed for the resizing process.
   *
   * @param domEventData The data of the `mousedown` event.
   * @param columnWidths The current widths of the columns.
   * @returns The data needed for the resizing process.
   */
  _getResizingData(e, t) {
    const n = this.editor, s = e.domEvent.clientX, o = e.target, r = o.findAncestor("td") || o.findAncestor("th"), a = n.editing.mapper.toModelElement(r), l = a.findAncestor("table"), c = F4(a, this._tableUtilsPlugin).rightEdge, u = this._tableUtilsPlugin.getColumns(l) - 1, d = c === u, h = !l.hasAttribute("tableAlignment"), f = n.locale.contentLanguageDirection !== "rtl", m = r.findAncestor("table"), p = m.findAncestor("figure"), w = [...m.getChildren()].find((S) => S.is("element", "colgroup")), v = w.getChild(c), C = d ? void 0 : w.getChild(c + 1), L = Va(n.editing.view.domConverter.mapViewToDom(p.parent)), F = Va(n.editing.view.domConverter.mapViewToDom(p)), q = Hp(l, n), x = t[c], R = d ? void 0 : t[c + 1];
    return {
      columnPosition: s,
      flags: {
        isRightEdge: d,
        isTableCentered: h,
        isLtrContent: f
      },
      elements: {
        viewResizer: o,
        modelTable: l,
        viewFigure: p,
        viewColgroup: w,
        viewLeftColumn: v,
        viewRightColumn: C
      },
      widths: {
        viewFigureParentWidth: L,
        viewFigureWidth: F,
        tableWidth: q,
        leftColumnWidth: x,
        rightColumnWidth: R
      }
    };
  }
  /**
   * Registers a listener ensuring that each resizable cell have a resizer handle.
   */
  _registerResizerInserter() {
    this.editor.conversion.for("editingDowncast").add((e) => {
      e.on("insert:tableCell", (t, n, s) => {
        const o = n.item, r = s.mapper.toViewElement(o), a = s.writer;
        a.insert(a.createPositionAt(r, "end"), a.createUIElement("div", { class: "ck-table-column-resizer" }));
      }, { priority: "lowest" });
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class x6 extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [A6, sb];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableColumnResize";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const I6 = { autoRefresh: !0 }, Oh = 36e5;
class Zl extends U() {
  /**
   * Creates `Token` instance.
   * Method `init` should be called after using the constructor or use `create` method instead.
   *
   * @param tokenUrlOrRefreshToken Endpoint address to download the token or a callback that provides the token. If the
   * value is a function it has to match the {@link module:cloud-services/token/token~Token#refreshToken} interface.
   */
  constructor(e, t = {}) {
    if (super(), !e)
      throw new g("token-missing-token-url", this);
    t.initValue && this._validateTokenValue(t.initValue), this.set("value", t.initValue), typeof e == "function" ? this._refresh = e : this._refresh = () => S6(e), this._options = { ...I6, ...t };
  }
  /**
   * Initializes the token.
   */
  init() {
    return new Promise((e, t) => {
      if (!this.value) {
        this.refreshToken().then(e).catch(t);
        return;
      }
      this._options.autoRefresh && this._registerRefreshTokenTimeout(), e(this);
    });
  }
  /**
   * Refresh token method. Useful in a method form as it can be override in tests.
   */
  refreshToken() {
    return this._refresh().then((e) => (this._validateTokenValue(e), this.set("value", e), this._options.autoRefresh && this._registerRefreshTokenTimeout(), this));
  }
  /**
   * Destroys token instance. Stops refreshing.
   */
  destroy() {
    clearTimeout(this._tokenRefreshTimeout);
  }
  /**
   * Checks whether the provided token follows the JSON Web Tokens (JWT) format.
   *
   * @param tokenValue The token to validate.
   */
  _validateTokenValue(e) {
    const t = typeof e == "string", n = !/^".*"$/.test(e), s = t && e.split(".").length === 3;
    if (!(n && s))
      throw new g("token-not-in-jwt-format", this);
  }
  /**
   * Registers a refresh token timeout for the time taken from token.
   */
  _registerRefreshTokenTimeout() {
    const e = this._getTokenRefreshTimeoutTime();
    clearTimeout(this._tokenRefreshTimeout), this._tokenRefreshTimeout = setTimeout(() => {
      this.refreshToken();
    }, e);
  }
  /**
   * Returns token refresh timeout time calculated from expire time in the token payload.
   *
   * If the token parse fails or the token payload doesn't contain, the default DEFAULT_TOKEN_REFRESH_TIMEOUT_TIME is returned.
   */
  _getTokenRefreshTimeoutTime() {
    try {
      const [, e] = this.value.split("."), { exp: t } = JSON.parse(atob(e));
      return t ? Math.floor((t * 1e3 - Date.now()) / 2) : Oh;
    } catch (e) {
      return Oh;
    }
  }
  /**
   * Creates a initialized {@link module:cloud-services/token/token~Token} instance.
   *
   * @param tokenUrlOrRefreshToken Endpoint address to download the token or a callback that provides the token. If the
   * value is a function it has to match the {@link module:cloud-services/token/token~Token#refreshToken} interface.
   */
  static create(e, t = {}) {
    return new Zl(e, t).init();
  }
}
function S6(i) {
  return new Promise((e, t) => {
    const n = new XMLHttpRequest();
    n.open("GET", i), n.addEventListener("load", () => {
      const s = n.status, o = n.response;
      return s < 200 || s > 299 ? t(new g("token-cannot-download-new-token", null)) : e(o);
    }), n.addEventListener("error", () => t(new Error("Network Error"))), n.addEventListener("abort", () => t(new Error("Abort"))), n.send();
  });
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Da = /^data:(\S*?);base64,/;
class P6 extends G() {
  /**
   * Creates `FileUploader` instance.
   *
   * @param fileOrData A blob object or a data string encoded with Base64.
   * @param token Token used for authentication.
   * @param apiAddress API address.
   */
  constructor(e, t, n) {
    if (super(), !e)
      throw new g("fileuploader-missing-file", null);
    if (!t)
      throw new g("fileuploader-missing-token", null);
    if (!n)
      throw new g("fileuploader-missing-api-address", null);
    this.file = V6(e) ? R6(e) : e, this._token = t, this._apiAddress = n;
  }
  /**
   * Registers callback on `progress` event.
   */
  onProgress(e) {
    return this.on("progress", (t, n) => e(n)), this;
  }
  /**
   * Registers callback on `error` event. Event is called once when error occurs.
   */
  onError(e) {
    return this.once("error", (t, n) => e(n)), this;
  }
  /**
   * Aborts upload process.
   */
  abort() {
    this.xhr.abort();
  }
  /**
   * Sends XHR request to API.
   */
  send() {
    return this._prepareRequest(), this._attachXHRListeners(), this._sendRequest();
  }
  /**
   * Prepares XHR request.
   */
  _prepareRequest() {
    const e = new XMLHttpRequest();
    e.open("POST", this._apiAddress), e.setRequestHeader("Authorization", this._token.value), e.responseType = "json", this.xhr = e;
  }
  /**
   * Attaches listeners to the XHR.
   */
  _attachXHRListeners() {
    const e = this.xhr, t = (n) => () => this.fire("error", n);
    e.addEventListener("error", t("Network Error")), e.addEventListener("abort", t("Abort"));
    /* istanbul ignore else -- @preserve */
    e.upload && e.upload.addEventListener("progress", (n) => {
      n.lengthComputable && this.fire("progress", {
        total: n.total,
        uploaded: n.loaded
      });
    }), e.addEventListener("load", () => {
      const n = e.status, s = e.response;
      if (n < 200 || n > 299)
        return this.fire("error", s.message || s.error);
    });
  }
  /**
   * Sends XHR request.
   */
  _sendRequest() {
    const e = new FormData(), t = this.xhr;
    return e.append("file", this.file), new Promise((n, s) => {
      t.addEventListener("load", () => {
        const o = t.status, r = t.response;
        return o < 200 || o > 299 ? r.message ? s(new g("fileuploader-uploading-data-failed", this, { message: r.message })) : s(r.error) : n(r);
      }), t.addEventListener("error", () => s(new Error("Network Error"))), t.addEventListener("abort", () => s(new Error("Abort"))), t.send(e);
    });
  }
}
function R6(i, e = 512) {
  try {
    const t = i.match(Da)[1], n = atob(i.replace(Da, "")), s = [];
    for (let o = 0; o < n.length; o += e) {
      const r = n.slice(o, o + e), a = new Array(r.length);
      for (let l = 0; l < r.length; l++)
        a[l] = r.charCodeAt(l);
      s.push(new Uint8Array(a));
    }
    return new Blob(s, { type: t });
  } catch (t) {
    throw new g("fileuploader-decoding-image-data-error", null);
  }
}
function V6(i) {
  if (typeof i != "string")
    return !1;
  const e = i.match(Da);
  return !!(e && e.length);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class M6 {
  /**
   * Creates `UploadGateway` instance.
   *
   * @param token Token used for authentication.
   * @param apiAddress API address.
   */
  constructor(e, t) {
    if (!e)
      throw new g("uploadgateway-missing-token", null);
    if (!t)
      throw new g("uploadgateway-missing-api-address", null);
    this._token = e, this._apiAddress = t;
  }
  /**
   * Creates a {@link module:cloud-services/uploadgateway/fileuploader~FileUploader} instance that wraps
   * file upload process. The file is being sent at a time when the
   * {@link module:cloud-services/uploadgateway/fileuploader~FileUploader#send} method is called.
   *
   * ```ts
   * const token = await Token.create( 'https://token-endpoint' );
   * new UploadGateway( token, 'https://example.org' )
   * 	.upload( 'FILE' )
   * 	.onProgress( ( data ) => console.log( data ) )
   * 	.send()
   * 	.then( ( response ) => console.log( response ) );
   * ```
   *
   * @param {Blob|String} fileOrData A blob object or a data string encoded with Base64.
   * @returns {module:cloud-services/uploadgateway/fileuploader~FileUploader} Returns `FileUploader` instance.
   */
  upload(e) {
    return new P6(e, this._token, this._apiAddress);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class B6 extends jo {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "CloudServicesCore";
  }
  /**
   * Creates the {@link module:cloud-services/token/token~Token} instance.
   *
   * @param tokenUrlOrRefreshToken Endpoint address to download the token or a callback that provides the token. If the
   * value is a function it has to match the {@link module:cloud-services/token/token~Token#refreshToken} interface.
   * @param options.initValue Initial value of the token.
   * @param options.autoRefresh Specifies whether to start the refresh automatically.
   */
  createToken(e, t) {
    return new Zl(e, t);
  }
  /**
   * Creates the {@link module:cloud-services/uploadgateway/uploadgateway~UploadGateway} instance.
   *
   * @param token Token used for authentication.
   * @param apiAddress API address.
   */
  createUploadGateway(e, t) {
    return new M6(e, t);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class L6 extends jo {
  constructor() {
    super(...arguments), this.token = null, this._tokens = /* @__PURE__ */ new Map();
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "CloudServices";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [B6];
  }
  /**
   * @inheritDoc
   */
  async init() {
    const t = this.context.config.get("cloudServices") || {};
    for (const [s, o] of Object.entries(t))
      this[s] = o;
    if (!this.tokenUrl) {
      this.token = null;
      return;
    }
    const n = this.context.plugins.get("CloudServicesCore");
    this.token = await n.createToken(this.tokenUrl).init(), this._tokens.set(this.tokenUrl, this.token);
  }
  /**
   * Registers an additional authentication token URL for CKEditor Cloud Services or a callback to the token value promise. See the
   * {@link module:cloud-services/cloudservicesconfig~CloudServicesConfig#tokenUrl} for more details.
   *
   * @param tokenUrl The authentication token URL for CKEditor Cloud Services or a callback to the token value promise.
   */
  async registerTokenUrl(e) {
    if (this._tokens.has(e))
      return this.getTokenFor(e);
    const n = await this.context.plugins.get("CloudServicesCore").createToken(e).init();
    return this._tokens.set(e, n), n;
  }
  /**
   * Returns an authentication token provider previously registered by {@link #registerTokenUrl}.
   *
   * @param tokenUrl The authentication token URL for CKEditor Cloud Services or a callback to the token value promise.
   */
  getTokenFor(e) {
    const t = this._tokens.get(e);
    if (!t)
      throw new g("cloudservices-token-not-registered", this);
    return t;
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    for (const e of this._tokens.values())
      e.destroy();
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Ot(i, e, t, n) {
  let s, o = null;
  typeof n == "function" ? s = n : (o = i.commands.get(n), s = () => {
    i.execute(n);
  }), i.model.document.on("change:data", (r, a) => {
    if (o && !o.isEnabled || !e.isEnabled)
      return;
    const l = me(i.model.document.selection.getRanges());
    if (!l.isCollapsed || a.isUndo || !a.isLocal)
      return;
    const c = Array.from(i.model.document.differ.getChanges()), u = c[0];
    if (c.length != 1 || u.type !== "insert" || u.name != "$text" || u.length != 1)
      return;
    const d = u.position.parent;
    if (d.is("element", "codeBlock") || d.is("element", "listItem") && typeof n != "function" && !["numberedList", "bulletedList", "todoList"].includes(n) || o && o.value === !0)
      return;
    const h = d.getChild(0), f = i.model.createRangeOn(h);
    if (!f.containsRange(l) && !l.end.isEqual(f.end))
      return;
    const m = t.exec(h.data.substr(0, l.end.offset));
    m && i.model.enqueueChange((p) => {
      const w = p.createPositionAt(d, 0), v = p.createPositionAt(d, m[0].length), C = new Pe(w, v);
      if (s({ match: m }) !== !1) {
        p.remove(C);
        const F = i.model.document.selection.getFirstRange(), q = p.createRangeIn(d);
        d.isEmpty && !q.isEqual(F) && !q.containsRange(F, !0) && p.remove(d);
      }
      C.detach(), i.model.enqueueChange(() => {
        i.plugins.get("Delete").requestUndoOnBackspace();
      });
    });
  });
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Nn(i, e, t, n) {
  let s, o;
  t instanceof RegExp ? s = t : o = t, o = o || ((r) => {
    let a;
    const l = [], c = [];
    for (; (a = s.exec(r)) !== null && !(a && a.length < 4); ) {
      let { index: u, "1": d, "2": h, "3": f } = a;
      const m = d + h + f;
      u += a[0].length - m.length;
      const p = [
        u,
        u + d.length
      ], w = [
        u + d.length + h.length,
        u + d.length + h.length + f.length
      ];
      l.push(p), l.push(w), c.push([u + d.length, u + d.length + h.length]);
    }
    return {
      remove: l,
      format: c
    };
  }), i.model.document.on("change:data", (r, a) => {
    if (a.isUndo || !a.isLocal || !e.isEnabled)
      return;
    const l = i.model, c = l.document.selection;
    if (!c.isCollapsed)
      return;
    const u = Array.from(l.document.differ.getChanges()), d = u[0];
    if (u.length != 1 || d.type !== "insert" || d.name != "$text" || d.length != 1)
      return;
    const h = c.focus, f = h.parent, { text: m, range: p } = O6(l.createRange(l.createPositionAt(f, 0), h), l), w = o(m), v = Fh(p.start, w.format, l), C = Fh(p.start, w.remove, l);
    v.length && C.length && l.enqueueChange((L) => {
      if (n(L, v) !== !1) {
        for (const q of C.reverse())
          L.remove(q);
        l.enqueueChange(() => {
          i.plugins.get("Delete").requestUndoOnBackspace();
        });
      }
    });
  });
}
function Fh(i, e, t) {
  return e.filter((n) => n[0] !== void 0 && n[1] !== void 0).map((n) => t.createRange(i.getShiftedBy(n[0]), i.getShiftedBy(n[1])));
}
function O6(i, e) {
  let t = i.start;
  return { text: Array.from(i.getItems()).reduce((s, o) => !(o.is("$text") || o.is("$textProxy")) || o.getAttribute("code") ? (t = e.createPositionAfter(o), "") : s + o.data, ""), range: e.createRange(t, i.end) };
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class F6 extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [bt];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Autoformat";
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    const e = this.editor, t = this.editor.t;
    this._addListAutoformats(), this._addBasicStylesAutoformats(), this._addHeadingAutoformats(), this._addBlockQuoteAutoformats(), this._addCodeBlockAutoformats(), this._addHorizontalLineAutoformats(), e.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: t("Revert autoformatting action"),
          keystroke: "Backspace"
        }
      ]
    });
  }
  /**
   * Adds autoformatting related to the {@link module:list/list~List}.
   *
   * When typed:
   * - `* ` or `- ` &ndash; A paragraph will be changed into a bulleted list.
   * - `1. ` or `1) ` &ndash; A paragraph will be changed into a numbered list ("1" can be any digit or a list of digits).
   * - `[] ` or `[ ] ` &ndash; A paragraph will be changed into a to-do list.
   * - `[x] ` or `[ x ] ` &ndash; A paragraph will be changed into a checked to-do list.
   */
  _addListAutoformats() {
    const e = this.editor.commands;
    e.get("bulletedList") && Ot(this.editor, this, /^[*-]\s$/, "bulletedList"), e.get("numberedList") && Ot(this.editor, this, /^1[.|)]\s$/, "numberedList"), e.get("todoList") && Ot(this.editor, this, /^\[\s?\]\s$/, "todoList"), e.get("checkTodoList") && Ot(this.editor, this, /^\[\s?x\s?\]\s$/, () => {
      this.editor.execute("todoList"), this.editor.execute("checkTodoList");
    });
  }
  /**
   * Adds autoformatting related to the {@link module:basic-styles/bold~Bold},
   * {@link module:basic-styles/italic~Italic}, {@link module:basic-styles/code~Code}
   * and {@link module:basic-styles/strikethrough~Strikethrough}
   *
   * When typed:
   * - `**foobar**` &ndash; `**` characters are removed and `foobar` is set to bold,
   * - `__foobar__` &ndash; `__` characters are removed and `foobar` is set to bold,
   * - `*foobar*` &ndash; `*` characters are removed and `foobar` is set to italic,
   * - `_foobar_` &ndash; `_` characters are removed and `foobar` is set to italic,
   * - ``` `foobar` &ndash; ``` ` ``` characters are removed and `foobar` is set to code,
   * - `~~foobar~~` &ndash; `~~` characters are removed and `foobar` is set to strikethrough.
   */
  _addBasicStylesAutoformats() {
    const e = this.editor.commands;
    if (e.get("bold")) {
      const t = no(this.editor, "bold");
      Nn(this.editor, this, /(?:^|\s)(\*\*)([^*]+)(\*\*)$/g, t), Nn(this.editor, this, /(?:^|\s)(__)([^_]+)(__)$/g, t);
    }
    if (e.get("italic")) {
      const t = no(this.editor, "italic");
      Nn(this.editor, this, /(?:^|\s)(\*)([^*_]+)(\*)$/g, t), Nn(this.editor, this, /(?:^|\s)(_)([^_]+)(_)$/g, t);
    }
    if (e.get("code")) {
      const t = no(this.editor, "code");
      Nn(this.editor, this, /(`)([^`]+)(`)$/g, t);
    }
    if (e.get("strikethrough")) {
      const t = no(this.editor, "strikethrough");
      Nn(this.editor, this, /(~~)([^~]+)(~~)$/g, t);
    }
  }
  /**
   * Adds autoformatting related to {@link module:heading/heading~Heading}.
   *
   * It is using a number at the end of the command name to associate it with the proper trigger:
   *
   * * `heading` with a `heading1` value will be executed when typing `#`,
   * * `heading` with a `heading2` value will be executed when typing `##`,
   * * ... up to `heading6` for `######`.
   */
  _addHeadingAutoformats() {
    const e = this.editor.commands.get("heading");
    e && e.modelElements.filter((t) => t.match(/^heading[1-6]$/)).forEach((t) => {
      const n = t[7], s = new RegExp(`^(#{${n}})\\s$`);
      Ot(this.editor, this, s, () => {
        if (!e.isEnabled || e.value === t)
          return !1;
        this.editor.execute("heading", { value: t });
      });
    });
  }
  /**
   * Adds autoformatting related to {@link module:block-quote/blockquote~BlockQuote}.
   *
   * When typed:
   * * `> ` &ndash; A paragraph will be changed to a block quote.
   */
  _addBlockQuoteAutoformats() {
    this.editor.commands.get("blockQuote") && Ot(this.editor, this, /^>\s$/, "blockQuote");
  }
  /**
   * Adds autoformatting related to {@link module:code-block/codeblock~CodeBlock}.
   *
   * When typed:
   * - `` ``` `` &ndash; A paragraph will be changed to a code block.
   */
  _addCodeBlockAutoformats() {
    const e = this.editor, t = e.model.document.selection;
    e.commands.get("codeBlock") && Ot(e, this, /^```$/, () => {
      if (t.getFirstPosition().parent.is("element", "listItem"))
        return !1;
      this.editor.execute("codeBlock", {
        usePreviousLanguageChoice: !0
      });
    });
  }
  /**
   * Adds autoformatting related to {@link module:horizontal-line/horizontalline~HorizontalLine}.
   *
   * When typed:
   * - `` --- `` &ndash; Will be replaced with a horizontal line.
   */
  _addHorizontalLineAutoformats() {
    this.editor.commands.get("horizontalLine") && Ot(this.editor, this, /^---$/, "horizontalLine");
  }
}
function no(i, e) {
  return (t, n) => {
    if (!i.commands.get(e).isEnabled)
      return !1;
    const o = i.model.schema.getValidRanges(n, e);
    for (const r of o)
      t.setAttribute(e, !0, r);
    t.removeSelectionAttribute(e);
  };
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function N6(i) {
  return i.createContainerElement("span", { class: "image-inline" }, i.createEmptyElement("img"));
}
function Nh(i) {
  return i.createContainerElement("figure", { class: "image" }, [
    i.createEmptyElement("img"),
    i.createSlot("children")
  ]);
}
function ob(i, e) {
  const t = i.plugins.get("ImageUtils"), n = i.plugins.has("ImageInlineEditing") && i.plugins.has("ImageBlockEditing");
  return (o) => t.isInlineImageView(o) ? n && (o.getStyle("display") == "block" || o.findAncestor(t.isBlockImageView) ? "imageBlock" : "imageInline") !== e ? null : s(o) : null;
  function s(o) {
    const r = {
      name: !0
    };
    return o.hasAttribute("src") && (r.attributes = ["src"]), r;
  }
}
function Jl(i, e) {
  const t = me(e.getSelectedBlocks());
  return !t || i.isObject(t) || t.isEmpty && t.name != "listItem" ? "imageBlock" : "imageInline";
}
function Lo(i) {
  return i && i.endsWith("px") ? parseInt(i) : null;
}
function Oo(i) {
  const e = Lo(i.getStyle("width")), t = Lo(i.getStyle("height"));
  return !!(e && t);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const D6 = /^(image|image-inline)$/;
class Ae extends b {
  constructor() {
    super(...arguments), this._domEmitter = new (Le())();
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageUtils";
  }
  /**
   * Checks if the provided model element is an `image` or `imageInline`.
   */
  isImage(e) {
    return this.isInlineImage(e) || this.isBlockImage(e);
  }
  /**
   * Checks if the provided view element represents an inline image.
   *
   * Also, see {@link module:image/imageutils~ImageUtils#isImageWidget}.
   */
  isInlineImageView(e) {
    return !!e && e.is("element", "img");
  }
  /**
   * Checks if the provided view element represents a block image.
   *
   * Also, see {@link module:image/imageutils~ImageUtils#isImageWidget}.
   */
  isBlockImageView(e) {
    return !!e && e.is("element", "figure") && e.hasClass("image");
  }
  /**
   * Handles inserting single file. This method unifies image insertion using {@link module:widget/utils~findOptimalInsertionRange}
   * method.
   *
   * ```ts
   * const imageUtils = editor.plugins.get( 'ImageUtils' );
   *
   * imageUtils.insertImage( { src: 'path/to/image.jpg' } );
   * ```
   *
   * @param attributes Attributes of the inserted image.
   * This method filters out the attributes which are disallowed by the {@link module:engine/model/schema~Schema}.
   * @param selectable Place to insert the image. If not specified,
   * the {@link module:widget/utils~findOptimalInsertionRange} logic will be applied for the block images
   * and `model.document.selection` for the inline images.
   *
   * **Note**: If `selectable` is passed, this helper will not be able to set selection attributes (such as `linkHref`)
   * and apply them to the new image. In this case, make sure all selection attributes are passed in `attributes`.
   *
   * @param imageType Image type of inserted image. If not specified,
   * it will be determined automatically depending of editor config or place of the insertion.
   * @param options.setImageSizes Specifies whether the image `width` and `height` attributes should be set automatically.
   * The default is `true`.
   * @return The inserted model image element.
   */
  insertImage(e = {}, t = null, n = null, s = {}) {
    const o = this.editor, r = o.model, a = r.document.selection, l = rb(o, t || a, n);
    e = {
      ...Object.fromEntries(a.getAttributes()),
      ...e
    };
    for (const c in e)
      r.schema.checkAttribute(l, c) || delete e[c];
    return r.change((c) => {
      const { setImageSizes: u = !0 } = s, d = c.createElement(l, e);
      return r.insertObject(d, t, null, {
        setSelection: "on",
        // If we want to insert a block image (for whatever reason) then we don't want to split text blocks.
        // This applies only when we don't have the selectable specified (i.e., we insert multiple block images at once).
        findOptimalPosition: !t && l != "imageInline" ? "auto" : void 0
      }), d.parent ? (u && this.setImageNaturalSizeAttributes(d), d) : null;
    });
  }
  /**
   * Reads original image sizes and sets them as `width` and `height`.
   *
   * The `src` attribute may not be available if the user is using an upload adapter. In such a case,
   * this method is called again after the upload process is complete and the `src` attribute is available.
   */
  setImageNaturalSizeAttributes(e) {
    const t = e.getAttribute("src");
    t && (e.getAttribute("width") || e.getAttribute("height") || this.editor.model.change((n) => {
      const s = new E.window.Image();
      this._domEmitter.listenTo(s, "load", () => {
        !e.getAttribute("width") && !e.getAttribute("height") && this.editor.model.enqueueChange(n.batch, (o) => {
          o.setAttribute("width", s.naturalWidth, e), o.setAttribute("height", s.naturalHeight, e);
        }), this._domEmitter.stopListening(s, "load");
      }), s.src = t;
    }));
  }
  /**
   * Returns an image widget editing view element if one is selected or is among the selection's ancestors.
   */
  getClosestSelectedImageWidget(e) {
    const t = e.getFirstPosition();
    if (!t)
      return null;
    const n = e.getSelectedElement();
    if (n && this.isImageWidget(n))
      return n;
    let s = t.parent;
    for (; s; ) {
      if (s.is("element") && this.isImageWidget(s))
        return s;
      s = s.parent;
    }
    return null;
  }
  /**
   * Returns a image model element if one is selected or is among the selection's ancestors.
   */
  getClosestSelectedImageElement(e) {
    const t = e.getSelectedElement();
    return this.isImage(t) ? t : e.getFirstPosition().findAncestor("imageBlock");
  }
  /**
   * Returns an image widget editing view based on the passed image view.
   */
  getImageWidgetFromImageView(e) {
    return e.findAncestor({ classes: D6 });
  }
  /**
   * Checks if image can be inserted at current model selection.
   *
   * @internal
   */
  isImageAllowed() {
    const t = this.editor.model.document.selection;
    return z6(this.editor, t) && H6(t);
  }
  /**
   * Converts a given {@link module:engine/view/element~Element} to an image widget:
   * * Adds a {@link module:engine/view/element~Element#_setCustomProperty custom property} allowing to recognize the image widget
   * element.
   * * Calls the {@link module:widget/utils~toWidget} function with the proper element's label creator.
   *
   * @param writer An instance of the view writer.
   * @param label The element's label. It will be concatenated with the image `alt` attribute if one is present.
   */
  toImageWidget(e, t, n) {
    return t.setCustomProperty("image", !0, e), lr(e, t, { label: () => {
      const r = this.findViewImgElement(e).getAttribute("alt");
      return r ? `${r} ${n}` : n;
    } });
  }
  /**
   * Checks if a given view element is an image widget.
   */
  isImageWidget(e) {
    return !!e.getCustomProperty("image") && ae(e);
  }
  /**
   * Checks if the provided model element is an `image`.
   */
  isBlockImage(e) {
    return !!e && e.is("element", "imageBlock");
  }
  /**
   * Checks if the provided model element is an `imageInline`.
   */
  isInlineImage(e) {
    return !!e && e.is("element", "imageInline");
  }
  /**
   * Get the view `<img>` from another view element, e.g. a widget (`<figure class="image">`), a link (`<a>`).
   *
   * The `<img>` can be located deep in other elements, so this helper performs a deep tree search.
   */
  findViewImgElement(e) {
    if (this.isInlineImageView(e))
      return e;
    const t = this.editor.editing.view;
    for (const { item: n } of t.createRangeIn(e))
      if (this.isInlineImageView(n))
        return n;
  }
  /**
   * @inheritDoc
   */
  destroy() {
    return this._domEmitter.stopListening(), super.destroy();
  }
}
function z6(i, e) {
  if (rb(i, e, null) == "imageBlock") {
    const n = U6(e, i.model);
    if (i.model.schema.checkChild(n, "imageBlock"))
      return !0;
  } else if (i.model.schema.checkChild(e.focus, "imageInline"))
    return !0;
  return !1;
}
function H6(i) {
  return [...i.focus.getAncestors()].every((e) => !e.is("element", "imageBlock"));
}
function U6(i, e) {
  const n = Bl(i, e).start.parent;
  return n.isEmpty && !n.is("element", "$root") ? n.parent : n;
}
function rb(i, e, t) {
  const n = i.model.schema, s = i.config.get("image.insert.type");
  return i.plugins.has("ImageBlockEditing") ? i.plugins.has("ImageInlineEditing") ? t || (s === "inline" ? "imageInline" : s !== "auto" ? "imageBlock" : e.is("selection") ? Jl(n, e) : n.checkChild(e, "imageInline") ? "imageInline" : "imageBlock") : "imageBlock" : "imageInline";
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const $6 = new RegExp(String(/^(http(s)?:\/\/)?[\w-]+\.[\w.~:/[\]@!$&'()*+,;=%-]+/.source + /\.(jpg|jpeg|png|gif|ico|webp|JPG|JPEG|PNG|GIF|ICO|WEBP)/.source + /(\?[\w.~:/[\]@!$&'()*+,;=%-]*)?/.source + /(#[\w.~:/[\]@!$&'()*+,;=%-]*)?$/.source));
class W6 extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Ol, Ae, Fl, bt];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "AutoImage";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this._timeoutId = null, this._positionToInsert = null;
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model.document, n = e.plugins.get("ClipboardPipeline");
    this.listenTo(n, "inputTransformation", () => {
      const s = t.selection.getFirstRange(), o = ce.fromPosition(s.start);
      o.stickiness = "toPrevious";
      const r = ce.fromPosition(s.end);
      r.stickiness = "toNext", t.once("change:data", () => {
        this._embedImageBetweenPositions(o, r), o.detach(), r.detach();
      }, { priority: "high" });
    }), e.commands.get("undo").on("execute", () => {
      this._timeoutId && (E.window.clearTimeout(this._timeoutId), this._positionToInsert.detach(), this._timeoutId = null, this._positionToInsert = null);
    }, { priority: "high" });
  }
  /**
   * Analyzes the part of the document between provided positions in search for a URL representing an image.
   * When the URL is found, it is automatically converted into an image.
   *
   * @param leftPosition Left position of the selection.
   * @param rightPosition Right position of the selection.
   */
  _embedImageBetweenPositions(e, t) {
    const n = this.editor, s = new Pe(e, t), o = s.getWalker({ ignoreElementEnd: !0 }), r = Object.fromEntries(n.model.document.selection.getAttributes()), a = this.editor.plugins.get("ImageUtils");
    let l = "";
    for (const c of o)
      c.item.is("$textProxy") && (l += c.item.data);
    if (l = l.trim(), !l.match($6)) {
      s.detach();
      return;
    }
    this._positionToInsert = ce.fromPosition(e), this._timeoutId = setTimeout(() => {
      if (!n.commands.get("insertImage").isEnabled) {
        s.detach();
        return;
      }
      n.model.change((d) => {
        this._timeoutId = null, d.remove(s), s.detach();
        let h;
        this._positionToInsert.root.rootName !== "$graveyard" && (h = this._positionToInsert.toPosition()), a.insertImage({ ...r, src: l }, h), this._positionToInsert.detach(), this._positionToInsert = null;
      }), n.plugins.get("Delete").requestUndoOnBackspace();
    }, 100);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class q6 extends V {
  /**
   * @inheritDoc
   */
  refresh() {
    const n = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
    this.isEnabled = !!n, this.isEnabled && n.hasAttribute("alt") ? this.value = n.getAttribute("alt") : this.value = !1;
  }
  /**
   * Executes the command.
   *
   * @fires execute
   * @param options
   * @param options.newValue The new value of the `alt` attribute to set.
   */
  execute(e) {
    const t = this.editor, n = t.plugins.get("ImageUtils"), s = t.model, o = n.getClosestSelectedImageElement(s.document.selection);
    s.change((r) => {
      r.setAttribute("alt", e.newValue, o);
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class G6 extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Ae];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageTextAlternativeEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    this.editor.commands.add("imageTextAlternative", new q6(this.editor));
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class j6 extends T {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e);
    const t = this.locale.t;
    this.focusTracker = new X(), this.keystrokes = new ie(), this.labeledInput = this._createLabeledInputView(), this.saveButtonView = this._createButton(t("Save"), A.check, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(t("Cancel"), A.cancel, "ck-button-cancel", "cancel"), this._focusables = new ve(), this._focusCycler = new ge({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    }), this.setTemplate({
      tag: "form",
      attributes: {
        class: [
          "ck",
          "ck-text-alternative-form",
          "ck-responsive-form"
        ],
        // https://github.com/ckeditor/ckeditor5-image/issues/40
        tabindex: "-1"
      },
      children: [
        this.labeledInput,
        this.saveButtonView,
        this.cancelButtonView
      ]
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.keystrokes.listenTo(this.element), Cn({ view: this }), [this.labeledInput, this.saveButtonView, this.cancelButtonView].forEach((e) => {
      this._focusables.add(e), this.focusTracker.add(e.element);
    });
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  /**
   * Creates the button view.
   *
   * @param label The button label
   * @param icon The button's icon.
   * @param className The additional button CSS class name.
   * @param eventName The event name that the ButtonView#execute event will be delegated to.
   * @returns The button view instance.
   */
  _createButton(e, t, n, s) {
    const o = new P(this.locale);
    return o.set({
      label: e,
      icon: t,
      tooltip: !0
    }), o.extendTemplate({
      attributes: {
        class: n
      }
    }), s && o.delegate("execute").to(this, s), o;
  }
  /**
   * Creates an input with a label.
   *
   * @returns Labeled field view instance.
   */
  _createLabeledInputView() {
    const e = this.locale.t, t = new ue(this.locale, He);
    return t.label = e("Text alternative"), t;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function K6(i) {
  const e = i.plugins.get("ContextualBalloon");
  if (i.plugins.get("ImageUtils").getClosestSelectedImageWidget(i.editing.view.document.selection)) {
    const n = Xl(i);
    e.updatePosition(n);
  }
}
function Xl(i) {
  const e = i.editing.view, t = Ce.defaultPositions, n = i.plugins.get("ImageUtils");
  return {
    target: e.domConverter.mapViewToDom(n.getClosestSelectedImageWidget(e.document.selection)),
    positions: [
      t.northArrowSouth,
      t.northArrowSouthWest,
      t.northArrowSouthEast,
      t.southArrowNorth,
      t.southArrowNorthWest,
      t.southArrowNorthEast,
      t.viewportStickyNorth
    ]
  };
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Z6 extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Rt];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageTextAlternativeUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    this._createButton();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this._form && this._form.destroy();
  }
  /**
   * Creates a button showing the balloon panel for changing the image text alternative and
   * registers it in the editor {@link module:ui/componentfactory~ComponentFactory ComponentFactory}.
   */
  _createButton() {
    const e = this.editor, t = e.t;
    e.ui.componentFactory.add("imageTextAlternative", (n) => {
      const s = e.commands.get("imageTextAlternative"), o = new P(n);
      return o.set({
        label: t("Change image text alternative"),
        icon: A.textAlternative,
        tooltip: !0
      }), o.bind("isEnabled").to(s, "isEnabled"), o.bind("isOn").to(s, "value", (r) => !!r), this.listenTo(o, "execute", () => {
        this._showForm();
      }), o;
    });
  }
  /**
   * Creates the {@link module:image/imagetextalternative/ui/textalternativeformview~TextAlternativeFormView}
   * form.
   */
  _createForm() {
    const e = this.editor, n = e.editing.view.document, s = e.plugins.get("ImageUtils");
    this._balloon = this.editor.plugins.get("ContextualBalloon"), this._form = new (tr(j6))(e.locale), this._form.render(), this.listenTo(this._form, "submit", () => {
      e.execute("imageTextAlternative", {
        newValue: this._form.labeledInput.fieldView.element.value
      }), this._hideForm(!0);
    }), this.listenTo(this._form, "cancel", () => {
      this._hideForm(!0);
    }), this._form.keystrokes.set("Esc", (o, r) => {
      this._hideForm(!0), r();
    }), this.listenTo(e.ui, "update", () => {
      s.getClosestSelectedImageWidget(n.selection) ? this._isVisible && K6(e) : this._hideForm(!0);
    }), yn({
      emitter: this._form,
      activator: () => this._isVisible,
      contextElements: () => [this._balloon.view.element],
      callback: () => this._hideForm()
    });
  }
  /**
   * Shows the {@link #_form} in the {@link #_balloon}.
   */
  _showForm() {
    if (this._isVisible)
      return;
    this._form || this._createForm();
    const e = this.editor, t = e.commands.get("imageTextAlternative"), n = this._form.labeledInput;
    this._form.disableCssTransitions(), this._isInBalloon || this._balloon.add({
      view: this._form,
      position: Xl(e)
    }), n.fieldView.value = n.fieldView.element.value = t.value || "", this._form.labeledInput.fieldView.select(), this._form.enableCssTransitions();
  }
  /**
   * Removes the {@link #_form} from the {@link #_balloon}.
   *
   * @param focusEditable Controls whether the editing view is focused afterwards.
   */
  _hideForm(e = !1) {
    this._isInBalloon && (this._form.focusTracker.isFocused && this._form.saveButtonView.focus(), this._balloon.remove(this._form), e && this.editor.editing.view.focus());
  }
  /**
   * Returns `true` when the {@link #_form} is the visible view in the {@link #_balloon}.
   */
  get _isVisible() {
    return !!this._balloon && this._balloon.visibleView === this._form;
  }
  /**
   * Returns `true` when the {@link #_form} is in the {@link #_balloon}.
   */
  get _isInBalloon() {
    return !!this._balloon && this._balloon.hasView(this._form);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ab extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [G6, Z6];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageTextAlternative";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function J6(i) {
  const e = (t, n, s) => {
    if (!s.consumable.test(n.viewItem, { name: !0, classes: "image" }))
      return;
    const o = i.findViewImgElement(n.viewItem);
    if (!o || !s.consumable.test(o, { name: !0 }))
      return;
    s.consumable.consume(n.viewItem, { name: !0, classes: "image" });
    const r = s.convertItem(o, n.modelCursor), a = me(r.modelRange.getItems());
    if (!a) {
      s.consumable.revert(n.viewItem, { name: !0, classes: "image" });
      return;
    }
    s.convertChildren(n.viewItem, a), s.updateConversionResult(a, n);
  };
  return (t) => {
    t.on("element:figure", e);
  };
}
function lb(i, e) {
  const t = (n, s, o) => {
    if (!o.consumable.consume(s.item, n.name))
      return;
    const r = o.writer, a = o.mapper.toViewElement(s.item), l = i.findViewImgElement(a);
    s.attributeNewValue === null ? (r.removeAttribute("srcset", l), r.removeAttribute("sizes", l)) : s.attributeNewValue && (r.setAttribute("srcset", s.attributeNewValue, l), r.setAttribute("sizes", "100vw", l));
  };
  return (n) => {
    n.on(`attribute:srcset:${e}`, t);
  };
}
function Fo(i, e, t) {
  const n = (s, o, r) => {
    if (!r.consumable.consume(o.item, s.name))
      return;
    const a = r.writer, l = r.mapper.toViewElement(o.item), c = i.findViewImgElement(l);
    a.setAttribute(o.attributeKey, o.attributeNewValue || "", c);
  };
  return (s) => {
    s.on(`attribute:${t}:${e}`, n);
  };
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Ql extends wt {
  /**
   * @inheritDoc
   */
  observe(e) {
    this.listenTo(e, "load", (t, n) => {
      const s = n.target;
      this.checkShouldIgnoreEventFromTarget(s) || s.tagName == "IMG" && this._fireEvents(n);
    }, { useCapture: !0 });
  }
  /**
   * @inheritDoc
   */
  stopObserving(e) {
    this.stopListening(e);
  }
  /**
   * Fires {@link module:engine/view/document~Document#event:layoutChanged} and
   * {@link module:engine/view/document~Document#event:imageLoaded}
   * if observer {@link #isEnabled is enabled}.
   *
   * @param domEvent The DOM event.
   */
  _fireEvents(e) {
    this.isEnabled && (this.document.fire("layoutChanged"), this.document.fire("imageLoaded", e));
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class X6 extends V {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e);
    const t = e.config.get("image.insert.type");
    e.plugins.has("ImageBlockEditing") || t === "block" && D("image-block-plugin-required"), e.plugins.has("ImageInlineEditing") || t === "inline" && D("image-inline-plugin-required");
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor.plugins.get("ImageUtils");
    this.isEnabled = e.isImageAllowed();
  }
  /**
   * Executes the command.
   *
   * @fires execute
   * @param options Options for the executed command.
   * @param options.source The image source or an array of image sources to insert.
   * See the documentation of the command to learn more about accepted formats.
   */
  execute(e) {
    const t = Z(e.source), n = this.editor.model.document.selection, s = this.editor.plugins.get("ImageUtils"), o = Object.fromEntries(n.getAttributes());
    t.forEach((r, a) => {
      const l = n.getSelectedElement();
      if (typeof r == "string" && (r = { src: r }), a && l && s.isImage(l)) {
        const c = this.editor.model.createPositionAfter(l);
        s.insertImage({ ...r, ...o }, c);
      } else
        s.insertImage({ ...r, ...o });
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Q6 extends V {
  constructor(e) {
    super(e), this.decorate("cleanupImage");
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const t = this.editor.plugins.get("ImageUtils"), n = this.editor.model.document.selection.getSelectedElement();
    this.isEnabled = t.isImage(n), this.value = this.isEnabled ? n.getAttribute("src") : null;
  }
  /**
   * Executes the command.
   *
   * @fires execute
   * @param options Options for the executed command.
   * @param options.source The image source to replace.
   */
  execute(e) {
    const t = this.editor.model.document.selection.getSelectedElement(), n = this.editor.plugins.get("ImageUtils");
    this.editor.model.change((s) => {
      s.setAttribute("src", e.source, t), this.cleanupImage(s, t), n.setImageNaturalSizeAttributes(t);
    });
  }
  /**
   * Cleanup image attributes that are not relevant to the new source.
   *
   * Removed attributes are: 'srcset', 'sizes', 'sources', 'width', 'height', 'alt'.
   *
   * This method is decorated, to allow custom cleanup logic.
   * For example, to remove 'myImageId' attribute after 'src' has changed:
   *
   * ```ts
   * replaceImageSourceCommand.on( 'cleanupImage', ( eventInfo, [ writer, image ] ) => {
   * 	writer.removeAttribute( 'myImageId', image );
   * } );
   * ```
   */
  cleanupImage(e, t) {
    e.removeAttribute("srcset", t), e.removeAttribute("sizes", t), e.removeAttribute("sources", t), e.removeAttribute("width", t), e.removeAttribute("height", t), e.removeAttribute("alt", t);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class cb extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Ae];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.conversion;
    e.editing.view.addObserver(Ql), t.for("upcast").attributeToAttribute({
      view: {
        name: "img",
        key: "alt"
      },
      model: "alt"
    }).attributeToAttribute({
      view: {
        name: "img",
        key: "srcset"
      },
      model: "srcset"
    });
    const n = new X6(e), s = new Q6(e);
    e.commands.add("insertImage", n), e.commands.add("replaceImageSource", s), e.commands.add("imageInsert", n);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ub extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Ae];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageSizeAttributes";
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    this._registerSchema(), this._registerConverters("imageBlock"), this._registerConverters("imageInline");
  }
  /**
   * Registers the `width` and `height` attributes for inline and block images.
   */
  _registerSchema() {
    this.editor.plugins.has("ImageBlockEditing") && this.editor.model.schema.extend("imageBlock", { allowAttributes: ["width", "height"] }), this.editor.plugins.has("ImageInlineEditing") && this.editor.model.schema.extend("imageInline", { allowAttributes: ["width", "height"] });
  }
  /**
   * Registers converters for `width` and `height` attributes.
   */
  _registerConverters(e) {
    const t = this.editor, n = t.plugins.get("ImageUtils"), s = e === "imageBlock" ? "figure" : "img";
    t.conversion.for("upcast").attributeToAttribute({
      view: {
        name: s,
        styles: {
          width: /.+/
        }
      },
      model: {
        key: "width",
        value: (r) => Oo(r) ? Lo(r.getStyle("width")) : null
      }
    }).attributeToAttribute({
      view: {
        name: s,
        key: "width"
      },
      model: "width"
    }).attributeToAttribute({
      view: {
        name: s,
        styles: {
          height: /.+/
        }
      },
      model: {
        key: "height",
        value: (r) => Oo(r) ? Lo(r.getStyle("height")) : null
      }
    }).attributeToAttribute({
      view: {
        name: s,
        key: "height"
      },
      model: "height"
    }), t.conversion.for("editingDowncast").add((r) => {
      o(r, "width", "width", !0), o(r, "height", "height", !0);
    }), t.conversion.for("dataDowncast").add((r) => {
      o(r, "width", "width", !1), o(r, "height", "height", !1);
    });
    function o(r, a, l, c) {
      r.on(`attribute:${a}:${e}`, (u, d, h) => {
        if (!h.consumable.consume(d.item, u.name))
          return;
        const f = h.writer, m = h.mapper.toViewElement(d.item), p = n.findViewImgElement(m);
        if (d.attributeNewValue !== null ? f.setAttribute(l, d.attributeNewValue, p) : f.removeAttribute(l, p), d.item.hasAttribute("sources"))
          return;
        const w = d.item.hasAttribute("resizedWidth");
        if (e === "imageInline" && !w && !c)
          return;
        const v = d.item.getAttribute("width"), C = d.item.getAttribute("height");
        v && C && f.setStyle("aspect-ratio", `${v}/${C}`, p);
      });
    }
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class db extends V {
  /**
   * @inheritDoc
   *
   * @param modelElementName Model element name the command converts to.
   */
  constructor(e, t) {
    super(e), this._modelElementName = t;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const t = this.editor.plugins.get("ImageUtils"), n = t.getClosestSelectedImageElement(this.editor.model.document.selection);
    this._modelElementName === "imageBlock" ? this.isEnabled = t.isInlineImage(n) : this.isEnabled = t.isBlockImage(n);
  }
  /**
   * Executes the command and changes the type of a selected image.
   *
   * @fires execute
   * @param options.setImageSizes Specifies whether the image `width` and `height` attributes should be set automatically.
   * The default is `true`.
   * @returns An object containing references to old and new model image elements
   * (for before and after the change) so external integrations can hook into the decorated
   * `execute` event and handle this change. `null` if the type change failed.
   */
  execute(e = {}) {
    const t = this.editor, n = this.editor.model, s = t.plugins.get("ImageUtils"), o = s.getClosestSelectedImageElement(n.document.selection), r = Object.fromEntries(o.getAttributes());
    return !r.src && !r.uploadId ? null : n.change((a) => {
      const { setImageSizes: l = !0 } = e, c = Array.from(n.markers).filter((h) => h.getRange().containsItem(o)), u = s.insertImage(r, n.createSelection(o, "on"), this._modelElementName, { setImageSizes: l });
      if (!u)
        return null;
      const d = a.createRangeOn(u);
      for (const h of c) {
        const f = h.getRange(), m = f.root.rootName != "$graveyard" ? f.getJoined(d, !0) : d;
        a.updateMarker(h, { range: m });
      }
      return {
        oldElement: o,
        newElement: u
      };
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class hb extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Ae];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImagePlaceholder";
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    this._setupSchema(), this._setupConversion(), this._setupLoadListener();
  }
  /**
   * Extends model schema.
   */
  _setupSchema() {
    const e = this.editor.model.schema;
    e.isRegistered("imageBlock") && e.extend("imageBlock", {
      allowAttributes: ["placeholder"]
    }), e.isRegistered("imageInline") && e.extend("imageInline", {
      allowAttributes: ["placeholder"]
    });
  }
  /**
   * Registers converters.
   */
  _setupConversion() {
    const e = this.editor, t = e.conversion, n = e.plugins.get("ImageUtils");
    t.for("editingDowncast").add((s) => {
      s.on("attribute:placeholder", (o, r, a) => {
        if (!a.consumable.test(r.item, o.name) || !r.item.is("element", "imageBlock") && !r.item.is("element", "imageInline"))
          return;
        a.consumable.consume(r.item, o.name);
        const l = a.writer, c = a.mapper.toViewElement(r.item), u = n.findViewImgElement(c);
        r.attributeNewValue ? (l.addClass("image_placeholder", u), l.setStyle("background-image", `url(${r.attributeNewValue})`, u), l.setCustomProperty("editingPipeline:doNotReuseOnce", !0, u)) : (l.removeClass("image_placeholder", u), l.removeStyle("background-image", u));
      });
    });
  }
  /**
   * Prepares listener for image load.
   */
  _setupLoadListener() {
    const e = this.editor, t = e.model, n = e.editing, s = n.view, o = e.plugins.get("ImageUtils");
    s.addObserver(Ql), this.listenTo(s.document, "imageLoaded", (r, a) => {
      const l = s.domConverter.mapDomToView(a.target);
      if (!l)
        return;
      const c = o.getImageWidgetFromImageView(l);
      if (!c)
        return;
      const u = n.mapper.toModelElement(c);
      !u || !u.hasAttribute("placeholder") || t.enqueueChange({ isUndoable: !1 }, (d) => {
        d.removeAttribute("placeholder", u);
      });
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class fb extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [cb, ub, Ae, hb, Ze];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageBlockEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor;
    e.model.schema.register("imageBlock", {
      inheritAllFrom: "$blockObject",
      allowAttributes: ["alt", "src", "srcset"]
    }), this._setupConversion(), e.plugins.has("ImageInlineEditing") && (e.commands.add("imageTypeBlock", new db(this.editor, "imageBlock")), this._setupClipboardIntegration());
  }
  /**
   * Configures conversion pipelines to support upcasting and downcasting
   * block images (block image widgets) and their attributes.
   */
  _setupConversion() {
    const e = this.editor, t = e.t, n = e.conversion, s = e.plugins.get("ImageUtils");
    n.for("dataDowncast").elementToStructure({
      model: "imageBlock",
      view: (o, { writer: r }) => Nh(r)
    }), n.for("editingDowncast").elementToStructure({
      model: "imageBlock",
      view: (o, { writer: r }) => s.toImageWidget(Nh(r), r, t("image widget"))
    }), n.for("downcast").add(Fo(s, "imageBlock", "src")).add(Fo(s, "imageBlock", "alt")).add(lb(s, "imageBlock")), n.for("upcast").elementToElement({
      view: ob(e, "imageBlock"),
      model: (o, { writer: r }) => r.createElement("imageBlock", o.hasAttribute("src") ? { src: o.getAttribute("src") } : void 0)
    }).add(J6(s));
  }
  /**
   * Integrates the plugin with the clipboard pipeline.
   *
   * Idea is that the feature should recognize the user's intent when an **inline** image is
   * pasted or dropped. If such an image is pasted/dropped:
   *
   * * into an empty block (e.g. an empty paragraph),
   * * on another object (e.g. some block widget).
   *
   * it gets converted into a block image on the fly. We assume this is the user's intent
   * if they decided to put their image there.
   *
   * See the `ImageInlineEditing` for the similar integration that works in the opposite direction.
   *
   * The feature also sets image `width` and `height` attributes on paste.
   */
  _setupClipboardIntegration() {
    const e = this.editor, t = e.model, n = e.editing.view, s = e.plugins.get("ImageUtils"), o = e.plugins.get("ClipboardPipeline");
    this.listenTo(o, "inputTransformation", (r, a) => {
      const l = Array.from(a.content.getChildren());
      let c;
      if (!l.every(s.isInlineImageView))
        return;
      a.targetRanges ? c = e.editing.mapper.toModelRange(a.targetRanges[0]) : c = t.document.selection.getFirstRange();
      const u = t.createSelection(c);
      if (Jl(t.schema, u) === "imageBlock") {
        const d = new Bt(n.document), h = l.map((f) => d.createElement("figure", { class: "image" }, f));
        a.content = d.createDocumentFragment(h);
      }
    }), this.listenTo(o, "contentInsertion", (r, a) => {
      a.method === "paste" && t.change((l) => {
        const c = l.createRangeIn(a.content);
        for (const u of c.getItems())
          u.is("element", "imageBlock") && s.setImageNaturalSizeAttributes(u);
      });
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Y6 extends T {
  /**
   * Creates a view for the dropdown panel of {@link module:image/imageinsert/imageinsertui~ImageInsertUI}.
   *
   * @param locale The localization services instance.
   * @param integrations An integrations object that contains components (or tokens for components) to be shown in the panel view.
   */
  constructor(e, t = []) {
    super(e), this.focusTracker = new X(), this.keystrokes = new ie(), this._focusables = new ve(), this.children = this.createCollection(), this._focusCycler = new ge({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    });
    for (const n of t)
      this.children.add(n), this._focusables.add(n), n instanceof Tg && this._focusables.addMany(n.children);
    if (this._focusables.length > 1)
      for (const n of this._focusables)
        eM(n) && (n.focusCycler.on("forwardCycle", (s) => {
          this._focusCycler.focusNext(), s.stop();
        }), n.focusCycler.on("backwardCycle", (s) => {
          this._focusCycler.focusPrevious(), s.stop();
        }));
    this.setTemplate({
      tag: "form",
      attributes: {
        class: [
          "ck",
          "ck-image-insert-form"
        ],
        tabindex: -1
      },
      children: this.children
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), Cn({
      view: this
    });
    for (const t of this._focusables)
      this.focusTracker.add(t.element);
    this.keystrokes.listenTo(this.element);
    const e = (t) => t.stopPropagation();
    this.keystrokes.set("arrowright", e), this.keystrokes.set("arrowleft", e), this.keystrokes.set("arrowup", e), this.keystrokes.set("arrowdown", e);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  /**
   * Focuses the first {@link #_focusables focusable} in the form.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
}
function eM(i) {
  return "focusCycler" in i;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Es extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageInsertUI";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Ae];
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this._integrations = /* @__PURE__ */ new Map(), e.config.define("image.insert.integrations", [
      "upload",
      "assetManager",
      "url"
    ]);
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model.document.selection, n = e.plugins.get("ImageUtils");
    this.set("isImageSelected", !1), this.listenTo(e.model.document, "change", () => {
      this.isImageSelected = n.isImage(t.getSelectedElement());
    });
    const s = (o) => this._createToolbarComponent(o);
    e.ui.componentFactory.add("insertImage", s), e.ui.componentFactory.add("imageInsert", s);
  }
  /**
   * Registers the insert image dropdown integration.
   */
  registerIntegration({ name: e, observable: t, buttonViewCreator: n, formViewCreator: s, requiresForm: o }) {
    this._integrations.has(e) && D("image-insert-integration-exists", { name: e }), this._integrations.set(e, {
      observable: t,
      buttonViewCreator: n,
      formViewCreator: s,
      requiresForm: !!o
    });
  }
  /**
   * Creates the toolbar component.
   */
  _createToolbarComponent(e) {
    const t = this.editor, n = e.t, s = this._prepareIntegrations();
    if (!s.length)
      return null;
    let o;
    const r = s[0];
    if (s.length == 1) {
      if (!r.requiresForm)
        return r.buttonViewCreator(!0);
      o = r.buttonViewCreator(!0);
    } else {
      const c = r.buttonViewCreator(!1);
      o = new sr(e, c), o.tooltip = !0, o.bind("label").to(this, "isImageSelected", (u) => n(u ? "Replace image" : "Insert image"));
    }
    const a = this.dropdownView = we(e, o), l = s.map(({ observable: c }) => typeof c == "function" ? c() : c);
    return a.bind("isEnabled").toMany(l, "isEnabled", (...c) => c.some((u) => u)), a.once("change:isOpen", () => {
      const c = s.map(({ formViewCreator: d }) => d(s.length == 1)), u = new Y6(t.locale, c);
      a.panelView.children.add(u);
    }), a;
  }
  /**
   * Validates the integrations list.
   */
  _prepareIntegrations() {
    const t = this.editor.config.get("image.insert.integrations"), n = [];
    if (!t.length)
      return D("image-insert-integrations-not-specified"), n;
    for (const s of t) {
      if (!this._integrations.has(s)) {
        ["upload", "assetManager", "url"].includes(s) || D("image-insert-unknown-integration", { item: s });
        continue;
      }
      n.push(this._integrations.get(s));
    }
    return n.length || D("image-insert-integrations-not-registered"), n;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class tM extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [fb, gi, ab, Es];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageBlock";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class nM extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [cb, ub, Ae, hb, Ze];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageInlineEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model.schema;
    t.register("imageInline", {
      inheritAllFrom: "$inlineObject",
      allowAttributes: ["alt", "src", "srcset"]
    }), t.addChildCheck((n, s) => {
      if (n.endsWith("caption") && s.name === "imageInline")
        return !1;
    }), this._setupConversion(), e.plugins.has("ImageBlockEditing") && (e.commands.add("imageTypeInline", new db(this.editor, "imageInline")), this._setupClipboardIntegration());
  }
  /**
   * Configures conversion pipelines to support upcasting and downcasting
   * inline images (inline image widgets) and their attributes.
   */
  _setupConversion() {
    const e = this.editor, t = e.t, n = e.conversion, s = e.plugins.get("ImageUtils");
    n.for("dataDowncast").elementToElement({
      model: "imageInline",
      view: (o, { writer: r }) => r.createEmptyElement("img")
    }), n.for("editingDowncast").elementToStructure({
      model: "imageInline",
      view: (o, { writer: r }) => s.toImageWidget(N6(r), r, t("image widget"))
    }), n.for("downcast").add(Fo(s, "imageInline", "src")).add(Fo(s, "imageInline", "alt")).add(lb(s, "imageInline")), n.for("upcast").elementToElement({
      view: ob(e, "imageInline"),
      model: (o, { writer: r }) => r.createElement("imageInline", o.hasAttribute("src") ? { src: o.getAttribute("src") } : void 0)
    });
  }
  /**
   * Integrates the plugin with the clipboard pipeline.
   *
   * Idea is that the feature should recognize the user's intent when an **block** image is
   * pasted or dropped. If such an image is pasted/dropped into a non-empty block
   * (e.g. a paragraph with some text) it gets converted into an inline image on the fly.
   *
   * We assume this is the user's intent if they decided to put their image there.
   *
   * **Note**: If a block image has a caption, it will not be converted to an inline image
   * to avoid the confusion. Captions are added on purpose and they should never be lost
   * in the clipboard pipeline.
   *
   * See the `ImageBlockEditing` for the similar integration that works in the opposite direction.
   *
   * The feature also sets image `width` and `height` attributes when pasting.
   */
  _setupClipboardIntegration() {
    const e = this.editor, t = e.model, n = e.editing.view, s = e.plugins.get("ImageUtils"), o = e.plugins.get("ClipboardPipeline");
    this.listenTo(o, "inputTransformation", (r, a) => {
      const l = Array.from(a.content.getChildren());
      let c;
      if (!l.every(s.isBlockImageView))
        return;
      a.targetRanges ? c = e.editing.mapper.toModelRange(a.targetRanges[0]) : c = t.document.selection.getFirstRange();
      const u = t.createSelection(c);
      if (Jl(t.schema, u) === "imageInline") {
        const d = new Bt(n.document), h = l.map((f) => f.childCount === 1 ? (Array.from(f.getAttributes()).forEach((m) => d.setAttribute(...m, s.findViewImgElement(f))), f.getChild(0)) : f);
        a.content = d.createDocumentFragment(h);
      }
    }), this.listenTo(o, "contentInsertion", (r, a) => {
      a.method === "paste" && t.change((l) => {
        const c = l.createRangeIn(a.content);
        for (const u of c.getItems())
          u.is("element", "imageInline") && s.setImageNaturalSizeAttributes(u);
      });
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class iM extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [nM, gi, ab, Es];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageInline";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class sM extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [tM, iM];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Image";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class mb extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageCaptionUtils";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Ae];
  }
  /**
   * Returns the caption model element from a given image element. Returns `null` if no caption is found.
   */
  getCaptionFromImageModelElement(e) {
    for (const t of e.getChildren())
      if (t && t.is("element", "caption"))
        return t;
    return null;
  }
  /**
   * Returns the caption model element for a model selection. Returns `null` if the selection has no caption element ancestor.
   */
  getCaptionFromModelSelection(e) {
    const t = this.editor.plugins.get("ImageUtils"), n = e.getFirstPosition().findAncestor("caption");
    return n && t.isBlockImage(n.parent) ? n : null;
  }
  /**
   * {@link module:engine/view/matcher~Matcher} pattern. Checks if a given element is a `<figcaption>` element that is placed
   * inside the image `<figure>` element.
   * @returns Returns the object accepted by {@link module:engine/view/matcher~Matcher} or `null` if the element
   * cannot be matched.
   */
  matchImageCaptionViewElement(e) {
    const t = this.editor.plugins.get("ImageUtils");
    return e.name == "figcaption" && t.isBlockImageView(e.parent) ? { name: !0 } : null;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class oM extends V {
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor, t = e.plugins.get("ImageCaptionUtils"), n = e.plugins.get("ImageUtils");
    if (!e.plugins.has(fb)) {
      this.isEnabled = !1, this.value = !1;
      return;
    }
    const s = e.model.document.selection, o = s.getSelectedElement();
    if (!o) {
      const r = t.getCaptionFromModelSelection(s);
      this.isEnabled = !!r, this.value = !!r;
      return;
    }
    this.isEnabled = n.isImage(o), this.isEnabled ? this.value = !!t.getCaptionFromImageModelElement(o) : this.value = !1;
  }
  /**
   * Executes the command.
   *
   * ```ts
   * editor.execute( 'toggleImageCaption' );
   * ```
   *
   * @param options Options for the executed command.
   * @param options.focusCaptionOnShow When true and the caption shows up, the selection will be moved into it straight away.
   * @fires execute
   */
  execute(e = {}) {
    const { focusCaptionOnShow: t } = e;
    this.editor.model.change((n) => {
      this.value ? this._hideImageCaption(n) : this._showImageCaption(n, t);
    });
  }
  /**
   * Shows the caption of the `<imageBlock>` or `<imageInline>`. Also:
   *
   * * it converts `<imageInline>` to `<imageBlock>` to show the caption,
   * * it attempts to restore the caption content from the `ImageCaptionEditing` caption registry,
   * * it moves the selection to the caption right away, it the `focusCaptionOnShow` option was set.
   */
  _showImageCaption(e, t) {
    const s = this.editor.model.document.selection, o = this.editor.plugins.get("ImageCaptionEditing"), r = this.editor.plugins.get("ImageUtils");
    let a = s.getSelectedElement();
    const l = o._getSavedCaption(a);
    r.isInlineImage(a) && (this.editor.execute("imageTypeBlock"), a = s.getSelectedElement());
    const c = l || e.createElement("caption");
    e.append(c, a), t && e.setSelection(c, "in");
  }
  /**
   * Hides the caption of a selected image (or an image caption the selection is anchored to).
   *
   * The content of the caption is stored in the `ImageCaptionEditing` caption registry to make this
   * a reversible action.
   */
  _hideImageCaption(e) {
    const t = this.editor, n = t.model.document.selection, s = t.plugins.get("ImageCaptionEditing"), o = t.plugins.get("ImageCaptionUtils");
    let r = n.getSelectedElement(), a;
    r ? a = o.getCaptionFromImageModelElement(r) : (a = o.getCaptionFromModelSelection(n), r = a.parent), s._saveCaption(r, a), e.setSelection(r, "on"), e.remove(a);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class rM extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Ae, mb];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageCaptionEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this._savedCaptionsMap = /* @__PURE__ */ new WeakMap();
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model.schema;
    t.isRegistered("caption") ? t.extend("caption", {
      allowIn: "imageBlock"
    }) : t.register("caption", {
      allowIn: "imageBlock",
      allowContentOf: "$block",
      isLimit: !0
    }), e.commands.add("toggleImageCaption", new oM(this.editor)), this._setupConversion(), this._setupImageTypeCommandsIntegration(), this._registerCaptionReconversion();
  }
  /**
   * Configures conversion pipelines to support upcasting and downcasting
   * image captions.
   */
  _setupConversion() {
    const e = this.editor, t = e.editing.view, n = e.plugins.get("ImageUtils"), s = e.plugins.get("ImageCaptionUtils"), o = e.t;
    e.conversion.for("upcast").elementToElement({
      view: (r) => s.matchImageCaptionViewElement(r),
      model: "caption"
    }), e.conversion.for("dataDowncast").elementToElement({
      model: "caption",
      view: (r, { writer: a }) => n.isBlockImage(r.parent) ? a.createContainerElement("figcaption") : null
    }), e.conversion.for("editingDowncast").elementToElement({
      model: "caption",
      view: (r, { writer: a }) => {
        if (!n.isBlockImage(r.parent))
          return null;
        const l = a.createEditableElement("figcaption");
        a.setCustomProperty("imageCaption", !0, l), l.placeholder = o("Enter image caption"), hl({
          view: t,
          element: l,
          keepOnFocus: !0
        });
        const c = r.parent.getAttribute("alt"), u = c ? o("Caption for image: %0", [c]) : o("Caption for the image");
        return Ml(l, a, { label: u });
      }
    });
  }
  /**
   * Integrates with {@link module:image/image/imagetypecommand~ImageTypeCommand image type commands}
   * to make sure the caption is preserved when the type of an image changes so it can be restored
   * in the future if the user decides they want their caption back.
   */
  _setupImageTypeCommandsIntegration() {
    const e = this.editor, t = e.plugins.get("ImageUtils"), n = e.plugins.get("ImageCaptionUtils"), s = e.commands.get("imageTypeInline"), o = e.commands.get("imageTypeBlock"), r = (a) => {
      if (!a.return)
        return;
      const { oldElement: l, newElement: c } = a.return;
      /* istanbul ignore if: paranoid check -- @preserve */
      if (!l)
        return;
      if (t.isBlockImage(l)) {
        const d = n.getCaptionFromImageModelElement(l);
        if (d) {
          this._saveCaption(c, d);
          return;
        }
      }
      const u = this._getSavedCaption(l);
      u && this._saveCaption(c, u);
    };
    s && this.listenTo(s, "execute", r, { priority: "low" }), o && this.listenTo(o, "execute", r, { priority: "low" });
  }
  /**
   * Returns the saved {@link module:engine/model/element~Element#toJSON JSONified} caption
   * of an image model element.
   *
   * See {@link #_saveCaption}.
   *
   * @internal
   * @param imageModelElement The model element the caption should be returned for.
   * @returns The model caption element or `null` if there is none.
   */
  _getSavedCaption(e) {
    const t = this._savedCaptionsMap.get(e);
    return t ? $.fromJSON(t) : null;
  }
  /**
   * Saves a {@link module:engine/model/element~Element#toJSON JSONified} caption for
   * an image element to allow restoring it in the future.
   *
   * A caption is saved every time it gets hidden and/or the type of an image changes. The
   * user should be able to restore it on demand.
   *
   * **Note**: The caption cannot be stored in the image model element attribute because,
   * for instance, when the model state propagates to collaborators, the attribute would get
   * lost (mainly because it does not convert to anything when the caption is hidden) and
   * the states of collaborators' models would de-synchronize causing numerous issues.
   *
   * See {@link #_getSavedCaption}.
   *
   * @internal
   * @param imageModelElement The model element the caption is saved for.
   * @param caption The caption model element to be saved.
   */
  _saveCaption(e, t) {
    this._savedCaptionsMap.set(e, t.toJSON());
  }
  /**
   * Reconverts image caption when image alt attribute changes.
   * The change of alt attribute is reflected in caption's aria-label attribute.
   */
  _registerCaptionReconversion() {
    const e = this.editor, t = e.model, n = e.plugins.get("ImageUtils"), s = e.plugins.get("ImageCaptionUtils");
    t.document.on("change:data", () => {
      const o = t.document.differ.getChanges();
      for (const r of o) {
        if (r.attributeKey !== "alt")
          continue;
        const a = r.range.start.nodeAfter;
        if (n.isBlockImage(a)) {
          const l = s.getCaptionFromImageModelElement(a);
          if (!l)
            return;
          e.editing.reconvertItem(l);
        }
      }
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class aM extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [mb];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageCaptionUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.editing.view, n = e.plugins.get("ImageCaptionUtils"), s = e.t;
    e.ui.componentFactory.add("toggleImageCaption", (o) => {
      const r = e.commands.get("toggleImageCaption"), a = new P(o);
      return a.set({
        icon: A.caption,
        tooltip: !0,
        isToggleable: !0
      }), a.bind("isOn", "isEnabled").to(r, "value", "isEnabled"), a.bind("label").to(r, "value", (l) => s(l ? "Toggle caption off" : "Toggle caption on")), this.listenTo(a, "execute", () => {
        e.execute("toggleImageCaption", { focusCaptionOnShow: !0 });
        const l = n.getCaptionFromModelSelection(e.model.document.selection);
        if (l) {
          const c = e.editing.mapper.toViewElement(l);
          t.scrollToTheSelection(), t.change((u) => {
            u.addClass("image__caption_highlighted", c);
          });
        }
        e.editing.view.focus();
      }), a;
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class lM extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [rM, aM];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageCaption";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function gb(i) {
  const e = i.map((t) => t.replace("+", "\\+"));
  return new RegExp(`^image\\/(${e.join("|")})$`);
}
function cM(i) {
  return new Promise((e, t) => {
    const n = i.getAttribute("src");
    fetch(n).then((s) => s.blob()).then((s) => {
      const o = pb(s, n), a = `image.${o.replace("image/", "")}`, l = new File([s], a, { type: o });
      e(l);
    }).catch((s) => s && s.name === "TypeError" ? dM(n).then(e).catch(t) : t(s));
  });
}
function uM(i, e) {
  return !i.isInlineImageView(e) || !e.getAttribute("src") ? !1 : !!e.getAttribute("src").match(/^data:image\/\w+;base64,/g) || !!e.getAttribute("src").match(/^blob:/g);
}
function pb(i, e) {
  return i.type ? i.type : e.match(/data:(image\/\w+);base64/) ? e.match(/data:(image\/\w+);base64/)[1].toLowerCase() : "image/jpeg";
}
function dM(i) {
  return hM(i).then((e) => {
    const t = pb(e, i), s = `image.${t.replace("image/", "")}`;
    return new File([e], s, { type: t });
  });
}
function hM(i) {
  return new Promise((e, t) => {
    const n = E.document.createElement("img");
    n.addEventListener("load", () => {
      const s = E.document.createElement("canvas");
      s.width = n.width, s.height = n.height, s.getContext("2d").drawImage(n, 0, 0), s.toBlob((r) => r ? e(r) : t());
    }), n.addEventListener("error", () => t()), n.src = i;
  });
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class fM extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageUploadUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.t, n = () => {
      const s = this._createButton(kg);
      return s.set({
        label: t("Upload image from computer"),
        tooltip: !0
      }), s;
    };
    if (e.ui.componentFactory.add("uploadImage", n), e.ui.componentFactory.add("imageUpload", n), e.ui.componentFactory.add("menuBar:uploadImage", () => {
      const s = this._createButton(Jg);
      return s.label = t("Image from computer"), s;
    }), e.plugins.has("ImageInsertUI")) {
      const s = e.plugins.get("ImageInsertUI");
      s.registerIntegration({
        name: "upload",
        observable: () => e.commands.get("uploadImage"),
        buttonViewCreator: () => {
          const o = e.ui.componentFactory.create("uploadImage");
          return o.bind("label").to(s, "isImageSelected", (r) => t(r ? "Replace image from computer" : "Upload image from computer")), o;
        },
        formViewCreator: () => {
          const o = e.ui.componentFactory.create("uploadImage");
          return o.withText = !0, o.bind("label").to(s, "isImageSelected", (r) => t(r ? "Replace from computer" : "Upload from computer")), o.on("execute", () => {
            s.dropdownView.isOpen = !1;
          }), o;
        }
      });
    }
  }
  /**
   * Creates a button for image upload command to use either in toolbar or in menu bar.
   */
  _createButton(e) {
    const t = this.editor, n = t.locale, s = t.commands.get("uploadImage"), o = t.config.get("image.upload.types"), r = gb(o), a = new e(t.locale), l = n.t;
    return a.set({
      acceptedType: o.map((c) => `image/${c}`).join(","),
      allowMultipleFiles: !0,
      label: l("Upload image from computer"),
      icon: A.imageUpload
    }), a.bind("isEnabled").to(s), a.on("done", (c, u) => {
      const d = Array.from(u).filter((h) => r.test(h.type));
      d.length && (t.execute("uploadImage", { file: d }), t.editing.view.focus());
    }), a;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class mM extends U() {
  /**
   * Creates an instance of the FileReader.
   */
  constructor() {
    super();
    const e = new window.FileReader();
    this._reader = e, this._data = void 0, this.set("loaded", 0), e.onprogress = (t) => {
      this.loaded = t.loaded;
    };
  }
  /**
   * Returns error that occurred during file reading.
   */
  get error() {
    return this._reader.error;
  }
  /**
   * Holds the data of an already loaded file. The file must be first loaded
   * by using {@link module:upload/filereader~FileReader#read `read()`}.
   */
  get data() {
    return this._data;
  }
  /**
   * Reads the provided file.
   *
   * @param file Native File object.
   * @returns Returns a promise that will be resolved with file's content.
   * The promise will be rejected in case of an error or when the reading process is aborted.
   */
  read(e) {
    const t = this._reader;
    return this.total = e.size, new Promise((n, s) => {
      t.onload = () => {
        const o = t.result;
        this._data = o, n(o);
      }, t.onerror = () => {
        s("error");
      }, t.onabort = () => {
        s("aborted");
      }, this._reader.readAsDataURL(e);
    });
  }
  /**
   * Aborts file reader.
   */
  abort() {
    this._reader.abort();
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class un extends b {
  constructor() {
    super(...arguments), this.loaders = new ke(), this._loadersMap = /* @__PURE__ */ new Map(), this._pendingAction = null;
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "FileRepository";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Vu];
  }
  /**
   * @inheritDoc
   */
  init() {
    this.loaders.on("change", () => this._updatePendingAction()), this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (e, t) => t ? e / t * 100 : 0);
  }
  /**
   * Returns the loader associated with specified file or promise.
   *
   * To get loader by id use `fileRepository.loaders.get( id )`.
   *
   * @param fileOrPromise Native file or promise handle.
   */
  getLoader(e) {
    return this._loadersMap.get(e) || null;
  }
  /**
   * Creates a loader instance for the given file.
   *
   * Requires {@link #createUploadAdapter} factory to be defined.
   *
   * @param fileOrPromise Native File object or native Promise object which resolves to a File.
   */
  createLoader(e) {
    if (!this.createUploadAdapter)
      return D("filerepository-no-upload-adapter"), null;
    const t = new Dh(Promise.resolve(e), this.createUploadAdapter);
    return this.loaders.add(t), this._loadersMap.set(e, t), e instanceof Promise && t.file.then((n) => {
      this._loadersMap.set(n, t);
    }).catch(() => {
    }), t.on("change:uploaded", () => {
      let n = 0;
      for (const s of this.loaders)
        n += s.uploaded;
      this.uploaded = n;
    }), t.on("change:uploadTotal", () => {
      let n = 0;
      for (const s of this.loaders)
        s.uploadTotal && (n += s.uploadTotal);
      this.uploadTotal = n;
    }), t;
  }
  /**
   * Destroys the given loader.
   *
   * @param fileOrPromiseOrLoader File or Promise associated with that loader or loader itself.
   */
  destroyLoader(e) {
    const t = e instanceof Dh ? e : this.getLoader(e);
    t._destroy(), this.loaders.remove(t), this._loadersMap.forEach((n, s) => {
      n === t && this._loadersMap.delete(s);
    });
  }
  /**
   * Registers or deregisters pending action bound with upload progress.
   */
  _updatePendingAction() {
    const e = this.editor.plugins.get(Vu);
    if (this.loaders.length) {
      if (!this._pendingAction) {
        const t = this.editor.t, n = (s) => `${t("Upload in progress")} ${parseInt(s)}%.`;
        this._pendingAction = e.add(n(this.uploadedPercent)), this._pendingAction.bind("message").to(this, "uploadedPercent", n);
      }
    } else
      e.remove(this._pendingAction), this._pendingAction = null;
  }
}
class Dh extends U() {
  /**
   * Creates a new instance of `FileLoader`.
   *
   * @param filePromise A promise which resolves to a file instance.
   * @param uploadAdapterCreator The function which returns {@link module:upload/filerepository~UploadAdapter} instance.
   */
  constructor(e, t) {
    super(), this.id = je(), this._filePromiseWrapper = this._createFilePromiseWrapper(e), this._adapter = t(this), this._reader = new mM(), this.set("status", "idle"), this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (n, s) => s ? n / s * 100 : 0), this.set("uploadResponse", null);
  }
  /**
   * A `Promise` which resolves to a `File` instance associated with this file loader.
   */
  get file() {
    return this._filePromiseWrapper ? this._filePromiseWrapper.promise.then((e) => this._filePromiseWrapper ? e : null) : Promise.resolve(null);
  }
  /**
   * Returns the file data. To read its data, you need for first load the file
   * by using the {@link module:upload/filerepository~FileLoader#read `read()`} method.
   */
  get data() {
    return this._reader.data;
  }
  /**
   * Reads file using {@link module:upload/filereader~FileReader}.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `filerepository-read-wrong-status` when status
   * is different than `idle`.
   *
   * Example usage:
   *
   * ```ts
   * fileLoader.read()
   * 	.then( data => { ... } )
   * 	.catch( err => {
   * 		if ( err === 'aborted' ) {
   * 			console.log( 'Reading aborted.' );
   * 		} else {
   * 			console.log( 'Reading error.', err );
   * 		}
   * 	} );
   * ```
   *
   * @returns Returns promise that will be resolved with read data. Promise will be rejected if error
   * occurs or if read process is aborted.
   */
  read() {
    if (this.status != "idle")
      throw new g("filerepository-read-wrong-status", this);
    return this.status = "reading", this.file.then((e) => this._reader.read(e)).then((e) => {
      if (this.status !== "reading")
        throw this.status;
      return this.status = "idle", e;
    }).catch((e) => {
      throw e === "aborted" ? (this.status = "aborted", "aborted") : (this.status = "error", this._reader.error ? this._reader.error : e);
    });
  }
  /**
   * Reads file using the provided {@link module:upload/filerepository~UploadAdapter}.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `filerepository-upload-wrong-status` when status
   * is different than `idle`.
   * Example usage:
   *
   * ```ts
   * fileLoader.upload()
   * 	.then( data => { ... } )
   * 	.catch( e => {
   * 		if ( e === 'aborted' ) {
   * 			console.log( 'Uploading aborted.' );
   * 		} else {
   * 			console.log( 'Uploading error.', e );
   * 		}
   * 	} );
   * ```
   *
   * @returns Returns promise that will be resolved with response data. Promise will be rejected if error
   * occurs or if read process is aborted.
   */
  upload() {
    if (this.status != "idle")
      throw new g("filerepository-upload-wrong-status", this);
    return this.status = "uploading", this.file.then(() => this._adapter.upload()).then((e) => (this.uploadResponse = e, this.status = "idle", e)).catch((e) => {
      throw this.status === "aborted" ? "aborted" : (this.status = "error", e);
    });
  }
  /**
   * Aborts loading process.
   */
  abort() {
    const e = this.status;
    this.status = "aborted", this._filePromiseWrapper.isFulfilled ? e == "reading" ? this._reader.abort() : e == "uploading" && this._adapter.abort && this._adapter.abort() : (this._filePromiseWrapper.promise.catch(() => {
    }), this._filePromiseWrapper.rejecter("aborted")), this._destroy();
  }
  /**
   * Performs cleanup.
   *
   * @internal
   */
  _destroy() {
    this._filePromiseWrapper = void 0, this._reader = void 0, this._adapter = void 0, this.uploadResponse = void 0;
  }
  /**
   * Wraps a given file promise into another promise giving additional
   * control (resolving, rejecting, checking if fulfilled) over it.
   *
   * @param filePromise The initial file promise to be wrapped.
   */
  _createFilePromiseWrapper(e) {
    const t = {};
    return t.promise = new Promise((n, s) => {
      t.rejecter = s, t.isFulfilled = !1, e.then((o) => {
        t.isFulfilled = !0, n(o);
      }).catch((o) => {
        t.isFulfilled = !0, s(o);
      });
    }), t;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class gM extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [un];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Base64UploadAdapter";
  }
  /**
   * @inheritDoc
   */
  init() {
    this.editor.plugins.get(un).createUploadAdapter = (e) => new pM(e);
  }
}
class pM {
  /**
   * Creates a new adapter instance.
   */
  constructor(e) {
    this.loader = e;
  }
  /**
   * Starts the upload process.
   *
   * @see module:upload/filerepository~UploadAdapter#upload
   */
  upload() {
    return new Promise((e, t) => {
      const n = this.reader = new window.FileReader();
      n.addEventListener("load", () => {
        e({ default: n.result });
      }), n.addEventListener("error", (s) => {
        t(s);
      }), n.addEventListener("abort", () => {
        t();
      }), this.loader.file.then((s) => {
        n.readAsDataURL(s);
      });
    });
  }
  /**
   * Aborts the upload process.
   *
   * @see module:upload/filerepository~UploadAdapter#abort
   */
  abort() {
    this.reader.abort();
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class bM extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageUploadProgress";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.uploadStatusChange = (t, n, s) => {
      const o = this.editor, r = n.item, a = r.getAttribute("uploadId");
      if (!s.consumable.consume(n.item, t.name))
        return;
      const l = o.plugins.get("ImageUtils"), c = o.plugins.get(un), u = a ? n.attributeNewValue : null, d = this.placeholder, h = o.editing.mapper.toViewElement(r), f = s.writer;
      if (u == "reading") {
        zh(h, f), Hh(l, d, h, f);
        return;
      }
      if (u == "uploading") {
        const m = c.loaders.get(a);
        zh(h, f), m ? (Uh(h, f), _M(h, f, m, o.editing.view), TM(l, h, f, m)) : Hh(l, d, h, f);
        return;
      }
      u == "complete" && c.loaders.get(a) && yM(h, f, o.editing.view), vM(h, f), Uh(h, f), wM(h, f);
    }, this.placeholder = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor;
    e.plugins.has("ImageBlockEditing") && e.editing.downcastDispatcher.on("attribute:uploadStatus:imageBlock", this.uploadStatusChange), e.plugins.has("ImageInlineEditing") && e.editing.downcastDispatcher.on("attribute:uploadStatus:imageInline", this.uploadStatusChange);
  }
}
function zh(i, e) {
  i.hasClass("ck-appear") || e.addClass("ck-appear", i);
}
function wM(i, e) {
  e.removeClass("ck-appear", i);
}
function Hh(i, e, t, n) {
  t.hasClass("ck-image-upload-placeholder") || n.addClass("ck-image-upload-placeholder", t);
  const s = i.findViewImgElement(t);
  s.getAttribute("src") !== e && n.setAttribute("src", e, s), bb(t, "placeholder") || n.insert(n.createPositionAfter(s), kM(n));
}
function Uh(i, e) {
  i.hasClass("ck-image-upload-placeholder") && e.removeClass("ck-image-upload-placeholder", i), wb(i, e, "placeholder");
}
function _M(i, e, t, n) {
  const s = CM(e);
  e.insert(e.createPositionAt(i, "end"), s), t.on("change:uploadedPercent", (o, r, a) => {
    n.change((l) => {
      l.setStyle("width", a + "%", s);
    });
  });
}
function vM(i, e) {
  wb(i, e, "progressBar");
}
function yM(i, e, t) {
  const n = e.createUIElement("div", { class: "ck-image-upload-complete-icon" });
  e.insert(e.createPositionAt(i, "end"), n), setTimeout(() => {
    t.change((s) => s.remove(s.createRangeOn(n)));
  }, 3e3);
}
function CM(i) {
  const e = i.createUIElement("div", { class: "ck-progress-bar" });
  return i.setCustomProperty("progressBar", !0, e), e;
}
function kM(i) {
  const e = i.createUIElement("div", { class: "ck-upload-placeholder-loader" });
  return i.setCustomProperty("placeholder", !0, e), e;
}
function bb(i, e) {
  for (const t of i.getChildren())
    if (t.getCustomProperty(e))
      return t;
}
function wb(i, e, t) {
  const n = bb(i, t);
  n && e.remove(e.createRangeOn(n));
}
function TM(i, e, t, n) {
  if (n.data) {
    const s = i.findViewImgElement(e);
    t.setAttribute("src", n.data, s);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class EM extends V {
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor, t = e.plugins.get("ImageUtils"), n = e.model.document.selection.getSelectedElement();
    this.isEnabled = t.isImageAllowed() || t.isImage(n);
  }
  /**
   * Executes the command.
   *
   * @fires execute
   * @param options Options for the executed command.
   * @param options.file The image file or an array of image files to upload.
   */
  execute(e) {
    const t = Z(e.file), n = this.editor.model.document.selection, s = this.editor.plugins.get("ImageUtils"), o = Object.fromEntries(n.getAttributes());
    t.forEach((r, a) => {
      const l = n.getSelectedElement();
      if (a && l && s.isImage(l)) {
        const c = this.editor.model.createPositionAfter(l);
        this._uploadImage(r, o, c);
      } else
        this._uploadImage(r, o);
    });
  }
  /**
   * Handles uploading single file.
   */
  _uploadImage(e, t, n) {
    const s = this.editor, r = s.plugins.get(un).createLoader(e), a = s.plugins.get("ImageUtils");
    r && a.insertImage({ ...t, uploadId: r.id }, n);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class AM extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [un, gd, Ze, Ae];
  }
  static get pluginName() {
    return "ImageUploadEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), e.config.define("image", {
      upload: {
        types: ["jpeg", "png", "gif", "bmp", "webp", "tiff"]
      }
    }), this._uploadImageElements = /* @__PURE__ */ new Map();
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model.document, n = e.conversion, s = e.plugins.get(un), o = e.plugins.get("ImageUtils"), r = e.plugins.get("ClipboardPipeline"), a = gb(e.config.get("image.upload.types")), l = new EM(e);
    e.commands.add("uploadImage", l), e.commands.add("imageUpload", l), n.for("upcast").attributeToAttribute({
      view: {
        name: "img",
        key: "uploadId"
      },
      model: "uploadId"
    }), this.listenTo(e.editing.view.document, "clipboardInput", (c, u) => {
      if (xM(u.dataTransfer))
        return;
      const d = Array.from(u.dataTransfer.files).filter((h) => h ? a.test(h.type) : !1);
      d.length && (c.stop(), e.model.change((h) => {
        u.targetRanges && h.setSelection(u.targetRanges.map((f) => e.editing.mapper.toModelRange(f))), e.execute("uploadImage", { file: d });
      }));
    }), this.listenTo(r, "inputTransformation", (c, u) => {
      const d = Array.from(e.editing.view.createRangeIn(u.content)).map((f) => f.item).filter((f) => uM(o, f) && !f.getAttribute("uploadProcessed")).map((f) => ({ promise: cM(f), imageElement: f }));
      if (!d.length)
        return;
      const h = new Bt(e.editing.view.document);
      for (const f of d) {
        h.setAttribute("uploadProcessed", !0, f.imageElement);
        const m = s.createLoader(f.promise);
        m && (h.setAttribute("src", "", f.imageElement), h.setAttribute("uploadId", m.id, f.imageElement));
      }
    }), e.editing.view.document.on("dragover", (c, u) => {
      u.preventDefault();
    }), t.on("change", () => {
      const c = t.differ.getChanges({ includeChangesInGraveyard: !0 }).reverse(), u = /* @__PURE__ */ new Set();
      for (const d of c)
        if (d.type == "insert" && d.name != "$text") {
          const h = d.position.nodeAfter, f = d.position.root.rootName == "$graveyard";
          for (const m of IM(e, h)) {
            const p = m.getAttribute("uploadId");
            if (!p)
              continue;
            const w = s.loaders.get(p);
            w && (f ? u.has(p) || w.abort() : (u.add(p), this._uploadImageElements.set(p, m), w.status == "idle" && this._readAndUpload(w)));
          }
        }
    }), this.on("uploadComplete", (c, { imageElement: u, data: d }) => {
      const h = d.urls ? d.urls : d;
      this.editor.model.change((f) => {
        f.setAttribute("src", h.default, u), this._parseAndSetSrcsetAttributeOnImage(h, u, f), o.setImageNaturalSizeAttributes(u);
      });
    }, { priority: "low" });
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    const e = this.editor.model.schema;
    this.editor.plugins.has("ImageBlockEditing") && e.extend("imageBlock", {
      allowAttributes: ["uploadId", "uploadStatus"]
    }), this.editor.plugins.has("ImageInlineEditing") && e.extend("imageInline", {
      allowAttributes: ["uploadId", "uploadStatus"]
    });
  }
  /**
   * Reads and uploads an image.
   *
   * The image is read from the disk and as a Base64-encoded string it is set temporarily to
   * `image[src]`. When the image is successfully uploaded, the temporary data is replaced with the target
   * image's URL (the URL to the uploaded image on the server).
   */
  _readAndUpload(e) {
    const t = this.editor, n = t.model, s = t.locale.t, o = t.plugins.get(un), r = t.plugins.get(gd), a = t.plugins.get("ImageUtils"), l = this._uploadImageElements;
    return n.enqueueChange({ isUndoable: !1 }, (u) => {
      u.setAttribute("uploadStatus", "reading", l.get(e.id));
    }), e.read().then(() => {
      const u = e.upload(), d = l.get(e.id);
      /* istanbul ignore next -- @preserve */
      if (M.isSafari) {
        const h = t.editing.mapper.toViewElement(d), f = a.findViewImgElement(h);
        t.editing.view.once("render", () => {
          if (!f.parent)
            return;
          const m = t.editing.view.domConverter.mapViewToDom(f.parent);
          if (!m)
            return;
          const p = m.style.display;
          m.style.display = "none", m._ckHack = m.offsetHeight, m.style.display = p;
        });
      }
      return t.ui && t.ui.ariaLiveAnnouncer.announce(s("Uploading image")), n.enqueueChange({ isUndoable: !1 }, (h) => {
        h.setAttribute("uploadStatus", "uploading", d);
      }), u;
    }).then((u) => {
      n.enqueueChange({ isUndoable: !1 }, (d) => {
        const h = l.get(e.id);
        d.setAttribute("uploadStatus", "complete", h), t.ui && t.ui.ariaLiveAnnouncer.announce(s("Image upload complete")), this.fire("uploadComplete", { data: u, imageElement: h });
      }), c();
    }).catch((u) => {
      if (t.ui && t.ui.ariaLiveAnnouncer.announce(s("Error during image upload")), e.status !== "error" && e.status !== "aborted")
        throw u;
      e.status == "error" && u && r.showWarning(u, {
        title: s("Upload failed"),
        namespace: "upload"
      }), n.enqueueChange({ isUndoable: !1 }, (d) => {
        d.remove(l.get(e.id));
      }), c();
    });
    function c() {
      n.enqueueChange({ isUndoable: !1 }, (u) => {
        const d = l.get(e.id);
        u.removeAttribute("uploadId", d), u.removeAttribute("uploadStatus", d), l.delete(e.id);
      }), o.destroyLoader(e);
    }
  }
  /**
   * Creates the `srcset` attribute based on a given file upload response and sets it as an attribute to a specific image element.
   *
   * @param data Data object from which `srcset` will be created.
   * @param image The image element on which the `srcset` attribute will be set.
   */
  _parseAndSetSrcsetAttributeOnImage(e, t, n) {
    let s = 0;
    const o = Object.keys(e).filter((r) => {
      const a = parseInt(r, 10);
      if (!isNaN(a))
        return s = Math.max(s, a), !0;
    }).map((r) => `${e[r]} ${r}w`).join(", ");
    if (o != "") {
      const r = {
        srcset: o
      };
      !t.hasAttribute("width") && !t.hasAttribute("height") && (r.width = s), n.setAttributes(r, t);
    }
  }
}
function xM(i) {
  return Array.from(i.types).includes("text/html") && i.getData("text/html") !== "";
}
function IM(i, e) {
  const t = i.plugins.get("ImageUtils");
  return Array.from(i.model.createRangeOn(e)).filter((n) => t.isImage(n.item)).map((n) => n.item);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class _b extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageUpload";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [AM, fM, bM];
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class SM extends T {
  /**
   * Creates a view for the dropdown panel of {@link module:image/imageinsert/imageinsertui~ImageInsertUI}.
   *
   * @param locale The localization services instance.
   */
  constructor(e) {
    super(e), this.set("imageURLInputValue", ""), this.set("isImageSelected", !1), this.set("isEnabled", !0), this.focusTracker = new X(), this.keystrokes = new ie(), this._focusables = new ve(), this.focusCycler = new ge({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    }), this.urlInputView = this._createUrlInputView(), this.insertButtonView = this._createInsertButton(), this.cancelButtonView = this._createCancelButton(), this._focusables.addMany([
      this.urlInputView,
      this.insertButtonView,
      this.cancelButtonView
    ]), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-image-insert-url"
        ]
      },
      children: [
        this.urlInputView,
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-image-insert-url__action-row"
            ]
          },
          children: [
            this.insertButtonView,
            this.cancelButtonView
          ]
        }
      ]
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    for (const e of this._focusables)
      this.focusTracker.add(e.element);
    this.keystrokes.listenTo(this.element);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  /**
   * Creates the {@link #urlInputView}.
   */
  _createUrlInputView() {
    const e = this.locale, t = e.t, n = new ue(e, He);
    return n.bind("label").to(this, "isImageSelected", (s) => t(s ? "Update image URL" : "Insert image via URL")), n.bind("isEnabled").to(this), n.fieldView.placeholder = "https://example.com/image.png", n.fieldView.bind("value").to(this, "imageURLInputValue", (s) => s || ""), n.fieldView.on("input", () => {
      this.imageURLInputValue = n.fieldView.element.value.trim();
    }), n;
  }
  /**
   * Creates the {@link #insertButtonView}.
   */
  _createInsertButton() {
    const e = this.locale, t = e.t, n = new P(e);
    return n.set({
      icon: A.check,
      class: "ck-button-save",
      type: "submit",
      withText: !0
    }), n.bind("label").to(this, "isImageSelected", (s) => t(s ? "Update" : "Insert")), n.bind("isEnabled").to(this, "imageURLInputValue", this, "isEnabled", (...s) => s.every((o) => o)), n.delegate("execute").to(this, "submit"), n;
  }
  /**
   * Creates the {@link #cancelButtonView}.
   */
  _createCancelButton() {
    const e = this.locale, t = e.t, n = new P(e);
    return n.set({
      label: t("Cancel"),
      icon: A.cancel,
      class: "ck-button-cancel",
      withText: !0
    }), n.bind("isEnabled").to(this), n.delegate("execute").to(this, "cancel"), n;
  }
  /**
   * Focuses the view.
   */
  focus(e) {
    e === -1 ? this.focusCycler.focusLast() : this.focusCycler.focusFirst();
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class PM extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageInsertViaUrlUI";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Es];
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    this._imageInsertUI = this.editor.plugins.get("ImageInsertUI"), this._imageInsertUI.registerIntegration({
      name: "url",
      observable: () => this.editor.commands.get("insertImage"),
      requiresForm: !0,
      buttonViewCreator: (e) => this._createInsertUrlButton(e),
      formViewCreator: (e) => this._createInsertUrlView(e)
    });
  }
  /**
   * Creates the view displayed in the dropdown.
   */
  _createInsertUrlView(e) {
    const t = this.editor, n = t.locale, s = n.t, o = t.commands.get("replaceImageSource"), r = t.commands.get("insertImage"), a = new SM(n), l = e ? null : new Tg(n, [a]);
    return a.bind("isImageSelected").to(this._imageInsertUI), a.bind("isEnabled").toMany([r, o], "isEnabled", (...c) => c.some((u) => u)), a.imageURLInputValue = o.value || "", this._imageInsertUI.dropdownView.on("change:isOpen", () => {
      this._imageInsertUI.dropdownView.isOpen && (a.imageURLInputValue = o.value || "", l && (l.isCollapsed = !0));
    }, { priority: "low" }), a.on("submit", () => {
      o.isEnabled ? t.execute("replaceImageSource", { source: a.imageURLInputValue }) : t.execute("insertImage", { source: a.imageURLInputValue }), this._closePanel();
    }), a.on("cancel", () => this._closePanel()), l ? (l.set({
      isCollapsed: !0
    }), l.bind("label").to(this._imageInsertUI, "isImageSelected", (c) => s(c ? "Update image URL" : "Insert image via URL")), l) : a;
  }
  /**
   * Creates the toolbar button.
   */
  _createInsertUrlButton(e) {
    const t = e ? xl : P, n = this.editor, s = new t(n.locale), o = n.locale.t;
    return s.set({
      icon: A.imageUrl,
      tooltip: !0
    }), s.bind("label").to(this._imageInsertUI, "isImageSelected", (r) => o(r ? "Update image URL" : "Insert image via URL")), s;
  }
  /**
   * Closes the dropdown.
   */
  _closePanel() {
    this.editor.editing.view.focus(), this._imageInsertUI.dropdownView.isOpen = !1;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class RM extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageInsertViaUrl";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [PM, Es];
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class VM extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageInsert";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [_b, RM, Es];
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class MM extends V {
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor, n = e.plugins.get("ImageUtils").getClosestSelectedImageElement(e.model.document.selection);
    this.isEnabled = !!n, !n || !n.hasAttribute("resizedWidth") ? this.value = null : this.value = {
      width: n.getAttribute("resizedWidth"),
      height: null
    };
  }
  /**
   * Executes the command.
   *
   * ```ts
   * // Sets the width to 50%:
   * editor.execute( 'resizeImage', { width: '50%' } );
   *
   * // Removes the width attribute:
   * editor.execute( 'resizeImage', { width: null } );
   * ```
   *
   * @param options
   * @param options.width The new width of the image.
   * @fires execute
   */
  execute(e) {
    const t = this.editor, n = t.model, s = t.plugins.get("ImageUtils"), o = s.getClosestSelectedImageElement(n.document.selection);
    this.value = {
      width: e.width,
      height: null
    }, o && n.change((r) => {
      r.setAttribute("resizedWidth", e.width, o), r.removeAttribute("resizedHeight", o), s.setImageNaturalSizeAttributes(o);
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class vb extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Ae];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageResizeEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), e.config.define("image", {
      resizeUnit: "%",
      resizeOptions: [
        {
          name: "resizeImage:original",
          value: null,
          icon: "original"
        },
        {
          name: "resizeImage:custom",
          value: "custom",
          icon: "custom"
        },
        {
          name: "resizeImage:25",
          value: "25",
          icon: "small"
        },
        {
          name: "resizeImage:50",
          value: "50",
          icon: "medium"
        },
        {
          name: "resizeImage:75",
          value: "75",
          icon: "large"
        }
      ]
    });
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = new MM(e);
    this._registerConverters("imageBlock"), this._registerConverters("imageInline"), e.commands.add("resizeImage", t), e.commands.add("imageResize", t);
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    this._registerSchema();
  }
  _registerSchema() {
    this.editor.plugins.has("ImageBlockEditing") && this.editor.model.schema.extend("imageBlock", { allowAttributes: ["resizedWidth", "resizedHeight"] }), this.editor.plugins.has("ImageInlineEditing") && this.editor.model.schema.extend("imageInline", { allowAttributes: ["resizedWidth", "resizedHeight"] });
  }
  /**
   * Registers image resize converters.
   *
   * @param imageType The type of the image.
   */
  _registerConverters(e) {
    const t = this.editor, n = t.plugins.get("ImageUtils");
    t.conversion.for("downcast").add((s) => s.on(`attribute:resizedWidth:${e}`, (o, r, a) => {
      if (!a.consumable.consume(r.item, o.name))
        return;
      const l = a.writer, c = a.mapper.toViewElement(r.item);
      r.attributeNewValue !== null ? (l.setStyle("width", r.attributeNewValue, c), l.addClass("image_resized", c)) : (l.removeStyle("width", c), l.removeClass("image_resized", c));
    })), t.conversion.for("dataDowncast").attributeToAttribute({
      model: {
        name: e,
        key: "resizedHeight"
      },
      view: (s) => ({
        key: "style",
        value: {
          height: s
        }
      })
    }), t.conversion.for("editingDowncast").add((s) => s.on(`attribute:resizedHeight:${e}`, (o, r, a) => {
      if (!a.consumable.consume(r.item, o.name))
        return;
      const l = a.writer, c = a.mapper.toViewElement(r.item), u = e === "imageInline" ? n.findViewImgElement(c) : c;
      r.attributeNewValue !== null ? l.setStyle("height", r.attributeNewValue, u) : l.removeStyle("height", u);
    })), t.conversion.for("upcast").attributeToAttribute({
      view: {
        name: e === "imageBlock" ? "figure" : "img",
        styles: {
          width: /.+/
        }
      },
      model: {
        key: "resizedWidth",
        value: (s) => Oo(s) ? null : s.getStyle("width")
      }
    }), t.conversion.for("upcast").attributeToAttribute({
      view: {
        name: e === "imageBlock" ? "figure" : "img",
        styles: {
          height: /.+/
        }
      },
      model: {
        key: "resizedHeight",
        value: (s) => Oo(s) ? null : s.getStyle("height")
      }
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Wr = {
  small: A.objectSizeSmall,
  medium: A.objectSizeMedium,
  large: A.objectSizeLarge,
  custom: A.objectSizeCustom,
  original: A.objectSizeFull
};
class BM extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [vb];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageResizeButtons";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this._resizeUnit = e.config.get("image.resizeUnit");
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.config.get("image.resizeOptions"), n = e.commands.get("resizeImage");
    this.bind("isEnabled").to(n);
    for (const s of t)
      this._registerImageResizeButton(s);
    this._registerImageResizeDropdown(t);
  }
  /**
   * A helper function that creates a standalone button component for the plugin.
   *
   * @param resizeOption A model of the resize option.
   */
  _registerImageResizeButton(e) {
    const t = this.editor, { name: n, value: s, icon: o } = e;
    t.ui.componentFactory.add(n, (r) => {
      const a = new P(r), l = t.commands.get("resizeImage"), c = this._getOptionLabelValue(e, !0);
      if (!Wr[o])
        throw new g("imageresizebuttons-missing-icon", t, e);
      if (a.set({
        // Use the `label` property for a verbose description (because of ARIA).
        label: c,
        icon: Wr[o],
        tooltip: c,
        isToggleable: !0
      }), a.bind("isEnabled").to(this), t.plugins.has("ImageCustomResizeUI") && Si(e)) {
        const u = t.plugins.get("ImageCustomResizeUI");
        this.listenTo(a, "execute", () => {
          u._showForm(this._resizeUnit);
        });
      } else {
        const u = s ? s + this._resizeUnit : null;
        a.bind("isOn").to(l, "value", za(u)), this.listenTo(a, "execute", () => {
          t.execute("resizeImage", { width: u });
        });
      }
      return a;
    });
  }
  /**
   * A helper function that creates a dropdown component for the plugin containing all the resize options defined in
   * the editor configuration.
   *
   * @param options An array of configured options.
   */
  _registerImageResizeDropdown(e) {
    const t = this.editor, n = t.t, s = e.find((r) => !r.value), o = (r) => {
      const a = t.commands.get("resizeImage"), l = we(r, xl), c = l.buttonView, u = n("Resize image");
      return c.set({
        tooltip: u,
        commandValue: s.value,
        icon: Wr.medium,
        isToggleable: !0,
        label: this._getOptionLabelValue(s),
        withText: !0,
        class: "ck-resize-image-button",
        ariaLabel: u,
        ariaLabelledBy: void 0
      }), c.bind("label").to(a, "value", (d) => d && d.width ? d.width : this._getOptionLabelValue(s)), l.bind("isEnabled").to(this), Kt(l, () => this._getResizeDropdownListItemDefinitions(e, a), {
        ariaLabel: n("Image resize list"),
        role: "menu"
      }), this.listenTo(l, "execute", (d) => {
        "onClick" in d.source ? d.source.onClick() : (t.execute(d.source.commandName, { width: d.source.commandValue }), t.editing.view.focus());
      }), l;
    };
    t.ui.componentFactory.add("resizeImage", o), t.ui.componentFactory.add("imageResize", o);
  }
  /**
   * A helper function for creating an option label value string.
   *
   * @param option A resize option object.
   * @param forTooltip An optional flag for creating a tooltip label.
   * @returns A user-defined label combined from the numeric value and the resize unit or the default label
   * for reset options (`Original`).
   */
  _getOptionLabelValue(e, t = !1) {
    const n = this.editor.t;
    return e.label ? e.label : t ? Si(e) ? n("Custom image size") : e.value ? n("Resize image to %0", e.value + this._resizeUnit) : n("Resize image to the original size") : Si(e) ? n("Custom") : e.value ? e.value + this._resizeUnit : n("Original");
  }
  /**
   * A helper function that parses the resize options and returns list item definitions ready for use in the dropdown.
   *
   * @param options The resize options.
   * @param command The resize image command.
   * @returns Dropdown item definitions.
   */
  _getResizeDropdownListItemDefinitions(e, t) {
    const { editor: n } = this, s = new ke(), o = e.map((r) => Si(r) ? {
      ...r,
      valueWithUnits: "custom"
    } : r.value ? {
      ...r,
      valueWithUnits: `${r.value}${this._resizeUnit}`
    } : {
      ...r,
      valueWithUnits: null
    });
    for (const r of o) {
      let a = null;
      if (n.plugins.has("ImageCustomResizeUI") && Si(r)) {
        const l = n.plugins.get("ImageCustomResizeUI");
        a = {
          type: "button",
          model: new $t({
            label: this._getOptionLabelValue(r),
            role: "menuitemradio",
            withText: !0,
            icon: null,
            onClick: () => {
              l._showForm(this._resizeUnit);
            }
          })
        };
        const c = Wy(o, "valueWithUnits");
        a.model.bind("isOn").to(t, "value", LM(c));
      } else
        a = {
          type: "button",
          model: new $t({
            commandName: "resizeImage",
            commandValue: r.valueWithUnits,
            label: this._getOptionLabelValue(r),
            role: "menuitemradio",
            withText: !0,
            icon: null
          })
        }, a.model.bind("isOn").to(t, "value", za(r.valueWithUnits));
      a.model.bind("isEnabled").to(t, "isEnabled"), s.add(a);
    }
    return s;
  }
}
function Si(i) {
  return i.value === "custom";
}
function za(i) {
  return (e) => {
    const t = e;
    return i === null && t === i ? !0 : t !== null && t.width === i;
  };
}
function LM(i) {
  return (e) => !i.some((t) => za(t)(e));
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const OM = "figure.image.ck-widget > img,figure.image.ck-widget > picture > img,figure.image.ck-widget > a > img,figure.image.ck-widget > a > picture > img,span.image-inline.ck-widget > img,span.image-inline.ck-widget > picture > img", qr = "image_resized";
class FM extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Nr, Ae];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageResizeHandles";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor.commands.get("resizeImage");
    this.bind("isEnabled").to(e), this._setupResizerCreator();
  }
  /**
   * Attaches the listeners responsible for creating a resizer for each image, except for images inside the HTML embed preview.
   */
  _setupResizerCreator() {
    const e = this.editor, t = e.editing.view, n = e.plugins.get("ImageUtils");
    t.addObserver(Ql), this.listenTo(t.document, "imageLoaded", (s, o) => {
      if (!o.target.matches(OM))
        return;
      const r = e.editing.view.domConverter, a = r.domToView(o.target), l = n.getImageWidgetFromImageView(a);
      let c = this.editor.plugins.get(Nr).getResizerByViewElement(l);
      if (c) {
        c.redraw();
        return;
      }
      const u = e.editing.mapper, d = u.toModelElement(l);
      c = e.plugins.get(Nr).attachTo({
        unit: e.config.get("image.resizeUnit"),
        modelElement: d,
        viewElement: l,
        editor: e,
        getHandleHost(h) {
          return h.querySelector("img");
        },
        getResizeHost() {
          return r.mapViewToDom(u.toViewElement(d));
        },
        isCentered() {
          return d.getAttribute("imageStyle") == "alignCenter";
        },
        onCommit(h) {
          t.change((f) => {
            f.removeClass(qr, l);
          }), e.execute("resizeImage", { width: h });
        }
      }), c.on("updateSize", () => {
        l.hasClass(qr) || t.change((f) => {
          f.addClass(qr, l);
        });
        const h = d.name === "imageInline" ? a : l;
        h.getStyle("height") && t.change((f) => {
          f.removeStyle("height", h);
        });
      }), c.bind("isEnabled").to(this);
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function yb(i) {
  if (!i)
    return null;
  const [, e, t] = i.trim().match(/([.,\d]+)(%|px)$/) || [], n = Number.parseFloat(e);
  return Number.isNaN(n) ? null : {
    value: n,
    unit: t
  };
}
function Cb(i, e, t) {
  return t === "px" ? {
    value: e.value,
    unit: "px"
  } : {
    value: e.value / i * 100,
    unit: "%"
  };
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function kb(i) {
  const { editing: e } = i, n = i.plugins.get("ImageUtils").getClosestSelectedImageElement(i.model.document.selection);
  if (!n)
    return null;
  const s = e.mapper.toViewElement(n), o = e.view.domConverter.mapViewToDom(s);
  return {
    model: n,
    view: s,
    dom: o
  };
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function NM(i, e) {
  const t = kb(i);
  if (!t)
    return null;
  const n = yb(t.model.getAttribute("resizedWidth") || null);
  if (!n)
    return null;
  if (n.unit === e)
    return n;
  const s = Ll(t.dom), o = {
    unit: "px",
    value: new B(t.dom).width
  };
  return Cb(s, o, e);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class DM extends T {
  /**
   * @inheritDoc
   */
  constructor(e, t, n) {
    super(e);
    const s = this.locale.t;
    this.focusTracker = new X(), this.keystrokes = new ie(), this.unit = t, this.labeledInput = this._createLabeledInputView(), this.saveButtonView = this._createButton(s("Save"), A.check, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(s("Cancel"), A.cancel, "ck-button-cancel", "cancel"), this._focusables = new ve(), this._validators = n, this._focusCycler = new ge({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    }), this.setTemplate({
      tag: "form",
      attributes: {
        class: [
          "ck",
          "ck-image-custom-resize-form",
          "ck-responsive-form"
        ],
        // https://github.com/ckeditor/ckeditor5-image/issues/40
        tabindex: "-1"
      },
      children: [
        this.labeledInput,
        this.saveButtonView,
        this.cancelButtonView
      ]
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.keystrokes.listenTo(this.element), Cn({ view: this }), [this.labeledInput, this.saveButtonView, this.cancelButtonView].forEach((e) => {
      this._focusables.add(e), this.focusTracker.add(e.element);
    });
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  /**
   * Creates the button view.
   *
   * @param label The button label
   * @param icon The button's icon.
   * @param className The additional button CSS class name.
   * @param eventName The event name that the ButtonView#execute event will be delegated to.
   * @returns The button view instance.
   */
  _createButton(e, t, n, s) {
    const o = new P(this.locale);
    return o.set({
      label: e,
      icon: t,
      tooltip: !0
    }), o.extendTemplate({
      attributes: {
        class: n
      }
    }), s && o.delegate("execute").to(this, s), o;
  }
  /**
   * Creates an input with a label.
   *
   * @returns Labeled field view instance.
   */
  _createLabeledInputView() {
    const e = this.locale.t, t = new ue(this.locale, Ax);
    return t.label = e("Resize image (in %0)", this.unit), t.fieldView.set({
      step: 0.1
    }), t;
  }
  /**
   * Validates the form and returns `false` when some fields are invalid.
   */
  isValid() {
    this.resetFormStatus();
    for (const e of this._validators) {
      const t = e(this);
      if (t)
        return this.labeledInput.errorText = t, !1;
    }
    return !0;
  }
  /**
   * Cleans up the supplementary error and information text of the {@link #labeledInput}
   * bringing them back to the state when the form has been displayed for the first time.
   *
   * See {@link #isValid}.
   */
  resetFormStatus() {
    this.labeledInput.errorText = null;
  }
  /**
   * The native DOM `value` of the input element of {@link #labeledInput}.
   */
  get rawSize() {
    const { element: e } = this.labeledInput.fieldView;
    return e ? e.value : null;
  }
  /**
   * Get numeric value of size. Returns `null` if value of size input element in {@link #labeledInput}.is not a number.
   */
  get parsedSize() {
    const { rawSize: e } = this;
    if (e === null)
      return null;
    const t = Number.parseFloat(e);
    return Number.isNaN(t) ? null : t;
  }
  /**
   * Returns serialized image input size with unit.
   * Returns `null` if value of size input element in {@link #labeledInput}.is not a number.
   */
  get sizeWithUnits() {
    const { parsedSize: e, unit: t } = this;
    return e === null ? null : `${e}${t}`;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function zM(i, e) {
  const t = kb(i);
  if (!t)
    return null;
  const n = Ll(t.dom), s = yb(window.getComputedStyle(t.dom).minWidth) || {
    value: 1,
    unit: "px"
  }, o = Math.max(0.1, Cb(n, s, e).value);
  return {
    unit: e,
    lower: o,
    upper: e === "px" ? n : 100
  };
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class HM extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Rt];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageCustomResizeUI";
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this._form && this._form.destroy();
  }
  /**
   * Creates the {@link module:image/imageresize/ui/imagecustomresizeformview~ImageCustomResizeFormView}
   * form.
   */
  _createForm(e) {
    const t = this.editor;
    this._balloon = this.editor.plugins.get("ContextualBalloon"), this._form = new (tr(DM))(t.locale, e, UM(t)), this._form.render(), this.listenTo(this._form, "submit", () => {
      this._form.isValid() && (t.execute("resizeImage", {
        width: this._form.sizeWithUnits
      }), this._hideForm(!0));
    }), this.listenTo(this._form.labeledInput, "change:errorText", () => {
      t.ui.update();
    }), this.listenTo(this._form, "cancel", () => {
      this._hideForm(!0);
    }), this._form.keystrokes.set("Esc", (n, s) => {
      this._hideForm(!0), s();
    }), yn({
      emitter: this._form,
      activator: () => this._isVisible,
      contextElements: () => [this._balloon.view.element],
      callback: () => this._hideForm()
    });
  }
  /**
   * Shows the {@link #_form} in the {@link #_balloon}.
   *
   * @internal
   */
  _showForm(e) {
    if (this._isVisible)
      return;
    this._form || this._createForm(e);
    const t = this.editor, n = this._form.labeledInput;
    this._form.disableCssTransitions(), this._form.resetFormStatus(), this._isInBalloon || this._balloon.add({
      view: this._form,
      position: Xl(t)
    });
    const s = NM(t, e), o = s ? s.value.toFixed(1) : "", r = zM(t, e);
    n.fieldView.value = n.fieldView.element.value = o, r && Object.assign(n.fieldView, {
      min: r.lower.toFixed(1),
      max: Math.ceil(r.upper).toFixed(1)
    }), this._form.labeledInput.fieldView.select(), this._form.enableCssTransitions();
  }
  /**
   * Removes the {@link #_form} from the {@link #_balloon}.
   *
   * @param focusEditable Controls whether the editing view is focused afterwards.
   */
  _hideForm(e = !1) {
    this._isInBalloon && (this._form.focusTracker.isFocused && this._form.saveButtonView.focus(), this._balloon.remove(this._form), e && this.editor.editing.view.focus());
  }
  /**
   * Returns `true` when the {@link #_form} is the visible view in the {@link #_balloon}.
   */
  get _isVisible() {
    return !!this._balloon && this._balloon.visibleView === this._form;
  }
  /**
   * Returns `true` when the {@link #_form} is in the {@link #_balloon}.
   */
  get _isInBalloon() {
    return !!this._balloon && this._balloon.hasView(this._form);
  }
}
function UM(i) {
  const e = i.t;
  return [
    (t) => {
      if (t.rawSize.trim() === "")
        return e("The value must not be empty.");
      if (t.parsedSize === null)
        return e("The value should be a plain number.");
    }
  ];
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class $M extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [vb, FM, HM, BM];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageResize";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class WM extends V {
  /**
   * Creates an instance of the image style command. When executed, the command applies one of
   * {@link module:image/imageconfig~ImageStyleConfig#options style options} to the currently selected image.
   *
   * @param editor The editor instance.
   * @param styles The style options that this command supports.
   */
  constructor(e, t) {
    super(e), this._defaultStyles = {
      imageBlock: !1,
      imageInline: !1
    }, this._styles = new Map(t.map((n) => {
      if (n.isDefault)
        for (const s of n.modelElements)
          this._defaultStyles[s] = n.name;
      return [n.name, n];
    }));
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const n = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
    this.isEnabled = !!n, this.isEnabled ? n.hasAttribute("imageStyle") ? this.value = n.getAttribute("imageStyle") : this.value = this._defaultStyles[n.name] : this.value = !1;
  }
  /**
   * Executes the command and applies the style to the currently selected image:
   *
   * ```ts
   * editor.execute( 'imageStyle', { value: 'side' } );
   * ```
   *
   * **Note**: Executing this command may change the image model element if the desired style requires an image
   * of a different type. Learn more about {@link module:image/imageconfig~ImageStyleOptionDefinition#modelElements model element}
   * configuration for the style option.
   *
   * @param options.value The name of the style (as configured in {@link module:image/imageconfig~ImageStyleConfig#options}).
   * @param options.setImageSizes Specifies whether the image `width` and `height` attributes should be set automatically.
   * The default is `true`.
   * @fires execute
   */
  execute(e = {}) {
    const t = this.editor, n = t.model, s = t.plugins.get("ImageUtils");
    n.change((o) => {
      const r = e.value, { setImageSizes: a = !0 } = e;
      let l = s.getClosestSelectedImageElement(n.document.selection);
      r && this.shouldConvertImageType(r, l) && (this.editor.execute(s.isBlockImage(l) ? "imageTypeInline" : "imageTypeBlock", { setImageSizes: a }), l = s.getClosestSelectedImageElement(n.document.selection)), !r || this._styles.get(r).isDefault ? o.removeAttribute("imageStyle", l) : o.setAttribute("imageStyle", r, l), a && s.setImageNaturalSizeAttributes(l);
    });
  }
  /**
   * Returns `true` if requested style change would trigger the image type change.
   *
   * @param requestedStyle The name of the style (as configured in {@link module:image/imageconfig~ImageStyleConfig#options}).
   * @param imageElement The image model element.
   */
  shouldConvertImageType(e, t) {
    return !this._styles.get(e).modelElements.includes(t.name);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const { objectFullWidth: qM, objectInline: Tb, objectLeft: Eb, objectRight: Ha, objectCenter: Ua, objectBlockLeft: Ab, objectBlockRight: xb } = A, ho = {
  // This style represents an image placed in the line of text.
  get inline() {
    return {
      name: "inline",
      title: "In line",
      icon: Tb,
      modelElements: ["imageInline"],
      isDefault: !0
    };
  },
  // This style represents an image aligned to the left and wrapped with text.
  get alignLeft() {
    return {
      name: "alignLeft",
      title: "Left aligned image",
      icon: Eb,
      modelElements: ["imageBlock", "imageInline"],
      className: "image-style-align-left"
    };
  },
  // This style represents an image aligned to the left.
  get alignBlockLeft() {
    return {
      name: "alignBlockLeft",
      title: "Left aligned image",
      icon: Ab,
      modelElements: ["imageBlock"],
      className: "image-style-block-align-left"
    };
  },
  // This style represents a centered image.
  get alignCenter() {
    return {
      name: "alignCenter",
      title: "Centered image",
      icon: Ua,
      modelElements: ["imageBlock"],
      className: "image-style-align-center"
    };
  },
  // This style represents an image aligned to the right and wrapped with text.
  get alignRight() {
    return {
      name: "alignRight",
      title: "Right aligned image",
      icon: Ha,
      modelElements: ["imageBlock", "imageInline"],
      className: "image-style-align-right"
    };
  },
  // This style represents an image aligned to the right.
  get alignBlockRight() {
    return {
      name: "alignBlockRight",
      title: "Right aligned image",
      icon: xb,
      modelElements: ["imageBlock"],
      className: "image-style-block-align-right"
    };
  },
  // This option is equal to the situation when no style is applied.
  get block() {
    return {
      name: "block",
      title: "Centered image",
      icon: Ua,
      modelElements: ["imageBlock"],
      isDefault: !0
    };
  },
  // This represents a side image.
  get side() {
    return {
      name: "side",
      title: "Side image",
      icon: Ha,
      modelElements: ["imageBlock"],
      className: "image-style-side"
    };
  }
}, Ib = {
  full: qM,
  left: Ab,
  right: xb,
  center: Ua,
  inlineLeft: Eb,
  inlineRight: Ha,
  inline: Tb
}, Sb = [{
  name: "imageStyle:wrapText",
  title: "Wrap text",
  defaultItem: "imageStyle:alignLeft",
  items: ["imageStyle:alignLeft", "imageStyle:alignRight"]
}, {
  name: "imageStyle:breakText",
  title: "Break text",
  defaultItem: "imageStyle:block",
  items: ["imageStyle:alignBlockLeft", "imageStyle:block", "imageStyle:alignBlockRight"]
}];
function GM(i) {
  return (i.configuredStyles.options || []).map((n) => ZM(n)).filter((n) => JM(n, i));
}
function jM(i, e) {
  return i && e ? {
    options: [
      "inline",
      "alignLeft",
      "alignRight",
      "alignCenter",
      "alignBlockLeft",
      "alignBlockRight",
      "block",
      "side"
    ]
  } : i ? {
    options: ["block", "side"]
  } : e ? {
    options: ["inline", "alignLeft", "alignRight"]
  } : {};
}
function KM(i) {
  return i.has("ImageBlockEditing") && i.has("ImageInlineEditing") ? [...Sb] : [];
}
function ZM(i) {
  return typeof i == "string" ? ho[i] ? i = { ...ho[i] } : i = { name: i } : i = XM(ho[i.name], i), typeof i.icon == "string" && (i.icon = Ib[i.icon] || i.icon), i;
}
function JM(i, { isBlockPluginLoaded: e, isInlinePluginLoaded: t }) {
  const { modelElements: n, name: s } = i;
  if (!n || !n.length || !s)
    return Pb({ style: i }), !1;
  {
    const o = [e ? "imageBlock" : null, t ? "imageInline" : null];
    if (!n.some((r) => o.includes(r)))
      return D("image-style-missing-dependency", {
        style: i,
        missingPlugins: n.map((r) => r === "imageBlock" ? "ImageBlockEditing" : "ImageInlineEditing")
      }), !1;
  }
  return !0;
}
function XM(i, e) {
  const t = { ...e };
  for (const n in i)
    Object.prototype.hasOwnProperty.call(e, n) || (t[n] = i[n]);
  return t;
}
function Pb(i) {
  D("image-style-configuration-definition-invalid", i);
}
const $a = {
  normalizeStyles: GM,
  getDefaultStylesConfiguration: jM,
  getDefaultDropdownDefinitions: KM,
  warnInvalidStyle: Pb,
  DEFAULT_OPTIONS: ho,
  DEFAULT_ICONS: Ib,
  DEFAULT_DROPDOWN_DEFINITIONS: Sb
};
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function QM(i) {
  return (e, t, n) => {
    if (!n.consumable.consume(t.item, e.name))
      return;
    const s = $h(t.attributeNewValue, i), o = $h(t.attributeOldValue, i), r = n.mapper.toViewElement(t.item), a = n.writer;
    o && a.removeClass(o.className, r), s && a.addClass(s.className, r);
  };
}
function YM(i) {
  const e = {
    imageInline: i.filter((t) => !t.isDefault && t.modelElements.includes("imageInline")),
    imageBlock: i.filter((t) => !t.isDefault && t.modelElements.includes("imageBlock"))
  };
  return (t, n, s) => {
    if (!n.modelRange)
      return;
    const o = n.viewItem, r = me(n.modelRange.getItems());
    if (r && s.schema.checkAttribute(r, "imageStyle"))
      for (const a of e[r.name])
        s.consumable.consume(o, { classes: a.className }) && s.writer.setAttribute("imageStyle", a.name, r);
  };
}
function $h(i, e) {
  for (const t of e)
    if (t.name === i)
      return t;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Rb extends b {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageStyleEditing";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Ae];
  }
  /**
   * @inheritDoc
   */
  init() {
    const { normalizeStyles: e, getDefaultStylesConfiguration: t } = $a, n = this.editor, s = n.plugins.has("ImageBlockEditing"), o = n.plugins.has("ImageInlineEditing");
    n.config.define("image.styles", t(s, o)), this.normalizedStyles = e({
      configuredStyles: n.config.get("image.styles"),
      isBlockPluginLoaded: s,
      isInlinePluginLoaded: o
    }), this._setupConversion(s, o), this._setupPostFixer(), n.commands.add("imageStyle", new WM(n, this.normalizedStyles));
  }
  /**
   * Sets the editor conversion taking the presence of
   * {@link module:image/image/imageinlineediting~ImageInlineEditing `ImageInlineEditing`}
   * and {@link module:image/image/imageblockediting~ImageBlockEditing `ImageBlockEditing`} plugins into consideration.
   */
  _setupConversion(e, t) {
    const n = this.editor, s = n.model.schema, o = QM(this.normalizedStyles), r = YM(this.normalizedStyles);
    n.editing.downcastDispatcher.on("attribute:imageStyle", o), n.data.downcastDispatcher.on("attribute:imageStyle", o), e && (s.extend("imageBlock", { allowAttributes: "imageStyle" }), n.data.upcastDispatcher.on("element:figure", r, { priority: "low" })), t && (s.extend("imageInline", { allowAttributes: "imageStyle" }), n.data.upcastDispatcher.on("element:img", r, { priority: "low" }));
  }
  /**
   * Registers a post-fixer that will make sure that the style attribute value is correct for a specific image type (block vs inline).
   */
  _setupPostFixer() {
    const e = this.editor, t = e.model.document, n = e.plugins.get(Ae), s = new Map(this.normalizedStyles.map((o) => [o.name, o]));
    t.registerPostFixer((o) => {
      let r = !1;
      for (const a of t.differ.getChanges())
        if (a.type == "insert" || a.type == "attribute" && a.attributeKey == "imageStyle") {
          let l = a.type == "insert" ? a.position.nodeAfter : a.range.start.nodeAfter;
          if (l && l.is("element", "paragraph") && l.childCount > 0 && (l = l.getChild(0)), !n.isImage(l))
            continue;
          const c = l.getAttribute("imageStyle");
          if (!c)
            continue;
          const u = s.get(c);
          (!u || !u.modelElements.includes(l.name)) && (o.removeAttribute("imageStyle", l), r = !0);
        }
      return r;
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class eB extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Rb];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageStyleUI";
  }
  /**
   * Returns the default localized style titles provided by the plugin.
   *
   * The following localized titles corresponding with
   * {@link module:image/imagestyle/utils#DEFAULT_OPTIONS} are available:
   *
   * * `'Wrap text'`,
   * * `'Break text'`,
   * * `'In line'`,
   * * `'Full size image'`,
   * * `'Side image'`,
   * * `'Left aligned image'`,
   * * `'Centered image'`,
   * * `'Right aligned image'`
   */
  get localizedDefaultStylesTitles() {
    const e = this.editor.t;
    return {
      "Wrap text": e("Wrap text"),
      "Break text": e("Break text"),
      "In line": e("In line"),
      "Full size image": e("Full size image"),
      "Side image": e("Side image"),
      "Left aligned image": e("Left aligned image"),
      "Centered image": e("Centered image"),
      "Right aligned image": e("Right aligned image")
    };
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor.plugins, t = this.editor.config.get("image.toolbar") || [], n = e.get("ImageStyleEditing"), s = Wh(n.normalizedStyles, this.localizedDefaultStylesTitles);
    for (const r of s)
      this._createButton(r);
    const o = Wh([
      ...t.filter(J),
      ...$a.getDefaultDropdownDefinitions(e)
    ], this.localizedDefaultStylesTitles);
    for (const r of o)
      this._createDropdown(r, s);
  }
  /**
   * Creates a dropdown and stores it in the editor {@link module:ui/componentfactory~ComponentFactory}.
   */
  _createDropdown(e, t) {
    const n = this.editor.ui.componentFactory;
    n.add(e.name, (s) => {
      let o;
      const { defaultItem: r, items: a, title: l } = e, c = a.filter((f) => t.find(({ name: m }) => qh(m) === f)).map((f) => {
        const m = n.create(f);
        return f === r && (o = m), m;
      });
      a.length !== c.length && $a.warnInvalidStyle({ dropdown: e });
      const u = we(s, sr), d = u.buttonView, h = d.arrowView;
      return or(u, c, { enableActiveItemFocusOnDropdownOpen: !0 }), d.set({
        label: Gh(l, o.label),
        class: null,
        tooltip: !0
      }), h.unbind("label"), h.set({
        label: l
      }), d.bind("icon").toMany(c, "isOn", (...f) => {
        const m = f.findIndex(Dt);
        return m < 0 ? o.icon : c[m].icon;
      }), d.bind("label").toMany(c, "isOn", (...f) => {
        const m = f.findIndex(Dt);
        return Gh(l, m < 0 ? o.label : c[m].label);
      }), d.bind("isOn").toMany(c, "isOn", (...f) => f.some(Dt)), d.bind("class").toMany(c, "isOn", (...f) => f.some(Dt) ? "ck-splitbutton_flatten" : void 0), d.on("execute", () => {
        c.some(({ isOn: f }) => f) ? u.isOpen = !u.isOpen : o.fire("execute");
      }), u.bind("isEnabled").toMany(c, "isEnabled", (...f) => f.some(Dt)), this.listenTo(u, "execute", () => {
        this.editor.editing.view.focus();
      }), u;
    });
  }
  /**
   * Creates a button and stores it in the editor {@link module:ui/componentfactory~ComponentFactory}.
   */
  _createButton(e) {
    const t = e.name;
    this.editor.ui.componentFactory.add(qh(t), (n) => {
      const s = this.editor.commands.get("imageStyle"), o = new P(n);
      return o.set({
        label: e.title,
        icon: e.icon,
        tooltip: !0,
        isToggleable: !0
      }), o.bind("isEnabled").to(s, "isEnabled"), o.bind("isOn").to(s, "value", (r) => r === t), o.on("execute", this._executeCommand.bind(this, t)), o;
    });
  }
  _executeCommand(e) {
    this.editor.execute("imageStyle", { value: e }), this.editor.editing.view.focus();
  }
}
function Wh(i, e) {
  for (const t of i)
    e[t.title] && (t.title = e[t.title]);
  return i;
}
function qh(i) {
  return `imageStyle:${i}`;
}
function Gh(i, e) {
  return (i ? i + ": " : "") + e;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class tB extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Rb, eB];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageStyle";
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class nB extends b {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [So, Ae];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageToolbar";
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    const e = this.editor, t = e.t, n = e.plugins.get(So), s = e.plugins.get("ImageUtils");
    n.register("image", {
      ariaLabel: t("Image toolbar"),
      items: iB(e.config.get("image.toolbar") || []),
      getRelatedElement: (o) => s.getClosestSelectedImageWidget(o)
    });
  }
}
function iB(i) {
  return i.map((e) => J(e) ? e.name : e);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class sB extends yI {
  /**
   * Creates an instance of the classic editor UI class.
   *
   * @param editor The editor instance.
   * @param view The view of the UI.
   */
  constructor(e, t) {
    super(e), this.view = t, this._toolbarConfig = Fg(e.config.get("toolbar")), this._elementReplacer = new aC(), this.listenTo(e.editing.view, "scrollToTheSelection", this._handleScrollToTheSelectionWithStickyPanel.bind(this));
  }
  /**
   * @inheritDoc
   */
  get element() {
    return this.view.element;
  }
  /**
   * Initializes the UI.
   *
   * @param replacementElement The DOM element that will be the source for the created editor.
   */
  init(e) {
    const t = this.editor, n = this.view, s = t.editing.view, o = n.editable, r = s.document.getRoot();
    o.name = r.rootName, n.render();
    const a = o.element;
    this.setEditableElement(o.name, a), n.editable.bind("isFocused").to(this.focusTracker), s.attachDomRoot(a), e && this._elementReplacer.replace(e, this.element), this._initPlaceholder(), this._initToolbar(), n.menuBarView && GI(t, n.menuBarView), this._initDialogPluginIntegration(), this.fire("ready");
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    const e = this.view, t = this.editor.editing.view;
    this._elementReplacer.restore(), t.detachDomRoot(e.editable.name), e.destroy();
  }
  /**
   * Initializes the editor toolbar.
   */
  _initToolbar() {
    const e = this.view;
    e.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused"), e.stickyPanel.limiterElement = e.element, e.stickyPanel.bind("viewportTopOffset").to(this, "viewportOffset", ({ top: t }) => t || 0), e.toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory), this.addToolbar(e.toolbar);
  }
  /**
   * Enable the placeholder text on the editing root.
   */
  _initPlaceholder() {
    const e = this.editor, t = e.editing.view, n = t.document.getRoot(), s = e.sourceElement;
    let o;
    const r = e.config.get("placeholder");
    r && (o = typeof r == "string" ? r : r[this.view.editable.name]), !o && s && s.tagName.toLowerCase() === "textarea" && (o = s.getAttribute("placeholder")), o && (n.placeholder = o), hl({
      view: t,
      element: n,
      isDirectHost: !1,
      keepOnFocus: !0
    });
  }
  /**
   * Provides an integration between the sticky toolbar and {@link module:utils/dom/scroll~scrollViewportToShowTarget}.
   * It allows the UI-agnostic engine method to consider the geometry of the
   * {@link module:editor-classic/classiceditoruiview~ClassicEditorUIView#stickyPanel} that pins to the
   * edge of the viewport and can obscure the user caret after scrolling the window.
   *
   * @param evt The `scrollToTheSelection` event info.
   * @param data The payload carried by the `scrollToTheSelection` event.
   * @param originalArgs The original arguments passed to `scrollViewportToShowTarget()` method (see implementation to learn more).
   */
  _handleScrollToTheSelectionWithStickyPanel(e, t, n) {
    const s = this.view.stickyPanel;
    if (s.isSticky) {
      const o = new B(s.element).height;
      t.viewportOffset.top += o;
    } else {
      const o = () => {
        this.editor.editing.view.scrollToTheSelection(n);
      };
      this.listenTo(s, "change:isSticky", o), setTimeout(() => {
        this.stopListening(s, "change:isSticky", o);
      }, 20);
    }
  }
  /**
   * Provides an integration between the sticky toolbar and {@link module:ui/dialog/dialog the Dialog plugin}.
   *
   * It moves the dialog down to ensure that the
   * {@link module:editor-classic/classiceditoruiview~ClassicEditorUIView#stickyPanel sticky panel}
   * used by the editor UI will not get obscured by the dialog when the dialog uses one of its automatic positions.
   */
  _initDialogPluginIntegration() {
    if (!this.editor.plugins.has("Dialog"))
      return;
    const e = this.view.stickyPanel, t = this.editor.plugins.get("Dialog");
    t.on("show", () => {
      const n = t.view;
      n.on("moveTo", (s, o) => {
        if (!e.isSticky || n.wasMoved)
          return;
        const r = new B(e.contentPanelElement);
        o[1] < r.bottom + si.defaultOffset && (o[1] = r.bottom + si.defaultOffset);
      }, { priority: "high" });
    }, { priority: "low" });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class oB extends kI {
  /**
   * Creates an instance of the classic editor UI view.
   *
   * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
   * @param editingView The editing view instance this view is related to.
   * @param options Configuration options for the view instance.
   * @param options.shouldToolbarGroupWhenFull When set `true` enables automatic items grouping
   * in the main {@link module:editor-classic/classiceditoruiview~ClassicEditorUIView#toolbar toolbar}.
   * See {@link module:ui/toolbar/toolbarview~ToolbarOptions#shouldGroupWhenFull} to learn more.
   */
  constructor(e, t, n = {}) {
    super(e), this.stickyPanel = new II(e), this.toolbar = new ni(e, {
      shouldGroupWhenFull: n.shouldToolbarGroupWhenFull
    }), n.useMenuBar && (this.menuBarView = new KI(e)), this.editable = new EI(e, t);
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.menuBarView ? this.stickyPanel.content.addMany([this.menuBarView, this.toolbar]) : this.stickyPanel.content.add(this.toolbar), this.top.add(this.stickyPanel), this.main.add(this.editable);
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Vb {
  /**
   * @param {module:watchdog/watchdog~WatchdogConfig} config The watchdog plugin configuration.
   */
  constructor(e) {
    if (this.crashes = [], this.state = "initializing", this._now = Date.now, this.crashes = [], this._crashNumberLimit = typeof e.crashNumberLimit == "number" ? e.crashNumberLimit : 3, this._minimumNonErrorTimePeriod = typeof e.minimumNonErrorTimePeriod == "number" ? e.minimumNonErrorTimePeriod : 5e3, this._boundErrorHandler = (t) => {
      const n = "error" in t ? t.error : t.reason;
      n instanceof Error && this._handleError(n, t);
    }, this._listeners = {}, !this._restart)
      throw new Error("The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.");
  }
  /**
   * Destroys the watchdog and releases the resources.
   */
  destroy() {
    this._stopErrorHandling(), this._listeners = {};
  }
  /**
   * Starts listening to a specific event name by registering a callback that will be executed
   * whenever an event with a given name fires.
   *
   * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.
   *
   * @param eventName The event name.
   * @param callback A callback which will be added to event listeners.
   */
  on(e, t) {
    this._listeners[e] || (this._listeners[e] = []), this._listeners[e].push(t);
  }
  /**
   * Stops listening to the specified event name by removing the callback from event listeners.
   *
   * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.
   *
   * @param eventName The event name.
   * @param callback A callback which will be removed from event listeners.
   */
  off(e, t) {
    this._listeners[e] = this._listeners[e].filter((n) => n !== t);
  }
  /**
   * Fires an event with a given event name and arguments.
   *
   * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.
   */
  _fire(e, ...t) {
    const n = this._listeners[e] || [];
    for (const s of n)
      s.apply(this, [null, ...t]);
  }
  /**
   * Starts error handling by attaching global error handlers.
   */
  _startErrorHandling() {
    window.addEventListener("error", this._boundErrorHandler), window.addEventListener("unhandledrejection", this._boundErrorHandler);
  }
  /**
   * Stops error handling by detaching global error handlers.
   */
  _stopErrorHandling() {
    window.removeEventListener("error", this._boundErrorHandler), window.removeEventListener("unhandledrejection", this._boundErrorHandler);
  }
  /**
   * Checks if an error comes from the watched item and restarts it.
   * It reacts to {@link module:utils/ckeditorerror~CKEditorError `CKEditorError` errors} only.
   *
   * @fires error
   * @param error Error.
   * @param evt An error event.
   */
  _handleError(e, t) {
    if (this._shouldReactToError(e)) {
      this.crashes.push({
        message: e.message,
        stack: e.stack,
        // `evt.filename`, `evt.lineno` and `evt.colno` are available only in ErrorEvent events
        filename: t instanceof ErrorEvent ? t.filename : void 0,
        lineno: t instanceof ErrorEvent ? t.lineno : void 0,
        colno: t instanceof ErrorEvent ? t.colno : void 0,
        date: this._now()
      });
      const n = this._shouldRestart();
      this.state = "crashed", this._fire("stateChange"), this._fire("error", { error: e, causesRestart: n }), n ? this._restart() : (this.state = "crashedPermanently", this._fire("stateChange"));
    }
  }
  /**
   * Checks whether an error should be handled by the watchdog.
   *
   * @param error An error that was caught by the error handling process.
   */
  _shouldReactToError(e) {
    return e.is && e.is("CKEditorError") && e.context !== void 0 && // In some cases the watched item should not be restarted - e.g. during the item initialization.
    // That's why the `null` was introduced as a correct error context which does cause restarting.
    e.context !== null && // Do not react to errors if the watchdog is in states other than `ready`.
    this.state === "ready" && this._isErrorComingFromThisItem(e);
  }
  /**
   * Checks if the watchdog should restart the underlying item.
   */
  _shouldRestart() {
    if (this.crashes.length <= this._crashNumberLimit)
      return !0;
    const e = this.crashes[this.crashes.length - 1].date, t = this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date;
    return (e - t) / this._crashNumberLimit > this._minimumNonErrorTimePeriod;
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Wa(i, e = /* @__PURE__ */ new Set()) {
  const t = [i], n = /* @__PURE__ */ new Set();
  let s = 0;
  for (; t.length > s; ) {
    const o = t[s++];
    if (!(n.has(o) || !rB(o) || e.has(o)))
      if (n.add(o), Symbol.iterator in o)
        try {
          for (const r of o)
            t.push(r);
        } catch (r) {
        }
      else
        for (const r in o)
          r !== "defaultValue" && t.push(o[r]);
  }
  return n;
}
function rB(i) {
  const e = Object.prototype.toString.call(i), t = typeof i;
  return !(t === "number" || t === "boolean" || t === "string" || t === "symbol" || t === "function" || e === "[object Date]" || e === "[object RegExp]" || e === "[object Module]" || i === void 0 || i === null || // This flag is meant to exclude singletons shared across editor instances. So when an error is thrown in one editor,
  // the other editors connected through the reference to the same singleton are not restarted. This is a temporary workaround
  // until a better solution is found.
  // More in https://github.com/ckeditor/ckeditor5/issues/12292.
  i._watchdogExcluded || // Skip native DOM objects, e.g. Window, nodes, events, etc.
  i instanceof EventTarget || i instanceof Event);
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Mb(i, e, t = /* @__PURE__ */ new Set()) {
  if (i === e && aB(i))
    return !0;
  const n = Wa(i, t), s = Wa(e, t);
  for (const o of n)
    if (s.has(o))
      return !0;
  return !1;
}
function aB(i) {
  return typeof i == "object" && i !== null;
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Bb extends Vb {
  /**
   * @param Editor The editor class.
   * @param watchdogConfig The watchdog plugin configuration.
   */
  constructor(e, t = {}) {
    super(t), this._editor = null, this._lifecyclePromise = null, this._initUsingData = !0, this._editables = {}, this._throttledSave = Xn(this._save.bind(this), typeof t.saveInterval == "number" ? t.saveInterval : 5e3), e && (this._creator = (n, s) => e.create(n, s)), this._destructor = (n) => n.destroy();
  }
  /**
   * The current editor instance.
   */
  get editor() {
    return this._editor;
  }
  /**
   * @internal
   */
  get _item() {
    return this._editor;
  }
  /**
   * Sets the function that is responsible for the editor creation.
   * It expects a function that should return a promise.
   *
   * ```ts
   * watchdog.setCreator( ( element, config ) => ClassicEditor.create( element, config ) );
   * ```
   */
  setCreator(e) {
    this._creator = e;
  }
  /**
   * Sets the function that is responsible for the editor destruction.
   * Overrides the default destruction function, which destroys only the editor instance.
   * It expects a function that should return a promise or `undefined`.
   *
   * ```ts
   * watchdog.setDestructor( editor => {
   * 	// Do something before the editor is destroyed.
   *
   * 	return editor
   * 		.destroy()
   * 		.then( () => {
   * 			// Do something after the editor is destroyed.
   * 		} );
   * } );
   * ```
   */
  setDestructor(e) {
    this._destructor = e;
  }
  /**
   * Restarts the editor instance. This method is called whenever an editor error occurs. It fires the `restart` event and changes
   * the state to `initializing`.
   *
   * @fires restart
   */
  _restart() {
    return Promise.resolve().then(() => (this.state = "initializing", this._fire("stateChange"), this._destroy())).catch((e) => {
      console.error("An error happened during the editor destroying.", e);
    }).then(() => {
      const e = {}, t = [], n = this._config.rootsAttributes || {}, s = {};
      for (const [r, a] of Object.entries(this._data.roots))
        a.isLoaded ? (e[r] = "", s[r] = n[r] || {}) : t.push(r);
      const o = {
        ...this._config,
        extraPlugins: this._config.extraPlugins || [],
        lazyRoots: t,
        rootsAttributes: s,
        _watchdogInitialData: this._data
      };
      return delete o.initialData, o.extraPlugins.push(lB), this._initUsingData ? this.create(e, o, o.context) : fn(this._elementOrData) ? this.create(this._elementOrData, o, o.context) : this.create(this._editables, o, o.context);
    }).then(() => {
      this._fire("restart");
    });
  }
  /**
   * Creates the editor instance and keeps it running, using the defined creator and destructor.
   *
   * @param elementOrData The editor source element or the editor data.
   * @param config The editor configuration.
   * @param context A context for the editor.
   */
  create(e = this._elementOrData, t = this._config, n) {
    return this._lifecyclePromise = Promise.resolve(this._lifecyclePromise).then(() => (super._startErrorHandling(), this._elementOrData = e, this._initUsingData = typeof e == "string" || Object.keys(e).length > 0 && typeof Object.values(e)[0] == "string", this._config = this._cloneEditorConfiguration(t) || {}, this._config.context = n, this._creator(e, this._config))).then((s) => {
      this._editor = s, s.model.document.on("change:data", this._throttledSave), this._lastDocumentVersion = s.model.document.version, this._data = this._getData(), this._initUsingData || (this._editables = this._getEditables()), this.state = "ready", this._fire("stateChange");
    }).finally(() => {
      this._lifecyclePromise = null;
    }), this._lifecyclePromise;
  }
  /**
   * Destroys the watchdog and the current editor instance. It fires the callback
   * registered in {@link #setDestructor `setDestructor()`} and uses it to destroy the editor instance.
   * It also sets the state to `destroyed`.
   */
  destroy() {
    return this._lifecyclePromise = Promise.resolve(this._lifecyclePromise).then(() => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy())).finally(() => {
      this._lifecyclePromise = null;
    }), this._lifecyclePromise;
  }
  _destroy() {
    return Promise.resolve().then(() => {
      this._stopErrorHandling(), this._throttledSave.cancel();
      const e = this._editor;
      return this._editor = null, e.model.document.off("change:data", this._throttledSave), this._destructor(e);
    });
  }
  /**
   * Saves the editor data, so it can be restored after the crash even if the data cannot be fetched at
   * the moment of the crash.
   */
  _save() {
    const e = this._editor.model.document.version;
    try {
      this._data = this._getData(), this._initUsingData || (this._editables = this._getEditables()), this._lastDocumentVersion = e;
    } catch (t) {
      console.error(t, "An error happened during restoring editor data. Editor will be restored from the previously saved data.");
    }
  }
  /**
   * @internal
   */
  _setExcludedProperties(e) {
    this._excludedProps = e;
  }
  /**
   * Gets all data that is required to reinitialize editor instance.
   */
  _getData() {
    const e = this._editor, t = e.model.document.roots.filter((a) => a.isAttached() && a.rootName != "$graveyard"), { plugins: n } = e, s = n.has("CommentsRepository") && n.get("CommentsRepository"), o = n.has("TrackChanges") && n.get("TrackChanges"), r = {
      roots: {},
      markers: {},
      commentThreads: JSON.stringify([]),
      suggestions: JSON.stringify([])
    };
    t.forEach((a) => {
      r.roots[a.rootName] = {
        content: JSON.stringify(Array.from(a.getChildren())),
        attributes: JSON.stringify(Array.from(a.getAttributes())),
        isLoaded: a._isLoaded
      };
    });
    for (const a of e.model.markers)
      a._affectsData && (r.markers[a.name] = {
        rangeJSON: a.getRange().toJSON(),
        usingOperation: a._managedUsingOperations,
        affectsData: a._affectsData
      });
    return s && (r.commentThreads = JSON.stringify(s.getCommentThreads({ toJSON: !0, skipNotAttached: !0 }))), o && (r.suggestions = JSON.stringify(o.getSuggestions({ toJSON: !0, skipNotAttached: !0 }))), r;
  }
  /**
   * For each attached model root, returns its HTML editable element (if available).
   */
  _getEditables() {
    const e = {};
    for (const t of this.editor.model.document.getRootNames()) {
      const n = this.editor.ui.getEditableElement(t);
      n && (e[t] = n);
    }
    return e;
  }
  /**
   * Traverses the error context and the current editor to find out whether these structures are connected
   * to each other via properties.
   *
   * @internal
   */
  _isErrorComingFromThisItem(e) {
    return Mb(this._editor, e.context, this._excludedProps);
  }
  /**
   * Clones the editor configuration.
   */
  _cloneEditorConfiguration(e) {
    return ol(e, (t, n) => {
      if (fn(t) || n === "context")
        return t;
    });
  }
}
class lB {
  constructor(e) {
    this.editor = e, this._data = e.config.get("_watchdogInitialData");
  }
  /**
   * @inheritDoc
   */
  init() {
    this.editor.data.on("init", (e) => {
      e.stop(), this.editor.model.enqueueChange({ isUndoable: !1 }, (t) => {
        this._restoreCollaborationData(), this._restoreEditorData(t);
      }), this.editor.data.fire("ready");
    }, { priority: 999 });
  }
  /**
   * Creates a model node (element or text) based on provided JSON.
   */
  _createNode(e, t) {
    if ("name" in t) {
      const n = e.createElement(t.name, t.attributes);
      if (t.children)
        for (const s of t.children)
          n._appendChild(this._createNode(e, s));
      return n;
    } else
      return e.createText(t.data, t.attributes);
  }
  /**
   * Restores the editor by setting the document data, roots attributes and markers.
   */
  _restoreEditorData(e) {
    const t = this.editor;
    Object.entries(this._data.roots).forEach(([n, { content: s, attributes: o }]) => {
      const r = JSON.parse(s), a = JSON.parse(o), l = t.model.document.getRoot(n);
      for (const [c, u] of a)
        e.setAttribute(c, u, l);
      for (const c of r) {
        const u = this._createNode(e, c);
        e.insert(u, l, "end");
      }
    }), Object.entries(this._data.markers).forEach(([n, s]) => {
      const { document: o } = t.model, { rangeJSON: { start: r, end: a }, ...l } = s, c = o.getRoot(r.root), u = e.createPositionFromPath(c, r.path, r.stickiness), d = e.createPositionFromPath(c, a.path, a.stickiness), h = e.createRange(u, d);
      e.addMarker(n, {
        range: h,
        ...l
      });
    });
  }
  /**
   * Restores the editor collaboration data - comment threads and suggestions.
   */
  _restoreCollaborationData() {
    const e = JSON.parse(this._data.commentThreads), t = JSON.parse(this._data.suggestions);
    e.forEach((n) => {
      const s = this.editor.config.get("collaboration.channelId"), o = this.editor.plugins.get("CommentsRepository");
      o.hasCommentThread(n.threadId) && o.getCommentThread(n.threadId).remove(), o.addCommentThread({ channelId: s, ...n });
    }), t.forEach((n) => {
      const s = this.editor.plugins.get("TrackChangesEditing");
      if (s.hasSuggestion(n.id)) {
        const o = s.getSuggestion(n.id);
        o.attributes = n.attributes;
      } else
        s.addSuggestionData(n);
    });
  }
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const qi = Symbol("MainQueueId");
class cB extends Vb {
  /**
   * The context watchdog class constructor.
   *
   * ```ts
   * const watchdog = new ContextWatchdog( Context );
   *
   * await watchdog.create( contextConfiguration );
   *
   * await watchdog.add( item );
   * ```
   *
   * See the {@glink features/watchdog Watchdog feature guide} to learn more how to use this feature.
   *
   * @param Context The {@link module:core/context~Context} class.
   * @param watchdogConfig The watchdog configuration.
   */
  constructor(e, t = {}) {
    super(t), this._watchdogs = /* @__PURE__ */ new Map(), this._context = null, this._contextProps = /* @__PURE__ */ new Set(), this._actionQueues = new uB(), this._watchdogConfig = t, this._creator = (n) => e.create(n), this._destructor = (n) => n.destroy(), this._actionQueues.onEmpty(() => {
      this.state === "initializing" && (this.state = "ready", this._fire("stateChange"));
    });
  }
  /**
   * Sets the function that is responsible for the context creation.
   * It expects a function that should return a promise (or `undefined`).
   *
   * ```ts
   * watchdog.setCreator( config => Context.create( config ) );
   * ```
   */
  setCreator(e) {
    this._creator = e;
  }
  /**
   * Sets the function that is responsible for the context destruction.
   * Overrides the default destruction function, which destroys only the context instance.
   * It expects a function that should return a promise (or `undefined`).
   *
   * ```ts
   * watchdog.setDestructor( context => {
   * 	// Do something before the context is destroyed.
   *
   * 	return context
   * 		.destroy()
   * 		.then( () => {
   * 			// Do something after the context is destroyed.
   * 		} );
   * } );
   * ```
   */
  setDestructor(e) {
    this._destructor = e;
  }
  /**
   * The context instance. Keep in mind that this property might be changed when the context watchdog restarts,
   * so do not keep this instance internally. Always operate on the `ContextWatchdog#context` property.
   */
  get context() {
    return this._context;
  }
  /**
   * Initializes the context watchdog. Once it is created, the watchdog takes care about
   * recreating the context and the provided items, and starts the error handling mechanism.
   *
   * ```ts
   * await watchdog.create( {
   * 	plugins: []
   * } );
   * ```
   *
   * @param contextConfig The context configuration. See {@link module:core/context~Context}.
   */
  create(e = {}) {
    return this._actionQueues.enqueue(qi, () => (this._contextConfig = e, this._create()));
  }
  /**
   * Returns an item instance with the given `itemId`.
   *
   * ```ts
   * const editor1 = watchdog.getItem( 'editor1' );
   * ```
   *
   * @param itemId The item ID.
   * @returns The item instance or `undefined` if an item with a given ID has not been found.
   */
  getItem(e) {
    return this._getWatchdog(e)._item;
  }
  /**
   * Gets the state of the given item. See {@link #state} for a list of available states.
   *
   * ```ts
   * const editor1State = watchdog.getItemState( 'editor1' );
   * ```
   *
   * @param itemId Item ID.
   * @returns The state of the item.
   */
  getItemState(e) {
    return this._getWatchdog(e).state;
  }
  /**
   * Adds items to the watchdog. Once created, instances of these items will be available using the {@link #getItem} method.
   *
   * Items can be passed together as an array of objects:
   *
   * ```ts
   * await watchdog.add( [ {
   * 	id: 'editor1',
   * 	type: 'editor',
   * 	sourceElementOrData: document.querySelector( '#editor' ),
   * 	config: {
   * 		plugins: [ Essentials, Paragraph, Bold, Italic ],
   * 		toolbar: [ 'bold', 'italic', 'alignment' ]
   * 	},
   * 	creator: ( element, config ) => ClassicEditor.create( element, config )
   * } ] );
   * ```
   *
   * Or one by one as objects:
   *
   * ```ts
   * await watchdog.add( {
   * 	id: 'editor1',
   * 	type: 'editor',
   * 	sourceElementOrData: document.querySelector( '#editor' ),
   * 	config: {
   * 		plugins: [ Essentials, Paragraph, Bold, Italic ],
   * 		toolbar: [ 'bold', 'italic', 'alignment' ]
   * 	},
   * 	creator: ( element, config ) => ClassicEditor.create( element, config )
   * ] );
   * ```
   *
   * Then an instance can be retrieved using the {@link #getItem} method:
   *
   * ```ts
   * const editor1 = watchdog.getItem( 'editor1' );
   * ```
   *
   * Note that this method can be called multiple times, but for performance reasons it is better
   * to pass all items together.
   *
   * @param itemConfigurationOrItemConfigurations An item configuration object or an array of item configurations.
   */
  add(e) {
    const t = jh(e);
    return Promise.all(t.map((n) => this._actionQueues.enqueue(n.id, () => {
      if (this.state === "destroyed")
        throw new Error("Cannot add items to destroyed watchdog.");
      if (!this._context)
        throw new Error("Context was not created yet. You should call the `ContextWatchdog#create()` method first.");
      let s;
      if (this._watchdogs.has(n.id))
        throw new Error(`Item with the given id is already added: '${n.id}'.`);
      if (n.type === "editor")
        return s = new Bb(null, this._watchdogConfig), s.setCreator(n.creator), s._setExcludedProperties(this._contextProps), n.destructor && s.setDestructor(n.destructor), this._watchdogs.set(n.id, s), s.on("error", (o, { error: r, causesRestart: a }) => {
          this._fire("itemError", { itemId: n.id, error: r }), a && this._actionQueues.enqueue(n.id, () => new Promise((l) => {
            const c = () => {
              s.off("restart", c), this._fire("itemRestart", { itemId: n.id }), l();
            };
            s.on("restart", c);
          }));
        }), s.create(n.sourceElementOrData, n.config, this._context);
      throw new Error(`Not supported item type: '${n.type}'.`);
    })));
  }
  /**
   * Removes and destroys item(s) with given ID(s).
   *
   * ```ts
   * await watchdog.remove( 'editor1' );
   * ```
   *
   * Or
   *
   * ```ts
   * await watchdog.remove( [ 'editor1', 'editor2' ] );
   * ```
   *
   * @param itemIdOrItemIds Item ID or an array of item IDs.
   */
  remove(e) {
    const t = jh(e);
    return Promise.all(t.map((n) => this._actionQueues.enqueue(n, () => {
      const s = this._getWatchdog(n);
      return this._watchdogs.delete(n), s.destroy();
    })));
  }
  /**
   * Destroys the context watchdog and all added items.
   * Once the context watchdog is destroyed, new items cannot be added.
   *
   * ```ts
   * await watchdog.destroy();
   * ```
   */
  destroy() {
    return this._actionQueues.enqueue(qi, () => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy()));
  }
  /**
   * Restarts the context watchdog.
   */
  _restart() {
    return this._actionQueues.enqueue(qi, () => (this.state = "initializing", this._fire("stateChange"), this._destroy().catch((e) => {
      console.error("An error happened during destroying the context or items.", e);
    }).then(() => this._create()).then(() => this._fire("restart"))));
  }
  /**
   * Initializes the context watchdog.
   */
  _create() {
    return Promise.resolve().then(() => (this._startErrorHandling(), this._creator(this._contextConfig))).then((e) => (this._context = e, this._contextProps = Wa(this._context), Promise.all(Array.from(this._watchdogs.values()).map((t) => (t._setExcludedProperties(this._contextProps), t.create(void 0, void 0, this._context))))));
  }
  /**
   * Destroys the context instance and all added items.
   */
  _destroy() {
    return Promise.resolve().then(() => {
      this._stopErrorHandling();
      const e = this._context;
      return this._context = null, this._contextProps = /* @__PURE__ */ new Set(), Promise.all(Array.from(this._watchdogs.values()).map((t) => t.destroy())).then(() => this._destructor(e));
    });
  }
  /**
   * Returns the watchdog for a given item ID.
   *
   * @param itemId Item ID.
   */
  _getWatchdog(e) {
    const t = this._watchdogs.get(e);
    if (!t)
      throw new Error(`Item with the given id was not registered: ${e}.`);
    return t;
  }
  /**
   * Checks whether an error comes from the context instance and not from the item instances.
   *
   * @internal
   */
  _isErrorComingFromThisItem(e) {
    for (const t of this._watchdogs.values())
      if (t._isErrorComingFromThisItem(e))
        return !1;
    return Mb(this._context, e.context);
  }
}
class uB {
  constructor() {
    this._onEmptyCallbacks = [], this._queues = /* @__PURE__ */ new Map(), this._activeActions = 0;
  }
  /**
   * Used to register callbacks that will be run when the queue becomes empty.
   *
   * @param onEmptyCallback A callback that will be run whenever the queue becomes empty.
   */
  onEmpty(e) {
    this._onEmptyCallbacks.push(e);
  }
  /**
   * It adds asynchronous actions (functions) to the proper queue and runs them one by one.
   *
   * @param queueId The action queue ID.
   * @param action A function that should be enqueued.
   */
  enqueue(e, t) {
    const n = e === qi;
    this._activeActions++, this._queues.get(e) || this._queues.set(e, Promise.resolve());
    const o = (n ? Promise.all(this._queues.values()) : Promise.all([this._queues.get(qi), this._queues.get(e)])).then(t), r = o.catch(() => {
    });
    return this._queues.set(e, r), o.finally(() => {
      this._activeActions--, this._queues.get(e) === r && this._activeActions === 0 && this._onEmptyCallbacks.forEach((a) => a());
    });
  }
}
function jh(i) {
  return Array.isArray(i) ? i : [i];
}
/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class As extends pa(X5) {
  /**
   * Creates an instance of the classic editor.
   *
   * **Note:** do not use the constructor to create editor instances. Use the static
   * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`} method instead.
   *
   * @param sourceElementOrData The DOM element that will be the source for the created editor
   * or the editor's initial data. For more information see
   * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`}.
   * @param config The editor configuration.
   */
  constructor(e, t = {}) {
    if (!fo(e) && t.initialData !== void 0)
      throw new g("editor-create-initial-data", null);
    super(t), this.config.define("menuBar.isVisible", !1), this.config.get("initialData") === void 0 && this.config.set("initialData", dB(e)), fo(e) && (this.sourceElement = e), this.model.document.createRoot();
    const n = !this.config.get("toolbar.shouldNotGroupWhenFull"), s = this.config.get("menuBar"), o = new oB(this.locale, this.editing.view, {
      shouldToolbarGroupWhenFull: n,
      useMenuBar: s.isVisible
    });
    this.ui = new sB(this, o), Q5(this);
  }
  /**
   * Destroys the editor instance, releasing all resources used by it.
   *
   * Updates the original editor element with the data if the
   * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy `updateSourceElementOnDestroy`}
   * configuration option is set to `true`.
   */
  destroy() {
    return this.sourceElement && this.updateSourceElement(), this.ui.destroy(), super.destroy();
  }
  /**
   * Creates a new classic editor instance.
   *
   * There are three ways how the editor can be initialized.
   *
   * # Replacing a DOM element (and loading data from it)
   *
   * You can initialize the editor using an existing DOM element:
   *
   * ```ts
   * ClassicEditor
   * 	.create( document.querySelector( '#editor' ) )
   * 	.then( editor => {
   * 		console.log( 'Editor was initialized', editor );
   * 	} )
   * 	.catch( err => {
   * 		console.error( err.stack );
   * 	} );
   * ```
   *
   * The element's content will be used as the editor data and the element will be replaced by the editor UI.
   *
   * # Creating a detached editor
   *
   * Alternatively, you can initialize the editor by passing the initial data directly as a string.
   * In this case, the editor will render an element that must be inserted into the DOM:
   *
   * ```ts
   * ClassicEditor
   * 	.create( '<p>Hello world!</p>' )
   * 	.then( editor => {
   * 		console.log( 'Editor was initialized', editor );
   *
   * 		// Initial data was provided so the editor UI element needs to be added manually to the DOM.
   * 		document.body.appendChild( editor.ui.element );
   * 	} )
   * 	.catch( err => {
   * 		console.error( err.stack );
   * 	} );
   * ```
   *
   * This lets you dynamically append the editor to your web page whenever it is convenient for you. You may use this method if your
   * web page content is generated on the client side and the DOM structure is not ready at the moment when you initialize the editor.
   *
   * # Replacing a DOM element (and data provided in `config.initialData`)
   *
   * You can also mix these two ways by providing a DOM element to be used and passing the initial data through the configuration:
   *
   * ```ts
   * ClassicEditor
   * 	.create( document.querySelector( '#editor' ), {
   * 		initialData: '<h2>Initial data</h2><p>Foo bar.</p>'
   * 	} )
   * 	.then( editor => {
   * 		console.log( 'Editor was initialized', editor );
   * 	} )
   * 	.catch( err => {
   * 		console.error( err.stack );
   * 	} );
   * ```
   *
   * This method can be used to initialize the editor on an existing element with the specified content in case if your integration
   * makes it difficult to set the content of the source element.
   *
   * Note that an error will be thrown if you pass the initial data both as the first parameter and also in the configuration.
   *
   * # Configuring the editor
   *
   * See the {@link module:core/editor/editorconfig~EditorConfig editor configuration documentation} to learn more about
   * customizing plugins, toolbar and more.
   *
   * # Using the editor from source
   *
   * The code samples listed in the previous sections of this documentation assume that you are using an
   * {@glink installation/getting-started/predefined-builds editor build} (for example – `@ckeditor/ckeditor5-build-classic`).
   *
   * If you want to use the classic editor from source (`@ckeditor/ckeditor5-editor-classic/src/classiceditor`),
   * you need to define the list of
   * {@link module:core/editor/editorconfig~EditorConfig#plugins plugins to be initialized} and
   * {@link module:core/editor/editorconfig~EditorConfig#toolbar toolbar items}. Read more about using the editor from
   * source in the {@glink installation/advanced/alternative-setups/integrating-from-source-webpack dedicated guide}.
   *
   * @param sourceElementOrData The DOM element that will be the source for the created editor
   * or the editor's initial data.
   *
   * If a DOM element is passed, its content will be automatically loaded to the editor upon initialization
   * and the {@link module:editor-classic/classiceditorui~ClassicEditorUI#element editor element} will replace the passed element
   * in the DOM (the original one will be hidden and the editor will be injected next to it).
   *
   * If the {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy updateSourceElementOnDestroy}
   * option is set to `true`, the editor data will be set back to the original element once the editor is destroyed and when a form,
   * in which this element is contained, is submitted (if the original element is a `<textarea>`). This ensures seamless integration
   * with native web forms.
   *
   * If the initial data is passed, a detached editor will be created. In this case you need to insert it into the DOM manually.
   * It is available under the {@link module:editor-classic/classiceditorui~ClassicEditorUI#element `editor.ui.element`} property.
   *
   * @param config The editor configuration.
   * @returns A promise resolved once the editor is ready. The promise resolves with the created editor instance.
   */
  static create(e, t = {}) {
    return new Promise((n) => {
      const s = new this(e, t);
      n(s.initPlugins().then(() => s.ui.init(fo(e) ? e : null)).then(() => s.data.init(s.config.get("initialData"))).then(() => s.fire("ready")).then(() => s));
    });
  }
}
As.Context = pm;
As.EditorWatchdog = Bb;
As.ContextWatchdog = cB;
function dB(i) {
  return fo(i) ? hC(i) : i;
}
function fo(i) {
  return fn(i);
}
const hB = (i) => i === ">", Kh = (i) => i === "<", Zh = (i) => /^\s+$/.test(i), Lb = (i) => /^\s*<img\b/.test(i), fB = (i) => /^\s*<[^>]+>\s*$/.test(i), Ob = (i) => !fB(i), mB = (i) => Lb(i) || Ob(i), gB = (i) => !Lb(i) && Ob(i);
function Jh(i) {
  let e = "char", t = "";
  const n = [];
  for (const s of i)
    switch (e) {
      case "tag":
        hB(s) ? (t += ">", n.push(t), t = "", Zh(s) ? e = "whitespace" : e = "char") : t += s;
        break;
      case "char":
        Kh(s) ? (t && n.push(t), t = "<", e = "tag") : /\s/.test(s) ? (t && n.push(t), t = s, e = "whitespace") : /[\w\#@]+/i.test(s) ? t += s : (t && n.push(t), t = s);
        break;
      case "whitespace":
        Kh(s) ? (t && n.push(t), t = "<", e = "tag") : Zh(s) ? t += s : (t && n.push(t), t = s, e = "char");
        break;
      default:
        throw new Error(`Unknown mode ${e}`);
    }
  return t && n.push(t), n;
}
class Fb {
  // 수정 후 배열에서 매칭 종료 인덱스
  constructor(e, t, n) {
    Pn(this, "startInBefore");
    // 수정 전 배열에서 매칭 시작 인덱스
    Pn(this, "startInAfter");
    // 수정 후 배열에서 매칭 시작 인덱스
    Pn(this, "length");
    // 매칭 블록의 길이
    Pn(this, "endInBefore");
    // 수정 전 배열에서 매칭 종료 인덱스
    Pn(this, "endInAfter");
    this.startInBefore = e, this.startInAfter = t, this.length = n, this.endInBefore = e + n - 1, this.endInAfter = t + n - 1;
  }
}
function pB(i, e, t, n, s, o, r) {
  let a = n, l = o, c = 0, u = {};
  for (let d = n; d < s; d++) {
    const h = {}, f = i[d], m = t[f] || [];
    for (const p of m) {
      if (p < o) continue;
      if (p >= r) break;
      u[p - 1] || (u[p - 1] = 0);
      const w = u[p - 1] + 1;
      h[p] = w, w > c && (a = d - w + 1, l = p - w + 1, c = w);
    }
    u = h;
  }
  if (c !== 0)
    return new Fb(a, l, c);
}
const io = "replace", Xh = "delete", Qh = "insert", Yh = "equal", Gr = "none";
function bB(i) {
  if (!i.findThese) throw new Error("params must have findThese key");
  if (!i.inThese) throw new Error("params must have inThese key");
  const e = {};
  for (const t of i.findThese) {
    e[t] = [];
    let n = i.inThese.indexOf(t);
    for (; n !== -1; )
      e[t].push(n), n = i.inThese.indexOf(t, n + 1);
  }
  return e;
}
function qa(i, e, t, n, s, o, r, a) {
  const l = pB(
    i,
    e,
    t,
    n,
    s,
    o,
    r
  );
  return l && (n < l.startInBefore && o < l.startInAfter && qa(
    i,
    e,
    t,
    n,
    l.startInBefore,
    o,
    l.startInAfter,
    a
  ), a.push(l), l.endInBefore <= s && l.endInAfter <= r && qa(
    i,
    e,
    t,
    l.endInBefore + 1,
    s,
    l.endInAfter + 1,
    r,
    a
  )), a;
}
function wB(i, e) {
  const t = [], n = bB({
    findThese: i,
    inThese: e
  });
  return qa(
    i,
    e,
    n,
    0,
    i.length,
    0,
    e.length,
    t
  );
}
function _B(i, e) {
  if (!i) throw new Error("There is no beforeTokens.");
  if (!e) throw new Error("There is no afterTokens.");
  let t = 0, n = 0;
  const s = [], o = {
    // 현재 위치에서의 수정 작업을 정의하기 위한 매핑입니다. false와 true 값의 조합을 통해 삽입, 삭제, 교체, 동일한 작업을 구분
    "false,false": io,
    "true,false": Qh,
    "false,true": Xh,
    "true,true": Gr
  }, r = wB(i, e);
  r.push(new Fb(i.length, e.length, 0));
  for (const u of r) {
    const d = t === u.startInBefore, h = n === u.startInAfter, f = o[[d, h].toString()];
    f !== Gr && s.push({
      action: f,
      startInBefore: t,
      endInBefore: f === Qh ? void 0 : u.startInBefore - 1,
      startInAfter: n,
      endInAfter: f === Xh ? void 0 : u.startInAfter - 1
    }), u.length !== 0 && s.push({
      action: Yh,
      startInBefore: u.startInBefore,
      endInBefore: u.endInBefore,
      startInAfter: u.startInAfter,
      endInAfter: u.endInAfter
    }), t = u.endInBefore + 1, n = u.endInAfter + 1;
  }
  const a = [];
  let l = { action: Gr, startInBefore: 0, startInAfter: 0 };
  const c = (u) => u.action !== Yh || u.endInBefore - u.startInBefore !== 0 ? !1 : /^\s$/.test(i[u.startInBefore]);
  for (const u of s)
    c(u) && l.action === io || u.action === io && l.action === io ? (l.endInBefore = u.endInBefore, l.endInAfter = u.endInAfter) : (a.push(u), l = u);
  return a;
}
function ef(i, e, t) {
  e = e.slice(i);
  let n;
  for (const [s, o] of e.entries()) {
    const r = t(o);
    if (r && (n = s), !r) break;
  }
  return n !== void 0 ? e.slice(0, n + 1) : [];
}
function tf(i, e, t) {
  let n = "", s = 0;
  const o = e.length;
  for (; s < o; ) {
    const r = ef(s, e, mB);
    if (s += r.length, r.length !== 0 && (r.some((l) => l.includes("<img")) ? n += r.join("").replace("<img", `<img style="${t === "insert" ? "background: rgba(0, 195, 81, 0.25);padding: 10px;" : "background: rgba(245, 97, 65, 0.25);padding: 10px;"}" `) : n += `<${i} style="background-color: ${t === "insert" ? "rgba(0, 195, 81, 0.25)" : "rgba(245, 97, 65, 0.25)"}; ${t === "delete" ? "text-decoration: line-through" : "font-weight: bold"}">${r.join("")}</${i}>`), s >= o) break;
    const a = ef(s, e, gB);
    s += a.length, n += a.join("");
  }
  return n;
}
const Ga = {
  equal: (i, e, t) => e.slice(i.startInBefore, i.endInBefore + 1).join(""),
  insert: (i, e, t) => {
    const n = t.slice(i.startInAfter, i.endInAfter + 1);
    return tf("span", n, "insert");
  },
  delete: (i, e, t) => {
    const n = e.slice(i.startInBefore, i.endInBefore + 1);
    return tf("span", n, "delete");
  },
  replace(i, e, t) {
    const n = Ga.delete(i, e, t), s = Ga.insert(i, e, t);
    return n.startsWith("<img") && s.startsWith("<img") ? `${n}</figure><figure class="image">${s}` : n + s;
  }
};
function vB(i, e, t) {
  let n = "";
  for (const s of t)
    n += Ga[s.action](s, i, e);
  return n;
}
function Nb(i, e) {
  if (i === e) return i;
  const t = Jh(i), n = Jh(e), s = _B(t, n);
  return vB(t, n, s);
}
const yB = [
  "undo",
  "redo",
  "|",
  "heading",
  "fontSize",
  "fontFamily",
  "bold",
  "italic",
  "underline",
  "strikethrough",
  "code",
  "fontColor",
  "fontBackgroundColor",
  "superscript",
  "subscript",
  "|",
  "alignment",
  "numberedList",
  "bulletedList",
  "outdent",
  "indent",
  "|",
  "horizontalLine",
  "blockQuote",
  "link",
  "|",
  "insertImage",
  "insertTable",
  "specialCharacters"
], Db = {
  language: "en",
  placeholder: "Please enter content",
  fontSize: {
    options: [
      8,
      9,
      10,
      11,
      12,
      14,
      "default",
      18,
      20,
      22,
      24,
      26,
      28,
      36,
      48,
      72
    ]
  },
  heading: {
    options: [
      { model: "paragraph", title: "Paragraph", class: "ck-heading_paragraph" },
      { model: "heading1", view: "h1", title: "Heading 1", class: "ck-heading_heading1" },
      { model: "heading2", view: "h2", title: "Heading 2", class: "ck-heading_heading2" },
      { model: "heading3", view: "h3", title: "Heading 3", class: "ck-heading_heading3" }
    ]
  },
  toolbar: {
    items: yB,
    shouldNotGroupWhenFull: !1
  },
  image: {
    toolbar: [
      "imageStyle:inline",
      "imageStyle:wrapText",
      "imageStyle:breakText",
      "|",
      "toggleImageCaption",
      "imageTextAlternative"
    ]
  },
  table: {
    contentToolbar: ["tableRow", "tableColumn", "tableProperties", "tableCellProperties", "mergeTableCells"]
  },
  alignment: {
    options: ["left", "center", "right", "justify"]
  },
  plugins: [
    oP,
    ws,
    bP,
    GP,
    ZP,
    eR,
    sR,
    lR,
    hR,
    pR,
    vR,
    ER,
    mp,
    hp,
    VR,
    gp,
    _p,
    MR,
    wp,
    bp,
    pp,
    r3,
    h3,
    u3,
    _3,
    k3,
    Y3,
    v7,
    c4,
    xV,
    IV,
    x6,
    C6,
    ZV,
    m6,
    yA,
    L6,
    F6,
    W6,
    VM,
    sM,
    lM,
    $M,
    tB,
    nB,
    r7,
    _b,
    gM
  ]
}, nf = async ({
  targetId: i,
  initialData: e = "",
  placeholder: t = ""
}) => {
  const n = document.getElementById(i), s = {
    ...Db,
    initialData: e,
    placeholder: t
  };
  return { editor: await As.create(n, s).then((r) => r).catch((r) => (console.error("[CKEditor Error] An error occurred while initializing the editor.", r), null)) };
}, CB = async ({
  targetId: i,
  beforeText: e = "",
  afterText: t = ""
}) => {
  const n = document.getElementById(i), s = Nb(e, t), o = {
    ...Db,
    initialData: s
  };
  return { editor: await As.create(n, o).then((a) => (a.enableReadOnlyMode(""), a.ui.view.toolbar.element.style.display = "none", a)).catch((a) => (console.error("[CKEditor Error] An error occurred while initializing the editor.", a), null)) };
}, kB = async () => {
  const { editor: i } = await CB({
    targetId: "sample-diff-editor",
    beforeText: "Same content, removed this!!",
    afterText: "Same content, added this!!"
  }), { editor: e } = await nf({
    targetId: "sample-diff-editor-before",
    initialData: "Same content, removed this!!"
  }), { editor: t } = await nf({
    targetId: "sample-diff-editor-after",
    placeholder: "Please enter content",
    initialData: "Same content, added this!!"
  });
  return {
    diffEditor: i,
    beforeEditor: e,
    afterEditor: t
  };
};
(async () => {
  const { afterEditor: i, diffEditor: e, beforeEditor: t } = await kB();
  document.getElementById("diff-button").addEventListener("click", async () => {
    const s = t.getData(), o = i.getData(), r = Nb(s, o);
    e.setData(r);
  });
})();
